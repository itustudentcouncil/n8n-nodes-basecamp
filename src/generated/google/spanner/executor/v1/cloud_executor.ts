// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/spanner/executor/v1/cloud_executor.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../longrunning/operations.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Status } from "../../../rpc/status.js";
import { Backup } from "../../admin/database/v1/backup.js";
import { EncryptionConfig } from "../../admin/database/v1/common.js";
import { Database } from "../../admin/database/v1/spanner_database_admin.js";
import {
  AutoscalingConfig,
  Instance,
  InstanceConfig,
  ReplicaInfo,
} from "../../admin/instance/v1/spanner_instance_admin.js";
import {
  RequestOptions_Priority,
  requestOptions_PriorityFromJSON,
  requestOptions_PriorityToJSON,
} from "../../v1/spanner.js";
import { StructType, Type } from "../../v1/type.js";

export const protobufPackage = "google.spanner.executor.v1";

/** Request to executor service that start a new Spanner action. */
export interface SpannerAsyncActionRequest {
  /** Action id to uniquely identify this action request. */
  actionId: number;
  /** The actual SpannerAction to perform. */
  action: SpannerAction | undefined;
}

/** Response from executor service. */
export interface SpannerAsyncActionResponse {
  /** Action id corresponds to the request. */
  actionId: number;
  /**
   * If action results are split into multiple responses, only the last response
   * can and should contain status.
   */
  outcome: SpannerActionOutcome | undefined;
}

/**
 * SpannerAction defines a primitive action that can be performed against
 * Spanner, such as begin or commit a transaction, or perform a read or
 * mutation.
 */
export interface SpannerAction {
  /**
   * Database against which to perform action.
   * In a context where a series of actions take place, an action may omit
   * database path if it applies to the same database as the previous action.
   */
  databasePath: string;
  /** Configuration options for Spanner backend */
  spannerOptions:
    | SpannerOptions
    | undefined;
  /** Action to start a transaction. */
  start?:
    | StartTransactionAction
    | undefined;
  /** Action to finish a transaction. */
  finish?:
    | FinishTransactionAction
    | undefined;
  /** Action to do a normal read. */
  read?:
    | ReadAction
    | undefined;
  /** Action to do a query. */
  query?:
    | QueryAction
    | undefined;
  /** Action to buffer a mutation. */
  mutation?:
    | MutationAction
    | undefined;
  /** Action to a DML. */
  dml?:
    | DmlAction
    | undefined;
  /** Action to a batch DML. */
  batchDml?:
    | BatchDmlAction
    | undefined;
  /** Action to write a mutation. */
  write?:
    | WriteMutationsAction
    | undefined;
  /** Action to a partitioned update. */
  partitionedUpdate?:
    | PartitionedUpdateAction
    | undefined;
  /**
   * Action that contains any administrative operation, like database,
   * instance manipulation.
   */
  admin?:
    | AdminAction
    | undefined;
  /** Action to start a batch transaction. */
  startBatchTxn?:
    | StartBatchTransactionAction
    | undefined;
  /** Action to close a batch transaction. */
  closeBatchTxn?:
    | CloseBatchTransactionAction
    | undefined;
  /** Action to generate database partitions for batch read. */
  generateDbPartitionsRead?:
    | GenerateDbPartitionsForReadAction
    | undefined;
  /** Action to generate database partitions for batch query. */
  generateDbPartitionsQuery?:
    | GenerateDbPartitionsForQueryAction
    | undefined;
  /** Action to execute batch actions on generated partitions. */
  executePartition?:
    | ExecutePartitionAction
    | undefined;
  /** Action to execute change stream query. */
  executeChangeStreamQuery?:
    | ExecuteChangeStreamQuery
    | undefined;
  /** Query cancellation action for testing the cancellation of a query. */
  queryCancellation?: QueryCancellationAction | undefined;
}

/** A single read request. */
export interface ReadAction {
  /** The table to read at. */
  table: string;
  /** The index to read at if it's an index read. */
  index?:
    | string
    | undefined;
  /** List of columns must begin with the key columns used for the read. */
  column: string[];
  /** Keys for performing this read. */
  keys:
    | KeySet
    | undefined;
  /** Limit on number of rows to read. If set, must be positive. */
  limit: number;
}

/** A SQL query request. */
export interface QueryAction {
  /** The SQL string. */
  sql: string;
  /** Parameters for the SQL string. */
  params: QueryAction_Parameter[];
}

/** Parameter that bind to placeholders in the SQL string */
export interface QueryAction_Parameter {
  /** Name of the parameter (with no leading @). */
  name: string;
  /** Type of the parameter. */
  type:
    | Type
    | undefined;
  /** Value of the parameter. */
  value: Value | undefined;
}

/** A single DML statement. */
export interface DmlAction {
  /** DML statement. */
  update:
    | QueryAction
    | undefined;
  /**
   * Whether to autocommit the transaction after executing the DML statement,
   * if the Executor supports autocommit.
   */
  autocommitIfSupported?: boolean | undefined;
}

/** Batch of DML statements invoked using batched execution. */
export interface BatchDmlAction {
  /** DML statements. */
  updates: QueryAction[];
}

/**
 * Value represents a single value that can be read or written to/from
 * Spanner.
 */
export interface Value {
  /** If is_null is set, then this value is null. */
  isNull?:
    | boolean
    | undefined;
  /**
   * Int type value. It's used for all integer number types, like int32 and
   * int64.
   */
  intValue?:
    | Long
    | undefined;
  /** Bool type value. */
  boolValue?:
    | boolean
    | undefined;
  /**
   * Double type value. It's used for all float point types, like float and
   * double.
   */
  doubleValue?:
    | number
    | undefined;
  /** Bytes type value, stored in CORD. It's also used for PROTO type value. */
  bytesValue?:
    | Buffer
    | undefined;
  /** String type value, stored in CORD. */
  stringValue?:
    | string
    | undefined;
  /**
   * Struct type value. It contains a ValueList representing the values in
   * this struct.
   */
  structValue?:
    | ValueList
    | undefined;
  /** Timestamp type value. */
  timestampValue?:
    | Date
    | undefined;
  /** Date type value. Date is specified as a number of days since Unix epoch. */
  dateDaysValue?:
    | number
    | undefined;
  /** If set, holds the sentinel value for the transaction CommitTimestamp. */
  isCommitTimestamp?:
    | boolean
    | undefined;
  /**
   * Array type value. The underlying Valuelist should have values that have
   * the same type.
   */
  arrayValue?:
    | ValueList
    | undefined;
  /** Type of array element. Only set if value is an array. */
  arrayType?: Type | undefined;
}

/**
 * KeyRange represents a range of rows in a table or index.
 *
 * A range has a start key and an end key. These keys can be open or
 * closed, indicating if the range includes rows with that key.
 *
 * Keys are represented by "ValueList", where the ith value in the list
 * corresponds to the ith component of the table or index primary key.
 */
export interface KeyRange {
  /**
   * "start" and "limit" must have the same number of key parts,
   * though they may name only a prefix of the table or index key.
   * The start key of this KeyRange.
   */
  start:
    | ValueList
    | undefined;
  /** The end key of this KeyRange. */
  limit:
    | ValueList
    | undefined;
  /** "start" and "limit" type for this KeyRange. */
  type?: KeyRange_Type | undefined;
}

/**
 * Type controls whether "start" and "limit" are open or closed. By default,
 * "start" is closed, and "limit" is open.
 */
export enum KeyRange_Type {
  /** TYPE_UNSPECIFIED - "TYPE_UNSPECIFIED" is equivalent to "CLOSED_OPEN". */
  TYPE_UNSPECIFIED = 0,
  /** CLOSED_CLOSED - [start,limit] */
  CLOSED_CLOSED = 1,
  /** CLOSED_OPEN - [start,limit) */
  CLOSED_OPEN = 2,
  /** OPEN_CLOSED - (start,limit] */
  OPEN_CLOSED = 3,
  /** OPEN_OPEN - (start,limit) */
  OPEN_OPEN = 4,
  UNRECOGNIZED = -1,
}

export function keyRange_TypeFromJSON(object: any): KeyRange_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return KeyRange_Type.TYPE_UNSPECIFIED;
    case 1:
    case "CLOSED_CLOSED":
      return KeyRange_Type.CLOSED_CLOSED;
    case 2:
    case "CLOSED_OPEN":
      return KeyRange_Type.CLOSED_OPEN;
    case 3:
    case "OPEN_CLOSED":
      return KeyRange_Type.OPEN_CLOSED;
    case 4:
    case "OPEN_OPEN":
      return KeyRange_Type.OPEN_OPEN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return KeyRange_Type.UNRECOGNIZED;
  }
}

export function keyRange_TypeToJSON(object: KeyRange_Type): string {
  switch (object) {
    case KeyRange_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case KeyRange_Type.CLOSED_CLOSED:
      return "CLOSED_CLOSED";
    case KeyRange_Type.CLOSED_OPEN:
      return "CLOSED_OPEN";
    case KeyRange_Type.OPEN_CLOSED:
      return "OPEN_CLOSED";
    case KeyRange_Type.OPEN_OPEN:
      return "OPEN_OPEN";
    case KeyRange_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * KeySet defines a collection of Spanner keys and/or key ranges. All
 * the keys are expected to be in the same table. The keys need not be
 * sorted in any particular way.
 */
export interface KeySet {
  /**
   * A list of specific keys. Entries in "keys" should have exactly as
   * many elements as there are columns in the primary or index key
   * with which this "KeySet" is used.
   */
  point: ValueList[];
  /** A list of key ranges. */
  range: KeyRange[];
  /**
   * For convenience "all" can be set to "true" to indicate that this
   * "KeySet" matches all keys in the table or index. Note that any keys
   * specified in "keys" or "ranges" are only yielded once.
   */
  all: boolean;
}

/** List of values. */
export interface ValueList {
  /** Values contained in this ValueList. */
  value: Value[];
}

/** A single mutation request. */
export interface MutationAction {
  /** Mods that contained in this mutation. */
  mod: MutationAction_Mod[];
}

/** Arguments to Insert, InsertOrUpdate, and Replace operations. */
export interface MutationAction_InsertArgs {
  /** The names of the columns to be written. */
  column: string[];
  /** Type information for the "values" entries below. */
  type: Type[];
  /** The values to be written. */
  values: ValueList[];
}

/** Arguments to Update. */
export interface MutationAction_UpdateArgs {
  /** The columns to be updated. Identical to InsertArgs.column. */
  column: string[];
  /** Type information for "values". Identical to InsertArgs.type. */
  type: Type[];
  /** The values to be updated. Identical to InsertArgs.values. */
  values: ValueList[];
}

/**
 * Mod represents the write action that will be perform to a table. Each mod
 * will specify exactly one action, from insert, update, insert_or_update,
 * replace and delete.
 */
export interface MutationAction_Mod {
  /** The table to write. */
  table: string;
  /**
   * Exactly one of the remaining elements may be present.
   * Insert new rows into "table".
   */
  insert:
    | MutationAction_InsertArgs
    | undefined;
  /** Update columns stored in existing rows of "table". */
  update:
    | MutationAction_UpdateArgs
    | undefined;
  /** Insert or update existing rows of "table". */
  insertOrUpdate:
    | MutationAction_InsertArgs
    | undefined;
  /** Replace existing rows of "table". */
  replace:
    | MutationAction_InsertArgs
    | undefined;
  /** Delete rows from "table". */
  deleteKeys: KeySet | undefined;
}

/**
 * WriteMutationAction defines an action of flushing the mutation so they
 * are visible to subsequent operations in the transaction.
 */
export interface WriteMutationsAction {
  /** The mutation to write. */
  mutation: MutationAction | undefined;
}

/**
 * PartitionedUpdateAction defines an action to execute a partitioned DML
 * which runs different partitions in parallel.
 */
export interface PartitionedUpdateAction {
  /** Options for partitioned update. */
  options?:
    | PartitionedUpdateAction_ExecutePartitionedUpdateOptions
    | undefined;
  /** Partitioned dml query. */
  update: QueryAction | undefined;
}

export interface PartitionedUpdateAction_ExecutePartitionedUpdateOptions {
  /** RPC Priority */
  rpcPriority?:
    | RequestOptions_Priority
    | undefined;
  /** Transaction tag */
  tag?: string | undefined;
}

/** StartTransactionAction defines an action of initializing a transaction. */
export interface StartTransactionAction {
  /**
   * Concurrency is for read-only transactions and must be omitted for
   * read-write transactions.
   */
  concurrency?:
    | Concurrency
    | undefined;
  /**
   * Metadata about tables and columns that will be involved in this
   * transaction. It is to convert values of key parts correctly.
   */
  table: TableMetadata[];
  /**
   * Transaction_seed contains workid and op pair for this transaction, used for
   * testing.
   */
  transactionSeed: string;
  /** Execution options (e.g., whether transaction is opaque, optimistic). */
  executionOptions?: TransactionExecutionOptions | undefined;
}

/** Concurrency for read-only transactions. */
export interface Concurrency {
  /**
   * Indicates a read at a consistent timestamp that is specified relative to
   * now. That is, if the caller has specified an exact staleness of s
   * seconds, we will read at now - s.
   */
  stalenessSeconds?:
    | number
    | undefined;
  /** Indicates a boundedly stale read that reads at a timestamp >= T. */
  minReadTimestampMicros?:
    | Long
    | undefined;
  /** Indicates a boundedly stale read that is at most N seconds stale. */
  maxStalenessSeconds?:
    | number
    | undefined;
  /** Indicates a read at a consistent timestamp. */
  exactTimestampMicros?:
    | Long
    | undefined;
  /** Indicates a strong read, must only be set to true, or unset. */
  strong?:
    | boolean
    | undefined;
  /** Indicates a batch read, must only be set to true, or unset. */
  batch?:
    | boolean
    | undefined;
  /**
   * True if exact_timestamp_micros is set, and the chosen timestamp is that of
   * a snapshot epoch.
   */
  snapshotEpochRead: boolean;
  /**
   * If set, this is a snapshot epoch read constrained to read only the
   * specified log scope root table, and its children. Will not be set for full
   * database epochs.
   */
  snapshotEpochRootTable: string;
  /** Set only when batch is true. */
  batchReadTimestampMicros: Long;
}

/** TableMetadata contains metadata of a single table. */
export interface TableMetadata {
  /** Table name. */
  name: string;
  /** Columns, in the same order as in the schema. */
  column: ColumnMetadata[];
  /** Keys, in order. Column name is currently not populated. */
  keyColumn: ColumnMetadata[];
}

/** ColumnMetadata represents metadata of a single column. */
export interface ColumnMetadata {
  /** Column name. */
  name: string;
  /** Column type. */
  type: Type | undefined;
}

/** Options for executing the transaction. */
export interface TransactionExecutionOptions {
  /** Whether optimistic concurrency should be used to execute this transaction. */
  optimistic: boolean;
}

/** FinishTransactionAction defines an action of finishing a transaction. */
export interface FinishTransactionAction {
  /**
   * Defines how exactly the transaction should be completed, e.g. with
   * commit or abortion.
   */
  mode: FinishTransactionAction_Mode;
}

/** Mode indicates how the transaction should be finished. */
export enum FinishTransactionAction_Mode {
  /** MODE_UNSPECIFIED - "MODE_UNSPECIFIED" is equivalent to "COMMIT". */
  MODE_UNSPECIFIED = 0,
  /** COMMIT - Commit the transaction. */
  COMMIT = 1,
  /** ABANDON - Drop the transaction without committing it. */
  ABANDON = 2,
  UNRECOGNIZED = -1,
}

export function finishTransactionAction_ModeFromJSON(object: any): FinishTransactionAction_Mode {
  switch (object) {
    case 0:
    case "MODE_UNSPECIFIED":
      return FinishTransactionAction_Mode.MODE_UNSPECIFIED;
    case 1:
    case "COMMIT":
      return FinishTransactionAction_Mode.COMMIT;
    case 2:
    case "ABANDON":
      return FinishTransactionAction_Mode.ABANDON;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FinishTransactionAction_Mode.UNRECOGNIZED;
  }
}

export function finishTransactionAction_ModeToJSON(object: FinishTransactionAction_Mode): string {
  switch (object) {
    case FinishTransactionAction_Mode.MODE_UNSPECIFIED:
      return "MODE_UNSPECIFIED";
    case FinishTransactionAction_Mode.COMMIT:
      return "COMMIT";
    case FinishTransactionAction_Mode.ABANDON:
      return "ABANDON";
    case FinishTransactionAction_Mode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * AdminAction defines all the cloud spanner admin actions, including
 * instance/database admin ops, backup ops and operation actions.
 */
export interface AdminAction {
  /** Action that creates a user instance config. */
  createUserInstanceConfig?:
    | CreateUserInstanceConfigAction
    | undefined;
  /** Action that updates a user instance config. */
  updateUserInstanceConfig?:
    | UpdateUserInstanceConfigAction
    | undefined;
  /** Action that deletes a user instance config. */
  deleteUserInstanceConfig?:
    | DeleteUserInstanceConfigAction
    | undefined;
  /** Action that gets a user instance config. */
  getCloudInstanceConfig?:
    | GetCloudInstanceConfigAction
    | undefined;
  /** Action that lists user instance configs. */
  listInstanceConfigs?:
    | ListCloudInstanceConfigsAction
    | undefined;
  /** Action that creates a Cloud Spanner instance. */
  createCloudInstance?:
    | CreateCloudInstanceAction
    | undefined;
  /** Action that updates a Cloud Spanner instance. */
  updateCloudInstance?:
    | UpdateCloudInstanceAction
    | undefined;
  /** Action that deletes a Cloud Spanner instance. */
  deleteCloudInstance?:
    | DeleteCloudInstanceAction
    | undefined;
  /** Action that lists Cloud Spanner instances. */
  listCloudInstances?:
    | ListCloudInstancesAction
    | undefined;
  /** Action that retrieves a Cloud Spanner instance. */
  getCloudInstance?:
    | GetCloudInstanceAction
    | undefined;
  /** Action that creates a Cloud Spanner database. */
  createCloudDatabase?:
    | CreateCloudDatabaseAction
    | undefined;
  /** Action that updates the schema of a Cloud Spanner database. */
  updateCloudDatabaseDdl?:
    | UpdateCloudDatabaseDdlAction
    | undefined;
  /** Action that updates the schema of a Cloud Spanner database. */
  updateCloudDatabase?:
    | UpdateCloudDatabaseAction
    | undefined;
  /** Action that drops a Cloud Spanner database. */
  dropCloudDatabase?:
    | DropCloudDatabaseAction
    | undefined;
  /** Action that lists Cloud Spanner databases. */
  listCloudDatabases?:
    | ListCloudDatabasesAction
    | undefined;
  /** Action that lists Cloud Spanner database operations. */
  listCloudDatabaseOperations?:
    | ListCloudDatabaseOperationsAction
    | undefined;
  /** Action that restores a Cloud Spanner database from a backup. */
  restoreCloudDatabase?:
    | RestoreCloudDatabaseAction
    | undefined;
  /** Action that gets a Cloud Spanner database. */
  getCloudDatabase?:
    | GetCloudDatabaseAction
    | undefined;
  /** Action that creates a Cloud Spanner database backup. */
  createCloudBackup?:
    | CreateCloudBackupAction
    | undefined;
  /** Action that copies a Cloud Spanner database backup. */
  copyCloudBackup?:
    | CopyCloudBackupAction
    | undefined;
  /** Action that gets a Cloud Spanner database backup. */
  getCloudBackup?:
    | GetCloudBackupAction
    | undefined;
  /** Action that updates a Cloud Spanner database backup. */
  updateCloudBackup?:
    | UpdateCloudBackupAction
    | undefined;
  /** Action that deletes a Cloud Spanner database backup. */
  deleteCloudBackup?:
    | DeleteCloudBackupAction
    | undefined;
  /** Action that lists Cloud Spanner database backups. */
  listCloudBackups?:
    | ListCloudBackupsAction
    | undefined;
  /** Action that lists Cloud Spanner database backup operations. */
  listCloudBackupOperations?:
    | ListCloudBackupOperationsAction
    | undefined;
  /** Action that gets an operation. */
  getOperation?:
    | GetOperationAction
    | undefined;
  /** Action that cancels an operation. */
  cancelOperation?:
    | CancelOperationAction
    | undefined;
  /** Action that changes quorum of a Cloud Spanner database. */
  changeQuorumCloudDatabase?: ChangeQuorumCloudDatabaseAction | undefined;
}

/** Action that creates a user instance config. */
export interface CreateUserInstanceConfigAction {
  /** User instance config ID (not path), e.g. "custom-config". */
  userConfigId: string;
  /** Cloud project ID, e.g. "spanner-cloud-systest". */
  projectId: string;
  /** Base config ID, e.g. "test-config". */
  baseConfigId: string;
  /** Replicas that should be included in the user config. */
  replicas: ReplicaInfo[];
}

/** Action that updates a user instance config. */
export interface UpdateUserInstanceConfigAction {
  /** User instance config ID (not path), e.g. "custom-config". */
  userConfigId: string;
  /** Cloud project ID, e.g. "spanner-cloud-systest". */
  projectId: string;
  /** The descriptive name for this instance config as it appears in UIs. */
  displayName?:
    | string
    | undefined;
  /** labels. */
  labels: { [key: string]: string };
}

export interface UpdateUserInstanceConfigAction_LabelsEntry {
  key: string;
  value: string;
}

/** Action that gets a user instance config. */
export interface GetCloudInstanceConfigAction {
  /** Instance config ID (not path), e.g. "custom-config". */
  instanceConfigId: string;
  /** Cloud project ID, e.g. "spanner-cloud-systest". */
  projectId: string;
}

/** Action that deletes a user instance configs. */
export interface DeleteUserInstanceConfigAction {
  /** User instance config ID (not path), e.g. "custom-config". */
  userConfigId: string;
  /** Cloud project ID, e.g. "spanner-cloud-systest". */
  projectId: string;
}

/** Action that lists user instance configs. */
export interface ListCloudInstanceConfigsAction {
  /** Cloud project ID, e.g. "spanner-cloud-systest". */
  projectId: string;
  /**
   * Number of instance configs to be returned in the response. If 0 or
   * less, defaults to the server's maximum allowed page size.
   */
  pageSize?:
    | number
    | undefined;
  /**
   * If non-empty, "page_token" should contain a next_page_token
   * from a previous ListInstanceConfigsResponse to the same "parent".
   */
  pageToken?: string | undefined;
}

/** Action that creates a Cloud Spanner instance. */
export interface CreateCloudInstanceAction {
  /** Cloud instance ID (not path), e.g. "test-instance". */
  instanceId: string;
  /** Cloud project ID, e.g. "spanner-cloud-systest". */
  projectId: string;
  /** Instance config ID, e.g. "test-config". */
  instanceConfigId: string;
  /** Number of nodes (processing_units should not be set or set to 0 if used). */
  nodeCount?:
    | number
    | undefined;
  /** Number of processing units (node_count should be set to 0 if used). */
  processingUnits?:
    | number
    | undefined;
  /**
   * The autoscaling config for this instance. If non-empty, an autoscaling
   * instance will be created (processing_units and node_count should be set to
   * 0 if used).
   */
  autoscalingConfig?:
    | AutoscalingConfig
    | undefined;
  /** labels. */
  labels: { [key: string]: string };
}

export interface CreateCloudInstanceAction_LabelsEntry {
  key: string;
  value: string;
}

/** Action that updates a Cloud Spanner instance. */
export interface UpdateCloudInstanceAction {
  /** Cloud instance ID (not path), e.g. "test-instance". */
  instanceId: string;
  /** Cloud project ID, e.g. "spanner-cloud-systest". */
  projectId: string;
  /**
   * The descriptive name for this instance as it appears in UIs.
   * Must be unique per project and between 4 and 30 characters in length.
   */
  displayName?:
    | string
    | undefined;
  /**
   * The number of nodes allocated to this instance. At most one of either
   * node_count or processing_units should be present in the message.
   */
  nodeCount?:
    | number
    | undefined;
  /**
   * The number of processing units allocated to this instance. At most one of
   * processing_units or node_count should be present in the message.
   */
  processingUnits?:
    | number
    | undefined;
  /**
   * The autoscaling config for this instance. If non-empty, this instance is
   * using autoscaling (processing_units and node_count should be set to
   * 0 if used).
   */
  autoscalingConfig?:
    | AutoscalingConfig
    | undefined;
  /** labels. */
  labels: { [key: string]: string };
}

export interface UpdateCloudInstanceAction_LabelsEntry {
  key: string;
  value: string;
}

/** Action that deletes a Cloud Spanner instance. */
export interface DeleteCloudInstanceAction {
  /** Cloud instance ID (not path), e.g. "test-instance". */
  instanceId: string;
  /** Cloud project ID, e.g. "spanner-cloud-systest". */
  projectId: string;
}

/** Action that creates a Cloud Spanner database. */
export interface CreateCloudDatabaseAction {
  /** Cloud instance ID (not path), e.g. "test-instance". */
  instanceId: string;
  /** Cloud project ID, e.g. "spanner-cloud-systest". */
  projectId: string;
  /** Cloud database ID (not full path), e.g. "db0". */
  databaseId: string;
  /** SDL statements to apply to the new database. */
  sdlStatement: string[];
  /**
   * The KMS key used to encrypt the database to be created if the database
   * should be CMEK protected.
   */
  encryptionConfig:
    | EncryptionConfig
    | undefined;
  /** Optional SQL dialect (GOOGLESQL or POSTGRESQL).  Default: GOOGLESQL. */
  dialect?: string | undefined;
  protoDescriptors?: Buffer | undefined;
}

/** Action that updates the schema of a Cloud Spanner database. */
export interface UpdateCloudDatabaseDdlAction {
  /** Cloud instance ID (not path), e.g. "test-instance". */
  instanceId: string;
  /** Cloud project ID, e.g. "spanner-cloud-systest". */
  projectId: string;
  /** Cloud database ID (not full path), e.g. "db0". */
  databaseId: string;
  /** SDL statements to apply to the database. */
  sdlStatement: string[];
  /**
   * Op ID can be used to track progress of the update. If set, it must be
   * unique per database. If not set, Cloud Spanner will generate operation ID
   * automatically.
   */
  operationId: string;
  protoDescriptors?: Buffer | undefined;
}

/** Action that updates a Cloud Spanner database. */
export interface UpdateCloudDatabaseAction {
  /** Cloud instance ID (not path), e.g. "test-instance". */
  instanceId: string;
  /** Cloud project ID, e.g. "spanner-cloud-systest". */
  projectId: string;
  /** Cloud database name (not full path), e.g. "db0". */
  databaseName: string;
  /**
   * Updated value of enable_drop_protection, this is the only field that has
   * supported to be updated.
   */
  enableDropProtection: boolean;
}

/** Action that drops a Cloud Spanner database. */
export interface DropCloudDatabaseAction {
  /** Cloud instance ID (not path), e.g. "test-instance". */
  instanceId: string;
  /** Cloud project ID, e.g. "spanner-cloud-systest". */
  projectId: string;
  /** Cloud database ID (not full path), e.g. "db0". */
  databaseId: string;
}

/** Action that changes quorum of a Cloud Spanner database. */
export interface ChangeQuorumCloudDatabaseAction {
  /** The fully qualified uri of the database whose quorum has to be changed. */
  databaseUri?:
    | string
    | undefined;
  /** The locations of the serving regions, e.g. "asia-south1". */
  servingLocations: string[];
}

/** Action that lists Cloud Spanner databases. */
export interface ListCloudDatabasesAction {
  /** Cloud project ID, e.g. "spanner-cloud-systest". */
  projectId: string;
  /** Cloud instance ID (not path) to list databases from, e.g. "test-instance". */
  instanceId: string;
  /**
   * Number of databases to be returned in the response. If 0 or
   * less, defaults to the server's maximum allowed page size.
   */
  pageSize: number;
  /**
   * If non-empty, "page_token" should contain a next_page_token
   * from a previous ListDatabasesResponse to the same "parent"
   * and with the same "filter".
   */
  pageToken: string;
}

/** Action that lists Cloud Spanner databases. */
export interface ListCloudInstancesAction {
  /** Cloud project ID, e.g. "spanner-cloud-systest". */
  projectId: string;
  /**
   * A filter expression that filters what operations are returned in the
   * response.
   * The expression must specify the field name, a comparison operator,
   * and the value that you want to use for filtering.
   * Refer spanner_instance_admin.proto.ListInstancesRequest for
   * detail.
   */
  filter?:
    | string
    | undefined;
  /**
   * Number of instances to be returned in the response. If 0 or
   * less, defaults to the server's maximum allowed page size.
   */
  pageSize?:
    | number
    | undefined;
  /**
   * If non-empty, "page_token" should contain a next_page_token
   * from a previous ListInstancesResponse to the same "parent"
   * and with the same "filter".
   */
  pageToken?: string | undefined;
}

/** Action that retrieves a Cloud Spanner instance. */
export interface GetCloudInstanceAction {
  /** Cloud project ID, e.g. "spanner-cloud-systest". */
  projectId: string;
  /**
   * Cloud instance ID (not path) to retrieve the instance from,
   * e.g. "test-instance".
   */
  instanceId: string;
}

/** Action that lists Cloud Spanner database operations. */
export interface ListCloudDatabaseOperationsAction {
  /** Cloud project ID, e.g. "spanner-cloud-systest". */
  projectId: string;
  /**
   * Cloud instance ID (not path) to list database operations from,
   * e.g. "test-instance".
   */
  instanceId: string;
  /**
   * A filter expression that filters what operations are returned in the
   * response.
   * The expression must specify the field name, a comparison operator,
   * and the value that you want to use for filtering.
   * Refer spanner_database_admin.proto.ListDatabaseOperationsRequest for
   * detail.
   */
  filter: string;
  /**
   * Number of databases to be returned in the response. If 0 or
   * less, defaults to the server's maximum allowed page size.
   */
  pageSize: number;
  /**
   * If non-empty, "page_token" should contain a next_page_token
   * from a previous ListDatabaseOperationsResponse to the same "parent"
   * and with the same "filter".
   */
  pageToken: string;
}

/** Action that restores a Cloud Spanner database from a backup. */
export interface RestoreCloudDatabaseAction {
  /** Cloud project ID, e.g. "spanner-cloud-systest". */
  projectId: string;
  /** Cloud instance ID (not path) containing the backup, e.g. "backup-instance". */
  backupInstanceId: string;
  /** The id of the backup from which to restore, e.g. "test-backup". */
  backupId: string;
  /**
   * Cloud instance ID (not path) containing the database, e.g.
   * "database-instance".
   */
  databaseInstanceId: string;
  /**
   * The id of the database to create and restore to, e.g. "db0". Note that this
   * database must not already exist.
   */
  databaseId: string;
  /**
   * The KMS key(s) used to encrypt the restored database to be created if the
   * restored database should be CMEK protected.
   */
  encryptionConfig: EncryptionConfig | undefined;
}

/** Action that gets a Cloud Spanner database. */
export interface GetCloudDatabaseAction {
  /** Cloud project ID, e.g. "spanner-cloud-systest". */
  projectId: string;
  /** Cloud instance ID (not path), e.g. "test-instance". */
  instanceId: string;
  /** The id of the database to get, e.g. "db0". */
  databaseId: string;
}

/** Action that creates a Cloud Spanner database backup. */
export interface CreateCloudBackupAction {
  /** Cloud project ID, e.g. "spanner-cloud-systest". */
  projectId: string;
  /** Cloud instance ID (not path), e.g. "test-instance". */
  instanceId: string;
  /** The id of the backup to be created, e.g. "test-backup". */
  backupId: string;
  /**
   * The id of the database from which this backup was
   * created, e.g. "db0". Note that this needs to be in the
   * same instance as the backup.
   */
  databaseId: string;
  /**
   * Output only. The expiration time of the backup, which must be at least 6
   * hours and at most 366 days from the time the request is received.
   */
  expireTime:
    | Date
    | undefined;
  /**
   * The version time of the backup, which must be within the time range of
   * [earliest_version_time, NOW], where earliest_version_time is retrieved by
   * cloud spanner frontend API (See details: go/cs-pitr-lite-design).
   */
  versionTime?:
    | Date
    | undefined;
  /**
   * The KMS key(s) used to encrypt the backup to be created if the backup
   * should be CMEK protected.
   */
  encryptionConfig: EncryptionConfig | undefined;
}

/** Action that copies a Cloud Spanner database backup. */
export interface CopyCloudBackupAction {
  /** Cloud project ID, e.g. "spanner-cloud-systest". */
  projectId: string;
  /** Cloud instance ID (not path), e.g. "test-instance". */
  instanceId: string;
  /** The id of the backup to be created, e.g. "test-backup". */
  backupId: string;
  /**
   * The fully qualified uri of the source backup from which this
   * backup was copied. eg.
   * "projects/<project_id>/instances/<instance_id>/backups/<backup_id>".
   */
  sourceBackup: string;
  /**
   * Output only. The expiration time of the backup, which must be at least 6
   * hours and at most 366 days from the time the request is received.
   */
  expireTime: Date | undefined;
}

/** Action that gets a Cloud Spanner database backup. */
export interface GetCloudBackupAction {
  /** Cloud project ID, e.g. "spanner-cloud-systest". */
  projectId: string;
  /** Cloud instance ID (not path), e.g. "test-instance". */
  instanceId: string;
  /** The id of the backup to get, e.g. "test-backup". */
  backupId: string;
}

/** Action that updates a Cloud Spanner database backup. */
export interface UpdateCloudBackupAction {
  /** Cloud project ID, e.g. "spanner-cloud-systest". */
  projectId: string;
  /** Cloud instance ID (not path), e.g. "test-instance". */
  instanceId: string;
  /** The id of the backup to update, e.g. "test-backup". */
  backupId: string;
  /**
   * Output only. Updated value of expire_time, this is the only field
   * that supported to be updated.
   */
  expireTime: Date | undefined;
}

/** Action that deletes a Cloud Spanner database backup. */
export interface DeleteCloudBackupAction {
  /** Cloud project ID, e.g. "spanner-cloud-systest". */
  projectId: string;
  /** Cloud instance ID (not path), e.g. "test-instance". */
  instanceId: string;
  /** The id of the backup to delete, e.g. "test-backup". */
  backupId: string;
}

/** Action that lists Cloud Spanner database backups. */
export interface ListCloudBackupsAction {
  /** Cloud project ID, e.g. "spanner-cloud-systest". */
  projectId: string;
  /** Cloud instance ID (not path) to list backups from, e.g. "test-instance". */
  instanceId: string;
  /**
   * A filter expression that filters backups listed in the response.
   * The expression must specify the field name, a comparison operator,
   * and the value that you want to use for filtering.
   * Refer backup.proto.ListBackupsRequest for detail.
   */
  filter: string;
  /**
   * Number of backups to be returned in the response. If 0 or
   * less, defaults to the server's maximum allowed page size.
   */
  pageSize: number;
  /**
   * If non-empty, "page_token" should contain a next_page_token
   * from a previous ListBackupsResponse to the same "parent"
   * and with the same "filter".
   */
  pageToken: string;
}

/** Action that lists Cloud Spanner database backup operations. */
export interface ListCloudBackupOperationsAction {
  /** Cloud project ID, e.g. "spanner-cloud-systest". */
  projectId: string;
  /**
   * Cloud instance ID (not path) to list backup operations from,
   * e.g. "test-instance".
   */
  instanceId: string;
  /**
   * A filter expression that filters what operations are returned in the
   * response.
   * The expression must specify the field name, a comparison operator,
   * and the value that you want to use for filtering.
   * Refer backup.proto.ListBackupOperationsRequest for detail.
   */
  filter: string;
  /**
   * Number of backups to be returned in the response. If 0 or
   * less, defaults to the server's maximum allowed page size.
   */
  pageSize: number;
  /**
   * If non-empty, "page_token" should contain a next_page_token
   * from a previous ListBackupOperationsResponse to the same "parent"
   * and with the same "filter".
   */
  pageToken: string;
}

/** Action that gets an operation. */
export interface GetOperationAction {
  /** The name of the operation resource. */
  operation: string;
}

/**
 * Query cancellation action defines the long running query and the cancel query
 * format depening on the Cloud database dialect.
 */
export interface QueryCancellationAction {
  /** Long running query. */
  longRunningSql: string;
  /** Format of the cancel query for the cloud database dialect. */
  cancelQuery: string;
}

/** Action that cancels an operation. */
export interface CancelOperationAction {
  /** The name of the operation resource to be cancelled. */
  operation: string;
}

/**
 * Starts a batch read-only transaction in executor. Successful outcomes of this
 * action will contain batch_txn_id--the identificator that can be used to start
 * the same transaction in other Executors to parallelize partition processing.
 *
 * Example of a batch read flow:
 * 1. Start batch transaction with a timestamp (StartBatchTransactionAction)
 * 2. Generate database partitions for a read or query
 * (GenerateDbPartitionsForReadAction/GenerateDbPartitionsForQueryAction)
 * 3. Call ExecutePartitionAction for some or all partitions, process rows
 * 4. Clean up the transaction (CloseBatchTransactionAction).
 *
 * More sophisticated example, with parallel processing:
 * 1. Start batch transaction with a timestamp (StartBatchTransactionAction),
 * note the returned BatchTransactionId
 * 2. Generate database partitions for a read or query
 * (GenerateDbPartitionsForReadAction/GenerateDbPartitionsForQueryAction)
 * 3. Distribute the partitions over a pool of workers, along with the
 * transaction ID.
 *
 * In each worker:
 * 4-1. StartBatchTransactionAction with the given transaction ID
 * 4-2. ExecutePartitionAction for each partition it got, process read results
 * 4-3. Close (not cleanup) the transaction (CloseBatchTransactionAction).
 *
 * When all workers are done:
 * 5. Cleanup the transaction (CloseBatchTransactionAction). This can be done
 * either by the last worker to finish the job, or by the main Executor that
 * initialized this transaction in the first place. It is also possible to clean
 * it up with a brand new Executor -- just execute StartBatchTransactionAction
 * with the ID, then clean it up right away.
 *
 * Cleaning up is optional, but recommended.
 */
export interface StartBatchTransactionAction {
  /** The exact timestamp to start the batch transaction. */
  batchTxnTime?:
    | Date
    | undefined;
  /**
   * ID of a batch read-only transaction. It can be used to start the same
   * batch transaction on multiple executors and parallelize partition
   * processing.
   */
  tid?:
    | Buffer
    | undefined;
  /**
   * Database role to assume while performing this action. Setting the
   * database_role will enforce additional role-based access checks on this
   * action.
   */
  cloudDatabaseRole: string;
}

/**
 * Closes or cleans up the currently opened batch read-only transaction.
 *
 * Once a transaction is closed, the Executor can be disposed of or used to
 * start start another transaction. Closing a batch transaction in one Executor
 * doesn't affect the transaction's state in other Executors that also read from
 * it.
 *
 * When a transaction is cleaned up, it becomes globally invalid. Cleaning up is
 * optional, but recommended.
 */
export interface CloseBatchTransactionAction {
  /** Indicates whether the transaction needs to be cleaned up. */
  cleanup: boolean;
}

/**
 * Generate database partitions for the given read. Successful outcomes will
 * contain database partitions in the db_partition field.
 */
export interface GenerateDbPartitionsForReadAction {
  /** Read to generate partitions for. */
  read:
    | ReadAction
    | undefined;
  /** Metadata related to the tables involved in the read. */
  table: TableMetadata[];
  /**
   * Desired size of data in each partition. Spanner doesn't guarantee to
   * respect this value.
   */
  desiredBytesPerPartition?:
    | Long
    | undefined;
  /**
   * If set, the desired max number of partitions. Spanner doesn't guarantee to
   * respect this value.
   */
  maxPartitionCount?: Long | undefined;
}

/**
 * Generate database partitions for the given query. Successful outcomes will
 * contain database partitions in the db_partition field.
 */
export interface GenerateDbPartitionsForQueryAction {
  /** Query to generate partitions for. */
  query:
    | QueryAction
    | undefined;
  /**
   * Desired size of data in each partition. Spanner doesn't guarantee to
   * respect this value.
   */
  desiredBytesPerPartition?: Long | undefined;
}

/**
 * Identifies a database partition generated for a particular read or query. To
 * read rows from the partition, use ExecutePartitionAction.
 */
export interface BatchPartition {
  /** Serialized Partition instance. */
  partition: Buffer;
  /** The partition token decrypted from partition. */
  partitionToken: Buffer;
  /**
   * Table name is set iff the partition was generated for a read (as opposed to
   * a query).
   */
  table?:
    | string
    | undefined;
  /** Index name if the partition was generated for an index read. */
  index?: string | undefined;
}

/**
 * Performs a read or query for the given partitions. This action must be
 * executed in the context of the same transaction that was used to generate
 * given partitions.
 */
export interface ExecutePartitionAction {
  /** Batch partition to execute on. */
  partition: BatchPartition | undefined;
}

/** Execute a change stream TVF query. */
export interface ExecuteChangeStreamQuery {
  /** Name for this change stream. */
  name: string;
  /**
   * Specifies that records with commit_timestamp greater than or equal to
   * start_time should be returned.
   */
  startTime:
    | Date
    | undefined;
  /**
   * Specifies that records with commit_timestamp less than or equal to
   * end_time should be returned.
   */
  endTime?:
    | Date
    | undefined;
  /**
   * Specifies which change stream partition to query, based on the content of
   * child partitions records.
   */
  partitionToken?:
    | string
    | undefined;
  /** Read options for this change stream query. */
  readOptions: string[];
  /**
   * Determines how frequently a heartbeat ChangeRecord will be returned in case
   * there are no transactions committed in this partition, in milliseconds.
   */
  heartbeatMilliseconds?:
    | number
    | undefined;
  /** Deadline for this change stream query, in seconds. */
  deadlineSeconds?:
    | Long
    | undefined;
  /**
   * Database role to assume while performing this action. This should only be
   * set for cloud requests. Setting the database role will enforce additional
   * role-based access checks on this action.
   */
  cloudDatabaseRole?: string | undefined;
}

/** SpannerActionOutcome defines a result of execution of a single SpannerAction. */
export interface SpannerActionOutcome {
  /**
   * If an outcome is split into multiple parts, status will be set only in the
   * last part.
   */
  status?:
    | Status
    | undefined;
  /** Transaction timestamp. It must be set for successful committed actions. */
  commitTime?:
    | Date
    | undefined;
  /**
   * Result of a ReadAction. This field must be set for ReadActions even if
   * no rows were read.
   */
  readResult?:
    | ReadResult
    | undefined;
  /**
   * Result of a Query. This field must be set for Queries even if no rows were
   * read.
   */
  queryResult?:
    | QueryResult
    | undefined;
  /**
   * This bit indicates that Spanner has restarted the current transaction. It
   * means that the client should replay all the reads and writes.
   * Setting it to true is only valid in the context of a read-write
   * transaction, as an outcome of a committing FinishTransactionAction.
   */
  transactionRestarted?:
    | boolean
    | undefined;
  /**
   * In successful StartBatchTransactionAction outcomes, this contains the ID of
   * the transaction.
   */
  batchTxnId?:
    | Buffer
    | undefined;
  /**
   * Generated database partitions (result of a
   * GenetageDbPartitionsForReadAction/GenerateDbPartitionsForQueryAction).
   */
  dbPartition: BatchPartition[];
  /** Result of admin related actions. */
  adminResult?:
    | AdminResult
    | undefined;
  /**
   * Stores rows modified by query in single DML or batch DML action.
   * In case of batch DML action, stores 0 as row count of errored DML query.
   */
  dmlRowsModified: Long[];
  /** Change stream records returned by a change stream query. */
  changeStreamRecords: ChangeStreamRecord[];
}

/** AdminResult contains admin action results, for database/backup/operation. */
export interface AdminResult {
  /** Results of cloud backup related actions. */
  backupResponse:
    | CloudBackupResponse
    | undefined;
  /** Results of operation related actions. */
  operationResponse:
    | OperationResponse
    | undefined;
  /** Results of database related actions. */
  databaseResponse:
    | CloudDatabaseResponse
    | undefined;
  /** Results of instance related actions. */
  instanceResponse:
    | CloudInstanceResponse
    | undefined;
  /** Results of instance config related actions. */
  instanceConfigResponse: CloudInstanceConfigResponse | undefined;
}

/**
 * CloudBackupResponse contains results returned by cloud backup related
 * actions.
 */
export interface CloudBackupResponse {
  /** List of backups returned by ListCloudBackupsAction. */
  listedBackups: Backup[];
  /** List of operations returned by ListCloudBackupOperationsAction. */
  listedBackupOperations: Operation[];
  /**
   * "next_page_token" can be sent in a subsequent list action
   * to fetch more of the matching data.
   */
  nextPageToken: string;
  /** Backup returned by GetCloudBackupAction/UpdateCloudBackupAction. */
  backup: Backup | undefined;
}

/** OperationResponse contains results returned by operation related actions. */
export interface OperationResponse {
  /** List of operations returned by ListOperationsAction. */
  listedOperations: Operation[];
  /**
   * "next_page_token" can be sent in a subsequent list action
   * to fetch more of the matching data.
   */
  nextPageToken: string;
  /** Operation returned by GetOperationAction. */
  operation: Operation | undefined;
}

/**
 * CloudInstanceResponse contains results returned by cloud instance related
 * actions.
 */
export interface CloudInstanceResponse {
  /** List of instances returned by ListCloudInstancesAction. */
  listedInstances: Instance[];
  /**
   * "next_page_token" can be sent in a subsequent list action
   * to fetch more of the matching data.
   */
  nextPageToken: string;
  /** Instance returned by GetCloudInstanceAction */
  instance: Instance | undefined;
}

/**
 * CloudInstanceConfigResponse contains results returned by cloud instance
 * config related actions.
 */
export interface CloudInstanceConfigResponse {
  /** List of instance configs returned by ListCloudInstanceConfigsAction. */
  listedInstanceConfigs: InstanceConfig[];
  /**
   * "next_page_token" can be sent in a subsequent list action
   * to fetch more of the matching data.
   */
  nextPageToken: string;
  /** Instance config returned by GetCloudInstanceConfigAction. */
  instanceConfig: InstanceConfig | undefined;
}

/**
 * CloudDatabaseResponse contains results returned by cloud database related
 * actions.
 */
export interface CloudDatabaseResponse {
  /** List of databases returned by ListCloudDatabasesAction. */
  listedDatabases: Database[];
  /** List of operations returned by ListCloudDatabaseOperationsAction. */
  listedDatabaseOperations: Operation[];
  /**
   * "next_page_token" can be sent in a subsequent list action
   * to fetch more of the matching data.
   */
  nextPageToken: string;
  /** Database returned by GetCloudDatabaseAction */
  database: Database | undefined;
}

/** ReadResult contains rows read. */
export interface ReadResult {
  /** Table name. */
  table: string;
  /** Index name, if read from an index. */
  index?:
    | string
    | undefined;
  /** Request index (multiread only). */
  requestIndex?:
    | number
    | undefined;
  /**
   * Rows read. Each row is a struct with multiple fields, one for each column
   * in read result. All rows have the same type.
   */
  row: ValueList[];
  /** The type of rows read. It must be set if at least one row was read. */
  rowType?: StructType | undefined;
}

/** QueryResult contains result of a Query. */
export interface QueryResult {
  /**
   * Rows read. Each row is a struct with multiple fields, one for each column
   * in read result. All rows have the same type.
   */
  row: ValueList[];
  /** The type of rows read. It must be set if at least one row was read. */
  rowType?: StructType | undefined;
}

/**
 * Raw ChangeStream records.
 * Encodes one of: DataChangeRecord, HeartbeatRecord, ChildPartitionsRecord
 * returned from the ChangeStream API.
 */
export interface ChangeStreamRecord {
  /** Data change record. */
  dataChange?:
    | DataChangeRecord
    | undefined;
  /** Child partitions record. */
  childPartition?:
    | ChildPartitionsRecord
    | undefined;
  /** Heartbeat record. */
  heartbeat?: HeartbeatRecord | undefined;
}

/** ChangeStream data change record. */
export interface DataChangeRecord {
  /** The timestamp in which the change was committed. */
  commitTime:
    | Date
    | undefined;
  /** The sequence number for the record within the transaction. */
  recordSequence: string;
  /**
   * A globally unique string that represents the transaction in which the
   * change was committed.
   */
  transactionId: string;
  /**
   * Indicates whether this is the last record for a transaction in the current
   * partition.
   */
  isLastRecord: boolean;
  /** Name of the table affected by the change. */
  table: string;
  /** Column types defined in the schema. */
  columnTypes: DataChangeRecord_ColumnType[];
  /** Changes made in the transaction. */
  mods: DataChangeRecord_Mod[];
  /** Describes the type of change. One of INSERT, UPDATE or DELETE. */
  modType: string;
  /** One of value capture type: NEW_VALUES, OLD_VALUES, OLD_AND_NEW_VALUES. */
  valueCaptureType: string;
  /** Number of records in transactions. */
  recordCount: Long;
  /** Number of partitions in transactions. */
  partitionCount: Long;
  /** Transaction tag info. */
  transactionTag: string;
  /** Whether the transaction is a system transactionn. */
  isSystemTransaction: boolean;
}

/** Column types. */
export interface DataChangeRecord_ColumnType {
  /** Column name. */
  name: string;
  /** Column type in JSON. */
  type: string;
  /** Whether the column is a primary key column. */
  isPrimaryKey: boolean;
  /** The position of the column as defined in the schema. */
  ordinalPosition: Long;
}

/** Describes the changes that were made. */
export interface DataChangeRecord_Mod {
  /** The primary key values in JSON. */
  keys: string;
  /**
   * The new values of the changed columns in JSON. Only contain the non-key
   * columns.
   */
  newValues: string;
  /**
   * The old values of the changed columns in JSON. Only contain the non-key
   * columns.
   */
  oldValues: string;
}

/** ChangeStream child partition record. */
export interface ChildPartitionsRecord {
  /**
   * Data change records returned from child partitions in this child partitions
   * record will have a commit timestamp greater than or equal to start_time.
   */
  startTime:
    | Date
    | undefined;
  /**
   * A monotonically increasing sequence number that can be used to define the
   * ordering of the child partitions record when there are multiple child
   * partitions records returned with the same start_time in a particular
   * partition.
   */
  recordSequence: string;
  /** A set of child partitions and their associated information. */
  childPartitions: ChildPartitionsRecord_ChildPartition[];
}

/** A single child partition. */
export interface ChildPartitionsRecord_ChildPartition {
  /** Partition token string used to identify the child partition in queries. */
  token: string;
  /** Parent partition tokens of this child partition. */
  parentPartitionTokens: string[];
}

/** ChangeStream heartbeat record. */
export interface HeartbeatRecord {
  /** Timestamp for this heartbeat check. */
  heartbeatTime: Date | undefined;
}

/** Options for Cloud Spanner Service. */
export interface SpannerOptions {
  /** Options for configuring the session pool */
  sessionPoolOptions: SessionPoolOptions | undefined;
}

/** Options for the session pool used by the DatabaseClient. */
export interface SessionPoolOptions {
  /**
   * passing this as true, will make applicable RPCs use multiplexed sessions
   * instead of regular sessions
   */
  useMultiplexed: boolean;
}

function createBaseSpannerAsyncActionRequest(): SpannerAsyncActionRequest {
  return { actionId: 0, action: undefined };
}

export const SpannerAsyncActionRequest: MessageFns<SpannerAsyncActionRequest> = {
  encode(message: SpannerAsyncActionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.actionId !== 0) {
      writer.uint32(8).int32(message.actionId);
    }
    if (message.action !== undefined) {
      SpannerAction.encode(message.action, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpannerAsyncActionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpannerAsyncActionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.actionId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.action = SpannerAction.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpannerAsyncActionRequest {
    return {
      actionId: isSet(object.actionId) ? globalThis.Number(object.actionId) : 0,
      action: isSet(object.action) ? SpannerAction.fromJSON(object.action) : undefined,
    };
  },

  toJSON(message: SpannerAsyncActionRequest): unknown {
    const obj: any = {};
    if (message.actionId !== 0) {
      obj.actionId = Math.round(message.actionId);
    }
    if (message.action !== undefined) {
      obj.action = SpannerAction.toJSON(message.action);
    }
    return obj;
  },

  create(base?: DeepPartial<SpannerAsyncActionRequest>): SpannerAsyncActionRequest {
    return SpannerAsyncActionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SpannerAsyncActionRequest>): SpannerAsyncActionRequest {
    const message = createBaseSpannerAsyncActionRequest();
    message.actionId = object.actionId ?? 0;
    message.action = (object.action !== undefined && object.action !== null)
      ? SpannerAction.fromPartial(object.action)
      : undefined;
    return message;
  },
};

function createBaseSpannerAsyncActionResponse(): SpannerAsyncActionResponse {
  return { actionId: 0, outcome: undefined };
}

export const SpannerAsyncActionResponse: MessageFns<SpannerAsyncActionResponse> = {
  encode(message: SpannerAsyncActionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.actionId !== 0) {
      writer.uint32(8).int32(message.actionId);
    }
    if (message.outcome !== undefined) {
      SpannerActionOutcome.encode(message.outcome, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpannerAsyncActionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpannerAsyncActionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.actionId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.outcome = SpannerActionOutcome.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpannerAsyncActionResponse {
    return {
      actionId: isSet(object.actionId) ? globalThis.Number(object.actionId) : 0,
      outcome: isSet(object.outcome) ? SpannerActionOutcome.fromJSON(object.outcome) : undefined,
    };
  },

  toJSON(message: SpannerAsyncActionResponse): unknown {
    const obj: any = {};
    if (message.actionId !== 0) {
      obj.actionId = Math.round(message.actionId);
    }
    if (message.outcome !== undefined) {
      obj.outcome = SpannerActionOutcome.toJSON(message.outcome);
    }
    return obj;
  },

  create(base?: DeepPartial<SpannerAsyncActionResponse>): SpannerAsyncActionResponse {
    return SpannerAsyncActionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SpannerAsyncActionResponse>): SpannerAsyncActionResponse {
    const message = createBaseSpannerAsyncActionResponse();
    message.actionId = object.actionId ?? 0;
    message.outcome = (object.outcome !== undefined && object.outcome !== null)
      ? SpannerActionOutcome.fromPartial(object.outcome)
      : undefined;
    return message;
  },
};

function createBaseSpannerAction(): SpannerAction {
  return {
    databasePath: "",
    spannerOptions: undefined,
    start: undefined,
    finish: undefined,
    read: undefined,
    query: undefined,
    mutation: undefined,
    dml: undefined,
    batchDml: undefined,
    write: undefined,
    partitionedUpdate: undefined,
    admin: undefined,
    startBatchTxn: undefined,
    closeBatchTxn: undefined,
    generateDbPartitionsRead: undefined,
    generateDbPartitionsQuery: undefined,
    executePartition: undefined,
    executeChangeStreamQuery: undefined,
    queryCancellation: undefined,
  };
}

export const SpannerAction: MessageFns<SpannerAction> = {
  encode(message: SpannerAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.databasePath !== "") {
      writer.uint32(10).string(message.databasePath);
    }
    if (message.spannerOptions !== undefined) {
      SpannerOptions.encode(message.spannerOptions, writer.uint32(18).fork()).join();
    }
    if (message.start !== undefined) {
      StartTransactionAction.encode(message.start, writer.uint32(82).fork()).join();
    }
    if (message.finish !== undefined) {
      FinishTransactionAction.encode(message.finish, writer.uint32(90).fork()).join();
    }
    if (message.read !== undefined) {
      ReadAction.encode(message.read, writer.uint32(162).fork()).join();
    }
    if (message.query !== undefined) {
      QueryAction.encode(message.query, writer.uint32(170).fork()).join();
    }
    if (message.mutation !== undefined) {
      MutationAction.encode(message.mutation, writer.uint32(178).fork()).join();
    }
    if (message.dml !== undefined) {
      DmlAction.encode(message.dml, writer.uint32(186).fork()).join();
    }
    if (message.batchDml !== undefined) {
      BatchDmlAction.encode(message.batchDml, writer.uint32(194).fork()).join();
    }
    if (message.write !== undefined) {
      WriteMutationsAction.encode(message.write, writer.uint32(202).fork()).join();
    }
    if (message.partitionedUpdate !== undefined) {
      PartitionedUpdateAction.encode(message.partitionedUpdate, writer.uint32(218).fork()).join();
    }
    if (message.admin !== undefined) {
      AdminAction.encode(message.admin, writer.uint32(242).fork()).join();
    }
    if (message.startBatchTxn !== undefined) {
      StartBatchTransactionAction.encode(message.startBatchTxn, writer.uint32(322).fork()).join();
    }
    if (message.closeBatchTxn !== undefined) {
      CloseBatchTransactionAction.encode(message.closeBatchTxn, writer.uint32(330).fork()).join();
    }
    if (message.generateDbPartitionsRead !== undefined) {
      GenerateDbPartitionsForReadAction.encode(message.generateDbPartitionsRead, writer.uint32(338).fork()).join();
    }
    if (message.generateDbPartitionsQuery !== undefined) {
      GenerateDbPartitionsForQueryAction.encode(message.generateDbPartitionsQuery, writer.uint32(346).fork()).join();
    }
    if (message.executePartition !== undefined) {
      ExecutePartitionAction.encode(message.executePartition, writer.uint32(354).fork()).join();
    }
    if (message.executeChangeStreamQuery !== undefined) {
      ExecuteChangeStreamQuery.encode(message.executeChangeStreamQuery, writer.uint32(402).fork()).join();
    }
    if (message.queryCancellation !== undefined) {
      QueryCancellationAction.encode(message.queryCancellation, writer.uint32(410).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpannerAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpannerAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.databasePath = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.spannerOptions = SpannerOptions.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.start = StartTransactionAction.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.finish = FinishTransactionAction.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.read = ReadAction.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.query = QueryAction.decode(reader, reader.uint32());
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.mutation = MutationAction.decode(reader, reader.uint32());
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.dml = DmlAction.decode(reader, reader.uint32());
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.batchDml = BatchDmlAction.decode(reader, reader.uint32());
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.write = WriteMutationsAction.decode(reader, reader.uint32());
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }

          message.partitionedUpdate = PartitionedUpdateAction.decode(reader, reader.uint32());
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }

          message.admin = AdminAction.decode(reader, reader.uint32());
          continue;
        case 40:
          if (tag !== 322) {
            break;
          }

          message.startBatchTxn = StartBatchTransactionAction.decode(reader, reader.uint32());
          continue;
        case 41:
          if (tag !== 330) {
            break;
          }

          message.closeBatchTxn = CloseBatchTransactionAction.decode(reader, reader.uint32());
          continue;
        case 42:
          if (tag !== 338) {
            break;
          }

          message.generateDbPartitionsRead = GenerateDbPartitionsForReadAction.decode(reader, reader.uint32());
          continue;
        case 43:
          if (tag !== 346) {
            break;
          }

          message.generateDbPartitionsQuery = GenerateDbPartitionsForQueryAction.decode(reader, reader.uint32());
          continue;
        case 44:
          if (tag !== 354) {
            break;
          }

          message.executePartition = ExecutePartitionAction.decode(reader, reader.uint32());
          continue;
        case 50:
          if (tag !== 402) {
            break;
          }

          message.executeChangeStreamQuery = ExecuteChangeStreamQuery.decode(reader, reader.uint32());
          continue;
        case 51:
          if (tag !== 410) {
            break;
          }

          message.queryCancellation = QueryCancellationAction.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpannerAction {
    return {
      databasePath: isSet(object.databasePath) ? globalThis.String(object.databasePath) : "",
      spannerOptions: isSet(object.spannerOptions) ? SpannerOptions.fromJSON(object.spannerOptions) : undefined,
      start: isSet(object.start) ? StartTransactionAction.fromJSON(object.start) : undefined,
      finish: isSet(object.finish) ? FinishTransactionAction.fromJSON(object.finish) : undefined,
      read: isSet(object.read) ? ReadAction.fromJSON(object.read) : undefined,
      query: isSet(object.query) ? QueryAction.fromJSON(object.query) : undefined,
      mutation: isSet(object.mutation) ? MutationAction.fromJSON(object.mutation) : undefined,
      dml: isSet(object.dml) ? DmlAction.fromJSON(object.dml) : undefined,
      batchDml: isSet(object.batchDml) ? BatchDmlAction.fromJSON(object.batchDml) : undefined,
      write: isSet(object.write) ? WriteMutationsAction.fromJSON(object.write) : undefined,
      partitionedUpdate: isSet(object.partitionedUpdate)
        ? PartitionedUpdateAction.fromJSON(object.partitionedUpdate)
        : undefined,
      admin: isSet(object.admin) ? AdminAction.fromJSON(object.admin) : undefined,
      startBatchTxn: isSet(object.startBatchTxn)
        ? StartBatchTransactionAction.fromJSON(object.startBatchTxn)
        : undefined,
      closeBatchTxn: isSet(object.closeBatchTxn)
        ? CloseBatchTransactionAction.fromJSON(object.closeBatchTxn)
        : undefined,
      generateDbPartitionsRead: isSet(object.generateDbPartitionsRead)
        ? GenerateDbPartitionsForReadAction.fromJSON(object.generateDbPartitionsRead)
        : undefined,
      generateDbPartitionsQuery: isSet(object.generateDbPartitionsQuery)
        ? GenerateDbPartitionsForQueryAction.fromJSON(object.generateDbPartitionsQuery)
        : undefined,
      executePartition: isSet(object.executePartition)
        ? ExecutePartitionAction.fromJSON(object.executePartition)
        : undefined,
      executeChangeStreamQuery: isSet(object.executeChangeStreamQuery)
        ? ExecuteChangeStreamQuery.fromJSON(object.executeChangeStreamQuery)
        : undefined,
      queryCancellation: isSet(object.queryCancellation)
        ? QueryCancellationAction.fromJSON(object.queryCancellation)
        : undefined,
    };
  },

  toJSON(message: SpannerAction): unknown {
    const obj: any = {};
    if (message.databasePath !== "") {
      obj.databasePath = message.databasePath;
    }
    if (message.spannerOptions !== undefined) {
      obj.spannerOptions = SpannerOptions.toJSON(message.spannerOptions);
    }
    if (message.start !== undefined) {
      obj.start = StartTransactionAction.toJSON(message.start);
    }
    if (message.finish !== undefined) {
      obj.finish = FinishTransactionAction.toJSON(message.finish);
    }
    if (message.read !== undefined) {
      obj.read = ReadAction.toJSON(message.read);
    }
    if (message.query !== undefined) {
      obj.query = QueryAction.toJSON(message.query);
    }
    if (message.mutation !== undefined) {
      obj.mutation = MutationAction.toJSON(message.mutation);
    }
    if (message.dml !== undefined) {
      obj.dml = DmlAction.toJSON(message.dml);
    }
    if (message.batchDml !== undefined) {
      obj.batchDml = BatchDmlAction.toJSON(message.batchDml);
    }
    if (message.write !== undefined) {
      obj.write = WriteMutationsAction.toJSON(message.write);
    }
    if (message.partitionedUpdate !== undefined) {
      obj.partitionedUpdate = PartitionedUpdateAction.toJSON(message.partitionedUpdate);
    }
    if (message.admin !== undefined) {
      obj.admin = AdminAction.toJSON(message.admin);
    }
    if (message.startBatchTxn !== undefined) {
      obj.startBatchTxn = StartBatchTransactionAction.toJSON(message.startBatchTxn);
    }
    if (message.closeBatchTxn !== undefined) {
      obj.closeBatchTxn = CloseBatchTransactionAction.toJSON(message.closeBatchTxn);
    }
    if (message.generateDbPartitionsRead !== undefined) {
      obj.generateDbPartitionsRead = GenerateDbPartitionsForReadAction.toJSON(message.generateDbPartitionsRead);
    }
    if (message.generateDbPartitionsQuery !== undefined) {
      obj.generateDbPartitionsQuery = GenerateDbPartitionsForQueryAction.toJSON(message.generateDbPartitionsQuery);
    }
    if (message.executePartition !== undefined) {
      obj.executePartition = ExecutePartitionAction.toJSON(message.executePartition);
    }
    if (message.executeChangeStreamQuery !== undefined) {
      obj.executeChangeStreamQuery = ExecuteChangeStreamQuery.toJSON(message.executeChangeStreamQuery);
    }
    if (message.queryCancellation !== undefined) {
      obj.queryCancellation = QueryCancellationAction.toJSON(message.queryCancellation);
    }
    return obj;
  },

  create(base?: DeepPartial<SpannerAction>): SpannerAction {
    return SpannerAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SpannerAction>): SpannerAction {
    const message = createBaseSpannerAction();
    message.databasePath = object.databasePath ?? "";
    message.spannerOptions = (object.spannerOptions !== undefined && object.spannerOptions !== null)
      ? SpannerOptions.fromPartial(object.spannerOptions)
      : undefined;
    message.start = (object.start !== undefined && object.start !== null)
      ? StartTransactionAction.fromPartial(object.start)
      : undefined;
    message.finish = (object.finish !== undefined && object.finish !== null)
      ? FinishTransactionAction.fromPartial(object.finish)
      : undefined;
    message.read = (object.read !== undefined && object.read !== null)
      ? ReadAction.fromPartial(object.read)
      : undefined;
    message.query = (object.query !== undefined && object.query !== null)
      ? QueryAction.fromPartial(object.query)
      : undefined;
    message.mutation = (object.mutation !== undefined && object.mutation !== null)
      ? MutationAction.fromPartial(object.mutation)
      : undefined;
    message.dml = (object.dml !== undefined && object.dml !== null) ? DmlAction.fromPartial(object.dml) : undefined;
    message.batchDml = (object.batchDml !== undefined && object.batchDml !== null)
      ? BatchDmlAction.fromPartial(object.batchDml)
      : undefined;
    message.write = (object.write !== undefined && object.write !== null)
      ? WriteMutationsAction.fromPartial(object.write)
      : undefined;
    message.partitionedUpdate = (object.partitionedUpdate !== undefined && object.partitionedUpdate !== null)
      ? PartitionedUpdateAction.fromPartial(object.partitionedUpdate)
      : undefined;
    message.admin = (object.admin !== undefined && object.admin !== null)
      ? AdminAction.fromPartial(object.admin)
      : undefined;
    message.startBatchTxn = (object.startBatchTxn !== undefined && object.startBatchTxn !== null)
      ? StartBatchTransactionAction.fromPartial(object.startBatchTxn)
      : undefined;
    message.closeBatchTxn = (object.closeBatchTxn !== undefined && object.closeBatchTxn !== null)
      ? CloseBatchTransactionAction.fromPartial(object.closeBatchTxn)
      : undefined;
    message.generateDbPartitionsRead =
      (object.generateDbPartitionsRead !== undefined && object.generateDbPartitionsRead !== null)
        ? GenerateDbPartitionsForReadAction.fromPartial(object.generateDbPartitionsRead)
        : undefined;
    message.generateDbPartitionsQuery =
      (object.generateDbPartitionsQuery !== undefined && object.generateDbPartitionsQuery !== null)
        ? GenerateDbPartitionsForQueryAction.fromPartial(object.generateDbPartitionsQuery)
        : undefined;
    message.executePartition = (object.executePartition !== undefined && object.executePartition !== null)
      ? ExecutePartitionAction.fromPartial(object.executePartition)
      : undefined;
    message.executeChangeStreamQuery =
      (object.executeChangeStreamQuery !== undefined && object.executeChangeStreamQuery !== null)
        ? ExecuteChangeStreamQuery.fromPartial(object.executeChangeStreamQuery)
        : undefined;
    message.queryCancellation = (object.queryCancellation !== undefined && object.queryCancellation !== null)
      ? QueryCancellationAction.fromPartial(object.queryCancellation)
      : undefined;
    return message;
  },
};

function createBaseReadAction(): ReadAction {
  return { table: "", index: undefined, column: [], keys: undefined, limit: 0 };
}

export const ReadAction: MessageFns<ReadAction> = {
  encode(message: ReadAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.table !== "") {
      writer.uint32(10).string(message.table);
    }
    if (message.index !== undefined) {
      writer.uint32(18).string(message.index);
    }
    for (const v of message.column) {
      writer.uint32(26).string(v!);
    }
    if (message.keys !== undefined) {
      KeySet.encode(message.keys, writer.uint32(34).fork()).join();
    }
    if (message.limit !== 0) {
      writer.uint32(40).int32(message.limit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReadAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.table = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.index = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.column.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.keys = KeySet.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.limit = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadAction {
    return {
      table: isSet(object.table) ? globalThis.String(object.table) : "",
      index: isSet(object.index) ? globalThis.String(object.index) : undefined,
      column: globalThis.Array.isArray(object?.column) ? object.column.map((e: any) => globalThis.String(e)) : [],
      keys: isSet(object.keys) ? KeySet.fromJSON(object.keys) : undefined,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
    };
  },

  toJSON(message: ReadAction): unknown {
    const obj: any = {};
    if (message.table !== "") {
      obj.table = message.table;
    }
    if (message.index !== undefined) {
      obj.index = message.index;
    }
    if (message.column?.length) {
      obj.column = message.column;
    }
    if (message.keys !== undefined) {
      obj.keys = KeySet.toJSON(message.keys);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    return obj;
  },

  create(base?: DeepPartial<ReadAction>): ReadAction {
    return ReadAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReadAction>): ReadAction {
    const message = createBaseReadAction();
    message.table = object.table ?? "";
    message.index = object.index ?? undefined;
    message.column = object.column?.map((e) => e) || [];
    message.keys = (object.keys !== undefined && object.keys !== null) ? KeySet.fromPartial(object.keys) : undefined;
    message.limit = object.limit ?? 0;
    return message;
  },
};

function createBaseQueryAction(): QueryAction {
  return { sql: "", params: [] };
}

export const QueryAction: MessageFns<QueryAction> = {
  encode(message: QueryAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sql !== "") {
      writer.uint32(10).string(message.sql);
    }
    for (const v of message.params) {
      QueryAction_Parameter.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sql = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.params.push(QueryAction_Parameter.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAction {
    return {
      sql: isSet(object.sql) ? globalThis.String(object.sql) : "",
      params: globalThis.Array.isArray(object?.params)
        ? object.params.map((e: any) => QueryAction_Parameter.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryAction): unknown {
    const obj: any = {};
    if (message.sql !== "") {
      obj.sql = message.sql;
    }
    if (message.params?.length) {
      obj.params = message.params.map((e) => QueryAction_Parameter.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<QueryAction>): QueryAction {
    return QueryAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryAction>): QueryAction {
    const message = createBaseQueryAction();
    message.sql = object.sql ?? "";
    message.params = object.params?.map((e) => QueryAction_Parameter.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryAction_Parameter(): QueryAction_Parameter {
  return { name: "", type: undefined, value: undefined };
}

export const QueryAction_Parameter: MessageFns<QueryAction_Parameter> = {
  encode(message: QueryAction_Parameter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== undefined) {
      Type.encode(message.type, writer.uint32(18).fork()).join();
    }
    if (message.value !== undefined) {
      Value.encode(message.value, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAction_Parameter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAction_Parameter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = Type.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.value = Value.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAction_Parameter {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? Type.fromJSON(object.type) : undefined,
      value: isSet(object.value) ? Value.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: QueryAction_Parameter): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== undefined) {
      obj.type = Type.toJSON(message.type);
    }
    if (message.value !== undefined) {
      obj.value = Value.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryAction_Parameter>): QueryAction_Parameter {
    return QueryAction_Parameter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryAction_Parameter>): QueryAction_Parameter {
    const message = createBaseQueryAction_Parameter();
    message.name = object.name ?? "";
    message.type = (object.type !== undefined && object.type !== null) ? Type.fromPartial(object.type) : undefined;
    message.value = (object.value !== undefined && object.value !== null) ? Value.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseDmlAction(): DmlAction {
  return { update: undefined, autocommitIfSupported: undefined };
}

export const DmlAction: MessageFns<DmlAction> = {
  encode(message: DmlAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.update !== undefined) {
      QueryAction.encode(message.update, writer.uint32(10).fork()).join();
    }
    if (message.autocommitIfSupported !== undefined) {
      writer.uint32(16).bool(message.autocommitIfSupported);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DmlAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDmlAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.update = QueryAction.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.autocommitIfSupported = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DmlAction {
    return {
      update: isSet(object.update) ? QueryAction.fromJSON(object.update) : undefined,
      autocommitIfSupported: isSet(object.autocommitIfSupported)
        ? globalThis.Boolean(object.autocommitIfSupported)
        : undefined,
    };
  },

  toJSON(message: DmlAction): unknown {
    const obj: any = {};
    if (message.update !== undefined) {
      obj.update = QueryAction.toJSON(message.update);
    }
    if (message.autocommitIfSupported !== undefined) {
      obj.autocommitIfSupported = message.autocommitIfSupported;
    }
    return obj;
  },

  create(base?: DeepPartial<DmlAction>): DmlAction {
    return DmlAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DmlAction>): DmlAction {
    const message = createBaseDmlAction();
    message.update = (object.update !== undefined && object.update !== null)
      ? QueryAction.fromPartial(object.update)
      : undefined;
    message.autocommitIfSupported = object.autocommitIfSupported ?? undefined;
    return message;
  },
};

function createBaseBatchDmlAction(): BatchDmlAction {
  return { updates: [] };
}

export const BatchDmlAction: MessageFns<BatchDmlAction> = {
  encode(message: BatchDmlAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.updates) {
      QueryAction.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchDmlAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchDmlAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updates.push(QueryAction.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchDmlAction {
    return {
      updates: globalThis.Array.isArray(object?.updates) ? object.updates.map((e: any) => QueryAction.fromJSON(e)) : [],
    };
  },

  toJSON(message: BatchDmlAction): unknown {
    const obj: any = {};
    if (message.updates?.length) {
      obj.updates = message.updates.map((e) => QueryAction.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchDmlAction>): BatchDmlAction {
    return BatchDmlAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchDmlAction>): BatchDmlAction {
    const message = createBaseBatchDmlAction();
    message.updates = object.updates?.map((e) => QueryAction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseValue(): Value {
  return {
    isNull: undefined,
    intValue: undefined,
    boolValue: undefined,
    doubleValue: undefined,
    bytesValue: undefined,
    stringValue: undefined,
    structValue: undefined,
    timestampValue: undefined,
    dateDaysValue: undefined,
    isCommitTimestamp: undefined,
    arrayValue: undefined,
    arrayType: undefined,
  };
}

export const Value: MessageFns<Value> = {
  encode(message: Value, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isNull !== undefined) {
      writer.uint32(8).bool(message.isNull);
    }
    if (message.intValue !== undefined) {
      writer.uint32(16).int64(message.intValue.toString());
    }
    if (message.boolValue !== undefined) {
      writer.uint32(24).bool(message.boolValue);
    }
    if (message.doubleValue !== undefined) {
      writer.uint32(33).double(message.doubleValue);
    }
    if (message.bytesValue !== undefined) {
      writer.uint32(42).bytes(message.bytesValue);
    }
    if (message.stringValue !== undefined) {
      writer.uint32(50).string(message.stringValue);
    }
    if (message.structValue !== undefined) {
      ValueList.encode(message.structValue, writer.uint32(58).fork()).join();
    }
    if (message.timestampValue !== undefined) {
      Timestamp.encode(toTimestamp(message.timestampValue), writer.uint32(66).fork()).join();
    }
    if (message.dateDaysValue !== undefined) {
      writer.uint32(72).int32(message.dateDaysValue);
    }
    if (message.isCommitTimestamp !== undefined) {
      writer.uint32(80).bool(message.isCommitTimestamp);
    }
    if (message.arrayValue !== undefined) {
      ValueList.encode(message.arrayValue, writer.uint32(90).fork()).join();
    }
    if (message.arrayType !== undefined) {
      Type.encode(message.arrayType, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Value {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.isNull = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.intValue = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.boolValue = reader.bool();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.doubleValue = reader.double();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.bytesValue = Buffer.from(reader.bytes());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.stringValue = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.structValue = ValueList.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.timestampValue = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.dateDaysValue = reader.int32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.isCommitTimestamp = reader.bool();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.arrayValue = ValueList.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.arrayType = Type.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Value {
    return {
      isNull: isSet(object.isNull) ? globalThis.Boolean(object.isNull) : undefined,
      intValue: isSet(object.intValue) ? Long.fromValue(object.intValue) : undefined,
      boolValue: isSet(object.boolValue) ? globalThis.Boolean(object.boolValue) : undefined,
      doubleValue: isSet(object.doubleValue) ? globalThis.Number(object.doubleValue) : undefined,
      bytesValue: isSet(object.bytesValue) ? Buffer.from(bytesFromBase64(object.bytesValue)) : undefined,
      stringValue: isSet(object.stringValue) ? globalThis.String(object.stringValue) : undefined,
      structValue: isSet(object.structValue) ? ValueList.fromJSON(object.structValue) : undefined,
      timestampValue: isSet(object.timestampValue) ? fromJsonTimestamp(object.timestampValue) : undefined,
      dateDaysValue: isSet(object.dateDaysValue) ? globalThis.Number(object.dateDaysValue) : undefined,
      isCommitTimestamp: isSet(object.isCommitTimestamp) ? globalThis.Boolean(object.isCommitTimestamp) : undefined,
      arrayValue: isSet(object.arrayValue) ? ValueList.fromJSON(object.arrayValue) : undefined,
      arrayType: isSet(object.arrayType) ? Type.fromJSON(object.arrayType) : undefined,
    };
  },

  toJSON(message: Value): unknown {
    const obj: any = {};
    if (message.isNull !== undefined) {
      obj.isNull = message.isNull;
    }
    if (message.intValue !== undefined) {
      obj.intValue = (message.intValue || Long.ZERO).toString();
    }
    if (message.boolValue !== undefined) {
      obj.boolValue = message.boolValue;
    }
    if (message.doubleValue !== undefined) {
      obj.doubleValue = message.doubleValue;
    }
    if (message.bytesValue !== undefined) {
      obj.bytesValue = base64FromBytes(message.bytesValue);
    }
    if (message.stringValue !== undefined) {
      obj.stringValue = message.stringValue;
    }
    if (message.structValue !== undefined) {
      obj.structValue = ValueList.toJSON(message.structValue);
    }
    if (message.timestampValue !== undefined) {
      obj.timestampValue = message.timestampValue.toISOString();
    }
    if (message.dateDaysValue !== undefined) {
      obj.dateDaysValue = Math.round(message.dateDaysValue);
    }
    if (message.isCommitTimestamp !== undefined) {
      obj.isCommitTimestamp = message.isCommitTimestamp;
    }
    if (message.arrayValue !== undefined) {
      obj.arrayValue = ValueList.toJSON(message.arrayValue);
    }
    if (message.arrayType !== undefined) {
      obj.arrayType = Type.toJSON(message.arrayType);
    }
    return obj;
  },

  create(base?: DeepPartial<Value>): Value {
    return Value.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Value>): Value {
    const message = createBaseValue();
    message.isNull = object.isNull ?? undefined;
    message.intValue = (object.intValue !== undefined && object.intValue !== null)
      ? Long.fromValue(object.intValue)
      : undefined;
    message.boolValue = object.boolValue ?? undefined;
    message.doubleValue = object.doubleValue ?? undefined;
    message.bytesValue = object.bytesValue ?? undefined;
    message.stringValue = object.stringValue ?? undefined;
    message.structValue = (object.structValue !== undefined && object.structValue !== null)
      ? ValueList.fromPartial(object.structValue)
      : undefined;
    message.timestampValue = object.timestampValue ?? undefined;
    message.dateDaysValue = object.dateDaysValue ?? undefined;
    message.isCommitTimestamp = object.isCommitTimestamp ?? undefined;
    message.arrayValue = (object.arrayValue !== undefined && object.arrayValue !== null)
      ? ValueList.fromPartial(object.arrayValue)
      : undefined;
    message.arrayType = (object.arrayType !== undefined && object.arrayType !== null)
      ? Type.fromPartial(object.arrayType)
      : undefined;
    return message;
  },
};

function createBaseKeyRange(): KeyRange {
  return { start: undefined, limit: undefined, type: undefined };
}

export const KeyRange: MessageFns<KeyRange> = {
  encode(message: KeyRange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.start !== undefined) {
      ValueList.encode(message.start, writer.uint32(10).fork()).join();
    }
    if (message.limit !== undefined) {
      ValueList.encode(message.limit, writer.uint32(18).fork()).join();
    }
    if (message.type !== undefined) {
      writer.uint32(24).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeyRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.start = ValueList.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.limit = ValueList.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyRange {
    return {
      start: isSet(object.start) ? ValueList.fromJSON(object.start) : undefined,
      limit: isSet(object.limit) ? ValueList.fromJSON(object.limit) : undefined,
      type: isSet(object.type) ? keyRange_TypeFromJSON(object.type) : undefined,
    };
  },

  toJSON(message: KeyRange): unknown {
    const obj: any = {};
    if (message.start !== undefined) {
      obj.start = ValueList.toJSON(message.start);
    }
    if (message.limit !== undefined) {
      obj.limit = ValueList.toJSON(message.limit);
    }
    if (message.type !== undefined) {
      obj.type = keyRange_TypeToJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<KeyRange>): KeyRange {
    return KeyRange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KeyRange>): KeyRange {
    const message = createBaseKeyRange();
    message.start = (object.start !== undefined && object.start !== null)
      ? ValueList.fromPartial(object.start)
      : undefined;
    message.limit = (object.limit !== undefined && object.limit !== null)
      ? ValueList.fromPartial(object.limit)
      : undefined;
    message.type = object.type ?? undefined;
    return message;
  },
};

function createBaseKeySet(): KeySet {
  return { point: [], range: [], all: false };
}

export const KeySet: MessageFns<KeySet> = {
  encode(message: KeySet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.point) {
      ValueList.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.range) {
      KeyRange.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.all !== false) {
      writer.uint32(24).bool(message.all);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeySet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeySet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.point.push(ValueList.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.range.push(KeyRange.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.all = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeySet {
    return {
      point: globalThis.Array.isArray(object?.point) ? object.point.map((e: any) => ValueList.fromJSON(e)) : [],
      range: globalThis.Array.isArray(object?.range) ? object.range.map((e: any) => KeyRange.fromJSON(e)) : [],
      all: isSet(object.all) ? globalThis.Boolean(object.all) : false,
    };
  },

  toJSON(message: KeySet): unknown {
    const obj: any = {};
    if (message.point?.length) {
      obj.point = message.point.map((e) => ValueList.toJSON(e));
    }
    if (message.range?.length) {
      obj.range = message.range.map((e) => KeyRange.toJSON(e));
    }
    if (message.all !== false) {
      obj.all = message.all;
    }
    return obj;
  },

  create(base?: DeepPartial<KeySet>): KeySet {
    return KeySet.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KeySet>): KeySet {
    const message = createBaseKeySet();
    message.point = object.point?.map((e) => ValueList.fromPartial(e)) || [];
    message.range = object.range?.map((e) => KeyRange.fromPartial(e)) || [];
    message.all = object.all ?? false;
    return message;
  },
};

function createBaseValueList(): ValueList {
  return { value: [] };
}

export const ValueList: MessageFns<ValueList> = {
  encode(message: ValueList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.value) {
      Value.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValueList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValueList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value.push(Value.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValueList {
    return { value: globalThis.Array.isArray(object?.value) ? object.value.map((e: any) => Value.fromJSON(e)) : [] };
  },

  toJSON(message: ValueList): unknown {
    const obj: any = {};
    if (message.value?.length) {
      obj.value = message.value.map((e) => Value.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ValueList>): ValueList {
    return ValueList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ValueList>): ValueList {
    const message = createBaseValueList();
    message.value = object.value?.map((e) => Value.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMutationAction(): MutationAction {
  return { mod: [] };
}

export const MutationAction: MessageFns<MutationAction> = {
  encode(message: MutationAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.mod) {
      MutationAction_Mod.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MutationAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMutationAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.mod.push(MutationAction_Mod.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MutationAction {
    return {
      mod: globalThis.Array.isArray(object?.mod) ? object.mod.map((e: any) => MutationAction_Mod.fromJSON(e)) : [],
    };
  },

  toJSON(message: MutationAction): unknown {
    const obj: any = {};
    if (message.mod?.length) {
      obj.mod = message.mod.map((e) => MutationAction_Mod.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MutationAction>): MutationAction {
    return MutationAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MutationAction>): MutationAction {
    const message = createBaseMutationAction();
    message.mod = object.mod?.map((e) => MutationAction_Mod.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMutationAction_InsertArgs(): MutationAction_InsertArgs {
  return { column: [], type: [], values: [] };
}

export const MutationAction_InsertArgs: MessageFns<MutationAction_InsertArgs> = {
  encode(message: MutationAction_InsertArgs, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.column) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.type) {
      Type.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.values) {
      ValueList.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MutationAction_InsertArgs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMutationAction_InsertArgs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.column.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type.push(Type.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.values.push(ValueList.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MutationAction_InsertArgs {
    return {
      column: globalThis.Array.isArray(object?.column) ? object.column.map((e: any) => globalThis.String(e)) : [],
      type: globalThis.Array.isArray(object?.type) ? object.type.map((e: any) => Type.fromJSON(e)) : [],
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => ValueList.fromJSON(e)) : [],
    };
  },

  toJSON(message: MutationAction_InsertArgs): unknown {
    const obj: any = {};
    if (message.column?.length) {
      obj.column = message.column;
    }
    if (message.type?.length) {
      obj.type = message.type.map((e) => Type.toJSON(e));
    }
    if (message.values?.length) {
      obj.values = message.values.map((e) => ValueList.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MutationAction_InsertArgs>): MutationAction_InsertArgs {
    return MutationAction_InsertArgs.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MutationAction_InsertArgs>): MutationAction_InsertArgs {
    const message = createBaseMutationAction_InsertArgs();
    message.column = object.column?.map((e) => e) || [];
    message.type = object.type?.map((e) => Type.fromPartial(e)) || [];
    message.values = object.values?.map((e) => ValueList.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMutationAction_UpdateArgs(): MutationAction_UpdateArgs {
  return { column: [], type: [], values: [] };
}

export const MutationAction_UpdateArgs: MessageFns<MutationAction_UpdateArgs> = {
  encode(message: MutationAction_UpdateArgs, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.column) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.type) {
      Type.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.values) {
      ValueList.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MutationAction_UpdateArgs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMutationAction_UpdateArgs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.column.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type.push(Type.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.values.push(ValueList.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MutationAction_UpdateArgs {
    return {
      column: globalThis.Array.isArray(object?.column) ? object.column.map((e: any) => globalThis.String(e)) : [],
      type: globalThis.Array.isArray(object?.type) ? object.type.map((e: any) => Type.fromJSON(e)) : [],
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => ValueList.fromJSON(e)) : [],
    };
  },

  toJSON(message: MutationAction_UpdateArgs): unknown {
    const obj: any = {};
    if (message.column?.length) {
      obj.column = message.column;
    }
    if (message.type?.length) {
      obj.type = message.type.map((e) => Type.toJSON(e));
    }
    if (message.values?.length) {
      obj.values = message.values.map((e) => ValueList.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MutationAction_UpdateArgs>): MutationAction_UpdateArgs {
    return MutationAction_UpdateArgs.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MutationAction_UpdateArgs>): MutationAction_UpdateArgs {
    const message = createBaseMutationAction_UpdateArgs();
    message.column = object.column?.map((e) => e) || [];
    message.type = object.type?.map((e) => Type.fromPartial(e)) || [];
    message.values = object.values?.map((e) => ValueList.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMutationAction_Mod(): MutationAction_Mod {
  return {
    table: "",
    insert: undefined,
    update: undefined,
    insertOrUpdate: undefined,
    replace: undefined,
    deleteKeys: undefined,
  };
}

export const MutationAction_Mod: MessageFns<MutationAction_Mod> = {
  encode(message: MutationAction_Mod, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.table !== "") {
      writer.uint32(10).string(message.table);
    }
    if (message.insert !== undefined) {
      MutationAction_InsertArgs.encode(message.insert, writer.uint32(18).fork()).join();
    }
    if (message.update !== undefined) {
      MutationAction_UpdateArgs.encode(message.update, writer.uint32(26).fork()).join();
    }
    if (message.insertOrUpdate !== undefined) {
      MutationAction_InsertArgs.encode(message.insertOrUpdate, writer.uint32(34).fork()).join();
    }
    if (message.replace !== undefined) {
      MutationAction_InsertArgs.encode(message.replace, writer.uint32(42).fork()).join();
    }
    if (message.deleteKeys !== undefined) {
      KeySet.encode(message.deleteKeys, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MutationAction_Mod {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMutationAction_Mod();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.table = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.insert = MutationAction_InsertArgs.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.update = MutationAction_UpdateArgs.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.insertOrUpdate = MutationAction_InsertArgs.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.replace = MutationAction_InsertArgs.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.deleteKeys = KeySet.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MutationAction_Mod {
    return {
      table: isSet(object.table) ? globalThis.String(object.table) : "",
      insert: isSet(object.insert) ? MutationAction_InsertArgs.fromJSON(object.insert) : undefined,
      update: isSet(object.update) ? MutationAction_UpdateArgs.fromJSON(object.update) : undefined,
      insertOrUpdate: isSet(object.insertOrUpdate)
        ? MutationAction_InsertArgs.fromJSON(object.insertOrUpdate)
        : undefined,
      replace: isSet(object.replace) ? MutationAction_InsertArgs.fromJSON(object.replace) : undefined,
      deleteKeys: isSet(object.deleteKeys) ? KeySet.fromJSON(object.deleteKeys) : undefined,
    };
  },

  toJSON(message: MutationAction_Mod): unknown {
    const obj: any = {};
    if (message.table !== "") {
      obj.table = message.table;
    }
    if (message.insert !== undefined) {
      obj.insert = MutationAction_InsertArgs.toJSON(message.insert);
    }
    if (message.update !== undefined) {
      obj.update = MutationAction_UpdateArgs.toJSON(message.update);
    }
    if (message.insertOrUpdate !== undefined) {
      obj.insertOrUpdate = MutationAction_InsertArgs.toJSON(message.insertOrUpdate);
    }
    if (message.replace !== undefined) {
      obj.replace = MutationAction_InsertArgs.toJSON(message.replace);
    }
    if (message.deleteKeys !== undefined) {
      obj.deleteKeys = KeySet.toJSON(message.deleteKeys);
    }
    return obj;
  },

  create(base?: DeepPartial<MutationAction_Mod>): MutationAction_Mod {
    return MutationAction_Mod.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MutationAction_Mod>): MutationAction_Mod {
    const message = createBaseMutationAction_Mod();
    message.table = object.table ?? "";
    message.insert = (object.insert !== undefined && object.insert !== null)
      ? MutationAction_InsertArgs.fromPartial(object.insert)
      : undefined;
    message.update = (object.update !== undefined && object.update !== null)
      ? MutationAction_UpdateArgs.fromPartial(object.update)
      : undefined;
    message.insertOrUpdate = (object.insertOrUpdate !== undefined && object.insertOrUpdate !== null)
      ? MutationAction_InsertArgs.fromPartial(object.insertOrUpdate)
      : undefined;
    message.replace = (object.replace !== undefined && object.replace !== null)
      ? MutationAction_InsertArgs.fromPartial(object.replace)
      : undefined;
    message.deleteKeys = (object.deleteKeys !== undefined && object.deleteKeys !== null)
      ? KeySet.fromPartial(object.deleteKeys)
      : undefined;
    return message;
  },
};

function createBaseWriteMutationsAction(): WriteMutationsAction {
  return { mutation: undefined };
}

export const WriteMutationsAction: MessageFns<WriteMutationsAction> = {
  encode(message: WriteMutationsAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mutation !== undefined) {
      MutationAction.encode(message.mutation, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WriteMutationsAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWriteMutationsAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.mutation = MutationAction.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WriteMutationsAction {
    return { mutation: isSet(object.mutation) ? MutationAction.fromJSON(object.mutation) : undefined };
  },

  toJSON(message: WriteMutationsAction): unknown {
    const obj: any = {};
    if (message.mutation !== undefined) {
      obj.mutation = MutationAction.toJSON(message.mutation);
    }
    return obj;
  },

  create(base?: DeepPartial<WriteMutationsAction>): WriteMutationsAction {
    return WriteMutationsAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WriteMutationsAction>): WriteMutationsAction {
    const message = createBaseWriteMutationsAction();
    message.mutation = (object.mutation !== undefined && object.mutation !== null)
      ? MutationAction.fromPartial(object.mutation)
      : undefined;
    return message;
  },
};

function createBasePartitionedUpdateAction(): PartitionedUpdateAction {
  return { options: undefined, update: undefined };
}

export const PartitionedUpdateAction: MessageFns<PartitionedUpdateAction> = {
  encode(message: PartitionedUpdateAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.options !== undefined) {
      PartitionedUpdateAction_ExecutePartitionedUpdateOptions.encode(message.options, writer.uint32(10).fork()).join();
    }
    if (message.update !== undefined) {
      QueryAction.encode(message.update, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PartitionedUpdateAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePartitionedUpdateAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.options = PartitionedUpdateAction_ExecutePartitionedUpdateOptions.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.update = QueryAction.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PartitionedUpdateAction {
    return {
      options: isSet(object.options)
        ? PartitionedUpdateAction_ExecutePartitionedUpdateOptions.fromJSON(object.options)
        : undefined,
      update: isSet(object.update) ? QueryAction.fromJSON(object.update) : undefined,
    };
  },

  toJSON(message: PartitionedUpdateAction): unknown {
    const obj: any = {};
    if (message.options !== undefined) {
      obj.options = PartitionedUpdateAction_ExecutePartitionedUpdateOptions.toJSON(message.options);
    }
    if (message.update !== undefined) {
      obj.update = QueryAction.toJSON(message.update);
    }
    return obj;
  },

  create(base?: DeepPartial<PartitionedUpdateAction>): PartitionedUpdateAction {
    return PartitionedUpdateAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PartitionedUpdateAction>): PartitionedUpdateAction {
    const message = createBasePartitionedUpdateAction();
    message.options = (object.options !== undefined && object.options !== null)
      ? PartitionedUpdateAction_ExecutePartitionedUpdateOptions.fromPartial(object.options)
      : undefined;
    message.update = (object.update !== undefined && object.update !== null)
      ? QueryAction.fromPartial(object.update)
      : undefined;
    return message;
  },
};

function createBasePartitionedUpdateAction_ExecutePartitionedUpdateOptions(): PartitionedUpdateAction_ExecutePartitionedUpdateOptions {
  return { rpcPriority: undefined, tag: undefined };
}

export const PartitionedUpdateAction_ExecutePartitionedUpdateOptions: MessageFns<
  PartitionedUpdateAction_ExecutePartitionedUpdateOptions
> = {
  encode(
    message: PartitionedUpdateAction_ExecutePartitionedUpdateOptions,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.rpcPriority !== undefined) {
      writer.uint32(8).int32(message.rpcPriority);
    }
    if (message.tag !== undefined) {
      writer.uint32(18).string(message.tag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PartitionedUpdateAction_ExecutePartitionedUpdateOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePartitionedUpdateAction_ExecutePartitionedUpdateOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.rpcPriority = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tag = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PartitionedUpdateAction_ExecutePartitionedUpdateOptions {
    return {
      rpcPriority: isSet(object.rpcPriority) ? requestOptions_PriorityFromJSON(object.rpcPriority) : undefined,
      tag: isSet(object.tag) ? globalThis.String(object.tag) : undefined,
    };
  },

  toJSON(message: PartitionedUpdateAction_ExecutePartitionedUpdateOptions): unknown {
    const obj: any = {};
    if (message.rpcPriority !== undefined) {
      obj.rpcPriority = requestOptions_PriorityToJSON(message.rpcPriority);
    }
    if (message.tag !== undefined) {
      obj.tag = message.tag;
    }
    return obj;
  },

  create(
    base?: DeepPartial<PartitionedUpdateAction_ExecutePartitionedUpdateOptions>,
  ): PartitionedUpdateAction_ExecutePartitionedUpdateOptions {
    return PartitionedUpdateAction_ExecutePartitionedUpdateOptions.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<PartitionedUpdateAction_ExecutePartitionedUpdateOptions>,
  ): PartitionedUpdateAction_ExecutePartitionedUpdateOptions {
    const message = createBasePartitionedUpdateAction_ExecutePartitionedUpdateOptions();
    message.rpcPriority = object.rpcPriority ?? undefined;
    message.tag = object.tag ?? undefined;
    return message;
  },
};

function createBaseStartTransactionAction(): StartTransactionAction {
  return { concurrency: undefined, table: [], transactionSeed: "", executionOptions: undefined };
}

export const StartTransactionAction: MessageFns<StartTransactionAction> = {
  encode(message: StartTransactionAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.concurrency !== undefined) {
      Concurrency.encode(message.concurrency, writer.uint32(10).fork()).join();
    }
    for (const v of message.table) {
      TableMetadata.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.transactionSeed !== "") {
      writer.uint32(26).string(message.transactionSeed);
    }
    if (message.executionOptions !== undefined) {
      TransactionExecutionOptions.encode(message.executionOptions, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartTransactionAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartTransactionAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.concurrency = Concurrency.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.table.push(TableMetadata.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.transactionSeed = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.executionOptions = TransactionExecutionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartTransactionAction {
    return {
      concurrency: isSet(object.concurrency) ? Concurrency.fromJSON(object.concurrency) : undefined,
      table: globalThis.Array.isArray(object?.table) ? object.table.map((e: any) => TableMetadata.fromJSON(e)) : [],
      transactionSeed: isSet(object.transactionSeed) ? globalThis.String(object.transactionSeed) : "",
      executionOptions: isSet(object.executionOptions)
        ? TransactionExecutionOptions.fromJSON(object.executionOptions)
        : undefined,
    };
  },

  toJSON(message: StartTransactionAction): unknown {
    const obj: any = {};
    if (message.concurrency !== undefined) {
      obj.concurrency = Concurrency.toJSON(message.concurrency);
    }
    if (message.table?.length) {
      obj.table = message.table.map((e) => TableMetadata.toJSON(e));
    }
    if (message.transactionSeed !== "") {
      obj.transactionSeed = message.transactionSeed;
    }
    if (message.executionOptions !== undefined) {
      obj.executionOptions = TransactionExecutionOptions.toJSON(message.executionOptions);
    }
    return obj;
  },

  create(base?: DeepPartial<StartTransactionAction>): StartTransactionAction {
    return StartTransactionAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartTransactionAction>): StartTransactionAction {
    const message = createBaseStartTransactionAction();
    message.concurrency = (object.concurrency !== undefined && object.concurrency !== null)
      ? Concurrency.fromPartial(object.concurrency)
      : undefined;
    message.table = object.table?.map((e) => TableMetadata.fromPartial(e)) || [];
    message.transactionSeed = object.transactionSeed ?? "";
    message.executionOptions = (object.executionOptions !== undefined && object.executionOptions !== null)
      ? TransactionExecutionOptions.fromPartial(object.executionOptions)
      : undefined;
    return message;
  },
};

function createBaseConcurrency(): Concurrency {
  return {
    stalenessSeconds: undefined,
    minReadTimestampMicros: undefined,
    maxStalenessSeconds: undefined,
    exactTimestampMicros: undefined,
    strong: undefined,
    batch: undefined,
    snapshotEpochRead: false,
    snapshotEpochRootTable: "",
    batchReadTimestampMicros: Long.ZERO,
  };
}

export const Concurrency: MessageFns<Concurrency> = {
  encode(message: Concurrency, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stalenessSeconds !== undefined) {
      writer.uint32(9).double(message.stalenessSeconds);
    }
    if (message.minReadTimestampMicros !== undefined) {
      writer.uint32(16).int64(message.minReadTimestampMicros.toString());
    }
    if (message.maxStalenessSeconds !== undefined) {
      writer.uint32(25).double(message.maxStalenessSeconds);
    }
    if (message.exactTimestampMicros !== undefined) {
      writer.uint32(32).int64(message.exactTimestampMicros.toString());
    }
    if (message.strong !== undefined) {
      writer.uint32(40).bool(message.strong);
    }
    if (message.batch !== undefined) {
      writer.uint32(48).bool(message.batch);
    }
    if (message.snapshotEpochRead !== false) {
      writer.uint32(56).bool(message.snapshotEpochRead);
    }
    if (message.snapshotEpochRootTable !== "") {
      writer.uint32(66).string(message.snapshotEpochRootTable);
    }
    if (!message.batchReadTimestampMicros.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.batchReadTimestampMicros.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Concurrency {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConcurrency();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.stalenessSeconds = reader.double();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.minReadTimestampMicros = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.maxStalenessSeconds = reader.double();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.exactTimestampMicros = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.strong = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.batch = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.snapshotEpochRead = reader.bool();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.snapshotEpochRootTable = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.batchReadTimestampMicros = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Concurrency {
    return {
      stalenessSeconds: isSet(object.stalenessSeconds) ? globalThis.Number(object.stalenessSeconds) : undefined,
      minReadTimestampMicros: isSet(object.minReadTimestampMicros)
        ? Long.fromValue(object.minReadTimestampMicros)
        : undefined,
      maxStalenessSeconds: isSet(object.maxStalenessSeconds)
        ? globalThis.Number(object.maxStalenessSeconds)
        : undefined,
      exactTimestampMicros: isSet(object.exactTimestampMicros)
        ? Long.fromValue(object.exactTimestampMicros)
        : undefined,
      strong: isSet(object.strong) ? globalThis.Boolean(object.strong) : undefined,
      batch: isSet(object.batch) ? globalThis.Boolean(object.batch) : undefined,
      snapshotEpochRead: isSet(object.snapshotEpochRead) ? globalThis.Boolean(object.snapshotEpochRead) : false,
      snapshotEpochRootTable: isSet(object.snapshotEpochRootTable)
        ? globalThis.String(object.snapshotEpochRootTable)
        : "",
      batchReadTimestampMicros: isSet(object.batchReadTimestampMicros)
        ? Long.fromValue(object.batchReadTimestampMicros)
        : Long.ZERO,
    };
  },

  toJSON(message: Concurrency): unknown {
    const obj: any = {};
    if (message.stalenessSeconds !== undefined) {
      obj.stalenessSeconds = message.stalenessSeconds;
    }
    if (message.minReadTimestampMicros !== undefined) {
      obj.minReadTimestampMicros = (message.minReadTimestampMicros || Long.ZERO).toString();
    }
    if (message.maxStalenessSeconds !== undefined) {
      obj.maxStalenessSeconds = message.maxStalenessSeconds;
    }
    if (message.exactTimestampMicros !== undefined) {
      obj.exactTimestampMicros = (message.exactTimestampMicros || Long.ZERO).toString();
    }
    if (message.strong !== undefined) {
      obj.strong = message.strong;
    }
    if (message.batch !== undefined) {
      obj.batch = message.batch;
    }
    if (message.snapshotEpochRead !== false) {
      obj.snapshotEpochRead = message.snapshotEpochRead;
    }
    if (message.snapshotEpochRootTable !== "") {
      obj.snapshotEpochRootTable = message.snapshotEpochRootTable;
    }
    if (!message.batchReadTimestampMicros.equals(Long.ZERO)) {
      obj.batchReadTimestampMicros = (message.batchReadTimestampMicros || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Concurrency>): Concurrency {
    return Concurrency.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Concurrency>): Concurrency {
    const message = createBaseConcurrency();
    message.stalenessSeconds = object.stalenessSeconds ?? undefined;
    message.minReadTimestampMicros =
      (object.minReadTimestampMicros !== undefined && object.minReadTimestampMicros !== null)
        ? Long.fromValue(object.minReadTimestampMicros)
        : undefined;
    message.maxStalenessSeconds = object.maxStalenessSeconds ?? undefined;
    message.exactTimestampMicros = (object.exactTimestampMicros !== undefined && object.exactTimestampMicros !== null)
      ? Long.fromValue(object.exactTimestampMicros)
      : undefined;
    message.strong = object.strong ?? undefined;
    message.batch = object.batch ?? undefined;
    message.snapshotEpochRead = object.snapshotEpochRead ?? false;
    message.snapshotEpochRootTable = object.snapshotEpochRootTable ?? "";
    message.batchReadTimestampMicros =
      (object.batchReadTimestampMicros !== undefined && object.batchReadTimestampMicros !== null)
        ? Long.fromValue(object.batchReadTimestampMicros)
        : Long.ZERO;
    return message;
  },
};

function createBaseTableMetadata(): TableMetadata {
  return { name: "", column: [], keyColumn: [] };
}

export const TableMetadata: MessageFns<TableMetadata> = {
  encode(message: TableMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.column) {
      ColumnMetadata.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.keyColumn) {
      ColumnMetadata.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TableMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTableMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.column.push(ColumnMetadata.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.keyColumn.push(ColumnMetadata.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TableMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      column: globalThis.Array.isArray(object?.column) ? object.column.map((e: any) => ColumnMetadata.fromJSON(e)) : [],
      keyColumn: globalThis.Array.isArray(object?.keyColumn)
        ? object.keyColumn.map((e: any) => ColumnMetadata.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TableMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.column?.length) {
      obj.column = message.column.map((e) => ColumnMetadata.toJSON(e));
    }
    if (message.keyColumn?.length) {
      obj.keyColumn = message.keyColumn.map((e) => ColumnMetadata.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TableMetadata>): TableMetadata {
    return TableMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TableMetadata>): TableMetadata {
    const message = createBaseTableMetadata();
    message.name = object.name ?? "";
    message.column = object.column?.map((e) => ColumnMetadata.fromPartial(e)) || [];
    message.keyColumn = object.keyColumn?.map((e) => ColumnMetadata.fromPartial(e)) || [];
    return message;
  },
};

function createBaseColumnMetadata(): ColumnMetadata {
  return { name: "", type: undefined };
}

export const ColumnMetadata: MessageFns<ColumnMetadata> = {
  encode(message: ColumnMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== undefined) {
      Type.encode(message.type, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ColumnMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseColumnMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = Type.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ColumnMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? Type.fromJSON(object.type) : undefined,
    };
  },

  toJSON(message: ColumnMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== undefined) {
      obj.type = Type.toJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<ColumnMetadata>): ColumnMetadata {
    return ColumnMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ColumnMetadata>): ColumnMetadata {
    const message = createBaseColumnMetadata();
    message.name = object.name ?? "";
    message.type = (object.type !== undefined && object.type !== null) ? Type.fromPartial(object.type) : undefined;
    return message;
  },
};

function createBaseTransactionExecutionOptions(): TransactionExecutionOptions {
  return { optimistic: false };
}

export const TransactionExecutionOptions: MessageFns<TransactionExecutionOptions> = {
  encode(message: TransactionExecutionOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.optimistic !== false) {
      writer.uint32(8).bool(message.optimistic);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionExecutionOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionExecutionOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.optimistic = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionExecutionOptions {
    return { optimistic: isSet(object.optimistic) ? globalThis.Boolean(object.optimistic) : false };
  },

  toJSON(message: TransactionExecutionOptions): unknown {
    const obj: any = {};
    if (message.optimistic !== false) {
      obj.optimistic = message.optimistic;
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionExecutionOptions>): TransactionExecutionOptions {
    return TransactionExecutionOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionExecutionOptions>): TransactionExecutionOptions {
    const message = createBaseTransactionExecutionOptions();
    message.optimistic = object.optimistic ?? false;
    return message;
  },
};

function createBaseFinishTransactionAction(): FinishTransactionAction {
  return { mode: 0 };
}

export const FinishTransactionAction: MessageFns<FinishTransactionAction> = {
  encode(message: FinishTransactionAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mode !== 0) {
      writer.uint32(8).int32(message.mode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinishTransactionAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinishTransactionAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinishTransactionAction {
    return { mode: isSet(object.mode) ? finishTransactionAction_ModeFromJSON(object.mode) : 0 };
  },

  toJSON(message: FinishTransactionAction): unknown {
    const obj: any = {};
    if (message.mode !== 0) {
      obj.mode = finishTransactionAction_ModeToJSON(message.mode);
    }
    return obj;
  },

  create(base?: DeepPartial<FinishTransactionAction>): FinishTransactionAction {
    return FinishTransactionAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FinishTransactionAction>): FinishTransactionAction {
    const message = createBaseFinishTransactionAction();
    message.mode = object.mode ?? 0;
    return message;
  },
};

function createBaseAdminAction(): AdminAction {
  return {
    createUserInstanceConfig: undefined,
    updateUserInstanceConfig: undefined,
    deleteUserInstanceConfig: undefined,
    getCloudInstanceConfig: undefined,
    listInstanceConfigs: undefined,
    createCloudInstance: undefined,
    updateCloudInstance: undefined,
    deleteCloudInstance: undefined,
    listCloudInstances: undefined,
    getCloudInstance: undefined,
    createCloudDatabase: undefined,
    updateCloudDatabaseDdl: undefined,
    updateCloudDatabase: undefined,
    dropCloudDatabase: undefined,
    listCloudDatabases: undefined,
    listCloudDatabaseOperations: undefined,
    restoreCloudDatabase: undefined,
    getCloudDatabase: undefined,
    createCloudBackup: undefined,
    copyCloudBackup: undefined,
    getCloudBackup: undefined,
    updateCloudBackup: undefined,
    deleteCloudBackup: undefined,
    listCloudBackups: undefined,
    listCloudBackupOperations: undefined,
    getOperation: undefined,
    cancelOperation: undefined,
    changeQuorumCloudDatabase: undefined,
  };
}

export const AdminAction: MessageFns<AdminAction> = {
  encode(message: AdminAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createUserInstanceConfig !== undefined) {
      CreateUserInstanceConfigAction.encode(message.createUserInstanceConfig, writer.uint32(10).fork()).join();
    }
    if (message.updateUserInstanceConfig !== undefined) {
      UpdateUserInstanceConfigAction.encode(message.updateUserInstanceConfig, writer.uint32(18).fork()).join();
    }
    if (message.deleteUserInstanceConfig !== undefined) {
      DeleteUserInstanceConfigAction.encode(message.deleteUserInstanceConfig, writer.uint32(26).fork()).join();
    }
    if (message.getCloudInstanceConfig !== undefined) {
      GetCloudInstanceConfigAction.encode(message.getCloudInstanceConfig, writer.uint32(34).fork()).join();
    }
    if (message.listInstanceConfigs !== undefined) {
      ListCloudInstanceConfigsAction.encode(message.listInstanceConfigs, writer.uint32(42).fork()).join();
    }
    if (message.createCloudInstance !== undefined) {
      CreateCloudInstanceAction.encode(message.createCloudInstance, writer.uint32(50).fork()).join();
    }
    if (message.updateCloudInstance !== undefined) {
      UpdateCloudInstanceAction.encode(message.updateCloudInstance, writer.uint32(58).fork()).join();
    }
    if (message.deleteCloudInstance !== undefined) {
      DeleteCloudInstanceAction.encode(message.deleteCloudInstance, writer.uint32(66).fork()).join();
    }
    if (message.listCloudInstances !== undefined) {
      ListCloudInstancesAction.encode(message.listCloudInstances, writer.uint32(74).fork()).join();
    }
    if (message.getCloudInstance !== undefined) {
      GetCloudInstanceAction.encode(message.getCloudInstance, writer.uint32(82).fork()).join();
    }
    if (message.createCloudDatabase !== undefined) {
      CreateCloudDatabaseAction.encode(message.createCloudDatabase, writer.uint32(90).fork()).join();
    }
    if (message.updateCloudDatabaseDdl !== undefined) {
      UpdateCloudDatabaseDdlAction.encode(message.updateCloudDatabaseDdl, writer.uint32(98).fork()).join();
    }
    if (message.updateCloudDatabase !== undefined) {
      UpdateCloudDatabaseAction.encode(message.updateCloudDatabase, writer.uint32(218).fork()).join();
    }
    if (message.dropCloudDatabase !== undefined) {
      DropCloudDatabaseAction.encode(message.dropCloudDatabase, writer.uint32(106).fork()).join();
    }
    if (message.listCloudDatabases !== undefined) {
      ListCloudDatabasesAction.encode(message.listCloudDatabases, writer.uint32(114).fork()).join();
    }
    if (message.listCloudDatabaseOperations !== undefined) {
      ListCloudDatabaseOperationsAction.encode(message.listCloudDatabaseOperations, writer.uint32(122).fork()).join();
    }
    if (message.restoreCloudDatabase !== undefined) {
      RestoreCloudDatabaseAction.encode(message.restoreCloudDatabase, writer.uint32(130).fork()).join();
    }
    if (message.getCloudDatabase !== undefined) {
      GetCloudDatabaseAction.encode(message.getCloudDatabase, writer.uint32(138).fork()).join();
    }
    if (message.createCloudBackup !== undefined) {
      CreateCloudBackupAction.encode(message.createCloudBackup, writer.uint32(146).fork()).join();
    }
    if (message.copyCloudBackup !== undefined) {
      CopyCloudBackupAction.encode(message.copyCloudBackup, writer.uint32(154).fork()).join();
    }
    if (message.getCloudBackup !== undefined) {
      GetCloudBackupAction.encode(message.getCloudBackup, writer.uint32(162).fork()).join();
    }
    if (message.updateCloudBackup !== undefined) {
      UpdateCloudBackupAction.encode(message.updateCloudBackup, writer.uint32(170).fork()).join();
    }
    if (message.deleteCloudBackup !== undefined) {
      DeleteCloudBackupAction.encode(message.deleteCloudBackup, writer.uint32(178).fork()).join();
    }
    if (message.listCloudBackups !== undefined) {
      ListCloudBackupsAction.encode(message.listCloudBackups, writer.uint32(186).fork()).join();
    }
    if (message.listCloudBackupOperations !== undefined) {
      ListCloudBackupOperationsAction.encode(message.listCloudBackupOperations, writer.uint32(194).fork()).join();
    }
    if (message.getOperation !== undefined) {
      GetOperationAction.encode(message.getOperation, writer.uint32(202).fork()).join();
    }
    if (message.cancelOperation !== undefined) {
      CancelOperationAction.encode(message.cancelOperation, writer.uint32(210).fork()).join();
    }
    if (message.changeQuorumCloudDatabase !== undefined) {
      ChangeQuorumCloudDatabaseAction.encode(message.changeQuorumCloudDatabase, writer.uint32(226).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdminAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdminAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.createUserInstanceConfig = CreateUserInstanceConfigAction.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateUserInstanceConfig = UpdateUserInstanceConfigAction.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.deleteUserInstanceConfig = DeleteUserInstanceConfigAction.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.getCloudInstanceConfig = GetCloudInstanceConfigAction.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.listInstanceConfigs = ListCloudInstanceConfigsAction.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.createCloudInstance = CreateCloudInstanceAction.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.updateCloudInstance = UpdateCloudInstanceAction.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.deleteCloudInstance = DeleteCloudInstanceAction.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.listCloudInstances = ListCloudInstancesAction.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.getCloudInstance = GetCloudInstanceAction.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.createCloudDatabase = CreateCloudDatabaseAction.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.updateCloudDatabaseDdl = UpdateCloudDatabaseDdlAction.decode(reader, reader.uint32());
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }

          message.updateCloudDatabase = UpdateCloudDatabaseAction.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.dropCloudDatabase = DropCloudDatabaseAction.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.listCloudDatabases = ListCloudDatabasesAction.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.listCloudDatabaseOperations = ListCloudDatabaseOperationsAction.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.restoreCloudDatabase = RestoreCloudDatabaseAction.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.getCloudDatabase = GetCloudDatabaseAction.decode(reader, reader.uint32());
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.createCloudBackup = CreateCloudBackupAction.decode(reader, reader.uint32());
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.copyCloudBackup = CopyCloudBackupAction.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.getCloudBackup = GetCloudBackupAction.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.updateCloudBackup = UpdateCloudBackupAction.decode(reader, reader.uint32());
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.deleteCloudBackup = DeleteCloudBackupAction.decode(reader, reader.uint32());
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.listCloudBackups = ListCloudBackupsAction.decode(reader, reader.uint32());
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.listCloudBackupOperations = ListCloudBackupOperationsAction.decode(reader, reader.uint32());
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.getOperation = GetOperationAction.decode(reader, reader.uint32());
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }

          message.cancelOperation = CancelOperationAction.decode(reader, reader.uint32());
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }

          message.changeQuorumCloudDatabase = ChangeQuorumCloudDatabaseAction.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdminAction {
    return {
      createUserInstanceConfig: isSet(object.createUserInstanceConfig)
        ? CreateUserInstanceConfigAction.fromJSON(object.createUserInstanceConfig)
        : undefined,
      updateUserInstanceConfig: isSet(object.updateUserInstanceConfig)
        ? UpdateUserInstanceConfigAction.fromJSON(object.updateUserInstanceConfig)
        : undefined,
      deleteUserInstanceConfig: isSet(object.deleteUserInstanceConfig)
        ? DeleteUserInstanceConfigAction.fromJSON(object.deleteUserInstanceConfig)
        : undefined,
      getCloudInstanceConfig: isSet(object.getCloudInstanceConfig)
        ? GetCloudInstanceConfigAction.fromJSON(object.getCloudInstanceConfig)
        : undefined,
      listInstanceConfigs: isSet(object.listInstanceConfigs)
        ? ListCloudInstanceConfigsAction.fromJSON(object.listInstanceConfigs)
        : undefined,
      createCloudInstance: isSet(object.createCloudInstance)
        ? CreateCloudInstanceAction.fromJSON(object.createCloudInstance)
        : undefined,
      updateCloudInstance: isSet(object.updateCloudInstance)
        ? UpdateCloudInstanceAction.fromJSON(object.updateCloudInstance)
        : undefined,
      deleteCloudInstance: isSet(object.deleteCloudInstance)
        ? DeleteCloudInstanceAction.fromJSON(object.deleteCloudInstance)
        : undefined,
      listCloudInstances: isSet(object.listCloudInstances)
        ? ListCloudInstancesAction.fromJSON(object.listCloudInstances)
        : undefined,
      getCloudInstance: isSet(object.getCloudInstance)
        ? GetCloudInstanceAction.fromJSON(object.getCloudInstance)
        : undefined,
      createCloudDatabase: isSet(object.createCloudDatabase)
        ? CreateCloudDatabaseAction.fromJSON(object.createCloudDatabase)
        : undefined,
      updateCloudDatabaseDdl: isSet(object.updateCloudDatabaseDdl)
        ? UpdateCloudDatabaseDdlAction.fromJSON(object.updateCloudDatabaseDdl)
        : undefined,
      updateCloudDatabase: isSet(object.updateCloudDatabase)
        ? UpdateCloudDatabaseAction.fromJSON(object.updateCloudDatabase)
        : undefined,
      dropCloudDatabase: isSet(object.dropCloudDatabase)
        ? DropCloudDatabaseAction.fromJSON(object.dropCloudDatabase)
        : undefined,
      listCloudDatabases: isSet(object.listCloudDatabases)
        ? ListCloudDatabasesAction.fromJSON(object.listCloudDatabases)
        : undefined,
      listCloudDatabaseOperations: isSet(object.listCloudDatabaseOperations)
        ? ListCloudDatabaseOperationsAction.fromJSON(object.listCloudDatabaseOperations)
        : undefined,
      restoreCloudDatabase: isSet(object.restoreCloudDatabase)
        ? RestoreCloudDatabaseAction.fromJSON(object.restoreCloudDatabase)
        : undefined,
      getCloudDatabase: isSet(object.getCloudDatabase)
        ? GetCloudDatabaseAction.fromJSON(object.getCloudDatabase)
        : undefined,
      createCloudBackup: isSet(object.createCloudBackup)
        ? CreateCloudBackupAction.fromJSON(object.createCloudBackup)
        : undefined,
      copyCloudBackup: isSet(object.copyCloudBackup)
        ? CopyCloudBackupAction.fromJSON(object.copyCloudBackup)
        : undefined,
      getCloudBackup: isSet(object.getCloudBackup) ? GetCloudBackupAction.fromJSON(object.getCloudBackup) : undefined,
      updateCloudBackup: isSet(object.updateCloudBackup)
        ? UpdateCloudBackupAction.fromJSON(object.updateCloudBackup)
        : undefined,
      deleteCloudBackup: isSet(object.deleteCloudBackup)
        ? DeleteCloudBackupAction.fromJSON(object.deleteCloudBackup)
        : undefined,
      listCloudBackups: isSet(object.listCloudBackups)
        ? ListCloudBackupsAction.fromJSON(object.listCloudBackups)
        : undefined,
      listCloudBackupOperations: isSet(object.listCloudBackupOperations)
        ? ListCloudBackupOperationsAction.fromJSON(object.listCloudBackupOperations)
        : undefined,
      getOperation: isSet(object.getOperation) ? GetOperationAction.fromJSON(object.getOperation) : undefined,
      cancelOperation: isSet(object.cancelOperation)
        ? CancelOperationAction.fromJSON(object.cancelOperation)
        : undefined,
      changeQuorumCloudDatabase: isSet(object.changeQuorumCloudDatabase)
        ? ChangeQuorumCloudDatabaseAction.fromJSON(object.changeQuorumCloudDatabase)
        : undefined,
    };
  },

  toJSON(message: AdminAction): unknown {
    const obj: any = {};
    if (message.createUserInstanceConfig !== undefined) {
      obj.createUserInstanceConfig = CreateUserInstanceConfigAction.toJSON(message.createUserInstanceConfig);
    }
    if (message.updateUserInstanceConfig !== undefined) {
      obj.updateUserInstanceConfig = UpdateUserInstanceConfigAction.toJSON(message.updateUserInstanceConfig);
    }
    if (message.deleteUserInstanceConfig !== undefined) {
      obj.deleteUserInstanceConfig = DeleteUserInstanceConfigAction.toJSON(message.deleteUserInstanceConfig);
    }
    if (message.getCloudInstanceConfig !== undefined) {
      obj.getCloudInstanceConfig = GetCloudInstanceConfigAction.toJSON(message.getCloudInstanceConfig);
    }
    if (message.listInstanceConfigs !== undefined) {
      obj.listInstanceConfigs = ListCloudInstanceConfigsAction.toJSON(message.listInstanceConfigs);
    }
    if (message.createCloudInstance !== undefined) {
      obj.createCloudInstance = CreateCloudInstanceAction.toJSON(message.createCloudInstance);
    }
    if (message.updateCloudInstance !== undefined) {
      obj.updateCloudInstance = UpdateCloudInstanceAction.toJSON(message.updateCloudInstance);
    }
    if (message.deleteCloudInstance !== undefined) {
      obj.deleteCloudInstance = DeleteCloudInstanceAction.toJSON(message.deleteCloudInstance);
    }
    if (message.listCloudInstances !== undefined) {
      obj.listCloudInstances = ListCloudInstancesAction.toJSON(message.listCloudInstances);
    }
    if (message.getCloudInstance !== undefined) {
      obj.getCloudInstance = GetCloudInstanceAction.toJSON(message.getCloudInstance);
    }
    if (message.createCloudDatabase !== undefined) {
      obj.createCloudDatabase = CreateCloudDatabaseAction.toJSON(message.createCloudDatabase);
    }
    if (message.updateCloudDatabaseDdl !== undefined) {
      obj.updateCloudDatabaseDdl = UpdateCloudDatabaseDdlAction.toJSON(message.updateCloudDatabaseDdl);
    }
    if (message.updateCloudDatabase !== undefined) {
      obj.updateCloudDatabase = UpdateCloudDatabaseAction.toJSON(message.updateCloudDatabase);
    }
    if (message.dropCloudDatabase !== undefined) {
      obj.dropCloudDatabase = DropCloudDatabaseAction.toJSON(message.dropCloudDatabase);
    }
    if (message.listCloudDatabases !== undefined) {
      obj.listCloudDatabases = ListCloudDatabasesAction.toJSON(message.listCloudDatabases);
    }
    if (message.listCloudDatabaseOperations !== undefined) {
      obj.listCloudDatabaseOperations = ListCloudDatabaseOperationsAction.toJSON(message.listCloudDatabaseOperations);
    }
    if (message.restoreCloudDatabase !== undefined) {
      obj.restoreCloudDatabase = RestoreCloudDatabaseAction.toJSON(message.restoreCloudDatabase);
    }
    if (message.getCloudDatabase !== undefined) {
      obj.getCloudDatabase = GetCloudDatabaseAction.toJSON(message.getCloudDatabase);
    }
    if (message.createCloudBackup !== undefined) {
      obj.createCloudBackup = CreateCloudBackupAction.toJSON(message.createCloudBackup);
    }
    if (message.copyCloudBackup !== undefined) {
      obj.copyCloudBackup = CopyCloudBackupAction.toJSON(message.copyCloudBackup);
    }
    if (message.getCloudBackup !== undefined) {
      obj.getCloudBackup = GetCloudBackupAction.toJSON(message.getCloudBackup);
    }
    if (message.updateCloudBackup !== undefined) {
      obj.updateCloudBackup = UpdateCloudBackupAction.toJSON(message.updateCloudBackup);
    }
    if (message.deleteCloudBackup !== undefined) {
      obj.deleteCloudBackup = DeleteCloudBackupAction.toJSON(message.deleteCloudBackup);
    }
    if (message.listCloudBackups !== undefined) {
      obj.listCloudBackups = ListCloudBackupsAction.toJSON(message.listCloudBackups);
    }
    if (message.listCloudBackupOperations !== undefined) {
      obj.listCloudBackupOperations = ListCloudBackupOperationsAction.toJSON(message.listCloudBackupOperations);
    }
    if (message.getOperation !== undefined) {
      obj.getOperation = GetOperationAction.toJSON(message.getOperation);
    }
    if (message.cancelOperation !== undefined) {
      obj.cancelOperation = CancelOperationAction.toJSON(message.cancelOperation);
    }
    if (message.changeQuorumCloudDatabase !== undefined) {
      obj.changeQuorumCloudDatabase = ChangeQuorumCloudDatabaseAction.toJSON(message.changeQuorumCloudDatabase);
    }
    return obj;
  },

  create(base?: DeepPartial<AdminAction>): AdminAction {
    return AdminAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AdminAction>): AdminAction {
    const message = createBaseAdminAction();
    message.createUserInstanceConfig =
      (object.createUserInstanceConfig !== undefined && object.createUserInstanceConfig !== null)
        ? CreateUserInstanceConfigAction.fromPartial(object.createUserInstanceConfig)
        : undefined;
    message.updateUserInstanceConfig =
      (object.updateUserInstanceConfig !== undefined && object.updateUserInstanceConfig !== null)
        ? UpdateUserInstanceConfigAction.fromPartial(object.updateUserInstanceConfig)
        : undefined;
    message.deleteUserInstanceConfig =
      (object.deleteUserInstanceConfig !== undefined && object.deleteUserInstanceConfig !== null)
        ? DeleteUserInstanceConfigAction.fromPartial(object.deleteUserInstanceConfig)
        : undefined;
    message.getCloudInstanceConfig =
      (object.getCloudInstanceConfig !== undefined && object.getCloudInstanceConfig !== null)
        ? GetCloudInstanceConfigAction.fromPartial(object.getCloudInstanceConfig)
        : undefined;
    message.listInstanceConfigs = (object.listInstanceConfigs !== undefined && object.listInstanceConfigs !== null)
      ? ListCloudInstanceConfigsAction.fromPartial(object.listInstanceConfigs)
      : undefined;
    message.createCloudInstance = (object.createCloudInstance !== undefined && object.createCloudInstance !== null)
      ? CreateCloudInstanceAction.fromPartial(object.createCloudInstance)
      : undefined;
    message.updateCloudInstance = (object.updateCloudInstance !== undefined && object.updateCloudInstance !== null)
      ? UpdateCloudInstanceAction.fromPartial(object.updateCloudInstance)
      : undefined;
    message.deleteCloudInstance = (object.deleteCloudInstance !== undefined && object.deleteCloudInstance !== null)
      ? DeleteCloudInstanceAction.fromPartial(object.deleteCloudInstance)
      : undefined;
    message.listCloudInstances = (object.listCloudInstances !== undefined && object.listCloudInstances !== null)
      ? ListCloudInstancesAction.fromPartial(object.listCloudInstances)
      : undefined;
    message.getCloudInstance = (object.getCloudInstance !== undefined && object.getCloudInstance !== null)
      ? GetCloudInstanceAction.fromPartial(object.getCloudInstance)
      : undefined;
    message.createCloudDatabase = (object.createCloudDatabase !== undefined && object.createCloudDatabase !== null)
      ? CreateCloudDatabaseAction.fromPartial(object.createCloudDatabase)
      : undefined;
    message.updateCloudDatabaseDdl =
      (object.updateCloudDatabaseDdl !== undefined && object.updateCloudDatabaseDdl !== null)
        ? UpdateCloudDatabaseDdlAction.fromPartial(object.updateCloudDatabaseDdl)
        : undefined;
    message.updateCloudDatabase = (object.updateCloudDatabase !== undefined && object.updateCloudDatabase !== null)
      ? UpdateCloudDatabaseAction.fromPartial(object.updateCloudDatabase)
      : undefined;
    message.dropCloudDatabase = (object.dropCloudDatabase !== undefined && object.dropCloudDatabase !== null)
      ? DropCloudDatabaseAction.fromPartial(object.dropCloudDatabase)
      : undefined;
    message.listCloudDatabases = (object.listCloudDatabases !== undefined && object.listCloudDatabases !== null)
      ? ListCloudDatabasesAction.fromPartial(object.listCloudDatabases)
      : undefined;
    message.listCloudDatabaseOperations =
      (object.listCloudDatabaseOperations !== undefined && object.listCloudDatabaseOperations !== null)
        ? ListCloudDatabaseOperationsAction.fromPartial(object.listCloudDatabaseOperations)
        : undefined;
    message.restoreCloudDatabase = (object.restoreCloudDatabase !== undefined && object.restoreCloudDatabase !== null)
      ? RestoreCloudDatabaseAction.fromPartial(object.restoreCloudDatabase)
      : undefined;
    message.getCloudDatabase = (object.getCloudDatabase !== undefined && object.getCloudDatabase !== null)
      ? GetCloudDatabaseAction.fromPartial(object.getCloudDatabase)
      : undefined;
    message.createCloudBackup = (object.createCloudBackup !== undefined && object.createCloudBackup !== null)
      ? CreateCloudBackupAction.fromPartial(object.createCloudBackup)
      : undefined;
    message.copyCloudBackup = (object.copyCloudBackup !== undefined && object.copyCloudBackup !== null)
      ? CopyCloudBackupAction.fromPartial(object.copyCloudBackup)
      : undefined;
    message.getCloudBackup = (object.getCloudBackup !== undefined && object.getCloudBackup !== null)
      ? GetCloudBackupAction.fromPartial(object.getCloudBackup)
      : undefined;
    message.updateCloudBackup = (object.updateCloudBackup !== undefined && object.updateCloudBackup !== null)
      ? UpdateCloudBackupAction.fromPartial(object.updateCloudBackup)
      : undefined;
    message.deleteCloudBackup = (object.deleteCloudBackup !== undefined && object.deleteCloudBackup !== null)
      ? DeleteCloudBackupAction.fromPartial(object.deleteCloudBackup)
      : undefined;
    message.listCloudBackups = (object.listCloudBackups !== undefined && object.listCloudBackups !== null)
      ? ListCloudBackupsAction.fromPartial(object.listCloudBackups)
      : undefined;
    message.listCloudBackupOperations =
      (object.listCloudBackupOperations !== undefined && object.listCloudBackupOperations !== null)
        ? ListCloudBackupOperationsAction.fromPartial(object.listCloudBackupOperations)
        : undefined;
    message.getOperation = (object.getOperation !== undefined && object.getOperation !== null)
      ? GetOperationAction.fromPartial(object.getOperation)
      : undefined;
    message.cancelOperation = (object.cancelOperation !== undefined && object.cancelOperation !== null)
      ? CancelOperationAction.fromPartial(object.cancelOperation)
      : undefined;
    message.changeQuorumCloudDatabase =
      (object.changeQuorumCloudDatabase !== undefined && object.changeQuorumCloudDatabase !== null)
        ? ChangeQuorumCloudDatabaseAction.fromPartial(object.changeQuorumCloudDatabase)
        : undefined;
    return message;
  },
};

function createBaseCreateUserInstanceConfigAction(): CreateUserInstanceConfigAction {
  return { userConfigId: "", projectId: "", baseConfigId: "", replicas: [] };
}

export const CreateUserInstanceConfigAction: MessageFns<CreateUserInstanceConfigAction> = {
  encode(message: CreateUserInstanceConfigAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userConfigId !== "") {
      writer.uint32(10).string(message.userConfigId);
    }
    if (message.projectId !== "") {
      writer.uint32(18).string(message.projectId);
    }
    if (message.baseConfigId !== "") {
      writer.uint32(26).string(message.baseConfigId);
    }
    for (const v of message.replicas) {
      ReplicaInfo.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateUserInstanceConfigAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateUserInstanceConfigAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userConfigId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.baseConfigId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.replicas.push(ReplicaInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateUserInstanceConfigAction {
    return {
      userConfigId: isSet(object.userConfigId) ? globalThis.String(object.userConfigId) : "",
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      baseConfigId: isSet(object.baseConfigId) ? globalThis.String(object.baseConfigId) : "",
      replicas: globalThis.Array.isArray(object?.replicas)
        ? object.replicas.map((e: any) => ReplicaInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CreateUserInstanceConfigAction): unknown {
    const obj: any = {};
    if (message.userConfigId !== "") {
      obj.userConfigId = message.userConfigId;
    }
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.baseConfigId !== "") {
      obj.baseConfigId = message.baseConfigId;
    }
    if (message.replicas?.length) {
      obj.replicas = message.replicas.map((e) => ReplicaInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CreateUserInstanceConfigAction>): CreateUserInstanceConfigAction {
    return CreateUserInstanceConfigAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateUserInstanceConfigAction>): CreateUserInstanceConfigAction {
    const message = createBaseCreateUserInstanceConfigAction();
    message.userConfigId = object.userConfigId ?? "";
    message.projectId = object.projectId ?? "";
    message.baseConfigId = object.baseConfigId ?? "";
    message.replicas = object.replicas?.map((e) => ReplicaInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUpdateUserInstanceConfigAction(): UpdateUserInstanceConfigAction {
  return { userConfigId: "", projectId: "", displayName: undefined, labels: {} };
}

export const UpdateUserInstanceConfigAction: MessageFns<UpdateUserInstanceConfigAction> = {
  encode(message: UpdateUserInstanceConfigAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userConfigId !== "") {
      writer.uint32(10).string(message.userConfigId);
    }
    if (message.projectId !== "") {
      writer.uint32(18).string(message.projectId);
    }
    if (message.displayName !== undefined) {
      writer.uint32(26).string(message.displayName);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      UpdateUserInstanceConfigAction_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateUserInstanceConfigAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateUserInstanceConfigAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userConfigId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = UpdateUserInstanceConfigAction_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateUserInstanceConfigAction {
    return {
      userConfigId: isSet(object.userConfigId) ? globalThis.String(object.userConfigId) : "",
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: UpdateUserInstanceConfigAction): unknown {
    const obj: any = {};
    if (message.userConfigId !== "") {
      obj.userConfigId = message.userConfigId;
    }
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.displayName !== undefined) {
      obj.displayName = message.displayName;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateUserInstanceConfigAction>): UpdateUserInstanceConfigAction {
    return UpdateUserInstanceConfigAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateUserInstanceConfigAction>): UpdateUserInstanceConfigAction {
    const message = createBaseUpdateUserInstanceConfigAction();
    message.userConfigId = object.userConfigId ?? "";
    message.projectId = object.projectId ?? "";
    message.displayName = object.displayName ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseUpdateUserInstanceConfigAction_LabelsEntry(): UpdateUserInstanceConfigAction_LabelsEntry {
  return { key: "", value: "" };
}

export const UpdateUserInstanceConfigAction_LabelsEntry: MessageFns<UpdateUserInstanceConfigAction_LabelsEntry> = {
  encode(message: UpdateUserInstanceConfigAction_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateUserInstanceConfigAction_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateUserInstanceConfigAction_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateUserInstanceConfigAction_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: UpdateUserInstanceConfigAction_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateUserInstanceConfigAction_LabelsEntry>): UpdateUserInstanceConfigAction_LabelsEntry {
    return UpdateUserInstanceConfigAction_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<UpdateUserInstanceConfigAction_LabelsEntry>,
  ): UpdateUserInstanceConfigAction_LabelsEntry {
    const message = createBaseUpdateUserInstanceConfigAction_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGetCloudInstanceConfigAction(): GetCloudInstanceConfigAction {
  return { instanceConfigId: "", projectId: "" };
}

export const GetCloudInstanceConfigAction: MessageFns<GetCloudInstanceConfigAction> = {
  encode(message: GetCloudInstanceConfigAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instanceConfigId !== "") {
      writer.uint32(10).string(message.instanceConfigId);
    }
    if (message.projectId !== "") {
      writer.uint32(18).string(message.projectId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCloudInstanceConfigAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCloudInstanceConfigAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instanceConfigId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.projectId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCloudInstanceConfigAction {
    return {
      instanceConfigId: isSet(object.instanceConfigId) ? globalThis.String(object.instanceConfigId) : "",
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
    };
  },

  toJSON(message: GetCloudInstanceConfigAction): unknown {
    const obj: any = {};
    if (message.instanceConfigId !== "") {
      obj.instanceConfigId = message.instanceConfigId;
    }
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetCloudInstanceConfigAction>): GetCloudInstanceConfigAction {
    return GetCloudInstanceConfigAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetCloudInstanceConfigAction>): GetCloudInstanceConfigAction {
    const message = createBaseGetCloudInstanceConfigAction();
    message.instanceConfigId = object.instanceConfigId ?? "";
    message.projectId = object.projectId ?? "";
    return message;
  },
};

function createBaseDeleteUserInstanceConfigAction(): DeleteUserInstanceConfigAction {
  return { userConfigId: "", projectId: "" };
}

export const DeleteUserInstanceConfigAction: MessageFns<DeleteUserInstanceConfigAction> = {
  encode(message: DeleteUserInstanceConfigAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userConfigId !== "") {
      writer.uint32(10).string(message.userConfigId);
    }
    if (message.projectId !== "") {
      writer.uint32(18).string(message.projectId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteUserInstanceConfigAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteUserInstanceConfigAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userConfigId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.projectId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteUserInstanceConfigAction {
    return {
      userConfigId: isSet(object.userConfigId) ? globalThis.String(object.userConfigId) : "",
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
    };
  },

  toJSON(message: DeleteUserInstanceConfigAction): unknown {
    const obj: any = {};
    if (message.userConfigId !== "") {
      obj.userConfigId = message.userConfigId;
    }
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteUserInstanceConfigAction>): DeleteUserInstanceConfigAction {
    return DeleteUserInstanceConfigAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteUserInstanceConfigAction>): DeleteUserInstanceConfigAction {
    const message = createBaseDeleteUserInstanceConfigAction();
    message.userConfigId = object.userConfigId ?? "";
    message.projectId = object.projectId ?? "";
    return message;
  },
};

function createBaseListCloudInstanceConfigsAction(): ListCloudInstanceConfigsAction {
  return { projectId: "", pageSize: undefined, pageToken: undefined };
}

export const ListCloudInstanceConfigsAction: MessageFns<ListCloudInstanceConfigsAction> = {
  encode(message: ListCloudInstanceConfigsAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.pageSize !== undefined) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCloudInstanceConfigsAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCloudInstanceConfigsAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCloudInstanceConfigsAction {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : undefined,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : undefined,
    };
  },

  toJSON(message: ListCloudInstanceConfigsAction): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListCloudInstanceConfigsAction>): ListCloudInstanceConfigsAction {
    return ListCloudInstanceConfigsAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListCloudInstanceConfigsAction>): ListCloudInstanceConfigsAction {
    const message = createBaseListCloudInstanceConfigsAction();
    message.projectId = object.projectId ?? "";
    message.pageSize = object.pageSize ?? undefined;
    message.pageToken = object.pageToken ?? undefined;
    return message;
  },
};

function createBaseCreateCloudInstanceAction(): CreateCloudInstanceAction {
  return {
    instanceId: "",
    projectId: "",
    instanceConfigId: "",
    nodeCount: undefined,
    processingUnits: undefined,
    autoscalingConfig: undefined,
    labels: {},
  };
}

export const CreateCloudInstanceAction: MessageFns<CreateCloudInstanceAction> = {
  encode(message: CreateCloudInstanceAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instanceId !== "") {
      writer.uint32(10).string(message.instanceId);
    }
    if (message.projectId !== "") {
      writer.uint32(18).string(message.projectId);
    }
    if (message.instanceConfigId !== "") {
      writer.uint32(26).string(message.instanceConfigId);
    }
    if (message.nodeCount !== undefined) {
      writer.uint32(32).int32(message.nodeCount);
    }
    if (message.processingUnits !== undefined) {
      writer.uint32(48).int32(message.processingUnits);
    }
    if (message.autoscalingConfig !== undefined) {
      AutoscalingConfig.encode(message.autoscalingConfig, writer.uint32(58).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      CreateCloudInstanceAction_LabelsEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCloudInstanceAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCloudInstanceAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instanceId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.instanceConfigId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.nodeCount = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.processingUnits = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.autoscalingConfig = AutoscalingConfig.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = CreateCloudInstanceAction_LabelsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.labels[entry5.key] = entry5.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCloudInstanceAction {
    return {
      instanceId: isSet(object.instanceId) ? globalThis.String(object.instanceId) : "",
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      instanceConfigId: isSet(object.instanceConfigId) ? globalThis.String(object.instanceConfigId) : "",
      nodeCount: isSet(object.nodeCount) ? globalThis.Number(object.nodeCount) : undefined,
      processingUnits: isSet(object.processingUnits) ? globalThis.Number(object.processingUnits) : undefined,
      autoscalingConfig: isSet(object.autoscalingConfig)
        ? AutoscalingConfig.fromJSON(object.autoscalingConfig)
        : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: CreateCloudInstanceAction): unknown {
    const obj: any = {};
    if (message.instanceId !== "") {
      obj.instanceId = message.instanceId;
    }
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.instanceConfigId !== "") {
      obj.instanceConfigId = message.instanceConfigId;
    }
    if (message.nodeCount !== undefined) {
      obj.nodeCount = Math.round(message.nodeCount);
    }
    if (message.processingUnits !== undefined) {
      obj.processingUnits = Math.round(message.processingUnits);
    }
    if (message.autoscalingConfig !== undefined) {
      obj.autoscalingConfig = AutoscalingConfig.toJSON(message.autoscalingConfig);
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<CreateCloudInstanceAction>): CreateCloudInstanceAction {
    return CreateCloudInstanceAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateCloudInstanceAction>): CreateCloudInstanceAction {
    const message = createBaseCreateCloudInstanceAction();
    message.instanceId = object.instanceId ?? "";
    message.projectId = object.projectId ?? "";
    message.instanceConfigId = object.instanceConfigId ?? "";
    message.nodeCount = object.nodeCount ?? undefined;
    message.processingUnits = object.processingUnits ?? undefined;
    message.autoscalingConfig = (object.autoscalingConfig !== undefined && object.autoscalingConfig !== null)
      ? AutoscalingConfig.fromPartial(object.autoscalingConfig)
      : undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseCreateCloudInstanceAction_LabelsEntry(): CreateCloudInstanceAction_LabelsEntry {
  return { key: "", value: "" };
}

export const CreateCloudInstanceAction_LabelsEntry: MessageFns<CreateCloudInstanceAction_LabelsEntry> = {
  encode(message: CreateCloudInstanceAction_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCloudInstanceAction_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCloudInstanceAction_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCloudInstanceAction_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreateCloudInstanceAction_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateCloudInstanceAction_LabelsEntry>): CreateCloudInstanceAction_LabelsEntry {
    return CreateCloudInstanceAction_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateCloudInstanceAction_LabelsEntry>): CreateCloudInstanceAction_LabelsEntry {
    const message = createBaseCreateCloudInstanceAction_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseUpdateCloudInstanceAction(): UpdateCloudInstanceAction {
  return {
    instanceId: "",
    projectId: "",
    displayName: undefined,
    nodeCount: undefined,
    processingUnits: undefined,
    autoscalingConfig: undefined,
    labels: {},
  };
}

export const UpdateCloudInstanceAction: MessageFns<UpdateCloudInstanceAction> = {
  encode(message: UpdateCloudInstanceAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instanceId !== "") {
      writer.uint32(10).string(message.instanceId);
    }
    if (message.projectId !== "") {
      writer.uint32(18).string(message.projectId);
    }
    if (message.displayName !== undefined) {
      writer.uint32(26).string(message.displayName);
    }
    if (message.nodeCount !== undefined) {
      writer.uint32(32).int32(message.nodeCount);
    }
    if (message.processingUnits !== undefined) {
      writer.uint32(40).int32(message.processingUnits);
    }
    if (message.autoscalingConfig !== undefined) {
      AutoscalingConfig.encode(message.autoscalingConfig, writer.uint32(58).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      UpdateCloudInstanceAction_LabelsEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateCloudInstanceAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCloudInstanceAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instanceId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.nodeCount = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.processingUnits = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.autoscalingConfig = AutoscalingConfig.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = UpdateCloudInstanceAction_LabelsEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.labels[entry6.key] = entry6.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateCloudInstanceAction {
    return {
      instanceId: isSet(object.instanceId) ? globalThis.String(object.instanceId) : "",
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : undefined,
      nodeCount: isSet(object.nodeCount) ? globalThis.Number(object.nodeCount) : undefined,
      processingUnits: isSet(object.processingUnits) ? globalThis.Number(object.processingUnits) : undefined,
      autoscalingConfig: isSet(object.autoscalingConfig)
        ? AutoscalingConfig.fromJSON(object.autoscalingConfig)
        : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: UpdateCloudInstanceAction): unknown {
    const obj: any = {};
    if (message.instanceId !== "") {
      obj.instanceId = message.instanceId;
    }
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.displayName !== undefined) {
      obj.displayName = message.displayName;
    }
    if (message.nodeCount !== undefined) {
      obj.nodeCount = Math.round(message.nodeCount);
    }
    if (message.processingUnits !== undefined) {
      obj.processingUnits = Math.round(message.processingUnits);
    }
    if (message.autoscalingConfig !== undefined) {
      obj.autoscalingConfig = AutoscalingConfig.toJSON(message.autoscalingConfig);
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateCloudInstanceAction>): UpdateCloudInstanceAction {
    return UpdateCloudInstanceAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateCloudInstanceAction>): UpdateCloudInstanceAction {
    const message = createBaseUpdateCloudInstanceAction();
    message.instanceId = object.instanceId ?? "";
    message.projectId = object.projectId ?? "";
    message.displayName = object.displayName ?? undefined;
    message.nodeCount = object.nodeCount ?? undefined;
    message.processingUnits = object.processingUnits ?? undefined;
    message.autoscalingConfig = (object.autoscalingConfig !== undefined && object.autoscalingConfig !== null)
      ? AutoscalingConfig.fromPartial(object.autoscalingConfig)
      : undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseUpdateCloudInstanceAction_LabelsEntry(): UpdateCloudInstanceAction_LabelsEntry {
  return { key: "", value: "" };
}

export const UpdateCloudInstanceAction_LabelsEntry: MessageFns<UpdateCloudInstanceAction_LabelsEntry> = {
  encode(message: UpdateCloudInstanceAction_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateCloudInstanceAction_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCloudInstanceAction_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateCloudInstanceAction_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: UpdateCloudInstanceAction_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateCloudInstanceAction_LabelsEntry>): UpdateCloudInstanceAction_LabelsEntry {
    return UpdateCloudInstanceAction_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateCloudInstanceAction_LabelsEntry>): UpdateCloudInstanceAction_LabelsEntry {
    const message = createBaseUpdateCloudInstanceAction_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseDeleteCloudInstanceAction(): DeleteCloudInstanceAction {
  return { instanceId: "", projectId: "" };
}

export const DeleteCloudInstanceAction: MessageFns<DeleteCloudInstanceAction> = {
  encode(message: DeleteCloudInstanceAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instanceId !== "") {
      writer.uint32(10).string(message.instanceId);
    }
    if (message.projectId !== "") {
      writer.uint32(18).string(message.projectId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteCloudInstanceAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteCloudInstanceAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instanceId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.projectId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteCloudInstanceAction {
    return {
      instanceId: isSet(object.instanceId) ? globalThis.String(object.instanceId) : "",
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
    };
  },

  toJSON(message: DeleteCloudInstanceAction): unknown {
    const obj: any = {};
    if (message.instanceId !== "") {
      obj.instanceId = message.instanceId;
    }
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteCloudInstanceAction>): DeleteCloudInstanceAction {
    return DeleteCloudInstanceAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteCloudInstanceAction>): DeleteCloudInstanceAction {
    const message = createBaseDeleteCloudInstanceAction();
    message.instanceId = object.instanceId ?? "";
    message.projectId = object.projectId ?? "";
    return message;
  },
};

function createBaseCreateCloudDatabaseAction(): CreateCloudDatabaseAction {
  return {
    instanceId: "",
    projectId: "",
    databaseId: "",
    sdlStatement: [],
    encryptionConfig: undefined,
    dialect: undefined,
    protoDescriptors: undefined,
  };
}

export const CreateCloudDatabaseAction: MessageFns<CreateCloudDatabaseAction> = {
  encode(message: CreateCloudDatabaseAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instanceId !== "") {
      writer.uint32(10).string(message.instanceId);
    }
    if (message.projectId !== "") {
      writer.uint32(18).string(message.projectId);
    }
    if (message.databaseId !== "") {
      writer.uint32(26).string(message.databaseId);
    }
    for (const v of message.sdlStatement) {
      writer.uint32(34).string(v!);
    }
    if (message.encryptionConfig !== undefined) {
      EncryptionConfig.encode(message.encryptionConfig, writer.uint32(42).fork()).join();
    }
    if (message.dialect !== undefined) {
      writer.uint32(50).string(message.dialect);
    }
    if (message.protoDescriptors !== undefined) {
      writer.uint32(58).bytes(message.protoDescriptors);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCloudDatabaseAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCloudDatabaseAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instanceId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.databaseId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sdlStatement.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.encryptionConfig = EncryptionConfig.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.dialect = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.protoDescriptors = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCloudDatabaseAction {
    return {
      instanceId: isSet(object.instanceId) ? globalThis.String(object.instanceId) : "",
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      databaseId: isSet(object.databaseId) ? globalThis.String(object.databaseId) : "",
      sdlStatement: globalThis.Array.isArray(object?.sdlStatement)
        ? object.sdlStatement.map((e: any) => globalThis.String(e))
        : [],
      encryptionConfig: isSet(object.encryptionConfig) ? EncryptionConfig.fromJSON(object.encryptionConfig) : undefined,
      dialect: isSet(object.dialect) ? globalThis.String(object.dialect) : undefined,
      protoDescriptors: isSet(object.protoDescriptors)
        ? Buffer.from(bytesFromBase64(object.protoDescriptors))
        : undefined,
    };
  },

  toJSON(message: CreateCloudDatabaseAction): unknown {
    const obj: any = {};
    if (message.instanceId !== "") {
      obj.instanceId = message.instanceId;
    }
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.databaseId !== "") {
      obj.databaseId = message.databaseId;
    }
    if (message.sdlStatement?.length) {
      obj.sdlStatement = message.sdlStatement;
    }
    if (message.encryptionConfig !== undefined) {
      obj.encryptionConfig = EncryptionConfig.toJSON(message.encryptionConfig);
    }
    if (message.dialect !== undefined) {
      obj.dialect = message.dialect;
    }
    if (message.protoDescriptors !== undefined) {
      obj.protoDescriptors = base64FromBytes(message.protoDescriptors);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateCloudDatabaseAction>): CreateCloudDatabaseAction {
    return CreateCloudDatabaseAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateCloudDatabaseAction>): CreateCloudDatabaseAction {
    const message = createBaseCreateCloudDatabaseAction();
    message.instanceId = object.instanceId ?? "";
    message.projectId = object.projectId ?? "";
    message.databaseId = object.databaseId ?? "";
    message.sdlStatement = object.sdlStatement?.map((e) => e) || [];
    message.encryptionConfig = (object.encryptionConfig !== undefined && object.encryptionConfig !== null)
      ? EncryptionConfig.fromPartial(object.encryptionConfig)
      : undefined;
    message.dialect = object.dialect ?? undefined;
    message.protoDescriptors = object.protoDescriptors ?? undefined;
    return message;
  },
};

function createBaseUpdateCloudDatabaseDdlAction(): UpdateCloudDatabaseDdlAction {
  return {
    instanceId: "",
    projectId: "",
    databaseId: "",
    sdlStatement: [],
    operationId: "",
    protoDescriptors: undefined,
  };
}

export const UpdateCloudDatabaseDdlAction: MessageFns<UpdateCloudDatabaseDdlAction> = {
  encode(message: UpdateCloudDatabaseDdlAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instanceId !== "") {
      writer.uint32(10).string(message.instanceId);
    }
    if (message.projectId !== "") {
      writer.uint32(18).string(message.projectId);
    }
    if (message.databaseId !== "") {
      writer.uint32(26).string(message.databaseId);
    }
    for (const v of message.sdlStatement) {
      writer.uint32(34).string(v!);
    }
    if (message.operationId !== "") {
      writer.uint32(42).string(message.operationId);
    }
    if (message.protoDescriptors !== undefined) {
      writer.uint32(50).bytes(message.protoDescriptors);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateCloudDatabaseDdlAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCloudDatabaseDdlAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instanceId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.databaseId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sdlStatement.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.operationId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.protoDescriptors = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateCloudDatabaseDdlAction {
    return {
      instanceId: isSet(object.instanceId) ? globalThis.String(object.instanceId) : "",
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      databaseId: isSet(object.databaseId) ? globalThis.String(object.databaseId) : "",
      sdlStatement: globalThis.Array.isArray(object?.sdlStatement)
        ? object.sdlStatement.map((e: any) => globalThis.String(e))
        : [],
      operationId: isSet(object.operationId) ? globalThis.String(object.operationId) : "",
      protoDescriptors: isSet(object.protoDescriptors)
        ? Buffer.from(bytesFromBase64(object.protoDescriptors))
        : undefined,
    };
  },

  toJSON(message: UpdateCloudDatabaseDdlAction): unknown {
    const obj: any = {};
    if (message.instanceId !== "") {
      obj.instanceId = message.instanceId;
    }
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.databaseId !== "") {
      obj.databaseId = message.databaseId;
    }
    if (message.sdlStatement?.length) {
      obj.sdlStatement = message.sdlStatement;
    }
    if (message.operationId !== "") {
      obj.operationId = message.operationId;
    }
    if (message.protoDescriptors !== undefined) {
      obj.protoDescriptors = base64FromBytes(message.protoDescriptors);
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateCloudDatabaseDdlAction>): UpdateCloudDatabaseDdlAction {
    return UpdateCloudDatabaseDdlAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateCloudDatabaseDdlAction>): UpdateCloudDatabaseDdlAction {
    const message = createBaseUpdateCloudDatabaseDdlAction();
    message.instanceId = object.instanceId ?? "";
    message.projectId = object.projectId ?? "";
    message.databaseId = object.databaseId ?? "";
    message.sdlStatement = object.sdlStatement?.map((e) => e) || [];
    message.operationId = object.operationId ?? "";
    message.protoDescriptors = object.protoDescriptors ?? undefined;
    return message;
  },
};

function createBaseUpdateCloudDatabaseAction(): UpdateCloudDatabaseAction {
  return { instanceId: "", projectId: "", databaseName: "", enableDropProtection: false };
}

export const UpdateCloudDatabaseAction: MessageFns<UpdateCloudDatabaseAction> = {
  encode(message: UpdateCloudDatabaseAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instanceId !== "") {
      writer.uint32(10).string(message.instanceId);
    }
    if (message.projectId !== "") {
      writer.uint32(18).string(message.projectId);
    }
    if (message.databaseName !== "") {
      writer.uint32(26).string(message.databaseName);
    }
    if (message.enableDropProtection !== false) {
      writer.uint32(32).bool(message.enableDropProtection);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateCloudDatabaseAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCloudDatabaseAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instanceId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.databaseName = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.enableDropProtection = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateCloudDatabaseAction {
    return {
      instanceId: isSet(object.instanceId) ? globalThis.String(object.instanceId) : "",
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      databaseName: isSet(object.databaseName) ? globalThis.String(object.databaseName) : "",
      enableDropProtection: isSet(object.enableDropProtection)
        ? globalThis.Boolean(object.enableDropProtection)
        : false,
    };
  },

  toJSON(message: UpdateCloudDatabaseAction): unknown {
    const obj: any = {};
    if (message.instanceId !== "") {
      obj.instanceId = message.instanceId;
    }
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.databaseName !== "") {
      obj.databaseName = message.databaseName;
    }
    if (message.enableDropProtection !== false) {
      obj.enableDropProtection = message.enableDropProtection;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateCloudDatabaseAction>): UpdateCloudDatabaseAction {
    return UpdateCloudDatabaseAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateCloudDatabaseAction>): UpdateCloudDatabaseAction {
    const message = createBaseUpdateCloudDatabaseAction();
    message.instanceId = object.instanceId ?? "";
    message.projectId = object.projectId ?? "";
    message.databaseName = object.databaseName ?? "";
    message.enableDropProtection = object.enableDropProtection ?? false;
    return message;
  },
};

function createBaseDropCloudDatabaseAction(): DropCloudDatabaseAction {
  return { instanceId: "", projectId: "", databaseId: "" };
}

export const DropCloudDatabaseAction: MessageFns<DropCloudDatabaseAction> = {
  encode(message: DropCloudDatabaseAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instanceId !== "") {
      writer.uint32(10).string(message.instanceId);
    }
    if (message.projectId !== "") {
      writer.uint32(18).string(message.projectId);
    }
    if (message.databaseId !== "") {
      writer.uint32(26).string(message.databaseId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DropCloudDatabaseAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDropCloudDatabaseAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instanceId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.databaseId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DropCloudDatabaseAction {
    return {
      instanceId: isSet(object.instanceId) ? globalThis.String(object.instanceId) : "",
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      databaseId: isSet(object.databaseId) ? globalThis.String(object.databaseId) : "",
    };
  },

  toJSON(message: DropCloudDatabaseAction): unknown {
    const obj: any = {};
    if (message.instanceId !== "") {
      obj.instanceId = message.instanceId;
    }
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.databaseId !== "") {
      obj.databaseId = message.databaseId;
    }
    return obj;
  },

  create(base?: DeepPartial<DropCloudDatabaseAction>): DropCloudDatabaseAction {
    return DropCloudDatabaseAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DropCloudDatabaseAction>): DropCloudDatabaseAction {
    const message = createBaseDropCloudDatabaseAction();
    message.instanceId = object.instanceId ?? "";
    message.projectId = object.projectId ?? "";
    message.databaseId = object.databaseId ?? "";
    return message;
  },
};

function createBaseChangeQuorumCloudDatabaseAction(): ChangeQuorumCloudDatabaseAction {
  return { databaseUri: undefined, servingLocations: [] };
}

export const ChangeQuorumCloudDatabaseAction: MessageFns<ChangeQuorumCloudDatabaseAction> = {
  encode(message: ChangeQuorumCloudDatabaseAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.databaseUri !== undefined) {
      writer.uint32(10).string(message.databaseUri);
    }
    for (const v of message.servingLocations) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangeQuorumCloudDatabaseAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangeQuorumCloudDatabaseAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.databaseUri = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.servingLocations.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangeQuorumCloudDatabaseAction {
    return {
      databaseUri: isSet(object.databaseUri) ? globalThis.String(object.databaseUri) : undefined,
      servingLocations: globalThis.Array.isArray(object?.servingLocations)
        ? object.servingLocations.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ChangeQuorumCloudDatabaseAction): unknown {
    const obj: any = {};
    if (message.databaseUri !== undefined) {
      obj.databaseUri = message.databaseUri;
    }
    if (message.servingLocations?.length) {
      obj.servingLocations = message.servingLocations;
    }
    return obj;
  },

  create(base?: DeepPartial<ChangeQuorumCloudDatabaseAction>): ChangeQuorumCloudDatabaseAction {
    return ChangeQuorumCloudDatabaseAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChangeQuorumCloudDatabaseAction>): ChangeQuorumCloudDatabaseAction {
    const message = createBaseChangeQuorumCloudDatabaseAction();
    message.databaseUri = object.databaseUri ?? undefined;
    message.servingLocations = object.servingLocations?.map((e) => e) || [];
    return message;
  },
};

function createBaseListCloudDatabasesAction(): ListCloudDatabasesAction {
  return { projectId: "", instanceId: "", pageSize: 0, pageToken: "" };
}

export const ListCloudDatabasesAction: MessageFns<ListCloudDatabasesAction> = {
  encode(message: ListCloudDatabasesAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.instanceId !== "") {
      writer.uint32(18).string(message.instanceId);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCloudDatabasesAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCloudDatabasesAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instanceId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCloudDatabasesAction {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      instanceId: isSet(object.instanceId) ? globalThis.String(object.instanceId) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListCloudDatabasesAction): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.instanceId !== "") {
      obj.instanceId = message.instanceId;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListCloudDatabasesAction>): ListCloudDatabasesAction {
    return ListCloudDatabasesAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListCloudDatabasesAction>): ListCloudDatabasesAction {
    const message = createBaseListCloudDatabasesAction();
    message.projectId = object.projectId ?? "";
    message.instanceId = object.instanceId ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListCloudInstancesAction(): ListCloudInstancesAction {
  return { projectId: "", filter: undefined, pageSize: undefined, pageToken: undefined };
}

export const ListCloudInstancesAction: MessageFns<ListCloudInstancesAction> = {
  encode(message: ListCloudInstancesAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.filter !== undefined) {
      writer.uint32(18).string(message.filter);
    }
    if (message.pageSize !== undefined) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      writer.uint32(34).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCloudInstancesAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCloudInstancesAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCloudInstancesAction {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : undefined,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : undefined,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : undefined,
    };
  },

  toJSON(message: ListCloudInstancesAction): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.filter !== undefined) {
      obj.filter = message.filter;
    }
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListCloudInstancesAction>): ListCloudInstancesAction {
    return ListCloudInstancesAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListCloudInstancesAction>): ListCloudInstancesAction {
    const message = createBaseListCloudInstancesAction();
    message.projectId = object.projectId ?? "";
    message.filter = object.filter ?? undefined;
    message.pageSize = object.pageSize ?? undefined;
    message.pageToken = object.pageToken ?? undefined;
    return message;
  },
};

function createBaseGetCloudInstanceAction(): GetCloudInstanceAction {
  return { projectId: "", instanceId: "" };
}

export const GetCloudInstanceAction: MessageFns<GetCloudInstanceAction> = {
  encode(message: GetCloudInstanceAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.instanceId !== "") {
      writer.uint32(18).string(message.instanceId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCloudInstanceAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCloudInstanceAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instanceId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCloudInstanceAction {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      instanceId: isSet(object.instanceId) ? globalThis.String(object.instanceId) : "",
    };
  },

  toJSON(message: GetCloudInstanceAction): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.instanceId !== "") {
      obj.instanceId = message.instanceId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetCloudInstanceAction>): GetCloudInstanceAction {
    return GetCloudInstanceAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetCloudInstanceAction>): GetCloudInstanceAction {
    const message = createBaseGetCloudInstanceAction();
    message.projectId = object.projectId ?? "";
    message.instanceId = object.instanceId ?? "";
    return message;
  },
};

function createBaseListCloudDatabaseOperationsAction(): ListCloudDatabaseOperationsAction {
  return { projectId: "", instanceId: "", filter: "", pageSize: 0, pageToken: "" };
}

export const ListCloudDatabaseOperationsAction: MessageFns<ListCloudDatabaseOperationsAction> = {
  encode(message: ListCloudDatabaseOperationsAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.instanceId !== "") {
      writer.uint32(18).string(message.instanceId);
    }
    if (message.filter !== "") {
      writer.uint32(26).string(message.filter);
    }
    if (message.pageSize !== 0) {
      writer.uint32(32).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(42).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCloudDatabaseOperationsAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCloudDatabaseOperationsAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instanceId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCloudDatabaseOperationsAction {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      instanceId: isSet(object.instanceId) ? globalThis.String(object.instanceId) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListCloudDatabaseOperationsAction): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.instanceId !== "") {
      obj.instanceId = message.instanceId;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListCloudDatabaseOperationsAction>): ListCloudDatabaseOperationsAction {
    return ListCloudDatabaseOperationsAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListCloudDatabaseOperationsAction>): ListCloudDatabaseOperationsAction {
    const message = createBaseListCloudDatabaseOperationsAction();
    message.projectId = object.projectId ?? "";
    message.instanceId = object.instanceId ?? "";
    message.filter = object.filter ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseRestoreCloudDatabaseAction(): RestoreCloudDatabaseAction {
  return {
    projectId: "",
    backupInstanceId: "",
    backupId: "",
    databaseInstanceId: "",
    databaseId: "",
    encryptionConfig: undefined,
  };
}

export const RestoreCloudDatabaseAction: MessageFns<RestoreCloudDatabaseAction> = {
  encode(message: RestoreCloudDatabaseAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.backupInstanceId !== "") {
      writer.uint32(18).string(message.backupInstanceId);
    }
    if (message.backupId !== "") {
      writer.uint32(26).string(message.backupId);
    }
    if (message.databaseInstanceId !== "") {
      writer.uint32(34).string(message.databaseInstanceId);
    }
    if (message.databaseId !== "") {
      writer.uint32(42).string(message.databaseId);
    }
    if (message.encryptionConfig !== undefined) {
      EncryptionConfig.encode(message.encryptionConfig, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RestoreCloudDatabaseAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRestoreCloudDatabaseAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.backupInstanceId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.backupId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.databaseInstanceId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.databaseId = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.encryptionConfig = EncryptionConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RestoreCloudDatabaseAction {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      backupInstanceId: isSet(object.backupInstanceId) ? globalThis.String(object.backupInstanceId) : "",
      backupId: isSet(object.backupId) ? globalThis.String(object.backupId) : "",
      databaseInstanceId: isSet(object.databaseInstanceId) ? globalThis.String(object.databaseInstanceId) : "",
      databaseId: isSet(object.databaseId) ? globalThis.String(object.databaseId) : "",
      encryptionConfig: isSet(object.encryptionConfig) ? EncryptionConfig.fromJSON(object.encryptionConfig) : undefined,
    };
  },

  toJSON(message: RestoreCloudDatabaseAction): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.backupInstanceId !== "") {
      obj.backupInstanceId = message.backupInstanceId;
    }
    if (message.backupId !== "") {
      obj.backupId = message.backupId;
    }
    if (message.databaseInstanceId !== "") {
      obj.databaseInstanceId = message.databaseInstanceId;
    }
    if (message.databaseId !== "") {
      obj.databaseId = message.databaseId;
    }
    if (message.encryptionConfig !== undefined) {
      obj.encryptionConfig = EncryptionConfig.toJSON(message.encryptionConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<RestoreCloudDatabaseAction>): RestoreCloudDatabaseAction {
    return RestoreCloudDatabaseAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RestoreCloudDatabaseAction>): RestoreCloudDatabaseAction {
    const message = createBaseRestoreCloudDatabaseAction();
    message.projectId = object.projectId ?? "";
    message.backupInstanceId = object.backupInstanceId ?? "";
    message.backupId = object.backupId ?? "";
    message.databaseInstanceId = object.databaseInstanceId ?? "";
    message.databaseId = object.databaseId ?? "";
    message.encryptionConfig = (object.encryptionConfig !== undefined && object.encryptionConfig !== null)
      ? EncryptionConfig.fromPartial(object.encryptionConfig)
      : undefined;
    return message;
  },
};

function createBaseGetCloudDatabaseAction(): GetCloudDatabaseAction {
  return { projectId: "", instanceId: "", databaseId: "" };
}

export const GetCloudDatabaseAction: MessageFns<GetCloudDatabaseAction> = {
  encode(message: GetCloudDatabaseAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.instanceId !== "") {
      writer.uint32(18).string(message.instanceId);
    }
    if (message.databaseId !== "") {
      writer.uint32(26).string(message.databaseId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCloudDatabaseAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCloudDatabaseAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instanceId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.databaseId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCloudDatabaseAction {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      instanceId: isSet(object.instanceId) ? globalThis.String(object.instanceId) : "",
      databaseId: isSet(object.databaseId) ? globalThis.String(object.databaseId) : "",
    };
  },

  toJSON(message: GetCloudDatabaseAction): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.instanceId !== "") {
      obj.instanceId = message.instanceId;
    }
    if (message.databaseId !== "") {
      obj.databaseId = message.databaseId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetCloudDatabaseAction>): GetCloudDatabaseAction {
    return GetCloudDatabaseAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetCloudDatabaseAction>): GetCloudDatabaseAction {
    const message = createBaseGetCloudDatabaseAction();
    message.projectId = object.projectId ?? "";
    message.instanceId = object.instanceId ?? "";
    message.databaseId = object.databaseId ?? "";
    return message;
  },
};

function createBaseCreateCloudBackupAction(): CreateCloudBackupAction {
  return {
    projectId: "",
    instanceId: "",
    backupId: "",
    databaseId: "",
    expireTime: undefined,
    versionTime: undefined,
    encryptionConfig: undefined,
  };
}

export const CreateCloudBackupAction: MessageFns<CreateCloudBackupAction> = {
  encode(message: CreateCloudBackupAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.instanceId !== "") {
      writer.uint32(18).string(message.instanceId);
    }
    if (message.backupId !== "") {
      writer.uint32(26).string(message.backupId);
    }
    if (message.databaseId !== "") {
      writer.uint32(34).string(message.databaseId);
    }
    if (message.expireTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expireTime), writer.uint32(42).fork()).join();
    }
    if (message.versionTime !== undefined) {
      Timestamp.encode(toTimestamp(message.versionTime), writer.uint32(50).fork()).join();
    }
    if (message.encryptionConfig !== undefined) {
      EncryptionConfig.encode(message.encryptionConfig, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCloudBackupAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCloudBackupAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instanceId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.backupId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.databaseId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.expireTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.versionTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.encryptionConfig = EncryptionConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCloudBackupAction {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      instanceId: isSet(object.instanceId) ? globalThis.String(object.instanceId) : "",
      backupId: isSet(object.backupId) ? globalThis.String(object.backupId) : "",
      databaseId: isSet(object.databaseId) ? globalThis.String(object.databaseId) : "",
      expireTime: isSet(object.expireTime) ? fromJsonTimestamp(object.expireTime) : undefined,
      versionTime: isSet(object.versionTime) ? fromJsonTimestamp(object.versionTime) : undefined,
      encryptionConfig: isSet(object.encryptionConfig) ? EncryptionConfig.fromJSON(object.encryptionConfig) : undefined,
    };
  },

  toJSON(message: CreateCloudBackupAction): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.instanceId !== "") {
      obj.instanceId = message.instanceId;
    }
    if (message.backupId !== "") {
      obj.backupId = message.backupId;
    }
    if (message.databaseId !== "") {
      obj.databaseId = message.databaseId;
    }
    if (message.expireTime !== undefined) {
      obj.expireTime = message.expireTime.toISOString();
    }
    if (message.versionTime !== undefined) {
      obj.versionTime = message.versionTime.toISOString();
    }
    if (message.encryptionConfig !== undefined) {
      obj.encryptionConfig = EncryptionConfig.toJSON(message.encryptionConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateCloudBackupAction>): CreateCloudBackupAction {
    return CreateCloudBackupAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateCloudBackupAction>): CreateCloudBackupAction {
    const message = createBaseCreateCloudBackupAction();
    message.projectId = object.projectId ?? "";
    message.instanceId = object.instanceId ?? "";
    message.backupId = object.backupId ?? "";
    message.databaseId = object.databaseId ?? "";
    message.expireTime = object.expireTime ?? undefined;
    message.versionTime = object.versionTime ?? undefined;
    message.encryptionConfig = (object.encryptionConfig !== undefined && object.encryptionConfig !== null)
      ? EncryptionConfig.fromPartial(object.encryptionConfig)
      : undefined;
    return message;
  },
};

function createBaseCopyCloudBackupAction(): CopyCloudBackupAction {
  return { projectId: "", instanceId: "", backupId: "", sourceBackup: "", expireTime: undefined };
}

export const CopyCloudBackupAction: MessageFns<CopyCloudBackupAction> = {
  encode(message: CopyCloudBackupAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.instanceId !== "") {
      writer.uint32(18).string(message.instanceId);
    }
    if (message.backupId !== "") {
      writer.uint32(26).string(message.backupId);
    }
    if (message.sourceBackup !== "") {
      writer.uint32(34).string(message.sourceBackup);
    }
    if (message.expireTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expireTime), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CopyCloudBackupAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCopyCloudBackupAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instanceId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.backupId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sourceBackup = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.expireTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CopyCloudBackupAction {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      instanceId: isSet(object.instanceId) ? globalThis.String(object.instanceId) : "",
      backupId: isSet(object.backupId) ? globalThis.String(object.backupId) : "",
      sourceBackup: isSet(object.sourceBackup) ? globalThis.String(object.sourceBackup) : "",
      expireTime: isSet(object.expireTime) ? fromJsonTimestamp(object.expireTime) : undefined,
    };
  },

  toJSON(message: CopyCloudBackupAction): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.instanceId !== "") {
      obj.instanceId = message.instanceId;
    }
    if (message.backupId !== "") {
      obj.backupId = message.backupId;
    }
    if (message.sourceBackup !== "") {
      obj.sourceBackup = message.sourceBackup;
    }
    if (message.expireTime !== undefined) {
      obj.expireTime = message.expireTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<CopyCloudBackupAction>): CopyCloudBackupAction {
    return CopyCloudBackupAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CopyCloudBackupAction>): CopyCloudBackupAction {
    const message = createBaseCopyCloudBackupAction();
    message.projectId = object.projectId ?? "";
    message.instanceId = object.instanceId ?? "";
    message.backupId = object.backupId ?? "";
    message.sourceBackup = object.sourceBackup ?? "";
    message.expireTime = object.expireTime ?? undefined;
    return message;
  },
};

function createBaseGetCloudBackupAction(): GetCloudBackupAction {
  return { projectId: "", instanceId: "", backupId: "" };
}

export const GetCloudBackupAction: MessageFns<GetCloudBackupAction> = {
  encode(message: GetCloudBackupAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.instanceId !== "") {
      writer.uint32(18).string(message.instanceId);
    }
    if (message.backupId !== "") {
      writer.uint32(26).string(message.backupId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCloudBackupAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCloudBackupAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instanceId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.backupId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCloudBackupAction {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      instanceId: isSet(object.instanceId) ? globalThis.String(object.instanceId) : "",
      backupId: isSet(object.backupId) ? globalThis.String(object.backupId) : "",
    };
  },

  toJSON(message: GetCloudBackupAction): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.instanceId !== "") {
      obj.instanceId = message.instanceId;
    }
    if (message.backupId !== "") {
      obj.backupId = message.backupId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetCloudBackupAction>): GetCloudBackupAction {
    return GetCloudBackupAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetCloudBackupAction>): GetCloudBackupAction {
    const message = createBaseGetCloudBackupAction();
    message.projectId = object.projectId ?? "";
    message.instanceId = object.instanceId ?? "";
    message.backupId = object.backupId ?? "";
    return message;
  },
};

function createBaseUpdateCloudBackupAction(): UpdateCloudBackupAction {
  return { projectId: "", instanceId: "", backupId: "", expireTime: undefined };
}

export const UpdateCloudBackupAction: MessageFns<UpdateCloudBackupAction> = {
  encode(message: UpdateCloudBackupAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.instanceId !== "") {
      writer.uint32(18).string(message.instanceId);
    }
    if (message.backupId !== "") {
      writer.uint32(26).string(message.backupId);
    }
    if (message.expireTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expireTime), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateCloudBackupAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCloudBackupAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instanceId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.backupId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.expireTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateCloudBackupAction {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      instanceId: isSet(object.instanceId) ? globalThis.String(object.instanceId) : "",
      backupId: isSet(object.backupId) ? globalThis.String(object.backupId) : "",
      expireTime: isSet(object.expireTime) ? fromJsonTimestamp(object.expireTime) : undefined,
    };
  },

  toJSON(message: UpdateCloudBackupAction): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.instanceId !== "") {
      obj.instanceId = message.instanceId;
    }
    if (message.backupId !== "") {
      obj.backupId = message.backupId;
    }
    if (message.expireTime !== undefined) {
      obj.expireTime = message.expireTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateCloudBackupAction>): UpdateCloudBackupAction {
    return UpdateCloudBackupAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateCloudBackupAction>): UpdateCloudBackupAction {
    const message = createBaseUpdateCloudBackupAction();
    message.projectId = object.projectId ?? "";
    message.instanceId = object.instanceId ?? "";
    message.backupId = object.backupId ?? "";
    message.expireTime = object.expireTime ?? undefined;
    return message;
  },
};

function createBaseDeleteCloudBackupAction(): DeleteCloudBackupAction {
  return { projectId: "", instanceId: "", backupId: "" };
}

export const DeleteCloudBackupAction: MessageFns<DeleteCloudBackupAction> = {
  encode(message: DeleteCloudBackupAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.instanceId !== "") {
      writer.uint32(18).string(message.instanceId);
    }
    if (message.backupId !== "") {
      writer.uint32(26).string(message.backupId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteCloudBackupAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteCloudBackupAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instanceId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.backupId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteCloudBackupAction {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      instanceId: isSet(object.instanceId) ? globalThis.String(object.instanceId) : "",
      backupId: isSet(object.backupId) ? globalThis.String(object.backupId) : "",
    };
  },

  toJSON(message: DeleteCloudBackupAction): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.instanceId !== "") {
      obj.instanceId = message.instanceId;
    }
    if (message.backupId !== "") {
      obj.backupId = message.backupId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteCloudBackupAction>): DeleteCloudBackupAction {
    return DeleteCloudBackupAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteCloudBackupAction>): DeleteCloudBackupAction {
    const message = createBaseDeleteCloudBackupAction();
    message.projectId = object.projectId ?? "";
    message.instanceId = object.instanceId ?? "";
    message.backupId = object.backupId ?? "";
    return message;
  },
};

function createBaseListCloudBackupsAction(): ListCloudBackupsAction {
  return { projectId: "", instanceId: "", filter: "", pageSize: 0, pageToken: "" };
}

export const ListCloudBackupsAction: MessageFns<ListCloudBackupsAction> = {
  encode(message: ListCloudBackupsAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.instanceId !== "") {
      writer.uint32(18).string(message.instanceId);
    }
    if (message.filter !== "") {
      writer.uint32(26).string(message.filter);
    }
    if (message.pageSize !== 0) {
      writer.uint32(32).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(42).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCloudBackupsAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCloudBackupsAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instanceId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCloudBackupsAction {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      instanceId: isSet(object.instanceId) ? globalThis.String(object.instanceId) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListCloudBackupsAction): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.instanceId !== "") {
      obj.instanceId = message.instanceId;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListCloudBackupsAction>): ListCloudBackupsAction {
    return ListCloudBackupsAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListCloudBackupsAction>): ListCloudBackupsAction {
    const message = createBaseListCloudBackupsAction();
    message.projectId = object.projectId ?? "";
    message.instanceId = object.instanceId ?? "";
    message.filter = object.filter ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListCloudBackupOperationsAction(): ListCloudBackupOperationsAction {
  return { projectId: "", instanceId: "", filter: "", pageSize: 0, pageToken: "" };
}

export const ListCloudBackupOperationsAction: MessageFns<ListCloudBackupOperationsAction> = {
  encode(message: ListCloudBackupOperationsAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.instanceId !== "") {
      writer.uint32(18).string(message.instanceId);
    }
    if (message.filter !== "") {
      writer.uint32(26).string(message.filter);
    }
    if (message.pageSize !== 0) {
      writer.uint32(32).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(42).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCloudBackupOperationsAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCloudBackupOperationsAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instanceId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCloudBackupOperationsAction {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      instanceId: isSet(object.instanceId) ? globalThis.String(object.instanceId) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListCloudBackupOperationsAction): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.instanceId !== "") {
      obj.instanceId = message.instanceId;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListCloudBackupOperationsAction>): ListCloudBackupOperationsAction {
    return ListCloudBackupOperationsAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListCloudBackupOperationsAction>): ListCloudBackupOperationsAction {
    const message = createBaseListCloudBackupOperationsAction();
    message.projectId = object.projectId ?? "";
    message.instanceId = object.instanceId ?? "";
    message.filter = object.filter ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseGetOperationAction(): GetOperationAction {
  return { operation: "" };
}

export const GetOperationAction: MessageFns<GetOperationAction> = {
  encode(message: GetOperationAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operation !== "") {
      writer.uint32(10).string(message.operation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOperationAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOperationAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.operation = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOperationAction {
    return { operation: isSet(object.operation) ? globalThis.String(object.operation) : "" };
  },

  toJSON(message: GetOperationAction): unknown {
    const obj: any = {};
    if (message.operation !== "") {
      obj.operation = message.operation;
    }
    return obj;
  },

  create(base?: DeepPartial<GetOperationAction>): GetOperationAction {
    return GetOperationAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetOperationAction>): GetOperationAction {
    const message = createBaseGetOperationAction();
    message.operation = object.operation ?? "";
    return message;
  },
};

function createBaseQueryCancellationAction(): QueryCancellationAction {
  return { longRunningSql: "", cancelQuery: "" };
}

export const QueryCancellationAction: MessageFns<QueryCancellationAction> = {
  encode(message: QueryCancellationAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.longRunningSql !== "") {
      writer.uint32(10).string(message.longRunningSql);
    }
    if (message.cancelQuery !== "") {
      writer.uint32(18).string(message.cancelQuery);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryCancellationAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryCancellationAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.longRunningSql = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cancelQuery = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryCancellationAction {
    return {
      longRunningSql: isSet(object.longRunningSql) ? globalThis.String(object.longRunningSql) : "",
      cancelQuery: isSet(object.cancelQuery) ? globalThis.String(object.cancelQuery) : "",
    };
  },

  toJSON(message: QueryCancellationAction): unknown {
    const obj: any = {};
    if (message.longRunningSql !== "") {
      obj.longRunningSql = message.longRunningSql;
    }
    if (message.cancelQuery !== "") {
      obj.cancelQuery = message.cancelQuery;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryCancellationAction>): QueryCancellationAction {
    return QueryCancellationAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryCancellationAction>): QueryCancellationAction {
    const message = createBaseQueryCancellationAction();
    message.longRunningSql = object.longRunningSql ?? "";
    message.cancelQuery = object.cancelQuery ?? "";
    return message;
  },
};

function createBaseCancelOperationAction(): CancelOperationAction {
  return { operation: "" };
}

export const CancelOperationAction: MessageFns<CancelOperationAction> = {
  encode(message: CancelOperationAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operation !== "") {
      writer.uint32(10).string(message.operation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelOperationAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelOperationAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.operation = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelOperationAction {
    return { operation: isSet(object.operation) ? globalThis.String(object.operation) : "" };
  },

  toJSON(message: CancelOperationAction): unknown {
    const obj: any = {};
    if (message.operation !== "") {
      obj.operation = message.operation;
    }
    return obj;
  },

  create(base?: DeepPartial<CancelOperationAction>): CancelOperationAction {
    return CancelOperationAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CancelOperationAction>): CancelOperationAction {
    const message = createBaseCancelOperationAction();
    message.operation = object.operation ?? "";
    return message;
  },
};

function createBaseStartBatchTransactionAction(): StartBatchTransactionAction {
  return { batchTxnTime: undefined, tid: undefined, cloudDatabaseRole: "" };
}

export const StartBatchTransactionAction: MessageFns<StartBatchTransactionAction> = {
  encode(message: StartBatchTransactionAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.batchTxnTime !== undefined) {
      Timestamp.encode(toTimestamp(message.batchTxnTime), writer.uint32(10).fork()).join();
    }
    if (message.tid !== undefined) {
      writer.uint32(18).bytes(message.tid);
    }
    if (message.cloudDatabaseRole !== "") {
      writer.uint32(26).string(message.cloudDatabaseRole);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartBatchTransactionAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartBatchTransactionAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.batchTxnTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tid = Buffer.from(reader.bytes());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cloudDatabaseRole = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartBatchTransactionAction {
    return {
      batchTxnTime: isSet(object.batchTxnTime) ? fromJsonTimestamp(object.batchTxnTime) : undefined,
      tid: isSet(object.tid) ? Buffer.from(bytesFromBase64(object.tid)) : undefined,
      cloudDatabaseRole: isSet(object.cloudDatabaseRole) ? globalThis.String(object.cloudDatabaseRole) : "",
    };
  },

  toJSON(message: StartBatchTransactionAction): unknown {
    const obj: any = {};
    if (message.batchTxnTime !== undefined) {
      obj.batchTxnTime = message.batchTxnTime.toISOString();
    }
    if (message.tid !== undefined) {
      obj.tid = base64FromBytes(message.tid);
    }
    if (message.cloudDatabaseRole !== "") {
      obj.cloudDatabaseRole = message.cloudDatabaseRole;
    }
    return obj;
  },

  create(base?: DeepPartial<StartBatchTransactionAction>): StartBatchTransactionAction {
    return StartBatchTransactionAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartBatchTransactionAction>): StartBatchTransactionAction {
    const message = createBaseStartBatchTransactionAction();
    message.batchTxnTime = object.batchTxnTime ?? undefined;
    message.tid = object.tid ?? undefined;
    message.cloudDatabaseRole = object.cloudDatabaseRole ?? "";
    return message;
  },
};

function createBaseCloseBatchTransactionAction(): CloseBatchTransactionAction {
  return { cleanup: false };
}

export const CloseBatchTransactionAction: MessageFns<CloseBatchTransactionAction> = {
  encode(message: CloseBatchTransactionAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cleanup !== false) {
      writer.uint32(8).bool(message.cleanup);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloseBatchTransactionAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloseBatchTransactionAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.cleanup = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloseBatchTransactionAction {
    return { cleanup: isSet(object.cleanup) ? globalThis.Boolean(object.cleanup) : false };
  },

  toJSON(message: CloseBatchTransactionAction): unknown {
    const obj: any = {};
    if (message.cleanup !== false) {
      obj.cleanup = message.cleanup;
    }
    return obj;
  },

  create(base?: DeepPartial<CloseBatchTransactionAction>): CloseBatchTransactionAction {
    return CloseBatchTransactionAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CloseBatchTransactionAction>): CloseBatchTransactionAction {
    const message = createBaseCloseBatchTransactionAction();
    message.cleanup = object.cleanup ?? false;
    return message;
  },
};

function createBaseGenerateDbPartitionsForReadAction(): GenerateDbPartitionsForReadAction {
  return { read: undefined, table: [], desiredBytesPerPartition: undefined, maxPartitionCount: undefined };
}

export const GenerateDbPartitionsForReadAction: MessageFns<GenerateDbPartitionsForReadAction> = {
  encode(message: GenerateDbPartitionsForReadAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.read !== undefined) {
      ReadAction.encode(message.read, writer.uint32(10).fork()).join();
    }
    for (const v of message.table) {
      TableMetadata.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.desiredBytesPerPartition !== undefined) {
      writer.uint32(24).int64(message.desiredBytesPerPartition.toString());
    }
    if (message.maxPartitionCount !== undefined) {
      writer.uint32(32).int64(message.maxPartitionCount.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateDbPartitionsForReadAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateDbPartitionsForReadAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.read = ReadAction.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.table.push(TableMetadata.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.desiredBytesPerPartition = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.maxPartitionCount = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateDbPartitionsForReadAction {
    return {
      read: isSet(object.read) ? ReadAction.fromJSON(object.read) : undefined,
      table: globalThis.Array.isArray(object?.table) ? object.table.map((e: any) => TableMetadata.fromJSON(e)) : [],
      desiredBytesPerPartition: isSet(object.desiredBytesPerPartition)
        ? Long.fromValue(object.desiredBytesPerPartition)
        : undefined,
      maxPartitionCount: isSet(object.maxPartitionCount) ? Long.fromValue(object.maxPartitionCount) : undefined,
    };
  },

  toJSON(message: GenerateDbPartitionsForReadAction): unknown {
    const obj: any = {};
    if (message.read !== undefined) {
      obj.read = ReadAction.toJSON(message.read);
    }
    if (message.table?.length) {
      obj.table = message.table.map((e) => TableMetadata.toJSON(e));
    }
    if (message.desiredBytesPerPartition !== undefined) {
      obj.desiredBytesPerPartition = (message.desiredBytesPerPartition || Long.ZERO).toString();
    }
    if (message.maxPartitionCount !== undefined) {
      obj.maxPartitionCount = (message.maxPartitionCount || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateDbPartitionsForReadAction>): GenerateDbPartitionsForReadAction {
    return GenerateDbPartitionsForReadAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateDbPartitionsForReadAction>): GenerateDbPartitionsForReadAction {
    const message = createBaseGenerateDbPartitionsForReadAction();
    message.read = (object.read !== undefined && object.read !== null)
      ? ReadAction.fromPartial(object.read)
      : undefined;
    message.table = object.table?.map((e) => TableMetadata.fromPartial(e)) || [];
    message.desiredBytesPerPartition =
      (object.desiredBytesPerPartition !== undefined && object.desiredBytesPerPartition !== null)
        ? Long.fromValue(object.desiredBytesPerPartition)
        : undefined;
    message.maxPartitionCount = (object.maxPartitionCount !== undefined && object.maxPartitionCount !== null)
      ? Long.fromValue(object.maxPartitionCount)
      : undefined;
    return message;
  },
};

function createBaseGenerateDbPartitionsForQueryAction(): GenerateDbPartitionsForQueryAction {
  return { query: undefined, desiredBytesPerPartition: undefined };
}

export const GenerateDbPartitionsForQueryAction: MessageFns<GenerateDbPartitionsForQueryAction> = {
  encode(message: GenerateDbPartitionsForQueryAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.query !== undefined) {
      QueryAction.encode(message.query, writer.uint32(10).fork()).join();
    }
    if (message.desiredBytesPerPartition !== undefined) {
      writer.uint32(16).int64(message.desiredBytesPerPartition.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateDbPartitionsForQueryAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateDbPartitionsForQueryAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.query = QueryAction.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.desiredBytesPerPartition = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateDbPartitionsForQueryAction {
    return {
      query: isSet(object.query) ? QueryAction.fromJSON(object.query) : undefined,
      desiredBytesPerPartition: isSet(object.desiredBytesPerPartition)
        ? Long.fromValue(object.desiredBytesPerPartition)
        : undefined,
    };
  },

  toJSON(message: GenerateDbPartitionsForQueryAction): unknown {
    const obj: any = {};
    if (message.query !== undefined) {
      obj.query = QueryAction.toJSON(message.query);
    }
    if (message.desiredBytesPerPartition !== undefined) {
      obj.desiredBytesPerPartition = (message.desiredBytesPerPartition || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateDbPartitionsForQueryAction>): GenerateDbPartitionsForQueryAction {
    return GenerateDbPartitionsForQueryAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateDbPartitionsForQueryAction>): GenerateDbPartitionsForQueryAction {
    const message = createBaseGenerateDbPartitionsForQueryAction();
    message.query = (object.query !== undefined && object.query !== null)
      ? QueryAction.fromPartial(object.query)
      : undefined;
    message.desiredBytesPerPartition =
      (object.desiredBytesPerPartition !== undefined && object.desiredBytesPerPartition !== null)
        ? Long.fromValue(object.desiredBytesPerPartition)
        : undefined;
    return message;
  },
};

function createBaseBatchPartition(): BatchPartition {
  return { partition: Buffer.alloc(0), partitionToken: Buffer.alloc(0), table: undefined, index: undefined };
}

export const BatchPartition: MessageFns<BatchPartition> = {
  encode(message: BatchPartition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.partition.length !== 0) {
      writer.uint32(10).bytes(message.partition);
    }
    if (message.partitionToken.length !== 0) {
      writer.uint32(18).bytes(message.partitionToken);
    }
    if (message.table !== undefined) {
      writer.uint32(26).string(message.table);
    }
    if (message.index !== undefined) {
      writer.uint32(34).string(message.index);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchPartition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchPartition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.partition = Buffer.from(reader.bytes());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.partitionToken = Buffer.from(reader.bytes());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.table = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.index = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchPartition {
    return {
      partition: isSet(object.partition) ? Buffer.from(bytesFromBase64(object.partition)) : Buffer.alloc(0),
      partitionToken: isSet(object.partitionToken)
        ? Buffer.from(bytesFromBase64(object.partitionToken))
        : Buffer.alloc(0),
      table: isSet(object.table) ? globalThis.String(object.table) : undefined,
      index: isSet(object.index) ? globalThis.String(object.index) : undefined,
    };
  },

  toJSON(message: BatchPartition): unknown {
    const obj: any = {};
    if (message.partition.length !== 0) {
      obj.partition = base64FromBytes(message.partition);
    }
    if (message.partitionToken.length !== 0) {
      obj.partitionToken = base64FromBytes(message.partitionToken);
    }
    if (message.table !== undefined) {
      obj.table = message.table;
    }
    if (message.index !== undefined) {
      obj.index = message.index;
    }
    return obj;
  },

  create(base?: DeepPartial<BatchPartition>): BatchPartition {
    return BatchPartition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchPartition>): BatchPartition {
    const message = createBaseBatchPartition();
    message.partition = object.partition ?? Buffer.alloc(0);
    message.partitionToken = object.partitionToken ?? Buffer.alloc(0);
    message.table = object.table ?? undefined;
    message.index = object.index ?? undefined;
    return message;
  },
};

function createBaseExecutePartitionAction(): ExecutePartitionAction {
  return { partition: undefined };
}

export const ExecutePartitionAction: MessageFns<ExecutePartitionAction> = {
  encode(message: ExecutePartitionAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.partition !== undefined) {
      BatchPartition.encode(message.partition, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecutePartitionAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutePartitionAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.partition = BatchPartition.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecutePartitionAction {
    return { partition: isSet(object.partition) ? BatchPartition.fromJSON(object.partition) : undefined };
  },

  toJSON(message: ExecutePartitionAction): unknown {
    const obj: any = {};
    if (message.partition !== undefined) {
      obj.partition = BatchPartition.toJSON(message.partition);
    }
    return obj;
  },

  create(base?: DeepPartial<ExecutePartitionAction>): ExecutePartitionAction {
    return ExecutePartitionAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExecutePartitionAction>): ExecutePartitionAction {
    const message = createBaseExecutePartitionAction();
    message.partition = (object.partition !== undefined && object.partition !== null)
      ? BatchPartition.fromPartial(object.partition)
      : undefined;
    return message;
  },
};

function createBaseExecuteChangeStreamQuery(): ExecuteChangeStreamQuery {
  return {
    name: "",
    startTime: undefined,
    endTime: undefined,
    partitionToken: undefined,
    readOptions: [],
    heartbeatMilliseconds: undefined,
    deadlineSeconds: undefined,
    cloudDatabaseRole: undefined,
  };
}

export const ExecuteChangeStreamQuery: MessageFns<ExecuteChangeStreamQuery> = {
  encode(message: ExecuteChangeStreamQuery, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(18).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(26).fork()).join();
    }
    if (message.partitionToken !== undefined) {
      writer.uint32(34).string(message.partitionToken);
    }
    for (const v of message.readOptions) {
      writer.uint32(42).string(v!);
    }
    if (message.heartbeatMilliseconds !== undefined) {
      writer.uint32(48).int32(message.heartbeatMilliseconds);
    }
    if (message.deadlineSeconds !== undefined) {
      writer.uint32(56).int64(message.deadlineSeconds.toString());
    }
    if (message.cloudDatabaseRole !== undefined) {
      writer.uint32(66).string(message.cloudDatabaseRole);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecuteChangeStreamQuery {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecuteChangeStreamQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.partitionToken = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.readOptions.push(reader.string());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.heartbeatMilliseconds = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.deadlineSeconds = Long.fromString(reader.int64().toString());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.cloudDatabaseRole = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecuteChangeStreamQuery {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      partitionToken: isSet(object.partitionToken) ? globalThis.String(object.partitionToken) : undefined,
      readOptions: globalThis.Array.isArray(object?.readOptions)
        ? object.readOptions.map((e: any) => globalThis.String(e))
        : [],
      heartbeatMilliseconds: isSet(object.heartbeatMilliseconds)
        ? globalThis.Number(object.heartbeatMilliseconds)
        : undefined,
      deadlineSeconds: isSet(object.deadlineSeconds) ? Long.fromValue(object.deadlineSeconds) : undefined,
      cloudDatabaseRole: isSet(object.cloudDatabaseRole) ? globalThis.String(object.cloudDatabaseRole) : undefined,
    };
  },

  toJSON(message: ExecuteChangeStreamQuery): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.partitionToken !== undefined) {
      obj.partitionToken = message.partitionToken;
    }
    if (message.readOptions?.length) {
      obj.readOptions = message.readOptions;
    }
    if (message.heartbeatMilliseconds !== undefined) {
      obj.heartbeatMilliseconds = Math.round(message.heartbeatMilliseconds);
    }
    if (message.deadlineSeconds !== undefined) {
      obj.deadlineSeconds = (message.deadlineSeconds || Long.ZERO).toString();
    }
    if (message.cloudDatabaseRole !== undefined) {
      obj.cloudDatabaseRole = message.cloudDatabaseRole;
    }
    return obj;
  },

  create(base?: DeepPartial<ExecuteChangeStreamQuery>): ExecuteChangeStreamQuery {
    return ExecuteChangeStreamQuery.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExecuteChangeStreamQuery>): ExecuteChangeStreamQuery {
    const message = createBaseExecuteChangeStreamQuery();
    message.name = object.name ?? "";
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.partitionToken = object.partitionToken ?? undefined;
    message.readOptions = object.readOptions?.map((e) => e) || [];
    message.heartbeatMilliseconds = object.heartbeatMilliseconds ?? undefined;
    message.deadlineSeconds = (object.deadlineSeconds !== undefined && object.deadlineSeconds !== null)
      ? Long.fromValue(object.deadlineSeconds)
      : undefined;
    message.cloudDatabaseRole = object.cloudDatabaseRole ?? undefined;
    return message;
  },
};

function createBaseSpannerActionOutcome(): SpannerActionOutcome {
  return {
    status: undefined,
    commitTime: undefined,
    readResult: undefined,
    queryResult: undefined,
    transactionRestarted: undefined,
    batchTxnId: undefined,
    dbPartition: [],
    adminResult: undefined,
    dmlRowsModified: [],
    changeStreamRecords: [],
  };
}

export const SpannerActionOutcome: MessageFns<SpannerActionOutcome> = {
  encode(message: SpannerActionOutcome, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.commitTime !== undefined) {
      Timestamp.encode(toTimestamp(message.commitTime), writer.uint32(18).fork()).join();
    }
    if (message.readResult !== undefined) {
      ReadResult.encode(message.readResult, writer.uint32(26).fork()).join();
    }
    if (message.queryResult !== undefined) {
      QueryResult.encode(message.queryResult, writer.uint32(34).fork()).join();
    }
    if (message.transactionRestarted !== undefined) {
      writer.uint32(40).bool(message.transactionRestarted);
    }
    if (message.batchTxnId !== undefined) {
      writer.uint32(50).bytes(message.batchTxnId);
    }
    for (const v of message.dbPartition) {
      BatchPartition.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.adminResult !== undefined) {
      AdminResult.encode(message.adminResult, writer.uint32(66).fork()).join();
    }
    writer.uint32(74).fork();
    for (const v of message.dmlRowsModified) {
      writer.int64(v.toString());
    }
    writer.join();
    for (const v of message.changeStreamRecords) {
      ChangeStreamRecord.encode(v!, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpannerActionOutcome {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpannerActionOutcome();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.commitTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.readResult = ReadResult.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.queryResult = QueryResult.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.transactionRestarted = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.batchTxnId = Buffer.from(reader.bytes());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.dbPartition.push(BatchPartition.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.adminResult = AdminResult.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag === 72) {
            message.dmlRowsModified.push(Long.fromString(reader.int64().toString()));

            continue;
          }

          if (tag === 74) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.dmlRowsModified.push(Long.fromString(reader.int64().toString()));
            }

            continue;
          }

          break;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.changeStreamRecords.push(ChangeStreamRecord.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpannerActionOutcome {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      commitTime: isSet(object.commitTime) ? fromJsonTimestamp(object.commitTime) : undefined,
      readResult: isSet(object.readResult) ? ReadResult.fromJSON(object.readResult) : undefined,
      queryResult: isSet(object.queryResult) ? QueryResult.fromJSON(object.queryResult) : undefined,
      transactionRestarted: isSet(object.transactionRestarted)
        ? globalThis.Boolean(object.transactionRestarted)
        : undefined,
      batchTxnId: isSet(object.batchTxnId) ? Buffer.from(bytesFromBase64(object.batchTxnId)) : undefined,
      dbPartition: globalThis.Array.isArray(object?.dbPartition)
        ? object.dbPartition.map((e: any) => BatchPartition.fromJSON(e))
        : [],
      adminResult: isSet(object.adminResult) ? AdminResult.fromJSON(object.adminResult) : undefined,
      dmlRowsModified: globalThis.Array.isArray(object?.dmlRowsModified)
        ? object.dmlRowsModified.map((e: any) => Long.fromValue(e))
        : [],
      changeStreamRecords: globalThis.Array.isArray(object?.changeStreamRecords)
        ? object.changeStreamRecords.map((e: any) => ChangeStreamRecord.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SpannerActionOutcome): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.commitTime !== undefined) {
      obj.commitTime = message.commitTime.toISOString();
    }
    if (message.readResult !== undefined) {
      obj.readResult = ReadResult.toJSON(message.readResult);
    }
    if (message.queryResult !== undefined) {
      obj.queryResult = QueryResult.toJSON(message.queryResult);
    }
    if (message.transactionRestarted !== undefined) {
      obj.transactionRestarted = message.transactionRestarted;
    }
    if (message.batchTxnId !== undefined) {
      obj.batchTxnId = base64FromBytes(message.batchTxnId);
    }
    if (message.dbPartition?.length) {
      obj.dbPartition = message.dbPartition.map((e) => BatchPartition.toJSON(e));
    }
    if (message.adminResult !== undefined) {
      obj.adminResult = AdminResult.toJSON(message.adminResult);
    }
    if (message.dmlRowsModified?.length) {
      obj.dmlRowsModified = message.dmlRowsModified.map((e) => (e || Long.ZERO).toString());
    }
    if (message.changeStreamRecords?.length) {
      obj.changeStreamRecords = message.changeStreamRecords.map((e) => ChangeStreamRecord.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SpannerActionOutcome>): SpannerActionOutcome {
    return SpannerActionOutcome.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SpannerActionOutcome>): SpannerActionOutcome {
    const message = createBaseSpannerActionOutcome();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.commitTime = object.commitTime ?? undefined;
    message.readResult = (object.readResult !== undefined && object.readResult !== null)
      ? ReadResult.fromPartial(object.readResult)
      : undefined;
    message.queryResult = (object.queryResult !== undefined && object.queryResult !== null)
      ? QueryResult.fromPartial(object.queryResult)
      : undefined;
    message.transactionRestarted = object.transactionRestarted ?? undefined;
    message.batchTxnId = object.batchTxnId ?? undefined;
    message.dbPartition = object.dbPartition?.map((e) => BatchPartition.fromPartial(e)) || [];
    message.adminResult = (object.adminResult !== undefined && object.adminResult !== null)
      ? AdminResult.fromPartial(object.adminResult)
      : undefined;
    message.dmlRowsModified = object.dmlRowsModified?.map((e) => Long.fromValue(e)) || [];
    message.changeStreamRecords = object.changeStreamRecords?.map((e) => ChangeStreamRecord.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAdminResult(): AdminResult {
  return {
    backupResponse: undefined,
    operationResponse: undefined,
    databaseResponse: undefined,
    instanceResponse: undefined,
    instanceConfigResponse: undefined,
  };
}

export const AdminResult: MessageFns<AdminResult> = {
  encode(message: AdminResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.backupResponse !== undefined) {
      CloudBackupResponse.encode(message.backupResponse, writer.uint32(10).fork()).join();
    }
    if (message.operationResponse !== undefined) {
      OperationResponse.encode(message.operationResponse, writer.uint32(18).fork()).join();
    }
    if (message.databaseResponse !== undefined) {
      CloudDatabaseResponse.encode(message.databaseResponse, writer.uint32(26).fork()).join();
    }
    if (message.instanceResponse !== undefined) {
      CloudInstanceResponse.encode(message.instanceResponse, writer.uint32(34).fork()).join();
    }
    if (message.instanceConfigResponse !== undefined) {
      CloudInstanceConfigResponse.encode(message.instanceConfigResponse, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdminResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdminResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.backupResponse = CloudBackupResponse.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.operationResponse = OperationResponse.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.databaseResponse = CloudDatabaseResponse.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.instanceResponse = CloudInstanceResponse.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.instanceConfigResponse = CloudInstanceConfigResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdminResult {
    return {
      backupResponse: isSet(object.backupResponse) ? CloudBackupResponse.fromJSON(object.backupResponse) : undefined,
      operationResponse: isSet(object.operationResponse)
        ? OperationResponse.fromJSON(object.operationResponse)
        : undefined,
      databaseResponse: isSet(object.databaseResponse)
        ? CloudDatabaseResponse.fromJSON(object.databaseResponse)
        : undefined,
      instanceResponse: isSet(object.instanceResponse)
        ? CloudInstanceResponse.fromJSON(object.instanceResponse)
        : undefined,
      instanceConfigResponse: isSet(object.instanceConfigResponse)
        ? CloudInstanceConfigResponse.fromJSON(object.instanceConfigResponse)
        : undefined,
    };
  },

  toJSON(message: AdminResult): unknown {
    const obj: any = {};
    if (message.backupResponse !== undefined) {
      obj.backupResponse = CloudBackupResponse.toJSON(message.backupResponse);
    }
    if (message.operationResponse !== undefined) {
      obj.operationResponse = OperationResponse.toJSON(message.operationResponse);
    }
    if (message.databaseResponse !== undefined) {
      obj.databaseResponse = CloudDatabaseResponse.toJSON(message.databaseResponse);
    }
    if (message.instanceResponse !== undefined) {
      obj.instanceResponse = CloudInstanceResponse.toJSON(message.instanceResponse);
    }
    if (message.instanceConfigResponse !== undefined) {
      obj.instanceConfigResponse = CloudInstanceConfigResponse.toJSON(message.instanceConfigResponse);
    }
    return obj;
  },

  create(base?: DeepPartial<AdminResult>): AdminResult {
    return AdminResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AdminResult>): AdminResult {
    const message = createBaseAdminResult();
    message.backupResponse = (object.backupResponse !== undefined && object.backupResponse !== null)
      ? CloudBackupResponse.fromPartial(object.backupResponse)
      : undefined;
    message.operationResponse = (object.operationResponse !== undefined && object.operationResponse !== null)
      ? OperationResponse.fromPartial(object.operationResponse)
      : undefined;
    message.databaseResponse = (object.databaseResponse !== undefined && object.databaseResponse !== null)
      ? CloudDatabaseResponse.fromPartial(object.databaseResponse)
      : undefined;
    message.instanceResponse = (object.instanceResponse !== undefined && object.instanceResponse !== null)
      ? CloudInstanceResponse.fromPartial(object.instanceResponse)
      : undefined;
    message.instanceConfigResponse =
      (object.instanceConfigResponse !== undefined && object.instanceConfigResponse !== null)
        ? CloudInstanceConfigResponse.fromPartial(object.instanceConfigResponse)
        : undefined;
    return message;
  },
};

function createBaseCloudBackupResponse(): CloudBackupResponse {
  return { listedBackups: [], listedBackupOperations: [], nextPageToken: "", backup: undefined };
}

export const CloudBackupResponse: MessageFns<CloudBackupResponse> = {
  encode(message: CloudBackupResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.listedBackups) {
      Backup.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.listedBackupOperations) {
      Operation.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(26).string(message.nextPageToken);
    }
    if (message.backup !== undefined) {
      Backup.encode(message.backup, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloudBackupResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloudBackupResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.listedBackups.push(Backup.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.listedBackupOperations.push(Operation.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.backup = Backup.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloudBackupResponse {
    return {
      listedBackups: globalThis.Array.isArray(object?.listedBackups)
        ? object.listedBackups.map((e: any) => Backup.fromJSON(e))
        : [],
      listedBackupOperations: globalThis.Array.isArray(object?.listedBackupOperations)
        ? object.listedBackupOperations.map((e: any) => Operation.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      backup: isSet(object.backup) ? Backup.fromJSON(object.backup) : undefined,
    };
  },

  toJSON(message: CloudBackupResponse): unknown {
    const obj: any = {};
    if (message.listedBackups?.length) {
      obj.listedBackups = message.listedBackups.map((e) => Backup.toJSON(e));
    }
    if (message.listedBackupOperations?.length) {
      obj.listedBackupOperations = message.listedBackupOperations.map((e) => Operation.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.backup !== undefined) {
      obj.backup = Backup.toJSON(message.backup);
    }
    return obj;
  },

  create(base?: DeepPartial<CloudBackupResponse>): CloudBackupResponse {
    return CloudBackupResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CloudBackupResponse>): CloudBackupResponse {
    const message = createBaseCloudBackupResponse();
    message.listedBackups = object.listedBackups?.map((e) => Backup.fromPartial(e)) || [];
    message.listedBackupOperations = object.listedBackupOperations?.map((e) => Operation.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.backup = (object.backup !== undefined && object.backup !== null)
      ? Backup.fromPartial(object.backup)
      : undefined;
    return message;
  },
};

function createBaseOperationResponse(): OperationResponse {
  return { listedOperations: [], nextPageToken: "", operation: undefined };
}

export const OperationResponse: MessageFns<OperationResponse> = {
  encode(message: OperationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.listedOperations) {
      Operation.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    if (message.operation !== undefined) {
      Operation.encode(message.operation, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.listedOperations.push(Operation.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.operation = Operation.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationResponse {
    return {
      listedOperations: globalThis.Array.isArray(object?.listedOperations)
        ? object.listedOperations.map((e: any) => Operation.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      operation: isSet(object.operation) ? Operation.fromJSON(object.operation) : undefined,
    };
  },

  toJSON(message: OperationResponse): unknown {
    const obj: any = {};
    if (message.listedOperations?.length) {
      obj.listedOperations = message.listedOperations.map((e) => Operation.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.operation !== undefined) {
      obj.operation = Operation.toJSON(message.operation);
    }
    return obj;
  },

  create(base?: DeepPartial<OperationResponse>): OperationResponse {
    return OperationResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OperationResponse>): OperationResponse {
    const message = createBaseOperationResponse();
    message.listedOperations = object.listedOperations?.map((e) => Operation.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.operation = (object.operation !== undefined && object.operation !== null)
      ? Operation.fromPartial(object.operation)
      : undefined;
    return message;
  },
};

function createBaseCloudInstanceResponse(): CloudInstanceResponse {
  return { listedInstances: [], nextPageToken: "", instance: undefined };
}

export const CloudInstanceResponse: MessageFns<CloudInstanceResponse> = {
  encode(message: CloudInstanceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.listedInstances) {
      Instance.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    if (message.instance !== undefined) {
      Instance.encode(message.instance, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloudInstanceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloudInstanceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.listedInstances.push(Instance.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.instance = Instance.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloudInstanceResponse {
    return {
      listedInstances: globalThis.Array.isArray(object?.listedInstances)
        ? object.listedInstances.map((e: any) => Instance.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      instance: isSet(object.instance) ? Instance.fromJSON(object.instance) : undefined,
    };
  },

  toJSON(message: CloudInstanceResponse): unknown {
    const obj: any = {};
    if (message.listedInstances?.length) {
      obj.listedInstances = message.listedInstances.map((e) => Instance.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.instance !== undefined) {
      obj.instance = Instance.toJSON(message.instance);
    }
    return obj;
  },

  create(base?: DeepPartial<CloudInstanceResponse>): CloudInstanceResponse {
    return CloudInstanceResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CloudInstanceResponse>): CloudInstanceResponse {
    const message = createBaseCloudInstanceResponse();
    message.listedInstances = object.listedInstances?.map((e) => Instance.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.instance = (object.instance !== undefined && object.instance !== null)
      ? Instance.fromPartial(object.instance)
      : undefined;
    return message;
  },
};

function createBaseCloudInstanceConfigResponse(): CloudInstanceConfigResponse {
  return { listedInstanceConfigs: [], nextPageToken: "", instanceConfig: undefined };
}

export const CloudInstanceConfigResponse: MessageFns<CloudInstanceConfigResponse> = {
  encode(message: CloudInstanceConfigResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.listedInstanceConfigs) {
      InstanceConfig.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    if (message.instanceConfig !== undefined) {
      InstanceConfig.encode(message.instanceConfig, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloudInstanceConfigResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloudInstanceConfigResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.listedInstanceConfigs.push(InstanceConfig.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.instanceConfig = InstanceConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloudInstanceConfigResponse {
    return {
      listedInstanceConfigs: globalThis.Array.isArray(object?.listedInstanceConfigs)
        ? object.listedInstanceConfigs.map((e: any) => InstanceConfig.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      instanceConfig: isSet(object.instanceConfig) ? InstanceConfig.fromJSON(object.instanceConfig) : undefined,
    };
  },

  toJSON(message: CloudInstanceConfigResponse): unknown {
    const obj: any = {};
    if (message.listedInstanceConfigs?.length) {
      obj.listedInstanceConfigs = message.listedInstanceConfigs.map((e) => InstanceConfig.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.instanceConfig !== undefined) {
      obj.instanceConfig = InstanceConfig.toJSON(message.instanceConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<CloudInstanceConfigResponse>): CloudInstanceConfigResponse {
    return CloudInstanceConfigResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CloudInstanceConfigResponse>): CloudInstanceConfigResponse {
    const message = createBaseCloudInstanceConfigResponse();
    message.listedInstanceConfigs = object.listedInstanceConfigs?.map((e) => InstanceConfig.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.instanceConfig = (object.instanceConfig !== undefined && object.instanceConfig !== null)
      ? InstanceConfig.fromPartial(object.instanceConfig)
      : undefined;
    return message;
  },
};

function createBaseCloudDatabaseResponse(): CloudDatabaseResponse {
  return { listedDatabases: [], listedDatabaseOperations: [], nextPageToken: "", database: undefined };
}

export const CloudDatabaseResponse: MessageFns<CloudDatabaseResponse> = {
  encode(message: CloudDatabaseResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.listedDatabases) {
      Database.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.listedDatabaseOperations) {
      Operation.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(26).string(message.nextPageToken);
    }
    if (message.database !== undefined) {
      Database.encode(message.database, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloudDatabaseResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloudDatabaseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.listedDatabases.push(Database.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.listedDatabaseOperations.push(Operation.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.database = Database.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloudDatabaseResponse {
    return {
      listedDatabases: globalThis.Array.isArray(object?.listedDatabases)
        ? object.listedDatabases.map((e: any) => Database.fromJSON(e))
        : [],
      listedDatabaseOperations: globalThis.Array.isArray(object?.listedDatabaseOperations)
        ? object.listedDatabaseOperations.map((e: any) => Operation.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      database: isSet(object.database) ? Database.fromJSON(object.database) : undefined,
    };
  },

  toJSON(message: CloudDatabaseResponse): unknown {
    const obj: any = {};
    if (message.listedDatabases?.length) {
      obj.listedDatabases = message.listedDatabases.map((e) => Database.toJSON(e));
    }
    if (message.listedDatabaseOperations?.length) {
      obj.listedDatabaseOperations = message.listedDatabaseOperations.map((e) => Operation.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.database !== undefined) {
      obj.database = Database.toJSON(message.database);
    }
    return obj;
  },

  create(base?: DeepPartial<CloudDatabaseResponse>): CloudDatabaseResponse {
    return CloudDatabaseResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CloudDatabaseResponse>): CloudDatabaseResponse {
    const message = createBaseCloudDatabaseResponse();
    message.listedDatabases = object.listedDatabases?.map((e) => Database.fromPartial(e)) || [];
    message.listedDatabaseOperations = object.listedDatabaseOperations?.map((e) => Operation.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.database = (object.database !== undefined && object.database !== null)
      ? Database.fromPartial(object.database)
      : undefined;
    return message;
  },
};

function createBaseReadResult(): ReadResult {
  return { table: "", index: undefined, requestIndex: undefined, row: [], rowType: undefined };
}

export const ReadResult: MessageFns<ReadResult> = {
  encode(message: ReadResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.table !== "") {
      writer.uint32(10).string(message.table);
    }
    if (message.index !== undefined) {
      writer.uint32(18).string(message.index);
    }
    if (message.requestIndex !== undefined) {
      writer.uint32(24).int32(message.requestIndex);
    }
    for (const v of message.row) {
      ValueList.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.rowType !== undefined) {
      StructType.encode(message.rowType, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReadResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.table = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.index = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.requestIndex = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.row.push(ValueList.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.rowType = StructType.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadResult {
    return {
      table: isSet(object.table) ? globalThis.String(object.table) : "",
      index: isSet(object.index) ? globalThis.String(object.index) : undefined,
      requestIndex: isSet(object.requestIndex) ? globalThis.Number(object.requestIndex) : undefined,
      row: globalThis.Array.isArray(object?.row) ? object.row.map((e: any) => ValueList.fromJSON(e)) : [],
      rowType: isSet(object.rowType) ? StructType.fromJSON(object.rowType) : undefined,
    };
  },

  toJSON(message: ReadResult): unknown {
    const obj: any = {};
    if (message.table !== "") {
      obj.table = message.table;
    }
    if (message.index !== undefined) {
      obj.index = message.index;
    }
    if (message.requestIndex !== undefined) {
      obj.requestIndex = Math.round(message.requestIndex);
    }
    if (message.row?.length) {
      obj.row = message.row.map((e) => ValueList.toJSON(e));
    }
    if (message.rowType !== undefined) {
      obj.rowType = StructType.toJSON(message.rowType);
    }
    return obj;
  },

  create(base?: DeepPartial<ReadResult>): ReadResult {
    return ReadResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReadResult>): ReadResult {
    const message = createBaseReadResult();
    message.table = object.table ?? "";
    message.index = object.index ?? undefined;
    message.requestIndex = object.requestIndex ?? undefined;
    message.row = object.row?.map((e) => ValueList.fromPartial(e)) || [];
    message.rowType = (object.rowType !== undefined && object.rowType !== null)
      ? StructType.fromPartial(object.rowType)
      : undefined;
    return message;
  },
};

function createBaseQueryResult(): QueryResult {
  return { row: [], rowType: undefined };
}

export const QueryResult: MessageFns<QueryResult> = {
  encode(message: QueryResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.row) {
      ValueList.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.rowType !== undefined) {
      StructType.encode(message.rowType, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.row.push(ValueList.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.rowType = StructType.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryResult {
    return {
      row: globalThis.Array.isArray(object?.row) ? object.row.map((e: any) => ValueList.fromJSON(e)) : [],
      rowType: isSet(object.rowType) ? StructType.fromJSON(object.rowType) : undefined,
    };
  },

  toJSON(message: QueryResult): unknown {
    const obj: any = {};
    if (message.row?.length) {
      obj.row = message.row.map((e) => ValueList.toJSON(e));
    }
    if (message.rowType !== undefined) {
      obj.rowType = StructType.toJSON(message.rowType);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryResult>): QueryResult {
    return QueryResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryResult>): QueryResult {
    const message = createBaseQueryResult();
    message.row = object.row?.map((e) => ValueList.fromPartial(e)) || [];
    message.rowType = (object.rowType !== undefined && object.rowType !== null)
      ? StructType.fromPartial(object.rowType)
      : undefined;
    return message;
  },
};

function createBaseChangeStreamRecord(): ChangeStreamRecord {
  return { dataChange: undefined, childPartition: undefined, heartbeat: undefined };
}

export const ChangeStreamRecord: MessageFns<ChangeStreamRecord> = {
  encode(message: ChangeStreamRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dataChange !== undefined) {
      DataChangeRecord.encode(message.dataChange, writer.uint32(10).fork()).join();
    }
    if (message.childPartition !== undefined) {
      ChildPartitionsRecord.encode(message.childPartition, writer.uint32(18).fork()).join();
    }
    if (message.heartbeat !== undefined) {
      HeartbeatRecord.encode(message.heartbeat, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangeStreamRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangeStreamRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dataChange = DataChangeRecord.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.childPartition = ChildPartitionsRecord.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.heartbeat = HeartbeatRecord.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangeStreamRecord {
    return {
      dataChange: isSet(object.dataChange) ? DataChangeRecord.fromJSON(object.dataChange) : undefined,
      childPartition: isSet(object.childPartition) ? ChildPartitionsRecord.fromJSON(object.childPartition) : undefined,
      heartbeat: isSet(object.heartbeat) ? HeartbeatRecord.fromJSON(object.heartbeat) : undefined,
    };
  },

  toJSON(message: ChangeStreamRecord): unknown {
    const obj: any = {};
    if (message.dataChange !== undefined) {
      obj.dataChange = DataChangeRecord.toJSON(message.dataChange);
    }
    if (message.childPartition !== undefined) {
      obj.childPartition = ChildPartitionsRecord.toJSON(message.childPartition);
    }
    if (message.heartbeat !== undefined) {
      obj.heartbeat = HeartbeatRecord.toJSON(message.heartbeat);
    }
    return obj;
  },

  create(base?: DeepPartial<ChangeStreamRecord>): ChangeStreamRecord {
    return ChangeStreamRecord.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChangeStreamRecord>): ChangeStreamRecord {
    const message = createBaseChangeStreamRecord();
    message.dataChange = (object.dataChange !== undefined && object.dataChange !== null)
      ? DataChangeRecord.fromPartial(object.dataChange)
      : undefined;
    message.childPartition = (object.childPartition !== undefined && object.childPartition !== null)
      ? ChildPartitionsRecord.fromPartial(object.childPartition)
      : undefined;
    message.heartbeat = (object.heartbeat !== undefined && object.heartbeat !== null)
      ? HeartbeatRecord.fromPartial(object.heartbeat)
      : undefined;
    return message;
  },
};

function createBaseDataChangeRecord(): DataChangeRecord {
  return {
    commitTime: undefined,
    recordSequence: "",
    transactionId: "",
    isLastRecord: false,
    table: "",
    columnTypes: [],
    mods: [],
    modType: "",
    valueCaptureType: "",
    recordCount: Long.ZERO,
    partitionCount: Long.ZERO,
    transactionTag: "",
    isSystemTransaction: false,
  };
}

export const DataChangeRecord: MessageFns<DataChangeRecord> = {
  encode(message: DataChangeRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.commitTime !== undefined) {
      Timestamp.encode(toTimestamp(message.commitTime), writer.uint32(10).fork()).join();
    }
    if (message.recordSequence !== "") {
      writer.uint32(18).string(message.recordSequence);
    }
    if (message.transactionId !== "") {
      writer.uint32(26).string(message.transactionId);
    }
    if (message.isLastRecord !== false) {
      writer.uint32(32).bool(message.isLastRecord);
    }
    if (message.table !== "") {
      writer.uint32(42).string(message.table);
    }
    for (const v of message.columnTypes) {
      DataChangeRecord_ColumnType.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.mods) {
      DataChangeRecord_Mod.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.modType !== "") {
      writer.uint32(66).string(message.modType);
    }
    if (message.valueCaptureType !== "") {
      writer.uint32(74).string(message.valueCaptureType);
    }
    if (!message.recordCount.equals(Long.ZERO)) {
      writer.uint32(80).int64(message.recordCount.toString());
    }
    if (!message.partitionCount.equals(Long.ZERO)) {
      writer.uint32(88).int64(message.partitionCount.toString());
    }
    if (message.transactionTag !== "") {
      writer.uint32(98).string(message.transactionTag);
    }
    if (message.isSystemTransaction !== false) {
      writer.uint32(104).bool(message.isSystemTransaction);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataChangeRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataChangeRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.commitTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.recordSequence = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.transactionId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.isLastRecord = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.table = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.columnTypes.push(DataChangeRecord_ColumnType.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.mods.push(DataChangeRecord_Mod.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.modType = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.valueCaptureType = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.recordCount = Long.fromString(reader.int64().toString());
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.partitionCount = Long.fromString(reader.int64().toString());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.transactionTag = reader.string();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.isSystemTransaction = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataChangeRecord {
    return {
      commitTime: isSet(object.commitTime) ? fromJsonTimestamp(object.commitTime) : undefined,
      recordSequence: isSet(object.recordSequence) ? globalThis.String(object.recordSequence) : "",
      transactionId: isSet(object.transactionId) ? globalThis.String(object.transactionId) : "",
      isLastRecord: isSet(object.isLastRecord) ? globalThis.Boolean(object.isLastRecord) : false,
      table: isSet(object.table) ? globalThis.String(object.table) : "",
      columnTypes: globalThis.Array.isArray(object?.columnTypes)
        ? object.columnTypes.map((e: any) => DataChangeRecord_ColumnType.fromJSON(e))
        : [],
      mods: globalThis.Array.isArray(object?.mods) ? object.mods.map((e: any) => DataChangeRecord_Mod.fromJSON(e)) : [],
      modType: isSet(object.modType) ? globalThis.String(object.modType) : "",
      valueCaptureType: isSet(object.valueCaptureType) ? globalThis.String(object.valueCaptureType) : "",
      recordCount: isSet(object.recordCount) ? Long.fromValue(object.recordCount) : Long.ZERO,
      partitionCount: isSet(object.partitionCount) ? Long.fromValue(object.partitionCount) : Long.ZERO,
      transactionTag: isSet(object.transactionTag) ? globalThis.String(object.transactionTag) : "",
      isSystemTransaction: isSet(object.isSystemTransaction) ? globalThis.Boolean(object.isSystemTransaction) : false,
    };
  },

  toJSON(message: DataChangeRecord): unknown {
    const obj: any = {};
    if (message.commitTime !== undefined) {
      obj.commitTime = message.commitTime.toISOString();
    }
    if (message.recordSequence !== "") {
      obj.recordSequence = message.recordSequence;
    }
    if (message.transactionId !== "") {
      obj.transactionId = message.transactionId;
    }
    if (message.isLastRecord !== false) {
      obj.isLastRecord = message.isLastRecord;
    }
    if (message.table !== "") {
      obj.table = message.table;
    }
    if (message.columnTypes?.length) {
      obj.columnTypes = message.columnTypes.map((e) => DataChangeRecord_ColumnType.toJSON(e));
    }
    if (message.mods?.length) {
      obj.mods = message.mods.map((e) => DataChangeRecord_Mod.toJSON(e));
    }
    if (message.modType !== "") {
      obj.modType = message.modType;
    }
    if (message.valueCaptureType !== "") {
      obj.valueCaptureType = message.valueCaptureType;
    }
    if (!message.recordCount.equals(Long.ZERO)) {
      obj.recordCount = (message.recordCount || Long.ZERO).toString();
    }
    if (!message.partitionCount.equals(Long.ZERO)) {
      obj.partitionCount = (message.partitionCount || Long.ZERO).toString();
    }
    if (message.transactionTag !== "") {
      obj.transactionTag = message.transactionTag;
    }
    if (message.isSystemTransaction !== false) {
      obj.isSystemTransaction = message.isSystemTransaction;
    }
    return obj;
  },

  create(base?: DeepPartial<DataChangeRecord>): DataChangeRecord {
    return DataChangeRecord.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataChangeRecord>): DataChangeRecord {
    const message = createBaseDataChangeRecord();
    message.commitTime = object.commitTime ?? undefined;
    message.recordSequence = object.recordSequence ?? "";
    message.transactionId = object.transactionId ?? "";
    message.isLastRecord = object.isLastRecord ?? false;
    message.table = object.table ?? "";
    message.columnTypes = object.columnTypes?.map((e) => DataChangeRecord_ColumnType.fromPartial(e)) || [];
    message.mods = object.mods?.map((e) => DataChangeRecord_Mod.fromPartial(e)) || [];
    message.modType = object.modType ?? "";
    message.valueCaptureType = object.valueCaptureType ?? "";
    message.recordCount = (object.recordCount !== undefined && object.recordCount !== null)
      ? Long.fromValue(object.recordCount)
      : Long.ZERO;
    message.partitionCount = (object.partitionCount !== undefined && object.partitionCount !== null)
      ? Long.fromValue(object.partitionCount)
      : Long.ZERO;
    message.transactionTag = object.transactionTag ?? "";
    message.isSystemTransaction = object.isSystemTransaction ?? false;
    return message;
  },
};

function createBaseDataChangeRecord_ColumnType(): DataChangeRecord_ColumnType {
  return { name: "", type: "", isPrimaryKey: false, ordinalPosition: Long.ZERO };
}

export const DataChangeRecord_ColumnType: MessageFns<DataChangeRecord_ColumnType> = {
  encode(message: DataChangeRecord_ColumnType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.isPrimaryKey !== false) {
      writer.uint32(24).bool(message.isPrimaryKey);
    }
    if (!message.ordinalPosition.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.ordinalPosition.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataChangeRecord_ColumnType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataChangeRecord_ColumnType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.isPrimaryKey = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.ordinalPosition = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataChangeRecord_ColumnType {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      isPrimaryKey: isSet(object.isPrimaryKey) ? globalThis.Boolean(object.isPrimaryKey) : false,
      ordinalPosition: isSet(object.ordinalPosition) ? Long.fromValue(object.ordinalPosition) : Long.ZERO,
    };
  },

  toJSON(message: DataChangeRecord_ColumnType): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.isPrimaryKey !== false) {
      obj.isPrimaryKey = message.isPrimaryKey;
    }
    if (!message.ordinalPosition.equals(Long.ZERO)) {
      obj.ordinalPosition = (message.ordinalPosition || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<DataChangeRecord_ColumnType>): DataChangeRecord_ColumnType {
    return DataChangeRecord_ColumnType.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataChangeRecord_ColumnType>): DataChangeRecord_ColumnType {
    const message = createBaseDataChangeRecord_ColumnType();
    message.name = object.name ?? "";
    message.type = object.type ?? "";
    message.isPrimaryKey = object.isPrimaryKey ?? false;
    message.ordinalPosition = (object.ordinalPosition !== undefined && object.ordinalPosition !== null)
      ? Long.fromValue(object.ordinalPosition)
      : Long.ZERO;
    return message;
  },
};

function createBaseDataChangeRecord_Mod(): DataChangeRecord_Mod {
  return { keys: "", newValues: "", oldValues: "" };
}

export const DataChangeRecord_Mod: MessageFns<DataChangeRecord_Mod> = {
  encode(message: DataChangeRecord_Mod, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keys !== "") {
      writer.uint32(10).string(message.keys);
    }
    if (message.newValues !== "") {
      writer.uint32(18).string(message.newValues);
    }
    if (message.oldValues !== "") {
      writer.uint32(26).string(message.oldValues);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataChangeRecord_Mod {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataChangeRecord_Mod();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.keys = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.newValues = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.oldValues = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataChangeRecord_Mod {
    return {
      keys: isSet(object.keys) ? globalThis.String(object.keys) : "",
      newValues: isSet(object.newValues) ? globalThis.String(object.newValues) : "",
      oldValues: isSet(object.oldValues) ? globalThis.String(object.oldValues) : "",
    };
  },

  toJSON(message: DataChangeRecord_Mod): unknown {
    const obj: any = {};
    if (message.keys !== "") {
      obj.keys = message.keys;
    }
    if (message.newValues !== "") {
      obj.newValues = message.newValues;
    }
    if (message.oldValues !== "") {
      obj.oldValues = message.oldValues;
    }
    return obj;
  },

  create(base?: DeepPartial<DataChangeRecord_Mod>): DataChangeRecord_Mod {
    return DataChangeRecord_Mod.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataChangeRecord_Mod>): DataChangeRecord_Mod {
    const message = createBaseDataChangeRecord_Mod();
    message.keys = object.keys ?? "";
    message.newValues = object.newValues ?? "";
    message.oldValues = object.oldValues ?? "";
    return message;
  },
};

function createBaseChildPartitionsRecord(): ChildPartitionsRecord {
  return { startTime: undefined, recordSequence: "", childPartitions: [] };
}

export const ChildPartitionsRecord: MessageFns<ChildPartitionsRecord> = {
  encode(message: ChildPartitionsRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(10).fork()).join();
    }
    if (message.recordSequence !== "") {
      writer.uint32(18).string(message.recordSequence);
    }
    for (const v of message.childPartitions) {
      ChildPartitionsRecord_ChildPartition.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChildPartitionsRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChildPartitionsRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.recordSequence = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.childPartitions.push(ChildPartitionsRecord_ChildPartition.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChildPartitionsRecord {
    return {
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      recordSequence: isSet(object.recordSequence) ? globalThis.String(object.recordSequence) : "",
      childPartitions: globalThis.Array.isArray(object?.childPartitions)
        ? object.childPartitions.map((e: any) => ChildPartitionsRecord_ChildPartition.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ChildPartitionsRecord): unknown {
    const obj: any = {};
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.recordSequence !== "") {
      obj.recordSequence = message.recordSequence;
    }
    if (message.childPartitions?.length) {
      obj.childPartitions = message.childPartitions.map((e) => ChildPartitionsRecord_ChildPartition.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ChildPartitionsRecord>): ChildPartitionsRecord {
    return ChildPartitionsRecord.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChildPartitionsRecord>): ChildPartitionsRecord {
    const message = createBaseChildPartitionsRecord();
    message.startTime = object.startTime ?? undefined;
    message.recordSequence = object.recordSequence ?? "";
    message.childPartitions = object.childPartitions?.map((e) => ChildPartitionsRecord_ChildPartition.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseChildPartitionsRecord_ChildPartition(): ChildPartitionsRecord_ChildPartition {
  return { token: "", parentPartitionTokens: [] };
}

export const ChildPartitionsRecord_ChildPartition: MessageFns<ChildPartitionsRecord_ChildPartition> = {
  encode(message: ChildPartitionsRecord_ChildPartition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    for (const v of message.parentPartitionTokens) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChildPartitionsRecord_ChildPartition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChildPartitionsRecord_ChildPartition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parentPartitionTokens.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChildPartitionsRecord_ChildPartition {
    return {
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      parentPartitionTokens: globalThis.Array.isArray(object?.parentPartitionTokens)
        ? object.parentPartitionTokens.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ChildPartitionsRecord_ChildPartition): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.parentPartitionTokens?.length) {
      obj.parentPartitionTokens = message.parentPartitionTokens;
    }
    return obj;
  },

  create(base?: DeepPartial<ChildPartitionsRecord_ChildPartition>): ChildPartitionsRecord_ChildPartition {
    return ChildPartitionsRecord_ChildPartition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChildPartitionsRecord_ChildPartition>): ChildPartitionsRecord_ChildPartition {
    const message = createBaseChildPartitionsRecord_ChildPartition();
    message.token = object.token ?? "";
    message.parentPartitionTokens = object.parentPartitionTokens?.map((e) => e) || [];
    return message;
  },
};

function createBaseHeartbeatRecord(): HeartbeatRecord {
  return { heartbeatTime: undefined };
}

export const HeartbeatRecord: MessageFns<HeartbeatRecord> = {
  encode(message: HeartbeatRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.heartbeatTime !== undefined) {
      Timestamp.encode(toTimestamp(message.heartbeatTime), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HeartbeatRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeartbeatRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.heartbeatTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HeartbeatRecord {
    return { heartbeatTime: isSet(object.heartbeatTime) ? fromJsonTimestamp(object.heartbeatTime) : undefined };
  },

  toJSON(message: HeartbeatRecord): unknown {
    const obj: any = {};
    if (message.heartbeatTime !== undefined) {
      obj.heartbeatTime = message.heartbeatTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<HeartbeatRecord>): HeartbeatRecord {
    return HeartbeatRecord.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HeartbeatRecord>): HeartbeatRecord {
    const message = createBaseHeartbeatRecord();
    message.heartbeatTime = object.heartbeatTime ?? undefined;
    return message;
  },
};

function createBaseSpannerOptions(): SpannerOptions {
  return { sessionPoolOptions: undefined };
}

export const SpannerOptions: MessageFns<SpannerOptions> = {
  encode(message: SpannerOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionPoolOptions !== undefined) {
      SessionPoolOptions.encode(message.sessionPoolOptions, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpannerOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpannerOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sessionPoolOptions = SessionPoolOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpannerOptions {
    return {
      sessionPoolOptions: isSet(object.sessionPoolOptions)
        ? SessionPoolOptions.fromJSON(object.sessionPoolOptions)
        : undefined,
    };
  },

  toJSON(message: SpannerOptions): unknown {
    const obj: any = {};
    if (message.sessionPoolOptions !== undefined) {
      obj.sessionPoolOptions = SessionPoolOptions.toJSON(message.sessionPoolOptions);
    }
    return obj;
  },

  create(base?: DeepPartial<SpannerOptions>): SpannerOptions {
    return SpannerOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SpannerOptions>): SpannerOptions {
    const message = createBaseSpannerOptions();
    message.sessionPoolOptions = (object.sessionPoolOptions !== undefined && object.sessionPoolOptions !== null)
      ? SessionPoolOptions.fromPartial(object.sessionPoolOptions)
      : undefined;
    return message;
  },
};

function createBaseSessionPoolOptions(): SessionPoolOptions {
  return { useMultiplexed: false };
}

export const SessionPoolOptions: MessageFns<SessionPoolOptions> = {
  encode(message: SessionPoolOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.useMultiplexed !== false) {
      writer.uint32(8).bool(message.useMultiplexed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SessionPoolOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionPoolOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.useMultiplexed = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionPoolOptions {
    return { useMultiplexed: isSet(object.useMultiplexed) ? globalThis.Boolean(object.useMultiplexed) : false };
  },

  toJSON(message: SessionPoolOptions): unknown {
    const obj: any = {};
    if (message.useMultiplexed !== false) {
      obj.useMultiplexed = message.useMultiplexed;
    }
    return obj;
  },

  create(base?: DeepPartial<SessionPoolOptions>): SessionPoolOptions {
    return SessionPoolOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SessionPoolOptions>): SessionPoolOptions {
    const message = createBaseSessionPoolOptions();
    message.useMultiplexed = object.useMultiplexed ?? false;
    return message;
  },
};

/** Service that executes SpannerActions asynchronously. */
export type SpannerExecutorProxyDefinition = typeof SpannerExecutorProxyDefinition;
export const SpannerExecutorProxyDefinition = {
  name: "SpannerExecutorProxy",
  fullName: "google.spanner.executor.v1.SpannerExecutorProxy",
  methods: {
    /**
     * ExecuteActionAsync is a streaming call that starts executing a new Spanner
     * action.
     *
     * For each request, the server will reply with one or more responses, but
     * only the last response will contain status in the outcome.
     *
     * Responses can be matched to requests by action_id. It is allowed to have
     * multiple actions in flight--in that case, actions are be executed in
     * parallel.
     */
    executeActionAsync: {
      name: "ExecuteActionAsync",
      requestType: SpannerAsyncActionRequest,
      requestStream: true,
      responseType: SpannerAsyncActionResponse,
      responseStream: true,
      options: {},
    },
  },
} as const;

export interface SpannerExecutorProxyServiceImplementation<CallContextExt = {}> {
  /**
   * ExecuteActionAsync is a streaming call that starts executing a new Spanner
   * action.
   *
   * For each request, the server will reply with one or more responses, but
   * only the last response will contain status in the outcome.
   *
   * Responses can be matched to requests by action_id. It is allowed to have
   * multiple actions in flight--in that case, actions are be executed in
   * parallel.
   */
  executeActionAsync(
    request: AsyncIterable<SpannerAsyncActionRequest>,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<DeepPartial<SpannerAsyncActionResponse>>;
}

export interface SpannerExecutorProxyClient<CallOptionsExt = {}> {
  /**
   * ExecuteActionAsync is a streaming call that starts executing a new Spanner
   * action.
   *
   * For each request, the server will reply with one or more responses, but
   * only the last response will contain status in the outcome.
   *
   * Responses can be matched to requests by action_id. It is allowed to have
   * multiple actions in flight--in that case, actions are be executed in
   * parallel.
   */
  executeActionAsync(
    request: AsyncIterable<DeepPartial<SpannerAsyncActionRequest>>,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<SpannerAsyncActionResponse>;
}

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export type ServerStreamingMethodResult<Response> = { [Symbol.asyncIterator](): AsyncIterator<Response, void> };

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
