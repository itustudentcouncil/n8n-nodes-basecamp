// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/container/v1alpha1/cluster_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Empty } from "../../protobuf/empty.js";

export const protobufPackage = "google.container.v1alpha1";

/** Parameters that describe the nodes in a cluster. */
export interface NodeConfig {
  /**
   * The name of a Google Compute Engine [machine
   * type](/compute/docs/machine-types) (e.g.
   * `n1-standard-1`).
   *
   * If unspecified, the default machine type is
   * `n1-standard-1`.
   */
  machineType: string;
  /**
   * Size of the disk attached to each node, specified in GB.
   * The smallest allowed disk size is 10GB.
   *
   * If unspecified, the default disk size is 100GB.
   */
  diskSizeGb: number;
  /**
   * The set of Google API scopes to be made available on all of the
   * node VMs under the "default" service account.
   *
   * The following scopes are recommended, but not required, and by default are
   * not included:
   *
   * * `https://www.googleapis.com/auth/compute` is required for mounting
   * persistent storage on your nodes.
   * * `https://www.googleapis.com/auth/devstorage.read_only` is required for
   * communicating with **gcr.io**
   * (the [Google Container Registry](/container-registry/)).
   *
   * If unspecified, no scopes are added, unless Cloud Logging or Cloud
   * Monitoring are enabled, in which case their required scopes will be added.
   */
  oauthScopes: string[];
  /**
   * The Google Cloud Platform Service Account to be used by the node VMs. If
   * no Service Account is specified, the "default" service account is used.
   */
  serviceAccount: string;
  /**
   * The metadata key/value pairs assigned to instances in the cluster.
   *
   * Keys must conform to the regexp [a-zA-Z0-9-_]+ and be less than 128 bytes
   * in length. These are reflected as part of a URL in the metadata server.
   * Additionally, to avoid ambiguity, keys must not conflict with any other
   * metadata keys for the project or be one of the four reserved keys:
   * "instance-template", "kube-env", "startup-script", and "user-data"
   *
   * Values are free-form strings, and only have meaning as interpreted by
   * the image running in the instance. The only restriction placed on them is
   * that each value's size must be less than or equal to 32 KB.
   *
   * The total size of all keys and values must be less than 512 KB.
   */
  metadata: { [key: string]: string };
  /**
   * The image type to use for this node. Note that for a given image type,
   * the latest version of it will be used.
   */
  imageType: string;
  /**
   * The map of Kubernetes labels (key/value pairs) to be applied to each node.
   * These will added in addition to any default label(s) that
   * Kubernetes may apply to the node.
   * In case of conflict in label keys, the applied set may differ depending on
   * the Kubernetes version -- it's best to assume the behavior is undefined
   * and conflicts should be avoided.
   * For more information, including usage and the valid values, see:
   * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
   */
  labels: { [key: string]: string };
  /**
   * The number of local SSD disks to be attached to the node.
   *
   * The limit for this value is dependant upon the maximum number of
   * disks available on a machine per zone. See:
   * https://cloud.google.com/compute/docs/disks/local-ssd#local_ssd_limits
   * for more information.
   */
  localSsdCount: number;
  /**
   * The list of instance tags applied to all nodes. Tags are used to identify
   * valid sources or targets for network firewalls and are specified by
   * the client during cluster or node pool creation. Each tag within the list
   * must comply with RFC1035.
   */
  tags: string[];
  /**
   * Whether the nodes are created as preemptible VM instances. See:
   * https://cloud.google.com/compute/docs/instances/preemptible for more
   * inforamtion about preemptible VM instances.
   */
  preemptible: boolean;
  /**
   * A list of hardware accelerators to be attached to each node.
   * See https://cloud.google.com/compute/docs/gpus for more information about
   * support for GPUs.
   */
  accelerators: AcceleratorConfig[];
  /**
   * Minimum CPU platform to be used by this instance. The instance may be
   * scheduled on the specified or newer CPU platform. Applicable values are the
   * friendly names of CPU platforms, such as
   * <code>minCpuPlatform: &quot;Intel Haswell&quot;</code> or
   * <code>minCpuPlatform: &quot;Intel Sandy Bridge&quot;</code>. For more
   * information, read [how to specify min CPU platform](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform)
   */
  minCpuPlatform: string;
  /**
   * List of kubernetes taints to be applied to each node.
   *
   * For more information, including usage and the valid values, see:
   * https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
   */
  taints: NodeTaint[];
}

export interface NodeConfig_MetadataEntry {
  key: string;
  value: string;
}

export interface NodeConfig_LabelsEntry {
  key: string;
  value: string;
}

/**
 * Kubernetes taint is comprised of three fields: key, value, and effect. Effect
 * can only be one of three types:  NoSchedule, PreferNoSchedule or NoExecute.
 *
 * For more information, including usage and the valid values, see:
 * https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
 */
export interface NodeTaint {
  /** Key for taint. */
  key: string;
  /** Value for taint. */
  value: string;
  /** Effect for taint. */
  effect: NodeTaint_Effect;
}

/** Possible values for Effect in taint. */
export enum NodeTaint_Effect {
  /** EFFECT_UNSPECIFIED - Not set */
  EFFECT_UNSPECIFIED = 0,
  /** NO_SCHEDULE - NoSchedule */
  NO_SCHEDULE = 1,
  /** PREFER_NO_SCHEDULE - PreferNoSchedule */
  PREFER_NO_SCHEDULE = 2,
  /** NO_EXECUTE - NoExecute */
  NO_EXECUTE = 3,
  UNRECOGNIZED = -1,
}

export function nodeTaint_EffectFromJSON(object: any): NodeTaint_Effect {
  switch (object) {
    case 0:
    case "EFFECT_UNSPECIFIED":
      return NodeTaint_Effect.EFFECT_UNSPECIFIED;
    case 1:
    case "NO_SCHEDULE":
      return NodeTaint_Effect.NO_SCHEDULE;
    case 2:
    case "PREFER_NO_SCHEDULE":
      return NodeTaint_Effect.PREFER_NO_SCHEDULE;
    case 3:
    case "NO_EXECUTE":
      return NodeTaint_Effect.NO_EXECUTE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NodeTaint_Effect.UNRECOGNIZED;
  }
}

export function nodeTaint_EffectToJSON(object: NodeTaint_Effect): string {
  switch (object) {
    case NodeTaint_Effect.EFFECT_UNSPECIFIED:
      return "EFFECT_UNSPECIFIED";
    case NodeTaint_Effect.NO_SCHEDULE:
      return "NO_SCHEDULE";
    case NodeTaint_Effect.PREFER_NO_SCHEDULE:
      return "PREFER_NO_SCHEDULE";
    case NodeTaint_Effect.NO_EXECUTE:
      return "NO_EXECUTE";
    case NodeTaint_Effect.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The authentication information for accessing the master endpoint.
 * Authentication can be done using HTTP basic auth or using client
 * certificates.
 */
export interface MasterAuth {
  /**
   * The username to use for HTTP basic authentication to the master endpoint.
   * For clusters v1.6.0 and later, you can disable basic authentication by
   * providing an empty username.
   */
  username: string;
  /**
   * The password to use for HTTP basic authentication to the master endpoint.
   * Because the master endpoint is open to the Internet, you should create a
   * strong password.  If a password is provided for cluster creation, username
   * must be non-empty.
   */
  password: string;
  /**
   * Configuration for client certificate authentication on the cluster.  If no
   * configuration is specified, a client certificate is issued.
   */
  clientCertificateConfig:
    | ClientCertificateConfig
    | undefined;
  /**
   * [Output only] Base64-encoded public certificate that is the root of
   * trust for the cluster.
   */
  clusterCaCertificate: string;
  /**
   * [Output only] Base64-encoded public certificate used by clients to
   * authenticate to the cluster endpoint.
   */
  clientCertificate: string;
  /**
   * [Output only] Base64-encoded private key used by clients to authenticate
   * to the cluster endpoint.
   */
  clientKey: string;
}

/** Configuration for client certificates on the cluster. */
export interface ClientCertificateConfig {
  /** Issue a client certificate. */
  issueClientCertificate: boolean;
}

/**
 * Configuration for the addons that can be automatically spun up in the
 * cluster, enabling additional functionality.
 */
export interface AddonsConfig {
  /**
   * Configuration for the HTTP (L7) load balancing controller addon, which
   * makes it easy to set up HTTP load balancers for services in a cluster.
   */
  httpLoadBalancing:
    | HttpLoadBalancing
    | undefined;
  /**
   * Configuration for the horizontal pod autoscaling feature, which
   * increases or decreases the number of replica pods a replication controller
   * has based on the resource usage of the existing pods.
   */
  horizontalPodAutoscaling:
    | HorizontalPodAutoscaling
    | undefined;
  /** Configuration for the Kubernetes Dashboard. */
  kubernetesDashboard:
    | KubernetesDashboard
    | undefined;
  /**
   * Configuration for NetworkPolicy. This only tracks whether the addon
   * is enabled or not on the Master, it does not track whether network policy
   * is enabled for the nodes.
   */
  networkPolicyConfig: NetworkPolicyConfig | undefined;
}

/**
 * Configuration options for the HTTP (L7) load balancing controller addon,
 * which makes it easy to set up HTTP load balancers for services in a cluster.
 */
export interface HttpLoadBalancing {
  /**
   * Whether the HTTP Load Balancing controller is enabled in the cluster.
   * When enabled, it runs a small pod in the cluster that manages the load
   * balancers.
   */
  disabled: boolean;
}

/**
 * Configuration options for the horizontal pod autoscaling feature, which
 * increases or decreases the number of replica pods a replication controller
 * has based on the resource usage of the existing pods.
 */
export interface HorizontalPodAutoscaling {
  /**
   * Whether the Horizontal Pod Autoscaling feature is enabled in the cluster.
   * When enabled, it ensures that a Heapster pod is running in the cluster,
   * which is also used by the Cloud Monitoring service.
   */
  disabled: boolean;
}

/** Configuration for the Kubernetes Dashboard. */
export interface KubernetesDashboard {
  /** Whether the Kubernetes Dashboard is enabled for this cluster. */
  disabled: boolean;
}

/**
 * Configuration for NetworkPolicy. This only tracks whether the addon
 * is enabled or not on the Master, it does not track whether network policy
 * is enabled for the nodes.
 */
export interface NetworkPolicyConfig {
  /** Whether NetworkPolicy is enabled for this cluster. */
  disabled: boolean;
}

/**
 * Configuration options for the master authorized networks feature. Enabled
 * master authorized networks will disallow all external traffic to access
 * Kubernetes master through HTTPS except traffic from the given CIDR blocks,
 * Google Compute Engine Public IPs and Google Prod IPs.
 */
export interface MasterAuthorizedNetworksConfig {
  /** Whether or not master authorized networks is enabled. */
  enabled: boolean;
  /**
   * cidr_blocks define up to 10 external networks that could access
   * Kubernetes master through HTTPS.
   */
  cidrBlocks: MasterAuthorizedNetworksConfig_CidrBlock[];
}

/** CidrBlock contains an optional name and one CIDR block. */
export interface MasterAuthorizedNetworksConfig_CidrBlock {
  /** display_name is an optional field for users to identify CIDR blocks. */
  displayName: string;
  /** cidr_block must be specified in CIDR notation. */
  cidrBlock: string;
}

/**
 * Configuration options for the NetworkPolicy feature.
 * https://kubernetes.io/docs/concepts/services-networking/networkpolicies/
 */
export interface NetworkPolicy {
  /** The selected network policy provider. */
  provider: NetworkPolicy_Provider;
  /** Whether network policy is enabled on the cluster. */
  enabled: boolean;
}

/** Allowed Network Policy providers. */
export enum NetworkPolicy_Provider {
  /** PROVIDER_UNSPECIFIED - Not set */
  PROVIDER_UNSPECIFIED = 0,
  /** CALICO - Tigera (Calico Felix). */
  CALICO = 1,
  UNRECOGNIZED = -1,
}

export function networkPolicy_ProviderFromJSON(object: any): NetworkPolicy_Provider {
  switch (object) {
    case 0:
    case "PROVIDER_UNSPECIFIED":
      return NetworkPolicy_Provider.PROVIDER_UNSPECIFIED;
    case 1:
    case "CALICO":
      return NetworkPolicy_Provider.CALICO;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NetworkPolicy_Provider.UNRECOGNIZED;
  }
}

export function networkPolicy_ProviderToJSON(object: NetworkPolicy_Provider): string {
  switch (object) {
    case NetworkPolicy_Provider.PROVIDER_UNSPECIFIED:
      return "PROVIDER_UNSPECIFIED";
    case NetworkPolicy_Provider.CALICO:
      return "CALICO";
    case NetworkPolicy_Provider.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Configuration for controlling how IPs are allocated in the cluster. */
export interface IPAllocationPolicy {
  /** Whether alias IPs will be used for pod IPs in the cluster. */
  useIpAliases: boolean;
  /**
   * Whether a new subnetwork will be created automatically for the cluster.
   *
   * This field is only applicable when `use_ip_aliases` is true.
   */
  createSubnetwork: boolean;
  /**
   * A custom subnetwork name to be used if `create_subnetwork` is true.  If
   * this field is empty, then an automatic name will be chosen for the new
   * subnetwork.
   */
  subnetworkName: string;
  /** This field is deprecated, use cluster_ipv4_cidr_block. */
  clusterIpv4Cidr: string;
  /** This field is deprecated, use node_ipv4_cidr_block. */
  nodeIpv4Cidr: string;
  /** This field is deprecated, use services_ipv4_cidr_block. */
  servicesIpv4Cidr: string;
  /**
   * The name of the secondary range to be used for the cluster CIDR
   * block.  The secondary range will be used for pod IP
   * addresses. This must be an existing secondary range associated
   * with the cluster subnetwork.
   *
   * This field is only applicable if use_ip_aliases is true and
   * create_subnetwork is false.
   */
  clusterSecondaryRangeName: string;
  /**
   * The name of the secondary range to be used as for the services
   * CIDR block.  The secondary range will be used for service
   * ClusterIPs. This must be an existing secondary range associated
   * with the cluster subnetwork.
   *
   * This field is only applicable with use_ip_aliases is true and
   * create_subnetwork is false.
   */
  servicesSecondaryRangeName: string;
  /**
   * The IP address range for the cluster pod IPs. If this field is set, then
   * `cluster.cluster_ipv4_cidr` must be left blank.
   *
   * This field is only applicable when `use_ip_aliases` is true.
   *
   * Set to blank to have a range chosen with the default size.
   *
   * Set to /netmask (e.g. `/14`) to have a range chosen with a specific
   * netmask.
   *
   * Set to a
   * [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
   * notation (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g.
   * `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range
   * to use.
   */
  clusterIpv4CidrBlock: string;
  /**
   * The IP address range of the instance IPs in this cluster.
   *
   * This is applicable only if `create_subnetwork` is true.
   *
   * Set to blank to have a range chosen with the default size.
   *
   * Set to /netmask (e.g. `/14`) to have a range chosen with a specific
   * netmask.
   *
   * Set to a
   * [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
   * notation (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g.
   * `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range
   * to use.
   */
  nodeIpv4CidrBlock: string;
  /**
   * The IP address range of the services IPs in this cluster. If blank, a range
   * will be automatically chosen with the default size.
   *
   * This field is only applicable when `use_ip_aliases` is true.
   *
   * Set to blank to have a range chosen with the default size.
   *
   * Set to /netmask (e.g. `/14`) to have a range chosen with a specific
   * netmask.
   *
   * Set to a
   * [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
   * notation (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g.
   * `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range
   * to use.
   */
  servicesIpv4CidrBlock: string;
}

/** Configuration for the PodSecurityPolicy feature. */
export interface PodSecurityPolicyConfig {
  /**
   * Enable the PodSecurityPolicy controller for this cluster. If enabled, pods
   * must be valid under a PodSecurityPolicy to be created.
   */
  enabled: boolean;
}

/** A Google Container Engine cluster. */
export interface Cluster {
  /**
   * The name of this cluster. The name must be unique within this project
   * and zone, and can be up to 40 characters with the following restrictions:
   *
   * * Lowercase letters, numbers, and hyphens only.
   * * Must start with a letter.
   * * Must end with a number or a letter.
   */
  name: string;
  /** An optional description of this cluster. */
  description: string;
  /**
   * The number of nodes to create in this cluster. You must ensure that your
   * Compute Engine <a href="/compute/docs/resource-quotas">resource quota</a>
   * is sufficient for this number of instances. You must also have available
   * firewall and routes quota.
   * For requests, this field should only be used in lieu of a
   * "node_pool" object, since this configuration (along with the
   * "node_config") will be used to create a "NodePool" object with an
   * auto-generated name. Do not use this and a node_pool at the same time.
   */
  initialNodeCount: number;
  /**
   * Parameters used in creating the cluster's nodes.
   * See `nodeConfig` for the description of its properties.
   * For requests, this field should only be used in lieu of a
   * "node_pool" object, since this configuration (along with the
   * "initial_node_count") will be used to create a "NodePool" object with an
   * auto-generated name. Do not use this and a node_pool at the same time.
   * For responses, this field will be populated with the node configuration of
   * the first node pool.
   *
   * If unspecified, the defaults are used.
   */
  nodeConfig:
    | NodeConfig
    | undefined;
  /** The authentication information for accessing the master endpoint. */
  masterAuth:
    | MasterAuth
    | undefined;
  /**
   * The logging service the cluster should use to write logs.
   * Currently available options:
   *
   * * `logging.googleapis.com` - the Google Cloud Logging service.
   * * `none` - no logs will be exported from the cluster.
   * * if left as an empty string,`logging.googleapis.com` will be used.
   */
  loggingService: string;
  /**
   * The monitoring service the cluster should use to write metrics.
   * Currently available options:
   *
   * * `monitoring.googleapis.com` - the Google Cloud Monitoring service.
   * * `none` - no metrics will be exported from the cluster.
   * * if left as an empty string, `monitoring.googleapis.com` will be used.
   */
  monitoringService: string;
  /**
   * The name of the Google Compute Engine
   * [network](/compute/docs/networks-and-firewalls#networks) to which the
   * cluster is connected. If left unspecified, the `default` network
   * will be used.
   */
  network: string;
  /**
   * The IP address range of the container pods in this cluster, in
   * [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
   * notation (e.g. `10.96.0.0/14`). Leave blank to have
   * one automatically chosen or specify a `/14` block in `10.0.0.0/8`.
   */
  clusterIpv4Cidr: string;
  /** Configurations for the various addons available to run in the cluster. */
  addonsConfig:
    | AddonsConfig
    | undefined;
  /**
   * The name of the Google Compute Engine
   * [subnetwork](/compute/docs/subnetworks) to which the
   * cluster is connected.
   */
  subnetwork: string;
  /**
   * The node pools associated with this cluster.
   * This field should not be set if "node_config" or "initial_node_count" are
   * specified.
   */
  nodePools: NodePool[];
  /**
   * The list of Google Compute Engine
   * [locations](/compute/docs/zones#available) in which the cluster's nodes
   * should be located.
   */
  locations: string[];
  /**
   * Kubernetes alpha features are enabled on this cluster. This includes alpha
   * API groups (e.g. v1alpha1) and features that may not be production ready in
   * the kubernetes version of the master and nodes.
   * The cluster has no SLA for uptime and master/node upgrades are disabled.
   * Alpha enabled clusters are automatically deleted thirty days after
   * creation.
   */
  enableKubernetesAlpha: boolean;
  /** Configuration options for the NetworkPolicy feature. */
  networkPolicy:
    | NetworkPolicy
    | undefined;
  /** Configuration for cluster IP allocation. */
  ipAllocationPolicy:
    | IPAllocationPolicy
    | undefined;
  /** The configuration options for master authorized networks feature. */
  masterAuthorizedNetworksConfig:
    | MasterAuthorizedNetworksConfig
    | undefined;
  /** Configure the maintenance policy for this cluster. */
  maintenancePolicy:
    | MaintenancePolicy
    | undefined;
  /** Configuration for the PodSecurityPolicy feature. */
  podSecurityPolicyConfig:
    | PodSecurityPolicyConfig
    | undefined;
  /** [Output only] Server-defined URL for the resource. */
  selfLink: string;
  /**
   * [Output only] The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use location instead.
   */
  zone: string;
  /**
   * [Output only] The IP address of this cluster's master endpoint.
   * The endpoint can be accessed from the internet at
   * `https://username:password@endpoint/`.
   *
   * See the `masterAuth` property of this resource for username and
   * password information.
   */
  endpoint: string;
  /**
   * The initial Kubernetes version for this cluster.  Valid versions are those
   * found in validMasterVersions returned by getServerConfig.  The version can
   * be upgraded over time; such upgrades are reflected in
   * currentMasterVersion and currentNodeVersion.
   */
  initialClusterVersion: string;
  /** [Output only] The current software version of the master endpoint. */
  currentMasterVersion: string;
  /**
   * [Output only] The current version of the node software components.
   * If they are currently at multiple versions because they're in the process
   * of being upgraded, this reflects the minimum version of all nodes.
   */
  currentNodeVersion: string;
  /**
   * [Output only] The time the cluster was created, in
   * [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
   */
  createTime: string;
  /** [Output only] The current status of this cluster. */
  status: Cluster_Status;
  /**
   * [Output only] Additional information about the current status of this
   * cluster, if available.
   */
  statusMessage: string;
  /**
   * [Output only] The size of the address space on each node for hosting
   * containers. This is provisioned from within the `container_ipv4_cidr`
   * range.
   */
  nodeIpv4CidrSize: number;
  /**
   * [Output only] The IP address range of the Kubernetes services in
   * this cluster, in
   * [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
   * notation (e.g. `1.2.3.4/29`). Service addresses are
   * typically put in the last `/16` from the container CIDR.
   */
  servicesIpv4Cidr: string;
  /**
   * [Output only] The resource URLs of [instance
   * groups](/compute/docs/instance-groups/) associated with this
   * cluster.
   */
  instanceGroupUrls: string[];
  /** [Output only] The number of nodes currently in the cluster. */
  currentNodeCount: number;
  /**
   * [Output only] The time the cluster will be automatically
   * deleted in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
   */
  expireTime: string;
  /**
   * [Output only] The name of the Google Compute Engine
   * [zone](/compute/docs/regions-zones/regions-zones#available) or
   * [region](/compute/docs/regions-zones/regions-zones#available) in which
   * the cluster resides.
   */
  location: string;
}

/** The current status of the cluster. */
export enum Cluster_Status {
  /** STATUS_UNSPECIFIED - Not set. */
  STATUS_UNSPECIFIED = 0,
  /** PROVISIONING - The PROVISIONING state indicates the cluster is being created. */
  PROVISIONING = 1,
  /**
   * RUNNING - The RUNNING state indicates the cluster has been created and is fully
   * usable.
   */
  RUNNING = 2,
  /**
   * RECONCILING - The RECONCILING state indicates that some work is actively being done on
   * the cluster, such as upgrading the master or node software. Details can
   * be found in the `statusMessage` field.
   */
  RECONCILING = 3,
  /** STOPPING - The STOPPING state indicates the cluster is being deleted. */
  STOPPING = 4,
  /**
   * ERROR - The ERROR state indicates the cluster may be unusable. Details
   * can be found in the `statusMessage` field.
   */
  ERROR = 5,
  UNRECOGNIZED = -1,
}

export function cluster_StatusFromJSON(object: any): Cluster_Status {
  switch (object) {
    case 0:
    case "STATUS_UNSPECIFIED":
      return Cluster_Status.STATUS_UNSPECIFIED;
    case 1:
    case "PROVISIONING":
      return Cluster_Status.PROVISIONING;
    case 2:
    case "RUNNING":
      return Cluster_Status.RUNNING;
    case 3:
    case "RECONCILING":
      return Cluster_Status.RECONCILING;
    case 4:
    case "STOPPING":
      return Cluster_Status.STOPPING;
    case 5:
    case "ERROR":
      return Cluster_Status.ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Cluster_Status.UNRECOGNIZED;
  }
}

export function cluster_StatusToJSON(object: Cluster_Status): string {
  switch (object) {
    case Cluster_Status.STATUS_UNSPECIFIED:
      return "STATUS_UNSPECIFIED";
    case Cluster_Status.PROVISIONING:
      return "PROVISIONING";
    case Cluster_Status.RUNNING:
      return "RUNNING";
    case Cluster_Status.RECONCILING:
      return "RECONCILING";
    case Cluster_Status.STOPPING:
      return "STOPPING";
    case Cluster_Status.ERROR:
      return "ERROR";
    case Cluster_Status.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * ClusterUpdate describes an update to the cluster. Exactly one update can
 * be applied to a cluster with each request, so at most one field can be
 * provided.
 */
export interface ClusterUpdate {
  /**
   * The Kubernetes version to change the nodes to (typically an
   * upgrade). Use `-` to upgrade to the latest version supported by
   * the server.
   */
  desiredNodeVersion: string;
  /**
   * The monitoring service the cluster should use to write metrics.
   * Currently available options:
   *
   * * "monitoring.googleapis.com" - the Google Cloud Monitoring service
   * * "none" - no metrics will be exported from the cluster
   */
  desiredMonitoringService: string;
  /** Configurations for the various addons available to run in the cluster. */
  desiredAddonsConfig:
    | AddonsConfig
    | undefined;
  /**
   * The node pool to be upgraded. This field is mandatory if
   * "desired_node_version", "desired_image_family" or
   * "desired_node_pool_autoscaling" is specified and there is more than one
   * node pool on the cluster.
   */
  desiredNodePoolId: string;
  /**
   * The desired image type for the node pool.
   * NOTE: Set the "desired_node_pool" field as well.
   */
  desiredImageType: string;
  /**
   * Autoscaler configuration for the node pool specified in
   * desired_node_pool_id. If there is only one pool in the
   * cluster and desired_node_pool_id is not provided then
   * the change applies to that single node pool.
   */
  desiredNodePoolAutoscaling:
    | NodePoolAutoscaling
    | undefined;
  /**
   * The desired list of Google Compute Engine
   * [locations](/compute/docs/zones#available) in which the cluster's nodes
   * should be located. Changing the locations a cluster is in will result
   * in nodes being either created or removed from the cluster, depending on
   * whether locations are being added or removed.
   *
   * This list must always include the cluster's primary zone.
   */
  desiredLocations: string[];
  /** The desired configuration options for master authorized networks feature. */
  desiredMasterAuthorizedNetworksConfig:
    | MasterAuthorizedNetworksConfig
    | undefined;
  /** The desired configuration options for the PodSecurityPolicy feature. */
  desiredPodSecurityPolicyConfig:
    | PodSecurityPolicyConfig
    | undefined;
  /**
   * The Kubernetes version to change the master to. The only valid value is the
   * latest supported version. Use "-" to have the server automatically select
   * the latest version.
   */
  desiredMasterVersion: string;
}

/**
 * This operation resource represents operations that may have happened or are
 * happening on the cluster. All fields are output only.
 */
export interface Operation {
  /** The server-assigned ID for the operation. */
  name: string;
  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the operation
   * is taking place.
   * This field is deprecated, use location instead.
   */
  zone: string;
  /** The operation type. */
  operationType: Operation_Type;
  /** The current status of the operation. */
  status: Operation_Status;
  /** Detailed operation progress, if available. */
  detail: string;
  /** If an error has occurred, a textual description of the error. */
  statusMessage: string;
  /** Server-defined URL for the resource. */
  selfLink: string;
  /** Server-defined URL for the target of the operation. */
  targetLink: string;
  /**
   * [Output only] The name of the Google Compute Engine
   * [zone](/compute/docs/regions-zones/regions-zones#available) or
   * [region](/compute/docs/regions-zones/regions-zones#available) in which
   * the cluster resides.
   */
  location: string;
  /**
   * [Output only] The time the operation started, in
   * [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
   */
  startTime: string;
  /**
   * [Output only] The time the operation completed, in
   * [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
   */
  endTime: string;
}

/** Current status of the operation. */
export enum Operation_Status {
  /** STATUS_UNSPECIFIED - Not set. */
  STATUS_UNSPECIFIED = 0,
  /** PENDING - The operation has been created. */
  PENDING = 1,
  /** RUNNING - The operation is currently running. */
  RUNNING = 2,
  /** DONE - The operation is done, either cancelled or completed. */
  DONE = 3,
  /** ABORTING - The operation is aborting. */
  ABORTING = 4,
  UNRECOGNIZED = -1,
}

export function operation_StatusFromJSON(object: any): Operation_Status {
  switch (object) {
    case 0:
    case "STATUS_UNSPECIFIED":
      return Operation_Status.STATUS_UNSPECIFIED;
    case 1:
    case "PENDING":
      return Operation_Status.PENDING;
    case 2:
    case "RUNNING":
      return Operation_Status.RUNNING;
    case 3:
    case "DONE":
      return Operation_Status.DONE;
    case 4:
    case "ABORTING":
      return Operation_Status.ABORTING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Operation_Status.UNRECOGNIZED;
  }
}

export function operation_StatusToJSON(object: Operation_Status): string {
  switch (object) {
    case Operation_Status.STATUS_UNSPECIFIED:
      return "STATUS_UNSPECIFIED";
    case Operation_Status.PENDING:
      return "PENDING";
    case Operation_Status.RUNNING:
      return "RUNNING";
    case Operation_Status.DONE:
      return "DONE";
    case Operation_Status.ABORTING:
      return "ABORTING";
    case Operation_Status.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Operation type. */
export enum Operation_Type {
  /** TYPE_UNSPECIFIED - Not set. */
  TYPE_UNSPECIFIED = 0,
  /** CREATE_CLUSTER - Cluster create. */
  CREATE_CLUSTER = 1,
  /** DELETE_CLUSTER - Cluster delete. */
  DELETE_CLUSTER = 2,
  /** UPGRADE_MASTER - A master upgrade. */
  UPGRADE_MASTER = 3,
  /** UPGRADE_NODES - A node upgrade. */
  UPGRADE_NODES = 4,
  /** REPAIR_CLUSTER - Cluster repair. */
  REPAIR_CLUSTER = 5,
  /** UPDATE_CLUSTER - Cluster update. */
  UPDATE_CLUSTER = 6,
  /** CREATE_NODE_POOL - Node pool create. */
  CREATE_NODE_POOL = 7,
  /** DELETE_NODE_POOL - Node pool delete. */
  DELETE_NODE_POOL = 8,
  /** SET_NODE_POOL_MANAGEMENT - Set node pool management. */
  SET_NODE_POOL_MANAGEMENT = 9,
  /** AUTO_REPAIR_NODES - Automatic node pool repair. */
  AUTO_REPAIR_NODES = 10,
  /** AUTO_UPGRADE_NODES - Automatic node upgrade. */
  AUTO_UPGRADE_NODES = 11,
  /** SET_LABELS - Set labels. */
  SET_LABELS = 12,
  /** SET_MASTER_AUTH - Set/generate master auth materials */
  SET_MASTER_AUTH = 13,
  /** SET_NODE_POOL_SIZE - Set node pool size. */
  SET_NODE_POOL_SIZE = 14,
  /** SET_NETWORK_POLICY - Updates network policy for a cluster. */
  SET_NETWORK_POLICY = 15,
  /** SET_MAINTENANCE_POLICY - Set the maintenance policy. */
  SET_MAINTENANCE_POLICY = 16,
  UNRECOGNIZED = -1,
}

export function operation_TypeFromJSON(object: any): Operation_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return Operation_Type.TYPE_UNSPECIFIED;
    case 1:
    case "CREATE_CLUSTER":
      return Operation_Type.CREATE_CLUSTER;
    case 2:
    case "DELETE_CLUSTER":
      return Operation_Type.DELETE_CLUSTER;
    case 3:
    case "UPGRADE_MASTER":
      return Operation_Type.UPGRADE_MASTER;
    case 4:
    case "UPGRADE_NODES":
      return Operation_Type.UPGRADE_NODES;
    case 5:
    case "REPAIR_CLUSTER":
      return Operation_Type.REPAIR_CLUSTER;
    case 6:
    case "UPDATE_CLUSTER":
      return Operation_Type.UPDATE_CLUSTER;
    case 7:
    case "CREATE_NODE_POOL":
      return Operation_Type.CREATE_NODE_POOL;
    case 8:
    case "DELETE_NODE_POOL":
      return Operation_Type.DELETE_NODE_POOL;
    case 9:
    case "SET_NODE_POOL_MANAGEMENT":
      return Operation_Type.SET_NODE_POOL_MANAGEMENT;
    case 10:
    case "AUTO_REPAIR_NODES":
      return Operation_Type.AUTO_REPAIR_NODES;
    case 11:
    case "AUTO_UPGRADE_NODES":
      return Operation_Type.AUTO_UPGRADE_NODES;
    case 12:
    case "SET_LABELS":
      return Operation_Type.SET_LABELS;
    case 13:
    case "SET_MASTER_AUTH":
      return Operation_Type.SET_MASTER_AUTH;
    case 14:
    case "SET_NODE_POOL_SIZE":
      return Operation_Type.SET_NODE_POOL_SIZE;
    case 15:
    case "SET_NETWORK_POLICY":
      return Operation_Type.SET_NETWORK_POLICY;
    case 16:
    case "SET_MAINTENANCE_POLICY":
      return Operation_Type.SET_MAINTENANCE_POLICY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Operation_Type.UNRECOGNIZED;
  }
}

export function operation_TypeToJSON(object: Operation_Type): string {
  switch (object) {
    case Operation_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case Operation_Type.CREATE_CLUSTER:
      return "CREATE_CLUSTER";
    case Operation_Type.DELETE_CLUSTER:
      return "DELETE_CLUSTER";
    case Operation_Type.UPGRADE_MASTER:
      return "UPGRADE_MASTER";
    case Operation_Type.UPGRADE_NODES:
      return "UPGRADE_NODES";
    case Operation_Type.REPAIR_CLUSTER:
      return "REPAIR_CLUSTER";
    case Operation_Type.UPDATE_CLUSTER:
      return "UPDATE_CLUSTER";
    case Operation_Type.CREATE_NODE_POOL:
      return "CREATE_NODE_POOL";
    case Operation_Type.DELETE_NODE_POOL:
      return "DELETE_NODE_POOL";
    case Operation_Type.SET_NODE_POOL_MANAGEMENT:
      return "SET_NODE_POOL_MANAGEMENT";
    case Operation_Type.AUTO_REPAIR_NODES:
      return "AUTO_REPAIR_NODES";
    case Operation_Type.AUTO_UPGRADE_NODES:
      return "AUTO_UPGRADE_NODES";
    case Operation_Type.SET_LABELS:
      return "SET_LABELS";
    case Operation_Type.SET_MASTER_AUTH:
      return "SET_MASTER_AUTH";
    case Operation_Type.SET_NODE_POOL_SIZE:
      return "SET_NODE_POOL_SIZE";
    case Operation_Type.SET_NETWORK_POLICY:
      return "SET_NETWORK_POLICY";
    case Operation_Type.SET_MAINTENANCE_POLICY:
      return "SET_MAINTENANCE_POLICY";
    case Operation_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** CreateClusterRequest creates a cluster. */
export interface CreateClusterRequest {
  /**
   * The Google Developers Console [project ID or project
   * number](https://support.google.com/cloud/answer/6158840).
   * This field is deprecated, use parent instead.
   */
  projectId: string;
  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use parent instead.
   */
  zone: string;
  /**
   * A [cluster
   * resource](/container-engine/reference/rest/v1alpha1/projects.zones.clusters)
   */
  cluster:
    | Cluster
    | undefined;
  /**
   * The parent (project and location) where the cluster will be created.
   * Specified in the format 'projects/* /locations/*'.
   */
  parent: string;
}

/** GetClusterRequest gets the settings of a cluster. */
export interface GetClusterRequest {
  /**
   * The Google Developers Console [project ID or project
   * number](https://support.google.com/cloud/answer/6158840).
   * This field is deprecated, use name instead.
   */
  projectId: string;
  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use name instead.
   */
  zone: string;
  /**
   * The name of the cluster to retrieve.
   * This field is deprecated, use name instead.
   */
  clusterId: string;
  /**
   * The name (project, location, cluster) of the cluster to retrieve.
   * Specified in the format 'projects/* /locations/* /clusters/*'.
   */
  name: string;
}

/** UpdateClusterRequest updates the settings of a cluster. */
export interface UpdateClusterRequest {
  /**
   * The Google Developers Console [project ID or project
   * number](https://support.google.com/cloud/answer/6158840).
   * This field is deprecated, use name instead.
   */
  projectId: string;
  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use name instead.
   */
  zone: string;
  /**
   * The name of the cluster to upgrade.
   * This field is deprecated, use name instead.
   */
  clusterId: string;
  /** A description of the update. */
  update:
    | ClusterUpdate
    | undefined;
  /**
   * The name (project, location, cluster) of the cluster to update.
   * Specified in the format 'projects/* /locations/* /clusters/*'.
   */
  name: string;
}

/** SetNodePoolVersionRequest updates the version of a node pool. */
export interface UpdateNodePoolRequest {
  /**
   * The Google Developers Console [project ID or project
   * number](https://support.google.com/cloud/answer/6158840).
   * This field is deprecated, use name instead.
   */
  projectId: string;
  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use name instead.
   */
  zone: string;
  /**
   * The name of the cluster to upgrade.
   * This field is deprecated, use name instead.
   */
  clusterId: string;
  /**
   * The name of the node pool to upgrade.
   * This field is deprecated, use name instead.
   */
  nodePoolId: string;
  /**
   * The Kubernetes version to change the nodes to (typically an
   * upgrade). Use `-` to upgrade to the latest version supported by
   * the server.
   */
  nodeVersion: string;
  /** The desired image type for the node pool. */
  imageType: string;
  /**
   * The name (project, location, cluster, node pool) of the node pool to update.
   * Specified in the format 'projects/* /locations/* /clusters/* /nodePools/*'.
   */
  name: string;
}

/** SetNodePoolAutoscalingRequest sets the autoscaler settings of a node pool. */
export interface SetNodePoolAutoscalingRequest {
  /**
   * The Google Developers Console [project ID or project
   * number](https://support.google.com/cloud/answer/6158840).
   * This field is deprecated, use name instead.
   */
  projectId: string;
  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use name instead.
   */
  zone: string;
  /**
   * The name of the cluster to upgrade.
   * This field is deprecated, use name instead.
   */
  clusterId: string;
  /**
   * The name of the node pool to upgrade.
   * This field is deprecated, use name instead.
   */
  nodePoolId: string;
  /** Autoscaling configuration for the node pool. */
  autoscaling:
    | NodePoolAutoscaling
    | undefined;
  /**
   * The name (project, location, cluster, node pool) of the node pool to set
   * autoscaler settings. Specified in the format
   * 'projects/* /locations/* /clusters/* /nodePools/*'.
   */
  name: string;
}

/** SetLoggingServiceRequest sets the logging service of a cluster. */
export interface SetLoggingServiceRequest {
  /**
   * The Google Developers Console [project ID or project
   * number](https://support.google.com/cloud/answer/6158840).
   * This field is deprecated, use name instead.
   */
  projectId: string;
  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   */
  zone: string;
  /**
   * The name of the cluster to upgrade.
   * This field is deprecated, use name instead.
   */
  clusterId: string;
  /**
   * The logging service the cluster should use to write metrics.
   * Currently available options:
   *
   * * "logging.googleapis.com" - the Google Cloud Logging service
   * * "none" - no metrics will be exported from the cluster
   */
  loggingService: string;
  /**
   * The name (project, location, cluster) of the cluster to set logging.
   * Specified in the format 'projects/* /locations/* /clusters/*'.
   */
  name: string;
}

/** SetMonitoringServiceRequest sets the monitoring service of a cluster. */
export interface SetMonitoringServiceRequest {
  /**
   * The Google Developers Console [project ID or project
   * number](https://support.google.com/cloud/answer/6158840).
   * This field is deprecated, use name instead.
   */
  projectId: string;
  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use name instead.
   */
  zone: string;
  /**
   * The name of the cluster to upgrade.
   * This field is deprecated, use name instead.
   */
  clusterId: string;
  /**
   * The monitoring service the cluster should use to write metrics.
   * Currently available options:
   *
   * * "monitoring.googleapis.com" - the Google Cloud Monitoring service
   * * "none" - no metrics will be exported from the cluster
   */
  monitoringService: string;
  /**
   * The name (project, location, cluster) of the cluster to set monitoring.
   * Specified in the format 'projects/* /locations/* /clusters/*'.
   */
  name: string;
}

/** SetAddonsRequest sets the addons associated with the cluster. */
export interface SetAddonsConfigRequest {
  /**
   * The Google Developers Console [project ID or project
   * number](https://support.google.com/cloud/answer/6158840).
   * This field is deprecated, use name instead.
   */
  projectId: string;
  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use name instead.
   */
  zone: string;
  /**
   * The name of the cluster to upgrade.
   * This field is deprecated, use name instead.
   */
  clusterId: string;
  /**
   * The desired configurations for the various addons available to run in the
   * cluster.
   */
  addonsConfig:
    | AddonsConfig
    | undefined;
  /**
   * The name (project, location, cluster) of the cluster to set addons.
   * Specified in the format 'projects/* /locations/* /clusters/*'.
   */
  name: string;
}

/** SetLocationsRequest sets the locations of the cluster. */
export interface SetLocationsRequest {
  /**
   * The Google Developers Console [project ID or project
   * number](https://support.google.com/cloud/answer/6158840).
   * This field is deprecated, use name instead.
   */
  projectId: string;
  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use name instead.
   */
  zone: string;
  /**
   * The name of the cluster to upgrade.
   * This field is deprecated, use name instead.
   */
  clusterId: string;
  /**
   * The desired list of Google Compute Engine
   * [locations](/compute/docs/zones#available) in which the cluster's nodes
   * should be located. Changing the locations a cluster is in will result
   * in nodes being either created or removed from the cluster, depending on
   * whether locations are being added or removed.
   *
   * This list must always include the cluster's primary zone.
   */
  locations: string[];
  /**
   * The name (project, location, cluster) of the cluster to set locations.
   * Specified in the format 'projects/* /locations/* /clusters/*'.
   */
  name: string;
}

/** UpdateMasterRequest updates the master of the cluster. */
export interface UpdateMasterRequest {
  /**
   * The Google Developers Console [project ID or project
   * number](https://support.google.com/cloud/answer/6158840).
   */
  projectId: string;
  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use name instead.
   */
  zone: string;
  /**
   * The name of the cluster to upgrade.
   * This field is deprecated, use name instead.
   */
  clusterId: string;
  /**
   * The Kubernetes version to change the master to. The only valid value is the
   * latest supported version. Use "-" to have the server automatically select
   * the latest version.
   */
  masterVersion: string;
  /**
   * The name (project, location, cluster) of the cluster to update.
   * Specified in the format 'projects/* /locations/* /clusters/*'.
   */
  name: string;
}

/** SetMasterAuthRequest updates the admin password of a cluster. */
export interface SetMasterAuthRequest {
  /**
   * The Google Developers Console [project ID or project
   * number](https://support.google.com/cloud/answer/6158840).
   * This field is deprecated, use name instead.
   */
  projectId: string;
  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use name instead.
   */
  zone: string;
  /**
   * The name of the cluster to upgrade.
   * This field is deprecated, use name instead.
   */
  clusterId: string;
  /** The exact form of action to be taken on the master auth. */
  action: SetMasterAuthRequest_Action;
  /** A description of the update. */
  update:
    | MasterAuth
    | undefined;
  /**
   * The name (project, location, cluster) of the cluster to set auth.
   * Specified in the format 'projects/* /locations/* /clusters/*'.
   */
  name: string;
}

/** Operation type: what type update to perform. */
export enum SetMasterAuthRequest_Action {
  /** UNKNOWN - Operation is unknown and will error out. */
  UNKNOWN = 0,
  /** SET_PASSWORD - Set the password to a user generated value. */
  SET_PASSWORD = 1,
  /** GENERATE_PASSWORD - Generate a new password and set it to that. */
  GENERATE_PASSWORD = 2,
  /**
   * SET_USERNAME - Set the username.  If an empty username is provided, basic authentication
   * is disabled for the cluster.  If a non-empty username is provided, basic
   * authentication is enabled, with either a provided password or a generated
   * one.
   */
  SET_USERNAME = 3,
  UNRECOGNIZED = -1,
}

export function setMasterAuthRequest_ActionFromJSON(object: any): SetMasterAuthRequest_Action {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return SetMasterAuthRequest_Action.UNKNOWN;
    case 1:
    case "SET_PASSWORD":
      return SetMasterAuthRequest_Action.SET_PASSWORD;
    case 2:
    case "GENERATE_PASSWORD":
      return SetMasterAuthRequest_Action.GENERATE_PASSWORD;
    case 3:
    case "SET_USERNAME":
      return SetMasterAuthRequest_Action.SET_USERNAME;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SetMasterAuthRequest_Action.UNRECOGNIZED;
  }
}

export function setMasterAuthRequest_ActionToJSON(object: SetMasterAuthRequest_Action): string {
  switch (object) {
    case SetMasterAuthRequest_Action.UNKNOWN:
      return "UNKNOWN";
    case SetMasterAuthRequest_Action.SET_PASSWORD:
      return "SET_PASSWORD";
    case SetMasterAuthRequest_Action.GENERATE_PASSWORD:
      return "GENERATE_PASSWORD";
    case SetMasterAuthRequest_Action.SET_USERNAME:
      return "SET_USERNAME";
    case SetMasterAuthRequest_Action.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** DeleteClusterRequest deletes a cluster. */
export interface DeleteClusterRequest {
  /**
   * The Google Developers Console [project ID or project
   * number](https://support.google.com/cloud/answer/6158840).
   * This field is deprecated, use name instead.
   */
  projectId: string;
  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use name instead.
   */
  zone: string;
  /**
   * The name of the cluster to delete.
   * This field is deprecated, use name instead.
   */
  clusterId: string;
  /**
   * The name (project, location, cluster) of the cluster to delete.
   * Specified in the format 'projects/* /locations/* /clusters/*'.
   */
  name: string;
}

/** ListClustersRequest lists clusters. */
export interface ListClustersRequest {
  /**
   * The Google Developers Console [project ID or project
   * number](https://support.google.com/cloud/answer/6158840).
   * This field is deprecated, use parent instead.
   */
  projectId: string;
  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides, or "-" for all zones.
   * This field is deprecated, use parent instead.
   */
  zone: string;
  /**
   * The parent (project and location) where the clusters will be listed.
   * Specified in the format 'projects/* /locations/*'.
   * Location "-" matches all zones and all regions.
   */
  parent: string;
}

/** ListClustersResponse is the result of ListClustersRequest. */
export interface ListClustersResponse {
  /**
   * A list of clusters in the project in the specified zone, or
   * across all ones.
   */
  clusters: Cluster[];
  /**
   * If any zones are listed here, the list of clusters returned
   * may be missing those zones.
   */
  missingZones: string[];
}

/** GetOperationRequest gets a single operation. */
export interface GetOperationRequest {
  /**
   * The Google Developers Console [project ID or project
   * number](https://support.google.com/cloud/answer/6158840).
   * This field is deprecated, use name instead.
   */
  projectId: string;
  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use name instead.
   */
  zone: string;
  /**
   * The server-assigned `name` of the operation.
   * This field is deprecated, use name instead.
   */
  operationId: string;
  /**
   * The name (project, location, operation id) of the operation to get.
   * Specified in the format 'projects/* /locations/* /operations/*'.
   */
  name: string;
}

/** ListOperationsRequest lists operations. */
export interface ListOperationsRequest {
  /**
   * The Google Developers Console [project ID or project
   * number](https://support.google.com/cloud/answer/6158840).
   * This field is deprecated, use parent instead.
   */
  projectId: string;
  /**
   * The name of the Google Compute Engine [zone](/compute/docs/zones#available)
   * to return operations for, or `-` for all zones.
   * This field is deprecated, use parent instead.
   */
  zone: string;
  /**
   * The parent (project and location) where the operations will be listed.
   * Specified in the format 'projects/* /locations/*'.
   * Location "-" matches all zones and all regions.
   */
  parent: string;
}

/** CancelOperationRequest cancels a single operation. */
export interface CancelOperationRequest {
  /**
   * The Google Developers Console [project ID or project
   * number](https://support.google.com/cloud/answer/6158840).
   * This field is deprecated, use name instead.
   */
  projectId: string;
  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the operation resides.
   * This field is deprecated, use name instead.
   */
  zone: string;
  /**
   * The server-assigned `name` of the operation.
   * This field is deprecated, use name instead.
   */
  operationId: string;
  /**
   * The name (project, location, operation id) of the operation to cancel.
   * Specified in the format 'projects/* /locations/* /operations/*'.
   */
  name: string;
}

/** ListOperationsResponse is the result of ListOperationsRequest. */
export interface ListOperationsResponse {
  /** A list of operations in the project in the specified zone. */
  operations: Operation[];
  /**
   * If any zones are listed here, the list of operations returned
   * may be missing the operations from those zones.
   */
  missingZones: string[];
}

/** Gets the current Container Engine service configuration. */
export interface GetServerConfigRequest {
  /**
   * The Google Developers Console [project ID or project
   * number](https://support.google.com/cloud/answer/6158840).
   * This field is deprecated, use name instead.
   */
  projectId: string;
  /**
   * The name of the Google Compute Engine [zone](/compute/docs/zones#available)
   * to return operations for.
   * This field is deprecated, use name instead.
   */
  zone: string;
  /**
   * The name (project and location) of the server config to get
   * Specified in the format 'projects/* /locations/*'.
   */
  name: string;
}

/** Container Engine service configuration. */
export interface ServerConfig {
  /** Version of Kubernetes the service deploys by default. */
  defaultClusterVersion: string;
  /** List of valid node upgrade target versions. */
  validNodeVersions: string[];
  /** Default image type. */
  defaultImageType: string;
  /** List of valid image types. */
  validImageTypes: string[];
  /** List of valid master versions. */
  validMasterVersions: string[];
}

/** CreateNodePoolRequest creates a node pool for a cluster. */
export interface CreateNodePoolRequest {
  /**
   * The Google Developers Console [project ID or project
   * number](https://developers.google.com/console/help/new/#projectnumber).
   * This field is deprecated, use parent instead.
   */
  projectId: string;
  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use parent instead.
   */
  zone: string;
  /**
   * The name of the cluster.
   * This field is deprecated, use parent instead.
   */
  clusterId: string;
  /** The node pool to create. */
  nodePool:
    | NodePool
    | undefined;
  /**
   * The parent (project, location, cluster id) where the node pool will be created.
   * Specified in the format 'projects/* /locations/* /clusters/* /nodePools/*'.
   */
  parent: string;
}

/** DeleteNodePoolRequest deletes a node pool for a cluster. */
export interface DeleteNodePoolRequest {
  /**
   * The Google Developers Console [project ID or project
   * number](https://developers.google.com/console/help/new/#projectnumber).
   * This field is deprecated, use name instead.
   */
  projectId: string;
  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use name instead.
   */
  zone: string;
  /**
   * The name of the cluster.
   * This field is deprecated, use name instead.
   */
  clusterId: string;
  /**
   * The name of the node pool to delete.
   * This field is deprecated, use name instead.
   */
  nodePoolId: string;
  /**
   * The name (project, location, cluster, node pool id) of the node pool to delete.
   * Specified in the format 'projects/* /locations/* /clusters/* /nodePools/*'.
   */
  name: string;
}

/** ListNodePoolsRequest lists the node pool(s) for a cluster. */
export interface ListNodePoolsRequest {
  /**
   * The Google Developers Console [project ID or project
   * number](https://developers.google.com/console/help/new/#projectnumber).
   * This field is deprecated, use parent instead.
   */
  projectId: string;
  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use parent instead.
   */
  zone: string;
  /**
   * The name of the cluster.
   * This field is deprecated, use parent instead.
   */
  clusterId: string;
  /**
   * The parent (project, location, cluster id) where the node pools will be listed.
   * Specified in the format 'projects/* /locations/* /clusters/*'.
   */
  parent: string;
}

/** GetNodePoolRequest retrieves a node pool for a cluster. */
export interface GetNodePoolRequest {
  /**
   * The Google Developers Console [project ID or project
   * number](https://developers.google.com/console/help/new/#projectnumber).
   * This field is deprecated, use name instead.
   */
  projectId: string;
  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use name instead.
   */
  zone: string;
  /**
   * The name of the cluster.
   * This field is deprecated, use name instead.
   */
  clusterId: string;
  /**
   * The name of the node pool.
   * This field is deprecated, use name instead.
   */
  nodePoolId: string;
  /**
   * The name (project, location, cluster, node pool id) of the node pool to get.
   * Specified in the format 'projects/* /locations/* /clusters/* /nodePools/*'.
   */
  name: string;
}

/**
 * NodePool contains the name and configuration for a cluster's node pool.
 * Node pools are a set of nodes (i.e. VM's), with a common configuration and
 * specification, under the control of the cluster master. They may have a set
 * of Kubernetes labels applied to them, which may be used to reference them
 * during pod scheduling. They may also be resized up or down, to accommodate
 * the workload.
 */
export interface NodePool {
  /** The name of the node pool. */
  name: string;
  /** The node configuration of the pool. */
  config:
    | NodeConfig
    | undefined;
  /**
   * The initial node count for the pool. You must ensure that your
   * Compute Engine <a href="/compute/docs/resource-quotas">resource quota</a>
   * is sufficient for this number of instances. You must also have available
   * firewall and routes quota.
   */
  initialNodeCount: number;
  /**
   * Autoscaler configuration for this NodePool. Autoscaler is enabled
   * only if a valid configuration is present.
   */
  autoscaling:
    | NodePoolAutoscaling
    | undefined;
  /** NodeManagement configuration for this NodePool. */
  management:
    | NodeManagement
    | undefined;
  /** [Output only] Server-defined URL for the resource. */
  selfLink: string;
  /** [Output only] The version of the Kubernetes of this node. */
  version: string;
  /**
   * [Output only] The resource URLs of [instance
   * groups](/compute/docs/instance-groups/) associated with this
   * node pool.
   */
  instanceGroupUrls: string[];
  /** [Output only] The status of the nodes in this pool instance. */
  status: NodePool_Status;
  /**
   * [Output only] Additional information about the current status of this
   * node pool instance, if available.
   */
  statusMessage: string;
}

/** The current status of the node pool instance. */
export enum NodePool_Status {
  /** STATUS_UNSPECIFIED - Not set. */
  STATUS_UNSPECIFIED = 0,
  /** PROVISIONING - The PROVISIONING state indicates the node pool is being created. */
  PROVISIONING = 1,
  /**
   * RUNNING - The RUNNING state indicates the node pool has been created
   * and is fully usable.
   */
  RUNNING = 2,
  /**
   * RUNNING_WITH_ERROR - The RUNNING_WITH_ERROR state indicates the node pool has been created
   * and is partially usable. Some error state has occurred and some
   * functionality may be impaired. Customer may need to reissue a request
   * or trigger a new update.
   */
  RUNNING_WITH_ERROR = 3,
  /**
   * RECONCILING - The RECONCILING state indicates that some work is actively being done on
   * the node pool, such as upgrading node software. Details can
   * be found in the `statusMessage` field.
   */
  RECONCILING = 4,
  /** STOPPING - The STOPPING state indicates the node pool is being deleted. */
  STOPPING = 5,
  /**
   * ERROR - The ERROR state indicates the node pool may be unusable. Details
   * can be found in the `statusMessage` field.
   */
  ERROR = 6,
  UNRECOGNIZED = -1,
}

export function nodePool_StatusFromJSON(object: any): NodePool_Status {
  switch (object) {
    case 0:
    case "STATUS_UNSPECIFIED":
      return NodePool_Status.STATUS_UNSPECIFIED;
    case 1:
    case "PROVISIONING":
      return NodePool_Status.PROVISIONING;
    case 2:
    case "RUNNING":
      return NodePool_Status.RUNNING;
    case 3:
    case "RUNNING_WITH_ERROR":
      return NodePool_Status.RUNNING_WITH_ERROR;
    case 4:
    case "RECONCILING":
      return NodePool_Status.RECONCILING;
    case 5:
    case "STOPPING":
      return NodePool_Status.STOPPING;
    case 6:
    case "ERROR":
      return NodePool_Status.ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NodePool_Status.UNRECOGNIZED;
  }
}

export function nodePool_StatusToJSON(object: NodePool_Status): string {
  switch (object) {
    case NodePool_Status.STATUS_UNSPECIFIED:
      return "STATUS_UNSPECIFIED";
    case NodePool_Status.PROVISIONING:
      return "PROVISIONING";
    case NodePool_Status.RUNNING:
      return "RUNNING";
    case NodePool_Status.RUNNING_WITH_ERROR:
      return "RUNNING_WITH_ERROR";
    case NodePool_Status.RECONCILING:
      return "RECONCILING";
    case NodePool_Status.STOPPING:
      return "STOPPING";
    case NodePool_Status.ERROR:
      return "ERROR";
    case NodePool_Status.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * NodeManagement defines the set of node management services turned on for the
 * node pool.
 */
export interface NodeManagement {
  /** Whether the nodes will be automatically upgraded. */
  autoUpgrade: boolean;
  /** Whether the nodes will be automatically repaired. */
  autoRepair: boolean;
  /** Specifies the Auto Upgrade knobs for the node pool. */
  upgradeOptions: AutoUpgradeOptions | undefined;
}

/**
 * AutoUpgradeOptions defines the set of options for the user to control how
 * the Auto Upgrades will proceed.
 */
export interface AutoUpgradeOptions {
  /**
   * [Output only] This field is set when upgrades are about to commence
   * with the approximate start time for the upgrades, in
   * [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
   */
  autoUpgradeStartTime: string;
  /**
   * [Output only] This field is set when upgrades are about to commence
   * with the description of the upgrade.
   */
  description: string;
}

/** MaintenancePolicy defines the maintenance policy to be used for the cluster. */
export interface MaintenancePolicy {
  /** Specifies the maintenance window in which maintenance may be performed. */
  window: MaintenanceWindow | undefined;
}

/** MaintenanceWindow defines the maintenance window to be used for the cluster. */
export interface MaintenanceWindow {
  /** DailyMaintenanceWindow specifies a daily maintenance operation window. */
  dailyMaintenanceWindow?: DailyMaintenanceWindow | undefined;
}

/** Time window specified for daily maintenance operations. */
export interface DailyMaintenanceWindow {
  /**
   * Time within the maintenance window to start the maintenance operations.
   * It must be in format "HH:MM, where HH : [00-23] and MM : [00-59] GMT.
   */
  startTime: string;
  /**
   * [Output only] Duration of the time window, automatically chosen to be
   * smallest possible in the given scenario.
   */
  duration: string;
}

/**
 * SetNodePoolManagementRequest sets the node management properties of a node
 * pool.
 */
export interface SetNodePoolManagementRequest {
  /**
   * The Google Developers Console [project ID or project
   * number](https://support.google.com/cloud/answer/6158840).
   * This field is deprecated, use name instead.
   */
  projectId: string;
  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use name instead.
   */
  zone: string;
  /**
   * The name of the cluster to update.
   * This field is deprecated, use name instead.
   */
  clusterId: string;
  /**
   * The name of the node pool to update.
   * This field is deprecated, use name instead.
   */
  nodePoolId: string;
  /** NodeManagement configuration for the node pool. */
  management:
    | NodeManagement
    | undefined;
  /**
   * The name (project, location, cluster, node pool id) of the node pool to set
   * management properties. Specified in the format
   * 'projects/* /locations/* /clusters/* /nodePools/*'.
   */
  name: string;
}

/**
 * SetNodePoolSizeRequest sets the size a node
 * pool.
 */
export interface SetNodePoolSizeRequest {
  /**
   * The Google Developers Console [project ID or project
   * number](https://support.google.com/cloud/answer/6158840).
   */
  projectId: string;
  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use name instead.
   */
  zone: string;
  /**
   * The name of the cluster to update.
   * This field is deprecated, use name instead.
   */
  clusterId: string;
  /**
   * The name of the node pool to update.
   * This field is deprecated, use name instead.
   */
  nodePoolId: string;
  /** The desired node count for the pool. */
  nodeCount: number;
  /**
   * The name (project, location, cluster, node pool id) of the node pool to set
   * size.
   * Specified in the format 'projects/* /locations/* /clusters/* /nodePools/*'.
   */
  name: string;
}

/**
 * RollbackNodePoolUpgradeRequest rollbacks the previously Aborted or Failed
 * NodePool upgrade. This will be an no-op if the last upgrade successfully
 * completed.
 */
export interface RollbackNodePoolUpgradeRequest {
  /**
   * The Google Developers Console [project ID or project
   * number](https://support.google.com/cloud/answer/6158840).
   * This field is deprecated, use name instead.
   */
  projectId: string;
  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use name instead.
   */
  zone: string;
  /**
   * The name of the cluster to rollback.
   * This field is deprecated, use name instead.
   */
  clusterId: string;
  /**
   * The name of the node pool to rollback.
   * This field is deprecated, use name instead.
   */
  nodePoolId: string;
  /**
   * The name (project, location, cluster, node pool id) of the node poll to
   * rollback upgrade.
   * Specified in the format 'projects/* /locations/* /clusters/* /nodePools/*'.
   */
  name: string;
}

/** ListNodePoolsResponse is the result of ListNodePoolsRequest. */
export interface ListNodePoolsResponse {
  /** A list of node pools for a cluster. */
  nodePools: NodePool[];
}

/**
 * NodePoolAutoscaling contains information required by cluster autoscaler to
 * adjust the size of the node pool to the current cluster usage.
 */
export interface NodePoolAutoscaling {
  /** Is autoscaling enabled for this node pool. */
  enabled: boolean;
  /**
   * Minimum number of nodes in the NodePool. Must be >= 1 and <=
   * max_node_count.
   */
  minNodeCount: number;
  /**
   * Maximum number of nodes in the NodePool. Must be >= min_node_count. There
   * has to enough quota to scale up the cluster.
   */
  maxNodeCount: number;
}

/**
 * SetLabelsRequest sets the Google Cloud Platform labels on a Google Container
 * Engine cluster, which will in turn set them for Google Compute Engine
 * resources used by that cluster
 */
export interface SetLabelsRequest {
  /**
   * The Google Developers Console [project ID or project
   * number](https://developers.google.com/console/help/new/#projectnumber).
   * This field is deprecated, use name instead.
   */
  projectId: string;
  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use name instead.
   */
  zone: string;
  /**
   * The name of the cluster.
   * This field is deprecated, use name instead.
   */
  clusterId: string;
  /** The labels to set for that cluster. */
  resourceLabels: { [key: string]: string };
  /**
   * The fingerprint of the previous set of labels for this resource,
   * used to detect conflicts. The fingerprint is initially generated by
   * Container Engine and changes after every request to modify or update
   * labels. You must always provide an up-to-date fingerprint hash when
   * updating or changing labels. Make a <code>get()</code> request to the
   * resource to get the latest fingerprint.
   */
  labelFingerprint: string;
  /**
   * The name (project, location, cluster id) of the cluster to set labels.
   * Specified in the format 'projects/* /locations/* /clusters/*'.
   */
  name: string;
}

export interface SetLabelsRequest_ResourceLabelsEntry {
  key: string;
  value: string;
}

/**
 * SetLegacyAbacRequest enables or disables the ABAC authorization mechanism for
 * a cluster.
 */
export interface SetLegacyAbacRequest {
  /**
   * The Google Developers Console [project ID or project
   * number](https://support.google.com/cloud/answer/6158840).
   * This field is deprecated, use name instead.
   */
  projectId: string;
  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use name instead.
   */
  zone: string;
  /**
   * The name of the cluster to update.
   * This field is deprecated, use name instead.
   */
  clusterId: string;
  /** Whether ABAC authorization will be enabled in the cluster. */
  enabled: boolean;
  /**
   * The name (project, location, cluster id) of the cluster to set legacy abac.
   * Specified in the format 'projects/* /locations/* /clusters/*'.
   */
  name: string;
}

/**
 * StartIPRotationRequest creates a new IP for the cluster and then performs
 * a node upgrade on each node pool to point to the new IP.
 */
export interface StartIPRotationRequest {
  /**
   * The Google Developers Console [project ID or project
   * number](https://developers.google.com/console/help/new/#projectnumber).
   * This field is deprecated, use name instead.
   */
  projectId: string;
  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use name instead.
   */
  zone: string;
  /**
   * The name of the cluster.
   * This field is deprecated, use name instead.
   */
  clusterId: string;
  /**
   * The name (project, location, cluster id) of the cluster to start IP rotation.
   * Specified in the format 'projects/* /locations/* /clusters/*'.
   */
  name: string;
}

/** CompleteIPRotationRequest moves the cluster master back into single-IP mode. */
export interface CompleteIPRotationRequest {
  /**
   * The Google Developers Console [project ID or project
   * number](https://developers.google.com/console/help/new/#projectnumber).
   * This field is deprecated, use name instead.
   */
  projectId: string;
  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use name instead.
   */
  zone: string;
  /**
   * The name of the cluster.
   * This field is deprecated, use name instead.
   */
  clusterId: string;
  /**
   * The name (project, location, cluster id) of the cluster to complete IP rotation.
   * Specified in the format 'projects/* /locations/* /clusters/*'.
   */
  name: string;
}

/** AcceleratorConfig represents a Hardware Accelerator request. */
export interface AcceleratorConfig {
  /** The number of the accelerator cards exposed to an instance. */
  acceleratorCount: Long;
  /**
   * The accelerator type resource name. List of supported accelerators
   * [here](/compute/docs/gpus/#Introduction)
   */
  acceleratorType: string;
}

/** SetNetworkPolicyRequest enables/disables network policy for a cluster. */
export interface SetNetworkPolicyRequest {
  /**
   * The Google Developers Console [project ID or project
   * number](https://developers.google.com/console/help/new/#projectnumber).
   * This field is deprecated, use name instead.
   */
  projectId: string;
  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use name instead.
   */
  zone: string;
  /**
   * The name of the cluster.
   * This field is deprecated, use name instead.
   */
  clusterId: string;
  /** Configuration options for the NetworkPolicy feature. */
  networkPolicy:
    | NetworkPolicy
    | undefined;
  /**
   * The name (project, location, cluster id) of the cluster to set networking
   * policy.
   * Specified in the format 'projects/* /locations/* /clusters/*'.
   */
  name: string;
}

/** SetMaintenancePolicyRequest sets the maintenance policy for a cluster. */
export interface SetMaintenancePolicyRequest {
  /**
   * The Google Developers Console [project ID or project
   * number](https://support.google.com/cloud/answer/6158840).
   */
  projectId: string;
  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   */
  zone: string;
  /** The name of the cluster to update. */
  clusterId: string;
  /**
   * The maintenance policy to be set for the cluster. An empty field
   * clears the existing maintenance policy.
   */
  maintenancePolicy:
    | MaintenancePolicy
    | undefined;
  /**
   * The name (project, location, cluster id) of the cluster to set maintenance
   * policy.
   * Specified in the format 'projects/* /locations/* /clusters/*'.
   */
  name: string;
}

function createBaseNodeConfig(): NodeConfig {
  return {
    machineType: "",
    diskSizeGb: 0,
    oauthScopes: [],
    serviceAccount: "",
    metadata: {},
    imageType: "",
    labels: {},
    localSsdCount: 0,
    tags: [],
    preemptible: false,
    accelerators: [],
    minCpuPlatform: "",
    taints: [],
  };
}

export const NodeConfig: MessageFns<NodeConfig> = {
  encode(message: NodeConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.machineType !== "") {
      writer.uint32(10).string(message.machineType);
    }
    if (message.diskSizeGb !== 0) {
      writer.uint32(16).int32(message.diskSizeGb);
    }
    for (const v of message.oauthScopes) {
      writer.uint32(26).string(v!);
    }
    if (message.serviceAccount !== "") {
      writer.uint32(74).string(message.serviceAccount);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      NodeConfig_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.imageType !== "") {
      writer.uint32(42).string(message.imageType);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      NodeConfig_LabelsEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    if (message.localSsdCount !== 0) {
      writer.uint32(56).int32(message.localSsdCount);
    }
    for (const v of message.tags) {
      writer.uint32(66).string(v!);
    }
    if (message.preemptible !== false) {
      writer.uint32(80).bool(message.preemptible);
    }
    for (const v of message.accelerators) {
      AcceleratorConfig.encode(v!, writer.uint32(90).fork()).join();
    }
    if (message.minCpuPlatform !== "") {
      writer.uint32(106).string(message.minCpuPlatform);
    }
    for (const v of message.taints) {
      NodeTaint.encode(v!, writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.machineType = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.diskSizeGb = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.oauthScopes.push(reader.string());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.serviceAccount = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = NodeConfig_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.imageType = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = NodeConfig_LabelsEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.labels[entry6.key] = entry6.value;
          }
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.localSsdCount = reader.int32();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.preemptible = reader.bool();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.accelerators.push(AcceleratorConfig.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.minCpuPlatform = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.taints.push(NodeTaint.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeConfig {
    return {
      machineType: isSet(object.machineType) ? globalThis.String(object.machineType) : "",
      diskSizeGb: isSet(object.diskSizeGb) ? globalThis.Number(object.diskSizeGb) : 0,
      oauthScopes: globalThis.Array.isArray(object?.oauthScopes)
        ? object.oauthScopes.map((e: any) => globalThis.String(e))
        : [],
      serviceAccount: isSet(object.serviceAccount) ? globalThis.String(object.serviceAccount) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      imageType: isSet(object.imageType) ? globalThis.String(object.imageType) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      localSsdCount: isSet(object.localSsdCount) ? globalThis.Number(object.localSsdCount) : 0,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      preemptible: isSet(object.preemptible) ? globalThis.Boolean(object.preemptible) : false,
      accelerators: globalThis.Array.isArray(object?.accelerators)
        ? object.accelerators.map((e: any) => AcceleratorConfig.fromJSON(e))
        : [],
      minCpuPlatform: isSet(object.minCpuPlatform) ? globalThis.String(object.minCpuPlatform) : "",
      taints: globalThis.Array.isArray(object?.taints)
        ? object.taints.map((e: any) => NodeTaint.fromJSON(e))
        : [],
    };
  },

  toJSON(message: NodeConfig): unknown {
    const obj: any = {};
    if (message.machineType !== "") {
      obj.machineType = message.machineType;
    }
    if (message.diskSizeGb !== 0) {
      obj.diskSizeGb = Math.round(message.diskSizeGb);
    }
    if (message.oauthScopes?.length) {
      obj.oauthScopes = message.oauthScopes;
    }
    if (message.serviceAccount !== "") {
      obj.serviceAccount = message.serviceAccount;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.imageType !== "") {
      obj.imageType = message.imageType;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.localSsdCount !== 0) {
      obj.localSsdCount = Math.round(message.localSsdCount);
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.preemptible !== false) {
      obj.preemptible = message.preemptible;
    }
    if (message.accelerators?.length) {
      obj.accelerators = message.accelerators.map((e) => AcceleratorConfig.toJSON(e));
    }
    if (message.minCpuPlatform !== "") {
      obj.minCpuPlatform = message.minCpuPlatform;
    }
    if (message.taints?.length) {
      obj.taints = message.taints.map((e) => NodeTaint.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<NodeConfig>): NodeConfig {
    return NodeConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeConfig>): NodeConfig {
    const message = createBaseNodeConfig();
    message.machineType = object.machineType ?? "";
    message.diskSizeGb = object.diskSizeGb ?? 0;
    message.oauthScopes = object.oauthScopes?.map((e) => e) || [];
    message.serviceAccount = object.serviceAccount ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.imageType = object.imageType ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.localSsdCount = object.localSsdCount ?? 0;
    message.tags = object.tags?.map((e) => e) || [];
    message.preemptible = object.preemptible ?? false;
    message.accelerators = object.accelerators?.map((e) => AcceleratorConfig.fromPartial(e)) || [];
    message.minCpuPlatform = object.minCpuPlatform ?? "";
    message.taints = object.taints?.map((e) => NodeTaint.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNodeConfig_MetadataEntry(): NodeConfig_MetadataEntry {
  return { key: "", value: "" };
}

export const NodeConfig_MetadataEntry: MessageFns<NodeConfig_MetadataEntry> = {
  encode(message: NodeConfig_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeConfig_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeConfig_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeConfig_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: NodeConfig_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<NodeConfig_MetadataEntry>): NodeConfig_MetadataEntry {
    return NodeConfig_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeConfig_MetadataEntry>): NodeConfig_MetadataEntry {
    const message = createBaseNodeConfig_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseNodeConfig_LabelsEntry(): NodeConfig_LabelsEntry {
  return { key: "", value: "" };
}

export const NodeConfig_LabelsEntry: MessageFns<NodeConfig_LabelsEntry> = {
  encode(message: NodeConfig_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeConfig_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeConfig_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeConfig_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: NodeConfig_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<NodeConfig_LabelsEntry>): NodeConfig_LabelsEntry {
    return NodeConfig_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeConfig_LabelsEntry>): NodeConfig_LabelsEntry {
    const message = createBaseNodeConfig_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseNodeTaint(): NodeTaint {
  return { key: "", value: "", effect: 0 };
}

export const NodeTaint: MessageFns<NodeTaint> = {
  encode(message: NodeTaint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    if (message.effect !== 0) {
      writer.uint32(24).int32(message.effect);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeTaint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeTaint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.effect = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeTaint {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      effect: isSet(object.effect) ? nodeTaint_EffectFromJSON(object.effect) : 0,
    };
  },

  toJSON(message: NodeTaint): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.effect !== 0) {
      obj.effect = nodeTaint_EffectToJSON(message.effect);
    }
    return obj;
  },

  create(base?: DeepPartial<NodeTaint>): NodeTaint {
    return NodeTaint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeTaint>): NodeTaint {
    const message = createBaseNodeTaint();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    message.effect = object.effect ?? 0;
    return message;
  },
};

function createBaseMasterAuth(): MasterAuth {
  return {
    username: "",
    password: "",
    clientCertificateConfig: undefined,
    clusterCaCertificate: "",
    clientCertificate: "",
    clientKey: "",
  };
}

export const MasterAuth: MessageFns<MasterAuth> = {
  encode(message: MasterAuth, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    if (message.clientCertificateConfig !== undefined) {
      ClientCertificateConfig.encode(message.clientCertificateConfig, writer.uint32(26).fork()).join();
    }
    if (message.clusterCaCertificate !== "") {
      writer.uint32(802).string(message.clusterCaCertificate);
    }
    if (message.clientCertificate !== "") {
      writer.uint32(810).string(message.clientCertificate);
    }
    if (message.clientKey !== "") {
      writer.uint32(818).string(message.clientKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MasterAuth {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMasterAuth();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clientCertificateConfig = ClientCertificateConfig.decode(reader, reader.uint32());
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }

          message.clusterCaCertificate = reader.string();
          continue;
        case 101:
          if (tag !== 810) {
            break;
          }

          message.clientCertificate = reader.string();
          continue;
        case 102:
          if (tag !== 818) {
            break;
          }

          message.clientKey = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MasterAuth {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      clientCertificateConfig: isSet(object.clientCertificateConfig)
        ? ClientCertificateConfig.fromJSON(object.clientCertificateConfig)
        : undefined,
      clusterCaCertificate: isSet(object.clusterCaCertificate) ? globalThis.String(object.clusterCaCertificate) : "",
      clientCertificate: isSet(object.clientCertificate) ? globalThis.String(object.clientCertificate) : "",
      clientKey: isSet(object.clientKey) ? globalThis.String(object.clientKey) : "",
    };
  },

  toJSON(message: MasterAuth): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.clientCertificateConfig !== undefined) {
      obj.clientCertificateConfig = ClientCertificateConfig.toJSON(message.clientCertificateConfig);
    }
    if (message.clusterCaCertificate !== "") {
      obj.clusterCaCertificate = message.clusterCaCertificate;
    }
    if (message.clientCertificate !== "") {
      obj.clientCertificate = message.clientCertificate;
    }
    if (message.clientKey !== "") {
      obj.clientKey = message.clientKey;
    }
    return obj;
  },

  create(base?: DeepPartial<MasterAuth>): MasterAuth {
    return MasterAuth.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MasterAuth>): MasterAuth {
    const message = createBaseMasterAuth();
    message.username = object.username ?? "";
    message.password = object.password ?? "";
    message.clientCertificateConfig =
      (object.clientCertificateConfig !== undefined && object.clientCertificateConfig !== null)
        ? ClientCertificateConfig.fromPartial(object.clientCertificateConfig)
        : undefined;
    message.clusterCaCertificate = object.clusterCaCertificate ?? "";
    message.clientCertificate = object.clientCertificate ?? "";
    message.clientKey = object.clientKey ?? "";
    return message;
  },
};

function createBaseClientCertificateConfig(): ClientCertificateConfig {
  return { issueClientCertificate: false };
}

export const ClientCertificateConfig: MessageFns<ClientCertificateConfig> = {
  encode(message: ClientCertificateConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.issueClientCertificate !== false) {
      writer.uint32(8).bool(message.issueClientCertificate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientCertificateConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientCertificateConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.issueClientCertificate = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientCertificateConfig {
    return {
      issueClientCertificate: isSet(object.issueClientCertificate)
        ? globalThis.Boolean(object.issueClientCertificate)
        : false,
    };
  },

  toJSON(message: ClientCertificateConfig): unknown {
    const obj: any = {};
    if (message.issueClientCertificate !== false) {
      obj.issueClientCertificate = message.issueClientCertificate;
    }
    return obj;
  },

  create(base?: DeepPartial<ClientCertificateConfig>): ClientCertificateConfig {
    return ClientCertificateConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClientCertificateConfig>): ClientCertificateConfig {
    const message = createBaseClientCertificateConfig();
    message.issueClientCertificate = object.issueClientCertificate ?? false;
    return message;
  },
};

function createBaseAddonsConfig(): AddonsConfig {
  return {
    httpLoadBalancing: undefined,
    horizontalPodAutoscaling: undefined,
    kubernetesDashboard: undefined,
    networkPolicyConfig: undefined,
  };
}

export const AddonsConfig: MessageFns<AddonsConfig> = {
  encode(message: AddonsConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.httpLoadBalancing !== undefined) {
      HttpLoadBalancing.encode(message.httpLoadBalancing, writer.uint32(10).fork()).join();
    }
    if (message.horizontalPodAutoscaling !== undefined) {
      HorizontalPodAutoscaling.encode(message.horizontalPodAutoscaling, writer.uint32(18).fork()).join();
    }
    if (message.kubernetesDashboard !== undefined) {
      KubernetesDashboard.encode(message.kubernetesDashboard, writer.uint32(26).fork()).join();
    }
    if (message.networkPolicyConfig !== undefined) {
      NetworkPolicyConfig.encode(message.networkPolicyConfig, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddonsConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddonsConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.httpLoadBalancing = HttpLoadBalancing.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.horizontalPodAutoscaling = HorizontalPodAutoscaling.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.kubernetesDashboard = KubernetesDashboard.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.networkPolicyConfig = NetworkPolicyConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddonsConfig {
    return {
      httpLoadBalancing: isSet(object.httpLoadBalancing)
        ? HttpLoadBalancing.fromJSON(object.httpLoadBalancing)
        : undefined,
      horizontalPodAutoscaling: isSet(object.horizontalPodAutoscaling)
        ? HorizontalPodAutoscaling.fromJSON(object.horizontalPodAutoscaling)
        : undefined,
      kubernetesDashboard: isSet(object.kubernetesDashboard)
        ? KubernetesDashboard.fromJSON(object.kubernetesDashboard)
        : undefined,
      networkPolicyConfig: isSet(object.networkPolicyConfig)
        ? NetworkPolicyConfig.fromJSON(object.networkPolicyConfig)
        : undefined,
    };
  },

  toJSON(message: AddonsConfig): unknown {
    const obj: any = {};
    if (message.httpLoadBalancing !== undefined) {
      obj.httpLoadBalancing = HttpLoadBalancing.toJSON(message.httpLoadBalancing);
    }
    if (message.horizontalPodAutoscaling !== undefined) {
      obj.horizontalPodAutoscaling = HorizontalPodAutoscaling.toJSON(message.horizontalPodAutoscaling);
    }
    if (message.kubernetesDashboard !== undefined) {
      obj.kubernetesDashboard = KubernetesDashboard.toJSON(message.kubernetesDashboard);
    }
    if (message.networkPolicyConfig !== undefined) {
      obj.networkPolicyConfig = NetworkPolicyConfig.toJSON(message.networkPolicyConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<AddonsConfig>): AddonsConfig {
    return AddonsConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AddonsConfig>): AddonsConfig {
    const message = createBaseAddonsConfig();
    message.httpLoadBalancing = (object.httpLoadBalancing !== undefined && object.httpLoadBalancing !== null)
      ? HttpLoadBalancing.fromPartial(object.httpLoadBalancing)
      : undefined;
    message.horizontalPodAutoscaling =
      (object.horizontalPodAutoscaling !== undefined && object.horizontalPodAutoscaling !== null)
        ? HorizontalPodAutoscaling.fromPartial(object.horizontalPodAutoscaling)
        : undefined;
    message.kubernetesDashboard = (object.kubernetesDashboard !== undefined && object.kubernetesDashboard !== null)
      ? KubernetesDashboard.fromPartial(object.kubernetesDashboard)
      : undefined;
    message.networkPolicyConfig = (object.networkPolicyConfig !== undefined && object.networkPolicyConfig !== null)
      ? NetworkPolicyConfig.fromPartial(object.networkPolicyConfig)
      : undefined;
    return message;
  },
};

function createBaseHttpLoadBalancing(): HttpLoadBalancing {
  return { disabled: false };
}

export const HttpLoadBalancing: MessageFns<HttpLoadBalancing> = {
  encode(message: HttpLoadBalancing, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.disabled !== false) {
      writer.uint32(8).bool(message.disabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpLoadBalancing {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpLoadBalancing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.disabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpLoadBalancing {
    return { disabled: isSet(object.disabled) ? globalThis.Boolean(object.disabled) : false };
  },

  toJSON(message: HttpLoadBalancing): unknown {
    const obj: any = {};
    if (message.disabled !== false) {
      obj.disabled = message.disabled;
    }
    return obj;
  },

  create(base?: DeepPartial<HttpLoadBalancing>): HttpLoadBalancing {
    return HttpLoadBalancing.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HttpLoadBalancing>): HttpLoadBalancing {
    const message = createBaseHttpLoadBalancing();
    message.disabled = object.disabled ?? false;
    return message;
  },
};

function createBaseHorizontalPodAutoscaling(): HorizontalPodAutoscaling {
  return { disabled: false };
}

export const HorizontalPodAutoscaling: MessageFns<HorizontalPodAutoscaling> = {
  encode(message: HorizontalPodAutoscaling, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.disabled !== false) {
      writer.uint32(8).bool(message.disabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HorizontalPodAutoscaling {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHorizontalPodAutoscaling();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.disabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HorizontalPodAutoscaling {
    return { disabled: isSet(object.disabled) ? globalThis.Boolean(object.disabled) : false };
  },

  toJSON(message: HorizontalPodAutoscaling): unknown {
    const obj: any = {};
    if (message.disabled !== false) {
      obj.disabled = message.disabled;
    }
    return obj;
  },

  create(base?: DeepPartial<HorizontalPodAutoscaling>): HorizontalPodAutoscaling {
    return HorizontalPodAutoscaling.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HorizontalPodAutoscaling>): HorizontalPodAutoscaling {
    const message = createBaseHorizontalPodAutoscaling();
    message.disabled = object.disabled ?? false;
    return message;
  },
};

function createBaseKubernetesDashboard(): KubernetesDashboard {
  return { disabled: false };
}

export const KubernetesDashboard: MessageFns<KubernetesDashboard> = {
  encode(message: KubernetesDashboard, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.disabled !== false) {
      writer.uint32(8).bool(message.disabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KubernetesDashboard {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKubernetesDashboard();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.disabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KubernetesDashboard {
    return { disabled: isSet(object.disabled) ? globalThis.Boolean(object.disabled) : false };
  },

  toJSON(message: KubernetesDashboard): unknown {
    const obj: any = {};
    if (message.disabled !== false) {
      obj.disabled = message.disabled;
    }
    return obj;
  },

  create(base?: DeepPartial<KubernetesDashboard>): KubernetesDashboard {
    return KubernetesDashboard.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KubernetesDashboard>): KubernetesDashboard {
    const message = createBaseKubernetesDashboard();
    message.disabled = object.disabled ?? false;
    return message;
  },
};

function createBaseNetworkPolicyConfig(): NetworkPolicyConfig {
  return { disabled: false };
}

export const NetworkPolicyConfig: MessageFns<NetworkPolicyConfig> = {
  encode(message: NetworkPolicyConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.disabled !== false) {
      writer.uint32(8).bool(message.disabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkPolicyConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkPolicyConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.disabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkPolicyConfig {
    return { disabled: isSet(object.disabled) ? globalThis.Boolean(object.disabled) : false };
  },

  toJSON(message: NetworkPolicyConfig): unknown {
    const obj: any = {};
    if (message.disabled !== false) {
      obj.disabled = message.disabled;
    }
    return obj;
  },

  create(base?: DeepPartial<NetworkPolicyConfig>): NetworkPolicyConfig {
    return NetworkPolicyConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NetworkPolicyConfig>): NetworkPolicyConfig {
    const message = createBaseNetworkPolicyConfig();
    message.disabled = object.disabled ?? false;
    return message;
  },
};

function createBaseMasterAuthorizedNetworksConfig(): MasterAuthorizedNetworksConfig {
  return { enabled: false, cidrBlocks: [] };
}

export const MasterAuthorizedNetworksConfig: MessageFns<MasterAuthorizedNetworksConfig> = {
  encode(message: MasterAuthorizedNetworksConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    for (const v of message.cidrBlocks) {
      MasterAuthorizedNetworksConfig_CidrBlock.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MasterAuthorizedNetworksConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMasterAuthorizedNetworksConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cidrBlocks.push(MasterAuthorizedNetworksConfig_CidrBlock.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MasterAuthorizedNetworksConfig {
    return {
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      cidrBlocks: globalThis.Array.isArray(object?.cidrBlocks)
        ? object.cidrBlocks.map((e: any) => MasterAuthorizedNetworksConfig_CidrBlock.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MasterAuthorizedNetworksConfig): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.cidrBlocks?.length) {
      obj.cidrBlocks = message.cidrBlocks.map((e) => MasterAuthorizedNetworksConfig_CidrBlock.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MasterAuthorizedNetworksConfig>): MasterAuthorizedNetworksConfig {
    return MasterAuthorizedNetworksConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MasterAuthorizedNetworksConfig>): MasterAuthorizedNetworksConfig {
    const message = createBaseMasterAuthorizedNetworksConfig();
    message.enabled = object.enabled ?? false;
    message.cidrBlocks = object.cidrBlocks?.map((e) => MasterAuthorizedNetworksConfig_CidrBlock.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMasterAuthorizedNetworksConfig_CidrBlock(): MasterAuthorizedNetworksConfig_CidrBlock {
  return { displayName: "", cidrBlock: "" };
}

export const MasterAuthorizedNetworksConfig_CidrBlock: MessageFns<MasterAuthorizedNetworksConfig_CidrBlock> = {
  encode(message: MasterAuthorizedNetworksConfig_CidrBlock, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.cidrBlock !== "") {
      writer.uint32(18).string(message.cidrBlock);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MasterAuthorizedNetworksConfig_CidrBlock {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMasterAuthorizedNetworksConfig_CidrBlock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cidrBlock = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MasterAuthorizedNetworksConfig_CidrBlock {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      cidrBlock: isSet(object.cidrBlock) ? globalThis.String(object.cidrBlock) : "",
    };
  },

  toJSON(message: MasterAuthorizedNetworksConfig_CidrBlock): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.cidrBlock !== "") {
      obj.cidrBlock = message.cidrBlock;
    }
    return obj;
  },

  create(base?: DeepPartial<MasterAuthorizedNetworksConfig_CidrBlock>): MasterAuthorizedNetworksConfig_CidrBlock {
    return MasterAuthorizedNetworksConfig_CidrBlock.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MasterAuthorizedNetworksConfig_CidrBlock>): MasterAuthorizedNetworksConfig_CidrBlock {
    const message = createBaseMasterAuthorizedNetworksConfig_CidrBlock();
    message.displayName = object.displayName ?? "";
    message.cidrBlock = object.cidrBlock ?? "";
    return message;
  },
};

function createBaseNetworkPolicy(): NetworkPolicy {
  return { provider: 0, enabled: false };
}

export const NetworkPolicy: MessageFns<NetworkPolicy> = {
  encode(message: NetworkPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.provider !== 0) {
      writer.uint32(8).int32(message.provider);
    }
    if (message.enabled !== false) {
      writer.uint32(16).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.provider = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.enabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkPolicy {
    return {
      provider: isSet(object.provider) ? networkPolicy_ProviderFromJSON(object.provider) : 0,
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
    };
  },

  toJSON(message: NetworkPolicy): unknown {
    const obj: any = {};
    if (message.provider !== 0) {
      obj.provider = networkPolicy_ProviderToJSON(message.provider);
    }
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create(base?: DeepPartial<NetworkPolicy>): NetworkPolicy {
    return NetworkPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NetworkPolicy>): NetworkPolicy {
    const message = createBaseNetworkPolicy();
    message.provider = object.provider ?? 0;
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBaseIPAllocationPolicy(): IPAllocationPolicy {
  return {
    useIpAliases: false,
    createSubnetwork: false,
    subnetworkName: "",
    clusterIpv4Cidr: "",
    nodeIpv4Cidr: "",
    servicesIpv4Cidr: "",
    clusterSecondaryRangeName: "",
    servicesSecondaryRangeName: "",
    clusterIpv4CidrBlock: "",
    nodeIpv4CidrBlock: "",
    servicesIpv4CidrBlock: "",
  };
}

export const IPAllocationPolicy: MessageFns<IPAllocationPolicy> = {
  encode(message: IPAllocationPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.useIpAliases !== false) {
      writer.uint32(8).bool(message.useIpAliases);
    }
    if (message.createSubnetwork !== false) {
      writer.uint32(16).bool(message.createSubnetwork);
    }
    if (message.subnetworkName !== "") {
      writer.uint32(26).string(message.subnetworkName);
    }
    if (message.clusterIpv4Cidr !== "") {
      writer.uint32(34).string(message.clusterIpv4Cidr);
    }
    if (message.nodeIpv4Cidr !== "") {
      writer.uint32(42).string(message.nodeIpv4Cidr);
    }
    if (message.servicesIpv4Cidr !== "") {
      writer.uint32(50).string(message.servicesIpv4Cidr);
    }
    if (message.clusterSecondaryRangeName !== "") {
      writer.uint32(58).string(message.clusterSecondaryRangeName);
    }
    if (message.servicesSecondaryRangeName !== "") {
      writer.uint32(66).string(message.servicesSecondaryRangeName);
    }
    if (message.clusterIpv4CidrBlock !== "") {
      writer.uint32(74).string(message.clusterIpv4CidrBlock);
    }
    if (message.nodeIpv4CidrBlock !== "") {
      writer.uint32(82).string(message.nodeIpv4CidrBlock);
    }
    if (message.servicesIpv4CidrBlock !== "") {
      writer.uint32(90).string(message.servicesIpv4CidrBlock);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IPAllocationPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIPAllocationPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.useIpAliases = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.createSubnetwork = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.subnetworkName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.clusterIpv4Cidr = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.nodeIpv4Cidr = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.servicesIpv4Cidr = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.clusterSecondaryRangeName = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.servicesSecondaryRangeName = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.clusterIpv4CidrBlock = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.nodeIpv4CidrBlock = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.servicesIpv4CidrBlock = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IPAllocationPolicy {
    return {
      useIpAliases: isSet(object.useIpAliases) ? globalThis.Boolean(object.useIpAliases) : false,
      createSubnetwork: isSet(object.createSubnetwork) ? globalThis.Boolean(object.createSubnetwork) : false,
      subnetworkName: isSet(object.subnetworkName) ? globalThis.String(object.subnetworkName) : "",
      clusterIpv4Cidr: isSet(object.clusterIpv4Cidr) ? globalThis.String(object.clusterIpv4Cidr) : "",
      nodeIpv4Cidr: isSet(object.nodeIpv4Cidr) ? globalThis.String(object.nodeIpv4Cidr) : "",
      servicesIpv4Cidr: isSet(object.servicesIpv4Cidr) ? globalThis.String(object.servicesIpv4Cidr) : "",
      clusterSecondaryRangeName: isSet(object.clusterSecondaryRangeName)
        ? globalThis.String(object.clusterSecondaryRangeName)
        : "",
      servicesSecondaryRangeName: isSet(object.servicesSecondaryRangeName)
        ? globalThis.String(object.servicesSecondaryRangeName)
        : "",
      clusterIpv4CidrBlock: isSet(object.clusterIpv4CidrBlock) ? globalThis.String(object.clusterIpv4CidrBlock) : "",
      nodeIpv4CidrBlock: isSet(object.nodeIpv4CidrBlock) ? globalThis.String(object.nodeIpv4CidrBlock) : "",
      servicesIpv4CidrBlock: isSet(object.servicesIpv4CidrBlock) ? globalThis.String(object.servicesIpv4CidrBlock) : "",
    };
  },

  toJSON(message: IPAllocationPolicy): unknown {
    const obj: any = {};
    if (message.useIpAliases !== false) {
      obj.useIpAliases = message.useIpAliases;
    }
    if (message.createSubnetwork !== false) {
      obj.createSubnetwork = message.createSubnetwork;
    }
    if (message.subnetworkName !== "") {
      obj.subnetworkName = message.subnetworkName;
    }
    if (message.clusterIpv4Cidr !== "") {
      obj.clusterIpv4Cidr = message.clusterIpv4Cidr;
    }
    if (message.nodeIpv4Cidr !== "") {
      obj.nodeIpv4Cidr = message.nodeIpv4Cidr;
    }
    if (message.servicesIpv4Cidr !== "") {
      obj.servicesIpv4Cidr = message.servicesIpv4Cidr;
    }
    if (message.clusterSecondaryRangeName !== "") {
      obj.clusterSecondaryRangeName = message.clusterSecondaryRangeName;
    }
    if (message.servicesSecondaryRangeName !== "") {
      obj.servicesSecondaryRangeName = message.servicesSecondaryRangeName;
    }
    if (message.clusterIpv4CidrBlock !== "") {
      obj.clusterIpv4CidrBlock = message.clusterIpv4CidrBlock;
    }
    if (message.nodeIpv4CidrBlock !== "") {
      obj.nodeIpv4CidrBlock = message.nodeIpv4CidrBlock;
    }
    if (message.servicesIpv4CidrBlock !== "") {
      obj.servicesIpv4CidrBlock = message.servicesIpv4CidrBlock;
    }
    return obj;
  },

  create(base?: DeepPartial<IPAllocationPolicy>): IPAllocationPolicy {
    return IPAllocationPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IPAllocationPolicy>): IPAllocationPolicy {
    const message = createBaseIPAllocationPolicy();
    message.useIpAliases = object.useIpAliases ?? false;
    message.createSubnetwork = object.createSubnetwork ?? false;
    message.subnetworkName = object.subnetworkName ?? "";
    message.clusterIpv4Cidr = object.clusterIpv4Cidr ?? "";
    message.nodeIpv4Cidr = object.nodeIpv4Cidr ?? "";
    message.servicesIpv4Cidr = object.servicesIpv4Cidr ?? "";
    message.clusterSecondaryRangeName = object.clusterSecondaryRangeName ?? "";
    message.servicesSecondaryRangeName = object.servicesSecondaryRangeName ?? "";
    message.clusterIpv4CidrBlock = object.clusterIpv4CidrBlock ?? "";
    message.nodeIpv4CidrBlock = object.nodeIpv4CidrBlock ?? "";
    message.servicesIpv4CidrBlock = object.servicesIpv4CidrBlock ?? "";
    return message;
  },
};

function createBasePodSecurityPolicyConfig(): PodSecurityPolicyConfig {
  return { enabled: false };
}

export const PodSecurityPolicyConfig: MessageFns<PodSecurityPolicyConfig> = {
  encode(message: PodSecurityPolicyConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PodSecurityPolicyConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePodSecurityPolicyConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PodSecurityPolicyConfig {
    return { enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false };
  },

  toJSON(message: PodSecurityPolicyConfig): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create(base?: DeepPartial<PodSecurityPolicyConfig>): PodSecurityPolicyConfig {
    return PodSecurityPolicyConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PodSecurityPolicyConfig>): PodSecurityPolicyConfig {
    const message = createBasePodSecurityPolicyConfig();
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBaseCluster(): Cluster {
  return {
    name: "",
    description: "",
    initialNodeCount: 0,
    nodeConfig: undefined,
    masterAuth: undefined,
    loggingService: "",
    monitoringService: "",
    network: "",
    clusterIpv4Cidr: "",
    addonsConfig: undefined,
    subnetwork: "",
    nodePools: [],
    locations: [],
    enableKubernetesAlpha: false,
    networkPolicy: undefined,
    ipAllocationPolicy: undefined,
    masterAuthorizedNetworksConfig: undefined,
    maintenancePolicy: undefined,
    podSecurityPolicyConfig: undefined,
    selfLink: "",
    zone: "",
    endpoint: "",
    initialClusterVersion: "",
    currentMasterVersion: "",
    currentNodeVersion: "",
    createTime: "",
    status: 0,
    statusMessage: "",
    nodeIpv4CidrSize: 0,
    servicesIpv4Cidr: "",
    instanceGroupUrls: [],
    currentNodeCount: 0,
    expireTime: "",
    location: "",
  };
}

export const Cluster: MessageFns<Cluster> = {
  encode(message: Cluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.initialNodeCount !== 0) {
      writer.uint32(24).int32(message.initialNodeCount);
    }
    if (message.nodeConfig !== undefined) {
      NodeConfig.encode(message.nodeConfig, writer.uint32(34).fork()).join();
    }
    if (message.masterAuth !== undefined) {
      MasterAuth.encode(message.masterAuth, writer.uint32(42).fork()).join();
    }
    if (message.loggingService !== "") {
      writer.uint32(50).string(message.loggingService);
    }
    if (message.monitoringService !== "") {
      writer.uint32(58).string(message.monitoringService);
    }
    if (message.network !== "") {
      writer.uint32(66).string(message.network);
    }
    if (message.clusterIpv4Cidr !== "") {
      writer.uint32(74).string(message.clusterIpv4Cidr);
    }
    if (message.addonsConfig !== undefined) {
      AddonsConfig.encode(message.addonsConfig, writer.uint32(82).fork()).join();
    }
    if (message.subnetwork !== "") {
      writer.uint32(90).string(message.subnetwork);
    }
    for (const v of message.nodePools) {
      NodePool.encode(v!, writer.uint32(98).fork()).join();
    }
    for (const v of message.locations) {
      writer.uint32(106).string(v!);
    }
    if (message.enableKubernetesAlpha !== false) {
      writer.uint32(112).bool(message.enableKubernetesAlpha);
    }
    if (message.networkPolicy !== undefined) {
      NetworkPolicy.encode(message.networkPolicy, writer.uint32(154).fork()).join();
    }
    if (message.ipAllocationPolicy !== undefined) {
      IPAllocationPolicy.encode(message.ipAllocationPolicy, writer.uint32(162).fork()).join();
    }
    if (message.masterAuthorizedNetworksConfig !== undefined) {
      MasterAuthorizedNetworksConfig.encode(message.masterAuthorizedNetworksConfig, writer.uint32(178).fork()).join();
    }
    if (message.maintenancePolicy !== undefined) {
      MaintenancePolicy.encode(message.maintenancePolicy, writer.uint32(186).fork()).join();
    }
    if (message.podSecurityPolicyConfig !== undefined) {
      PodSecurityPolicyConfig.encode(message.podSecurityPolicyConfig, writer.uint32(202).fork()).join();
    }
    if (message.selfLink !== "") {
      writer.uint32(802).string(message.selfLink);
    }
    if (message.zone !== "") {
      writer.uint32(810).string(message.zone);
    }
    if (message.endpoint !== "") {
      writer.uint32(818).string(message.endpoint);
    }
    if (message.initialClusterVersion !== "") {
      writer.uint32(826).string(message.initialClusterVersion);
    }
    if (message.currentMasterVersion !== "") {
      writer.uint32(834).string(message.currentMasterVersion);
    }
    if (message.currentNodeVersion !== "") {
      writer.uint32(842).string(message.currentNodeVersion);
    }
    if (message.createTime !== "") {
      writer.uint32(850).string(message.createTime);
    }
    if (message.status !== 0) {
      writer.uint32(856).int32(message.status);
    }
    if (message.statusMessage !== "") {
      writer.uint32(866).string(message.statusMessage);
    }
    if (message.nodeIpv4CidrSize !== 0) {
      writer.uint32(872).int32(message.nodeIpv4CidrSize);
    }
    if (message.servicesIpv4Cidr !== "") {
      writer.uint32(882).string(message.servicesIpv4Cidr);
    }
    for (const v of message.instanceGroupUrls) {
      writer.uint32(890).string(v!);
    }
    if (message.currentNodeCount !== 0) {
      writer.uint32(896).int32(message.currentNodeCount);
    }
    if (message.expireTime !== "") {
      writer.uint32(906).string(message.expireTime);
    }
    if (message.location !== "") {
      writer.uint32(914).string(message.location);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.initialNodeCount = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.nodeConfig = NodeConfig.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.masterAuth = MasterAuth.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.loggingService = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.monitoringService = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.network = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.clusterIpv4Cidr = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.addonsConfig = AddonsConfig.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.subnetwork = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.nodePools.push(NodePool.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.locations.push(reader.string());
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.enableKubernetesAlpha = reader.bool();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.networkPolicy = NetworkPolicy.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.ipAllocationPolicy = IPAllocationPolicy.decode(reader, reader.uint32());
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.masterAuthorizedNetworksConfig = MasterAuthorizedNetworksConfig.decode(reader, reader.uint32());
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.maintenancePolicy = MaintenancePolicy.decode(reader, reader.uint32());
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.podSecurityPolicyConfig = PodSecurityPolicyConfig.decode(reader, reader.uint32());
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }

          message.selfLink = reader.string();
          continue;
        case 101:
          if (tag !== 810) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 102:
          if (tag !== 818) {
            break;
          }

          message.endpoint = reader.string();
          continue;
        case 103:
          if (tag !== 826) {
            break;
          }

          message.initialClusterVersion = reader.string();
          continue;
        case 104:
          if (tag !== 834) {
            break;
          }

          message.currentMasterVersion = reader.string();
          continue;
        case 105:
          if (tag !== 842) {
            break;
          }

          message.currentNodeVersion = reader.string();
          continue;
        case 106:
          if (tag !== 850) {
            break;
          }

          message.createTime = reader.string();
          continue;
        case 107:
          if (tag !== 856) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 108:
          if (tag !== 866) {
            break;
          }

          message.statusMessage = reader.string();
          continue;
        case 109:
          if (tag !== 872) {
            break;
          }

          message.nodeIpv4CidrSize = reader.int32();
          continue;
        case 110:
          if (tag !== 882) {
            break;
          }

          message.servicesIpv4Cidr = reader.string();
          continue;
        case 111:
          if (tag !== 890) {
            break;
          }

          message.instanceGroupUrls.push(reader.string());
          continue;
        case 112:
          if (tag !== 896) {
            break;
          }

          message.currentNodeCount = reader.int32();
          continue;
        case 113:
          if (tag !== 906) {
            break;
          }

          message.expireTime = reader.string();
          continue;
        case 114:
          if (tag !== 914) {
            break;
          }

          message.location = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      initialNodeCount: isSet(object.initialNodeCount) ? globalThis.Number(object.initialNodeCount) : 0,
      nodeConfig: isSet(object.nodeConfig) ? NodeConfig.fromJSON(object.nodeConfig) : undefined,
      masterAuth: isSet(object.masterAuth) ? MasterAuth.fromJSON(object.masterAuth) : undefined,
      loggingService: isSet(object.loggingService) ? globalThis.String(object.loggingService) : "",
      monitoringService: isSet(object.monitoringService) ? globalThis.String(object.monitoringService) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      clusterIpv4Cidr: isSet(object.clusterIpv4Cidr) ? globalThis.String(object.clusterIpv4Cidr) : "",
      addonsConfig: isSet(object.addonsConfig) ? AddonsConfig.fromJSON(object.addonsConfig) : undefined,
      subnetwork: isSet(object.subnetwork) ? globalThis.String(object.subnetwork) : "",
      nodePools: globalThis.Array.isArray(object?.nodePools)
        ? object.nodePools.map((e: any) => NodePool.fromJSON(e))
        : [],
      locations: globalThis.Array.isArray(object?.locations)
        ? object.locations.map((e: any) => globalThis.String(e))
        : [],
      enableKubernetesAlpha: isSet(object.enableKubernetesAlpha)
        ? globalThis.Boolean(object.enableKubernetesAlpha)
        : false,
      networkPolicy: isSet(object.networkPolicy) ? NetworkPolicy.fromJSON(object.networkPolicy) : undefined,
      ipAllocationPolicy: isSet(object.ipAllocationPolicy)
        ? IPAllocationPolicy.fromJSON(object.ipAllocationPolicy)
        : undefined,
      masterAuthorizedNetworksConfig: isSet(object.masterAuthorizedNetworksConfig)
        ? MasterAuthorizedNetworksConfig.fromJSON(object.masterAuthorizedNetworksConfig)
        : undefined,
      maintenancePolicy: isSet(object.maintenancePolicy)
        ? MaintenancePolicy.fromJSON(object.maintenancePolicy)
        : undefined,
      podSecurityPolicyConfig: isSet(object.podSecurityPolicyConfig)
        ? PodSecurityPolicyConfig.fromJSON(object.podSecurityPolicyConfig)
        : undefined,
      selfLink: isSet(object.selfLink) ? globalThis.String(object.selfLink) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      endpoint: isSet(object.endpoint) ? globalThis.String(object.endpoint) : "",
      initialClusterVersion: isSet(object.initialClusterVersion) ? globalThis.String(object.initialClusterVersion) : "",
      currentMasterVersion: isSet(object.currentMasterVersion) ? globalThis.String(object.currentMasterVersion) : "",
      currentNodeVersion: isSet(object.currentNodeVersion) ? globalThis.String(object.currentNodeVersion) : "",
      createTime: isSet(object.createTime) ? globalThis.String(object.createTime) : "",
      status: isSet(object.status) ? cluster_StatusFromJSON(object.status) : 0,
      statusMessage: isSet(object.statusMessage) ? globalThis.String(object.statusMessage) : "",
      nodeIpv4CidrSize: isSet(object.nodeIpv4CidrSize) ? globalThis.Number(object.nodeIpv4CidrSize) : 0,
      servicesIpv4Cidr: isSet(object.servicesIpv4Cidr) ? globalThis.String(object.servicesIpv4Cidr) : "",
      instanceGroupUrls: globalThis.Array.isArray(object?.instanceGroupUrls)
        ? object.instanceGroupUrls.map((e: any) => globalThis.String(e))
        : [],
      currentNodeCount: isSet(object.currentNodeCount) ? globalThis.Number(object.currentNodeCount) : 0,
      expireTime: isSet(object.expireTime) ? globalThis.String(object.expireTime) : "",
      location: isSet(object.location) ? globalThis.String(object.location) : "",
    };
  },

  toJSON(message: Cluster): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.initialNodeCount !== 0) {
      obj.initialNodeCount = Math.round(message.initialNodeCount);
    }
    if (message.nodeConfig !== undefined) {
      obj.nodeConfig = NodeConfig.toJSON(message.nodeConfig);
    }
    if (message.masterAuth !== undefined) {
      obj.masterAuth = MasterAuth.toJSON(message.masterAuth);
    }
    if (message.loggingService !== "") {
      obj.loggingService = message.loggingService;
    }
    if (message.monitoringService !== "") {
      obj.monitoringService = message.monitoringService;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.clusterIpv4Cidr !== "") {
      obj.clusterIpv4Cidr = message.clusterIpv4Cidr;
    }
    if (message.addonsConfig !== undefined) {
      obj.addonsConfig = AddonsConfig.toJSON(message.addonsConfig);
    }
    if (message.subnetwork !== "") {
      obj.subnetwork = message.subnetwork;
    }
    if (message.nodePools?.length) {
      obj.nodePools = message.nodePools.map((e) => NodePool.toJSON(e));
    }
    if (message.locations?.length) {
      obj.locations = message.locations;
    }
    if (message.enableKubernetesAlpha !== false) {
      obj.enableKubernetesAlpha = message.enableKubernetesAlpha;
    }
    if (message.networkPolicy !== undefined) {
      obj.networkPolicy = NetworkPolicy.toJSON(message.networkPolicy);
    }
    if (message.ipAllocationPolicy !== undefined) {
      obj.ipAllocationPolicy = IPAllocationPolicy.toJSON(message.ipAllocationPolicy);
    }
    if (message.masterAuthorizedNetworksConfig !== undefined) {
      obj.masterAuthorizedNetworksConfig = MasterAuthorizedNetworksConfig.toJSON(
        message.masterAuthorizedNetworksConfig,
      );
    }
    if (message.maintenancePolicy !== undefined) {
      obj.maintenancePolicy = MaintenancePolicy.toJSON(message.maintenancePolicy);
    }
    if (message.podSecurityPolicyConfig !== undefined) {
      obj.podSecurityPolicyConfig = PodSecurityPolicyConfig.toJSON(message.podSecurityPolicyConfig);
    }
    if (message.selfLink !== "") {
      obj.selfLink = message.selfLink;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.endpoint !== "") {
      obj.endpoint = message.endpoint;
    }
    if (message.initialClusterVersion !== "") {
      obj.initialClusterVersion = message.initialClusterVersion;
    }
    if (message.currentMasterVersion !== "") {
      obj.currentMasterVersion = message.currentMasterVersion;
    }
    if (message.currentNodeVersion !== "") {
      obj.currentNodeVersion = message.currentNodeVersion;
    }
    if (message.createTime !== "") {
      obj.createTime = message.createTime;
    }
    if (message.status !== 0) {
      obj.status = cluster_StatusToJSON(message.status);
    }
    if (message.statusMessage !== "") {
      obj.statusMessage = message.statusMessage;
    }
    if (message.nodeIpv4CidrSize !== 0) {
      obj.nodeIpv4CidrSize = Math.round(message.nodeIpv4CidrSize);
    }
    if (message.servicesIpv4Cidr !== "") {
      obj.servicesIpv4Cidr = message.servicesIpv4Cidr;
    }
    if (message.instanceGroupUrls?.length) {
      obj.instanceGroupUrls = message.instanceGroupUrls;
    }
    if (message.currentNodeCount !== 0) {
      obj.currentNodeCount = Math.round(message.currentNodeCount);
    }
    if (message.expireTime !== "") {
      obj.expireTime = message.expireTime;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    return obj;
  },

  create(base?: DeepPartial<Cluster>): Cluster {
    return Cluster.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Cluster>): Cluster {
    const message = createBaseCluster();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.initialNodeCount = object.initialNodeCount ?? 0;
    message.nodeConfig = (object.nodeConfig !== undefined && object.nodeConfig !== null)
      ? NodeConfig.fromPartial(object.nodeConfig)
      : undefined;
    message.masterAuth = (object.masterAuth !== undefined && object.masterAuth !== null)
      ? MasterAuth.fromPartial(object.masterAuth)
      : undefined;
    message.loggingService = object.loggingService ?? "";
    message.monitoringService = object.monitoringService ?? "";
    message.network = object.network ?? "";
    message.clusterIpv4Cidr = object.clusterIpv4Cidr ?? "";
    message.addonsConfig = (object.addonsConfig !== undefined && object.addonsConfig !== null)
      ? AddonsConfig.fromPartial(object.addonsConfig)
      : undefined;
    message.subnetwork = object.subnetwork ?? "";
    message.nodePools = object.nodePools?.map((e) => NodePool.fromPartial(e)) || [];
    message.locations = object.locations?.map((e) => e) || [];
    message.enableKubernetesAlpha = object.enableKubernetesAlpha ?? false;
    message.networkPolicy = (object.networkPolicy !== undefined && object.networkPolicy !== null)
      ? NetworkPolicy.fromPartial(object.networkPolicy)
      : undefined;
    message.ipAllocationPolicy = (object.ipAllocationPolicy !== undefined && object.ipAllocationPolicy !== null)
      ? IPAllocationPolicy.fromPartial(object.ipAllocationPolicy)
      : undefined;
    message.masterAuthorizedNetworksConfig =
      (object.masterAuthorizedNetworksConfig !== undefined && object.masterAuthorizedNetworksConfig !== null)
        ? MasterAuthorizedNetworksConfig.fromPartial(object.masterAuthorizedNetworksConfig)
        : undefined;
    message.maintenancePolicy = (object.maintenancePolicy !== undefined && object.maintenancePolicy !== null)
      ? MaintenancePolicy.fromPartial(object.maintenancePolicy)
      : undefined;
    message.podSecurityPolicyConfig =
      (object.podSecurityPolicyConfig !== undefined && object.podSecurityPolicyConfig !== null)
        ? PodSecurityPolicyConfig.fromPartial(object.podSecurityPolicyConfig)
        : undefined;
    message.selfLink = object.selfLink ?? "";
    message.zone = object.zone ?? "";
    message.endpoint = object.endpoint ?? "";
    message.initialClusterVersion = object.initialClusterVersion ?? "";
    message.currentMasterVersion = object.currentMasterVersion ?? "";
    message.currentNodeVersion = object.currentNodeVersion ?? "";
    message.createTime = object.createTime ?? "";
    message.status = object.status ?? 0;
    message.statusMessage = object.statusMessage ?? "";
    message.nodeIpv4CidrSize = object.nodeIpv4CidrSize ?? 0;
    message.servicesIpv4Cidr = object.servicesIpv4Cidr ?? "";
    message.instanceGroupUrls = object.instanceGroupUrls?.map((e) => e) || [];
    message.currentNodeCount = object.currentNodeCount ?? 0;
    message.expireTime = object.expireTime ?? "";
    message.location = object.location ?? "";
    return message;
  },
};

function createBaseClusterUpdate(): ClusterUpdate {
  return {
    desiredNodeVersion: "",
    desiredMonitoringService: "",
    desiredAddonsConfig: undefined,
    desiredNodePoolId: "",
    desiredImageType: "",
    desiredNodePoolAutoscaling: undefined,
    desiredLocations: [],
    desiredMasterAuthorizedNetworksConfig: undefined,
    desiredPodSecurityPolicyConfig: undefined,
    desiredMasterVersion: "",
  };
}

export const ClusterUpdate: MessageFns<ClusterUpdate> = {
  encode(message: ClusterUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.desiredNodeVersion !== "") {
      writer.uint32(34).string(message.desiredNodeVersion);
    }
    if (message.desiredMonitoringService !== "") {
      writer.uint32(42).string(message.desiredMonitoringService);
    }
    if (message.desiredAddonsConfig !== undefined) {
      AddonsConfig.encode(message.desiredAddonsConfig, writer.uint32(50).fork()).join();
    }
    if (message.desiredNodePoolId !== "") {
      writer.uint32(58).string(message.desiredNodePoolId);
    }
    if (message.desiredImageType !== "") {
      writer.uint32(66).string(message.desiredImageType);
    }
    if (message.desiredNodePoolAutoscaling !== undefined) {
      NodePoolAutoscaling.encode(message.desiredNodePoolAutoscaling, writer.uint32(74).fork()).join();
    }
    for (const v of message.desiredLocations) {
      writer.uint32(82).string(v!);
    }
    if (message.desiredMasterAuthorizedNetworksConfig !== undefined) {
      MasterAuthorizedNetworksConfig.encode(message.desiredMasterAuthorizedNetworksConfig, writer.uint32(98).fork())
        .join();
    }
    if (message.desiredPodSecurityPolicyConfig !== undefined) {
      PodSecurityPolicyConfig.encode(message.desiredPodSecurityPolicyConfig, writer.uint32(114).fork()).join();
    }
    if (message.desiredMasterVersion !== "") {
      writer.uint32(802).string(message.desiredMasterVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClusterUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClusterUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 34) {
            break;
          }

          message.desiredNodeVersion = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.desiredMonitoringService = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.desiredAddonsConfig = AddonsConfig.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.desiredNodePoolId = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.desiredImageType = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.desiredNodePoolAutoscaling = NodePoolAutoscaling.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.desiredLocations.push(reader.string());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.desiredMasterAuthorizedNetworksConfig = MasterAuthorizedNetworksConfig.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.desiredPodSecurityPolicyConfig = PodSecurityPolicyConfig.decode(reader, reader.uint32());
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }

          message.desiredMasterVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClusterUpdate {
    return {
      desiredNodeVersion: isSet(object.desiredNodeVersion) ? globalThis.String(object.desiredNodeVersion) : "",
      desiredMonitoringService: isSet(object.desiredMonitoringService)
        ? globalThis.String(object.desiredMonitoringService)
        : "",
      desiredAddonsConfig: isSet(object.desiredAddonsConfig)
        ? AddonsConfig.fromJSON(object.desiredAddonsConfig)
        : undefined,
      desiredNodePoolId: isSet(object.desiredNodePoolId) ? globalThis.String(object.desiredNodePoolId) : "",
      desiredImageType: isSet(object.desiredImageType) ? globalThis.String(object.desiredImageType) : "",
      desiredNodePoolAutoscaling: isSet(object.desiredNodePoolAutoscaling)
        ? NodePoolAutoscaling.fromJSON(object.desiredNodePoolAutoscaling)
        : undefined,
      desiredLocations: globalThis.Array.isArray(object?.desiredLocations)
        ? object.desiredLocations.map((e: any) => globalThis.String(e))
        : [],
      desiredMasterAuthorizedNetworksConfig: isSet(object.desiredMasterAuthorizedNetworksConfig)
        ? MasterAuthorizedNetworksConfig.fromJSON(object.desiredMasterAuthorizedNetworksConfig)
        : undefined,
      desiredPodSecurityPolicyConfig: isSet(object.desiredPodSecurityPolicyConfig)
        ? PodSecurityPolicyConfig.fromJSON(object.desiredPodSecurityPolicyConfig)
        : undefined,
      desiredMasterVersion: isSet(object.desiredMasterVersion) ? globalThis.String(object.desiredMasterVersion) : "",
    };
  },

  toJSON(message: ClusterUpdate): unknown {
    const obj: any = {};
    if (message.desiredNodeVersion !== "") {
      obj.desiredNodeVersion = message.desiredNodeVersion;
    }
    if (message.desiredMonitoringService !== "") {
      obj.desiredMonitoringService = message.desiredMonitoringService;
    }
    if (message.desiredAddonsConfig !== undefined) {
      obj.desiredAddonsConfig = AddonsConfig.toJSON(message.desiredAddonsConfig);
    }
    if (message.desiredNodePoolId !== "") {
      obj.desiredNodePoolId = message.desiredNodePoolId;
    }
    if (message.desiredImageType !== "") {
      obj.desiredImageType = message.desiredImageType;
    }
    if (message.desiredNodePoolAutoscaling !== undefined) {
      obj.desiredNodePoolAutoscaling = NodePoolAutoscaling.toJSON(message.desiredNodePoolAutoscaling);
    }
    if (message.desiredLocations?.length) {
      obj.desiredLocations = message.desiredLocations;
    }
    if (message.desiredMasterAuthorizedNetworksConfig !== undefined) {
      obj.desiredMasterAuthorizedNetworksConfig = MasterAuthorizedNetworksConfig.toJSON(
        message.desiredMasterAuthorizedNetworksConfig,
      );
    }
    if (message.desiredPodSecurityPolicyConfig !== undefined) {
      obj.desiredPodSecurityPolicyConfig = PodSecurityPolicyConfig.toJSON(message.desiredPodSecurityPolicyConfig);
    }
    if (message.desiredMasterVersion !== "") {
      obj.desiredMasterVersion = message.desiredMasterVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<ClusterUpdate>): ClusterUpdate {
    return ClusterUpdate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClusterUpdate>): ClusterUpdate {
    const message = createBaseClusterUpdate();
    message.desiredNodeVersion = object.desiredNodeVersion ?? "";
    message.desiredMonitoringService = object.desiredMonitoringService ?? "";
    message.desiredAddonsConfig = (object.desiredAddonsConfig !== undefined && object.desiredAddonsConfig !== null)
      ? AddonsConfig.fromPartial(object.desiredAddonsConfig)
      : undefined;
    message.desiredNodePoolId = object.desiredNodePoolId ?? "";
    message.desiredImageType = object.desiredImageType ?? "";
    message.desiredNodePoolAutoscaling =
      (object.desiredNodePoolAutoscaling !== undefined && object.desiredNodePoolAutoscaling !== null)
        ? NodePoolAutoscaling.fromPartial(object.desiredNodePoolAutoscaling)
        : undefined;
    message.desiredLocations = object.desiredLocations?.map((e) => e) || [];
    message.desiredMasterAuthorizedNetworksConfig =
      (object.desiredMasterAuthorizedNetworksConfig !== undefined &&
          object.desiredMasterAuthorizedNetworksConfig !== null)
        ? MasterAuthorizedNetworksConfig.fromPartial(object.desiredMasterAuthorizedNetworksConfig)
        : undefined;
    message.desiredPodSecurityPolicyConfig =
      (object.desiredPodSecurityPolicyConfig !== undefined && object.desiredPodSecurityPolicyConfig !== null)
        ? PodSecurityPolicyConfig.fromPartial(object.desiredPodSecurityPolicyConfig)
        : undefined;
    message.desiredMasterVersion = object.desiredMasterVersion ?? "";
    return message;
  },
};

function createBaseOperation(): Operation {
  return {
    name: "",
    zone: "",
    operationType: 0,
    status: 0,
    detail: "",
    statusMessage: "",
    selfLink: "",
    targetLink: "",
    location: "",
    startTime: "",
    endTime: "",
  };
}

export const Operation: MessageFns<Operation> = {
  encode(message: Operation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.operationType !== 0) {
      writer.uint32(24).int32(message.operationType);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    if (message.detail !== "") {
      writer.uint32(66).string(message.detail);
    }
    if (message.statusMessage !== "") {
      writer.uint32(42).string(message.statusMessage);
    }
    if (message.selfLink !== "") {
      writer.uint32(50).string(message.selfLink);
    }
    if (message.targetLink !== "") {
      writer.uint32(58).string(message.targetLink);
    }
    if (message.location !== "") {
      writer.uint32(74).string(message.location);
    }
    if (message.startTime !== "") {
      writer.uint32(82).string(message.startTime);
    }
    if (message.endTime !== "") {
      writer.uint32(90).string(message.endTime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Operation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.operationType = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.detail = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.statusMessage = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.selfLink = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.targetLink = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.location = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.startTime = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.endTime = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Operation {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      operationType: isSet(object.operationType) ? operation_TypeFromJSON(object.operationType) : 0,
      status: isSet(object.status) ? operation_StatusFromJSON(object.status) : 0,
      detail: isSet(object.detail) ? globalThis.String(object.detail) : "",
      statusMessage: isSet(object.statusMessage) ? globalThis.String(object.statusMessage) : "",
      selfLink: isSet(object.selfLink) ? globalThis.String(object.selfLink) : "",
      targetLink: isSet(object.targetLink) ? globalThis.String(object.targetLink) : "",
      location: isSet(object.location) ? globalThis.String(object.location) : "",
      startTime: isSet(object.startTime) ? globalThis.String(object.startTime) : "",
      endTime: isSet(object.endTime) ? globalThis.String(object.endTime) : "",
    };
  },

  toJSON(message: Operation): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.operationType !== 0) {
      obj.operationType = operation_TypeToJSON(message.operationType);
    }
    if (message.status !== 0) {
      obj.status = operation_StatusToJSON(message.status);
    }
    if (message.detail !== "") {
      obj.detail = message.detail;
    }
    if (message.statusMessage !== "") {
      obj.statusMessage = message.statusMessage;
    }
    if (message.selfLink !== "") {
      obj.selfLink = message.selfLink;
    }
    if (message.targetLink !== "") {
      obj.targetLink = message.targetLink;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.startTime !== "") {
      obj.startTime = message.startTime;
    }
    if (message.endTime !== "") {
      obj.endTime = message.endTime;
    }
    return obj;
  },

  create(base?: DeepPartial<Operation>): Operation {
    return Operation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Operation>): Operation {
    const message = createBaseOperation();
    message.name = object.name ?? "";
    message.zone = object.zone ?? "";
    message.operationType = object.operationType ?? 0;
    message.status = object.status ?? 0;
    message.detail = object.detail ?? "";
    message.statusMessage = object.statusMessage ?? "";
    message.selfLink = object.selfLink ?? "";
    message.targetLink = object.targetLink ?? "";
    message.location = object.location ?? "";
    message.startTime = object.startTime ?? "";
    message.endTime = object.endTime ?? "";
    return message;
  },
};

function createBaseCreateClusterRequest(): CreateClusterRequest {
  return { projectId: "", zone: "", cluster: undefined, parent: "" };
}

export const CreateClusterRequest: MessageFns<CreateClusterRequest> = {
  encode(message: CreateClusterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.cluster !== undefined) {
      Cluster.encode(message.cluster, writer.uint32(26).fork()).join();
    }
    if (message.parent !== "") {
      writer.uint32(42).string(message.parent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateClusterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateClusterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cluster = Cluster.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.parent = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateClusterRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      cluster: isSet(object.cluster) ? Cluster.fromJSON(object.cluster) : undefined,
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
    };
  },

  toJSON(message: CreateClusterRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.cluster !== undefined) {
      obj.cluster = Cluster.toJSON(message.cluster);
    }
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateClusterRequest>): CreateClusterRequest {
    return CreateClusterRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateClusterRequest>): CreateClusterRequest {
    const message = createBaseCreateClusterRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.cluster = (object.cluster !== undefined && object.cluster !== null)
      ? Cluster.fromPartial(object.cluster)
      : undefined;
    message.parent = object.parent ?? "";
    return message;
  },
};

function createBaseGetClusterRequest(): GetClusterRequest {
  return { projectId: "", zone: "", clusterId: "", name: "" };
}

export const GetClusterRequest: MessageFns<GetClusterRequest> = {
  encode(message: GetClusterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.name !== "") {
      writer.uint32(42).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetClusterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetClusterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetClusterRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: GetClusterRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetClusterRequest>): GetClusterRequest {
    return GetClusterRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetClusterRequest>): GetClusterRequest {
    const message = createBaseGetClusterRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateClusterRequest(): UpdateClusterRequest {
  return { projectId: "", zone: "", clusterId: "", update: undefined, name: "" };
}

export const UpdateClusterRequest: MessageFns<UpdateClusterRequest> = {
  encode(message: UpdateClusterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.update !== undefined) {
      ClusterUpdate.encode(message.update, writer.uint32(34).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(42).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateClusterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateClusterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.update = ClusterUpdate.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateClusterRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      update: isSet(object.update) ? ClusterUpdate.fromJSON(object.update) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: UpdateClusterRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.update !== undefined) {
      obj.update = ClusterUpdate.toJSON(message.update);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateClusterRequest>): UpdateClusterRequest {
    return UpdateClusterRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateClusterRequest>): UpdateClusterRequest {
    const message = createBaseUpdateClusterRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.update = (object.update !== undefined && object.update !== null)
      ? ClusterUpdate.fromPartial(object.update)
      : undefined;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateNodePoolRequest(): UpdateNodePoolRequest {
  return { projectId: "", zone: "", clusterId: "", nodePoolId: "", nodeVersion: "", imageType: "", name: "" };
}

export const UpdateNodePoolRequest: MessageFns<UpdateNodePoolRequest> = {
  encode(message: UpdateNodePoolRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.nodePoolId !== "") {
      writer.uint32(34).string(message.nodePoolId);
    }
    if (message.nodeVersion !== "") {
      writer.uint32(42).string(message.nodeVersion);
    }
    if (message.imageType !== "") {
      writer.uint32(50).string(message.imageType);
    }
    if (message.name !== "") {
      writer.uint32(66).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateNodePoolRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateNodePoolRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.nodePoolId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.nodeVersion = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.imageType = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateNodePoolRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      nodePoolId: isSet(object.nodePoolId) ? globalThis.String(object.nodePoolId) : "",
      nodeVersion: isSet(object.nodeVersion) ? globalThis.String(object.nodeVersion) : "",
      imageType: isSet(object.imageType) ? globalThis.String(object.imageType) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: UpdateNodePoolRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.nodePoolId !== "") {
      obj.nodePoolId = message.nodePoolId;
    }
    if (message.nodeVersion !== "") {
      obj.nodeVersion = message.nodeVersion;
    }
    if (message.imageType !== "") {
      obj.imageType = message.imageType;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateNodePoolRequest>): UpdateNodePoolRequest {
    return UpdateNodePoolRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateNodePoolRequest>): UpdateNodePoolRequest {
    const message = createBaseUpdateNodePoolRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.nodePoolId = object.nodePoolId ?? "";
    message.nodeVersion = object.nodeVersion ?? "";
    message.imageType = object.imageType ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseSetNodePoolAutoscalingRequest(): SetNodePoolAutoscalingRequest {
  return { projectId: "", zone: "", clusterId: "", nodePoolId: "", autoscaling: undefined, name: "" };
}

export const SetNodePoolAutoscalingRequest: MessageFns<SetNodePoolAutoscalingRequest> = {
  encode(message: SetNodePoolAutoscalingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.nodePoolId !== "") {
      writer.uint32(34).string(message.nodePoolId);
    }
    if (message.autoscaling !== undefined) {
      NodePoolAutoscaling.encode(message.autoscaling, writer.uint32(42).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(50).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetNodePoolAutoscalingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetNodePoolAutoscalingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.nodePoolId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.autoscaling = NodePoolAutoscaling.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetNodePoolAutoscalingRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      nodePoolId: isSet(object.nodePoolId) ? globalThis.String(object.nodePoolId) : "",
      autoscaling: isSet(object.autoscaling) ? NodePoolAutoscaling.fromJSON(object.autoscaling) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: SetNodePoolAutoscalingRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.nodePoolId !== "") {
      obj.nodePoolId = message.nodePoolId;
    }
    if (message.autoscaling !== undefined) {
      obj.autoscaling = NodePoolAutoscaling.toJSON(message.autoscaling);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<SetNodePoolAutoscalingRequest>): SetNodePoolAutoscalingRequest {
    return SetNodePoolAutoscalingRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SetNodePoolAutoscalingRequest>): SetNodePoolAutoscalingRequest {
    const message = createBaseSetNodePoolAutoscalingRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.nodePoolId = object.nodePoolId ?? "";
    message.autoscaling = (object.autoscaling !== undefined && object.autoscaling !== null)
      ? NodePoolAutoscaling.fromPartial(object.autoscaling)
      : undefined;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseSetLoggingServiceRequest(): SetLoggingServiceRequest {
  return { projectId: "", zone: "", clusterId: "", loggingService: "", name: "" };
}

export const SetLoggingServiceRequest: MessageFns<SetLoggingServiceRequest> = {
  encode(message: SetLoggingServiceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.loggingService !== "") {
      writer.uint32(34).string(message.loggingService);
    }
    if (message.name !== "") {
      writer.uint32(42).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetLoggingServiceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetLoggingServiceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.loggingService = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetLoggingServiceRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      loggingService: isSet(object.loggingService) ? globalThis.String(object.loggingService) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: SetLoggingServiceRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.loggingService !== "") {
      obj.loggingService = message.loggingService;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<SetLoggingServiceRequest>): SetLoggingServiceRequest {
    return SetLoggingServiceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SetLoggingServiceRequest>): SetLoggingServiceRequest {
    const message = createBaseSetLoggingServiceRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.loggingService = object.loggingService ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseSetMonitoringServiceRequest(): SetMonitoringServiceRequest {
  return { projectId: "", zone: "", clusterId: "", monitoringService: "", name: "" };
}

export const SetMonitoringServiceRequest: MessageFns<SetMonitoringServiceRequest> = {
  encode(message: SetMonitoringServiceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.monitoringService !== "") {
      writer.uint32(34).string(message.monitoringService);
    }
    if (message.name !== "") {
      writer.uint32(50).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetMonitoringServiceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetMonitoringServiceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.monitoringService = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetMonitoringServiceRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      monitoringService: isSet(object.monitoringService) ? globalThis.String(object.monitoringService) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: SetMonitoringServiceRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.monitoringService !== "") {
      obj.monitoringService = message.monitoringService;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<SetMonitoringServiceRequest>): SetMonitoringServiceRequest {
    return SetMonitoringServiceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SetMonitoringServiceRequest>): SetMonitoringServiceRequest {
    const message = createBaseSetMonitoringServiceRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.monitoringService = object.monitoringService ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseSetAddonsConfigRequest(): SetAddonsConfigRequest {
  return { projectId: "", zone: "", clusterId: "", addonsConfig: undefined, name: "" };
}

export const SetAddonsConfigRequest: MessageFns<SetAddonsConfigRequest> = {
  encode(message: SetAddonsConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.addonsConfig !== undefined) {
      AddonsConfig.encode(message.addonsConfig, writer.uint32(34).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(50).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetAddonsConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetAddonsConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.addonsConfig = AddonsConfig.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetAddonsConfigRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      addonsConfig: isSet(object.addonsConfig) ? AddonsConfig.fromJSON(object.addonsConfig) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: SetAddonsConfigRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.addonsConfig !== undefined) {
      obj.addonsConfig = AddonsConfig.toJSON(message.addonsConfig);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<SetAddonsConfigRequest>): SetAddonsConfigRequest {
    return SetAddonsConfigRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SetAddonsConfigRequest>): SetAddonsConfigRequest {
    const message = createBaseSetAddonsConfigRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.addonsConfig = (object.addonsConfig !== undefined && object.addonsConfig !== null)
      ? AddonsConfig.fromPartial(object.addonsConfig)
      : undefined;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseSetLocationsRequest(): SetLocationsRequest {
  return { projectId: "", zone: "", clusterId: "", locations: [], name: "" };
}

export const SetLocationsRequest: MessageFns<SetLocationsRequest> = {
  encode(message: SetLocationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    for (const v of message.locations) {
      writer.uint32(34).string(v!);
    }
    if (message.name !== "") {
      writer.uint32(50).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetLocationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetLocationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.locations.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetLocationsRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      locations: globalThis.Array.isArray(object?.locations)
        ? object.locations.map((e: any) => globalThis.String(e))
        : [],
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: SetLocationsRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.locations?.length) {
      obj.locations = message.locations;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<SetLocationsRequest>): SetLocationsRequest {
    return SetLocationsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SetLocationsRequest>): SetLocationsRequest {
    const message = createBaseSetLocationsRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.locations = object.locations?.map((e) => e) || [];
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateMasterRequest(): UpdateMasterRequest {
  return { projectId: "", zone: "", clusterId: "", masterVersion: "", name: "" };
}

export const UpdateMasterRequest: MessageFns<UpdateMasterRequest> = {
  encode(message: UpdateMasterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.masterVersion !== "") {
      writer.uint32(34).string(message.masterVersion);
    }
    if (message.name !== "") {
      writer.uint32(58).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateMasterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateMasterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.masterVersion = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateMasterRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      masterVersion: isSet(object.masterVersion) ? globalThis.String(object.masterVersion) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: UpdateMasterRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.masterVersion !== "") {
      obj.masterVersion = message.masterVersion;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateMasterRequest>): UpdateMasterRequest {
    return UpdateMasterRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateMasterRequest>): UpdateMasterRequest {
    const message = createBaseUpdateMasterRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.masterVersion = object.masterVersion ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseSetMasterAuthRequest(): SetMasterAuthRequest {
  return { projectId: "", zone: "", clusterId: "", action: 0, update: undefined, name: "" };
}

export const SetMasterAuthRequest: MessageFns<SetMasterAuthRequest> = {
  encode(message: SetMasterAuthRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.action !== 0) {
      writer.uint32(32).int32(message.action);
    }
    if (message.update !== undefined) {
      MasterAuth.encode(message.update, writer.uint32(42).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(58).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetMasterAuthRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetMasterAuthRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.update = MasterAuth.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetMasterAuthRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      action: isSet(object.action) ? setMasterAuthRequest_ActionFromJSON(object.action) : 0,
      update: isSet(object.update) ? MasterAuth.fromJSON(object.update) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: SetMasterAuthRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.action !== 0) {
      obj.action = setMasterAuthRequest_ActionToJSON(message.action);
    }
    if (message.update !== undefined) {
      obj.update = MasterAuth.toJSON(message.update);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<SetMasterAuthRequest>): SetMasterAuthRequest {
    return SetMasterAuthRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SetMasterAuthRequest>): SetMasterAuthRequest {
    const message = createBaseSetMasterAuthRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.action = object.action ?? 0;
    message.update = (object.update !== undefined && object.update !== null)
      ? MasterAuth.fromPartial(object.update)
      : undefined;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteClusterRequest(): DeleteClusterRequest {
  return { projectId: "", zone: "", clusterId: "", name: "" };
}

export const DeleteClusterRequest: MessageFns<DeleteClusterRequest> = {
  encode(message: DeleteClusterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteClusterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteClusterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteClusterRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: DeleteClusterRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteClusterRequest>): DeleteClusterRequest {
    return DeleteClusterRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteClusterRequest>): DeleteClusterRequest {
    const message = createBaseDeleteClusterRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListClustersRequest(): ListClustersRequest {
  return { projectId: "", zone: "", parent: "" };
}

export const ListClustersRequest: MessageFns<ListClustersRequest> = {
  encode(message: ListClustersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.parent !== "") {
      writer.uint32(34).string(message.parent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListClustersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListClustersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.parent = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListClustersRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
    };
  },

  toJSON(message: ListClustersRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    return obj;
  },

  create(base?: DeepPartial<ListClustersRequest>): ListClustersRequest {
    return ListClustersRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListClustersRequest>): ListClustersRequest {
    const message = createBaseListClustersRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.parent = object.parent ?? "";
    return message;
  },
};

function createBaseListClustersResponse(): ListClustersResponse {
  return { clusters: [], missingZones: [] };
}

export const ListClustersResponse: MessageFns<ListClustersResponse> = {
  encode(message: ListClustersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.clusters) {
      Cluster.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.missingZones) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListClustersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListClustersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clusters.push(Cluster.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.missingZones.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListClustersResponse {
    return {
      clusters: globalThis.Array.isArray(object?.clusters) ? object.clusters.map((e: any) => Cluster.fromJSON(e)) : [],
      missingZones: globalThis.Array.isArray(object?.missingZones)
        ? object.missingZones.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListClustersResponse): unknown {
    const obj: any = {};
    if (message.clusters?.length) {
      obj.clusters = message.clusters.map((e) => Cluster.toJSON(e));
    }
    if (message.missingZones?.length) {
      obj.missingZones = message.missingZones;
    }
    return obj;
  },

  create(base?: DeepPartial<ListClustersResponse>): ListClustersResponse {
    return ListClustersResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListClustersResponse>): ListClustersResponse {
    const message = createBaseListClustersResponse();
    message.clusters = object.clusters?.map((e) => Cluster.fromPartial(e)) || [];
    message.missingZones = object.missingZones?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetOperationRequest(): GetOperationRequest {
  return { projectId: "", zone: "", operationId: "", name: "" };
}

export const GetOperationRequest: MessageFns<GetOperationRequest> = {
  encode(message: GetOperationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.operationId !== "") {
      writer.uint32(26).string(message.operationId);
    }
    if (message.name !== "") {
      writer.uint32(42).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOperationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOperationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.operationId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOperationRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      operationId: isSet(object.operationId) ? globalThis.String(object.operationId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: GetOperationRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.operationId !== "") {
      obj.operationId = message.operationId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetOperationRequest>): GetOperationRequest {
    return GetOperationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetOperationRequest>): GetOperationRequest {
    const message = createBaseGetOperationRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.operationId = object.operationId ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListOperationsRequest(): ListOperationsRequest {
  return { projectId: "", zone: "", parent: "" };
}

export const ListOperationsRequest: MessageFns<ListOperationsRequest> = {
  encode(message: ListOperationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.parent !== "") {
      writer.uint32(34).string(message.parent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListOperationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOperationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.parent = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListOperationsRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
    };
  },

  toJSON(message: ListOperationsRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    return obj;
  },

  create(base?: DeepPartial<ListOperationsRequest>): ListOperationsRequest {
    return ListOperationsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListOperationsRequest>): ListOperationsRequest {
    const message = createBaseListOperationsRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.parent = object.parent ?? "";
    return message;
  },
};

function createBaseCancelOperationRequest(): CancelOperationRequest {
  return { projectId: "", zone: "", operationId: "", name: "" };
}

export const CancelOperationRequest: MessageFns<CancelOperationRequest> = {
  encode(message: CancelOperationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.operationId !== "") {
      writer.uint32(26).string(message.operationId);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelOperationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelOperationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.operationId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelOperationRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      operationId: isSet(object.operationId) ? globalThis.String(object.operationId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: CancelOperationRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.operationId !== "") {
      obj.operationId = message.operationId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<CancelOperationRequest>): CancelOperationRequest {
    return CancelOperationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CancelOperationRequest>): CancelOperationRequest {
    const message = createBaseCancelOperationRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.operationId = object.operationId ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListOperationsResponse(): ListOperationsResponse {
  return { operations: [], missingZones: [] };
}

export const ListOperationsResponse: MessageFns<ListOperationsResponse> = {
  encode(message: ListOperationsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.operations) {
      Operation.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.missingZones) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListOperationsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOperationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.operations.push(Operation.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.missingZones.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListOperationsResponse {
    return {
      operations: globalThis.Array.isArray(object?.operations)
        ? object.operations.map((e: any) => Operation.fromJSON(e))
        : [],
      missingZones: globalThis.Array.isArray(object?.missingZones)
        ? object.missingZones.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListOperationsResponse): unknown {
    const obj: any = {};
    if (message.operations?.length) {
      obj.operations = message.operations.map((e) => Operation.toJSON(e));
    }
    if (message.missingZones?.length) {
      obj.missingZones = message.missingZones;
    }
    return obj;
  },

  create(base?: DeepPartial<ListOperationsResponse>): ListOperationsResponse {
    return ListOperationsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListOperationsResponse>): ListOperationsResponse {
    const message = createBaseListOperationsResponse();
    message.operations = object.operations?.map((e) => Operation.fromPartial(e)) || [];
    message.missingZones = object.missingZones?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetServerConfigRequest(): GetServerConfigRequest {
  return { projectId: "", zone: "", name: "" };
}

export const GetServerConfigRequest: MessageFns<GetServerConfigRequest> = {
  encode(message: GetServerConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetServerConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetServerConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetServerConfigRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: GetServerConfigRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetServerConfigRequest>): GetServerConfigRequest {
    return GetServerConfigRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetServerConfigRequest>): GetServerConfigRequest {
    const message = createBaseGetServerConfigRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseServerConfig(): ServerConfig {
  return {
    defaultClusterVersion: "",
    validNodeVersions: [],
    defaultImageType: "",
    validImageTypes: [],
    validMasterVersions: [],
  };
}

export const ServerConfig: MessageFns<ServerConfig> = {
  encode(message: ServerConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.defaultClusterVersion !== "") {
      writer.uint32(10).string(message.defaultClusterVersion);
    }
    for (const v of message.validNodeVersions) {
      writer.uint32(26).string(v!);
    }
    if (message.defaultImageType !== "") {
      writer.uint32(34).string(message.defaultImageType);
    }
    for (const v of message.validImageTypes) {
      writer.uint32(42).string(v!);
    }
    for (const v of message.validMasterVersions) {
      writer.uint32(50).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.defaultClusterVersion = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.validNodeVersions.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.defaultImageType = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.validImageTypes.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.validMasterVersions.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerConfig {
    return {
      defaultClusterVersion: isSet(object.defaultClusterVersion) ? globalThis.String(object.defaultClusterVersion) : "",
      validNodeVersions: globalThis.Array.isArray(object?.validNodeVersions)
        ? object.validNodeVersions.map((e: any) => globalThis.String(e))
        : [],
      defaultImageType: isSet(object.defaultImageType) ? globalThis.String(object.defaultImageType) : "",
      validImageTypes: globalThis.Array.isArray(object?.validImageTypes)
        ? object.validImageTypes.map((e: any) => globalThis.String(e))
        : [],
      validMasterVersions: globalThis.Array.isArray(object?.validMasterVersions)
        ? object.validMasterVersions.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ServerConfig): unknown {
    const obj: any = {};
    if (message.defaultClusterVersion !== "") {
      obj.defaultClusterVersion = message.defaultClusterVersion;
    }
    if (message.validNodeVersions?.length) {
      obj.validNodeVersions = message.validNodeVersions;
    }
    if (message.defaultImageType !== "") {
      obj.defaultImageType = message.defaultImageType;
    }
    if (message.validImageTypes?.length) {
      obj.validImageTypes = message.validImageTypes;
    }
    if (message.validMasterVersions?.length) {
      obj.validMasterVersions = message.validMasterVersions;
    }
    return obj;
  },

  create(base?: DeepPartial<ServerConfig>): ServerConfig {
    return ServerConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ServerConfig>): ServerConfig {
    const message = createBaseServerConfig();
    message.defaultClusterVersion = object.defaultClusterVersion ?? "";
    message.validNodeVersions = object.validNodeVersions?.map((e) => e) || [];
    message.defaultImageType = object.defaultImageType ?? "";
    message.validImageTypes = object.validImageTypes?.map((e) => e) || [];
    message.validMasterVersions = object.validMasterVersions?.map((e) => e) || [];
    return message;
  },
};

function createBaseCreateNodePoolRequest(): CreateNodePoolRequest {
  return { projectId: "", zone: "", clusterId: "", nodePool: undefined, parent: "" };
}

export const CreateNodePoolRequest: MessageFns<CreateNodePoolRequest> = {
  encode(message: CreateNodePoolRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.nodePool !== undefined) {
      NodePool.encode(message.nodePool, writer.uint32(34).fork()).join();
    }
    if (message.parent !== "") {
      writer.uint32(50).string(message.parent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateNodePoolRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateNodePoolRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.nodePool = NodePool.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.parent = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateNodePoolRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      nodePool: isSet(object.nodePool) ? NodePool.fromJSON(object.nodePool) : undefined,
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
    };
  },

  toJSON(message: CreateNodePoolRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.nodePool !== undefined) {
      obj.nodePool = NodePool.toJSON(message.nodePool);
    }
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateNodePoolRequest>): CreateNodePoolRequest {
    return CreateNodePoolRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateNodePoolRequest>): CreateNodePoolRequest {
    const message = createBaseCreateNodePoolRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.nodePool = (object.nodePool !== undefined && object.nodePool !== null)
      ? NodePool.fromPartial(object.nodePool)
      : undefined;
    message.parent = object.parent ?? "";
    return message;
  },
};

function createBaseDeleteNodePoolRequest(): DeleteNodePoolRequest {
  return { projectId: "", zone: "", clusterId: "", nodePoolId: "", name: "" };
}

export const DeleteNodePoolRequest: MessageFns<DeleteNodePoolRequest> = {
  encode(message: DeleteNodePoolRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.nodePoolId !== "") {
      writer.uint32(34).string(message.nodePoolId);
    }
    if (message.name !== "") {
      writer.uint32(50).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteNodePoolRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteNodePoolRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.nodePoolId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteNodePoolRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      nodePoolId: isSet(object.nodePoolId) ? globalThis.String(object.nodePoolId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: DeleteNodePoolRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.nodePoolId !== "") {
      obj.nodePoolId = message.nodePoolId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteNodePoolRequest>): DeleteNodePoolRequest {
    return DeleteNodePoolRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteNodePoolRequest>): DeleteNodePoolRequest {
    const message = createBaseDeleteNodePoolRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.nodePoolId = object.nodePoolId ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListNodePoolsRequest(): ListNodePoolsRequest {
  return { projectId: "", zone: "", clusterId: "", parent: "" };
}

export const ListNodePoolsRequest: MessageFns<ListNodePoolsRequest> = {
  encode(message: ListNodePoolsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.parent !== "") {
      writer.uint32(42).string(message.parent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNodePoolsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNodePoolsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.parent = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNodePoolsRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
    };
  },

  toJSON(message: ListNodePoolsRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    return obj;
  },

  create(base?: DeepPartial<ListNodePoolsRequest>): ListNodePoolsRequest {
    return ListNodePoolsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListNodePoolsRequest>): ListNodePoolsRequest {
    const message = createBaseListNodePoolsRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.parent = object.parent ?? "";
    return message;
  },
};

function createBaseGetNodePoolRequest(): GetNodePoolRequest {
  return { projectId: "", zone: "", clusterId: "", nodePoolId: "", name: "" };
}

export const GetNodePoolRequest: MessageFns<GetNodePoolRequest> = {
  encode(message: GetNodePoolRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.nodePoolId !== "") {
      writer.uint32(34).string(message.nodePoolId);
    }
    if (message.name !== "") {
      writer.uint32(50).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNodePoolRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNodePoolRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.nodePoolId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNodePoolRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      nodePoolId: isSet(object.nodePoolId) ? globalThis.String(object.nodePoolId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: GetNodePoolRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.nodePoolId !== "") {
      obj.nodePoolId = message.nodePoolId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetNodePoolRequest>): GetNodePoolRequest {
    return GetNodePoolRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetNodePoolRequest>): GetNodePoolRequest {
    const message = createBaseGetNodePoolRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.nodePoolId = object.nodePoolId ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseNodePool(): NodePool {
  return {
    name: "",
    config: undefined,
    initialNodeCount: 0,
    autoscaling: undefined,
    management: undefined,
    selfLink: "",
    version: "",
    instanceGroupUrls: [],
    status: 0,
    statusMessage: "",
  };
}

export const NodePool: MessageFns<NodePool> = {
  encode(message: NodePool, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.config !== undefined) {
      NodeConfig.encode(message.config, writer.uint32(18).fork()).join();
    }
    if (message.initialNodeCount !== 0) {
      writer.uint32(24).int32(message.initialNodeCount);
    }
    if (message.autoscaling !== undefined) {
      NodePoolAutoscaling.encode(message.autoscaling, writer.uint32(34).fork()).join();
    }
    if (message.management !== undefined) {
      NodeManagement.encode(message.management, writer.uint32(42).fork()).join();
    }
    if (message.selfLink !== "") {
      writer.uint32(802).string(message.selfLink);
    }
    if (message.version !== "") {
      writer.uint32(810).string(message.version);
    }
    for (const v of message.instanceGroupUrls) {
      writer.uint32(818).string(v!);
    }
    if (message.status !== 0) {
      writer.uint32(824).int32(message.status);
    }
    if (message.statusMessage !== "") {
      writer.uint32(834).string(message.statusMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodePool {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodePool();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.config = NodeConfig.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.initialNodeCount = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.autoscaling = NodePoolAutoscaling.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.management = NodeManagement.decode(reader, reader.uint32());
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }

          message.selfLink = reader.string();
          continue;
        case 101:
          if (tag !== 810) {
            break;
          }

          message.version = reader.string();
          continue;
        case 102:
          if (tag !== 818) {
            break;
          }

          message.instanceGroupUrls.push(reader.string());
          continue;
        case 103:
          if (tag !== 824) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 104:
          if (tag !== 834) {
            break;
          }

          message.statusMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodePool {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      config: isSet(object.config) ? NodeConfig.fromJSON(object.config) : undefined,
      initialNodeCount: isSet(object.initialNodeCount) ? globalThis.Number(object.initialNodeCount) : 0,
      autoscaling: isSet(object.autoscaling) ? NodePoolAutoscaling.fromJSON(object.autoscaling) : undefined,
      management: isSet(object.management) ? NodeManagement.fromJSON(object.management) : undefined,
      selfLink: isSet(object.selfLink) ? globalThis.String(object.selfLink) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      instanceGroupUrls: globalThis.Array.isArray(object?.instanceGroupUrls)
        ? object.instanceGroupUrls.map((e: any) => globalThis.String(e))
        : [],
      status: isSet(object.status) ? nodePool_StatusFromJSON(object.status) : 0,
      statusMessage: isSet(object.statusMessage) ? globalThis.String(object.statusMessage) : "",
    };
  },

  toJSON(message: NodePool): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.config !== undefined) {
      obj.config = NodeConfig.toJSON(message.config);
    }
    if (message.initialNodeCount !== 0) {
      obj.initialNodeCount = Math.round(message.initialNodeCount);
    }
    if (message.autoscaling !== undefined) {
      obj.autoscaling = NodePoolAutoscaling.toJSON(message.autoscaling);
    }
    if (message.management !== undefined) {
      obj.management = NodeManagement.toJSON(message.management);
    }
    if (message.selfLink !== "") {
      obj.selfLink = message.selfLink;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.instanceGroupUrls?.length) {
      obj.instanceGroupUrls = message.instanceGroupUrls;
    }
    if (message.status !== 0) {
      obj.status = nodePool_StatusToJSON(message.status);
    }
    if (message.statusMessage !== "") {
      obj.statusMessage = message.statusMessage;
    }
    return obj;
  },

  create(base?: DeepPartial<NodePool>): NodePool {
    return NodePool.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodePool>): NodePool {
    const message = createBaseNodePool();
    message.name = object.name ?? "";
    message.config = (object.config !== undefined && object.config !== null)
      ? NodeConfig.fromPartial(object.config)
      : undefined;
    message.initialNodeCount = object.initialNodeCount ?? 0;
    message.autoscaling = (object.autoscaling !== undefined && object.autoscaling !== null)
      ? NodePoolAutoscaling.fromPartial(object.autoscaling)
      : undefined;
    message.management = (object.management !== undefined && object.management !== null)
      ? NodeManagement.fromPartial(object.management)
      : undefined;
    message.selfLink = object.selfLink ?? "";
    message.version = object.version ?? "";
    message.instanceGroupUrls = object.instanceGroupUrls?.map((e) => e) || [];
    message.status = object.status ?? 0;
    message.statusMessage = object.statusMessage ?? "";
    return message;
  },
};

function createBaseNodeManagement(): NodeManagement {
  return { autoUpgrade: false, autoRepair: false, upgradeOptions: undefined };
}

export const NodeManagement: MessageFns<NodeManagement> = {
  encode(message: NodeManagement, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.autoUpgrade !== false) {
      writer.uint32(8).bool(message.autoUpgrade);
    }
    if (message.autoRepair !== false) {
      writer.uint32(16).bool(message.autoRepair);
    }
    if (message.upgradeOptions !== undefined) {
      AutoUpgradeOptions.encode(message.upgradeOptions, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeManagement {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeManagement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.autoUpgrade = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.autoRepair = reader.bool();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.upgradeOptions = AutoUpgradeOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeManagement {
    return {
      autoUpgrade: isSet(object.autoUpgrade) ? globalThis.Boolean(object.autoUpgrade) : false,
      autoRepair: isSet(object.autoRepair) ? globalThis.Boolean(object.autoRepair) : false,
      upgradeOptions: isSet(object.upgradeOptions) ? AutoUpgradeOptions.fromJSON(object.upgradeOptions) : undefined,
    };
  },

  toJSON(message: NodeManagement): unknown {
    const obj: any = {};
    if (message.autoUpgrade !== false) {
      obj.autoUpgrade = message.autoUpgrade;
    }
    if (message.autoRepair !== false) {
      obj.autoRepair = message.autoRepair;
    }
    if (message.upgradeOptions !== undefined) {
      obj.upgradeOptions = AutoUpgradeOptions.toJSON(message.upgradeOptions);
    }
    return obj;
  },

  create(base?: DeepPartial<NodeManagement>): NodeManagement {
    return NodeManagement.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeManagement>): NodeManagement {
    const message = createBaseNodeManagement();
    message.autoUpgrade = object.autoUpgrade ?? false;
    message.autoRepair = object.autoRepair ?? false;
    message.upgradeOptions = (object.upgradeOptions !== undefined && object.upgradeOptions !== null)
      ? AutoUpgradeOptions.fromPartial(object.upgradeOptions)
      : undefined;
    return message;
  },
};

function createBaseAutoUpgradeOptions(): AutoUpgradeOptions {
  return { autoUpgradeStartTime: "", description: "" };
}

export const AutoUpgradeOptions: MessageFns<AutoUpgradeOptions> = {
  encode(message: AutoUpgradeOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.autoUpgradeStartTime !== "") {
      writer.uint32(10).string(message.autoUpgradeStartTime);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutoUpgradeOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutoUpgradeOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.autoUpgradeStartTime = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutoUpgradeOptions {
    return {
      autoUpgradeStartTime: isSet(object.autoUpgradeStartTime) ? globalThis.String(object.autoUpgradeStartTime) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: AutoUpgradeOptions): unknown {
    const obj: any = {};
    if (message.autoUpgradeStartTime !== "") {
      obj.autoUpgradeStartTime = message.autoUpgradeStartTime;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create(base?: DeepPartial<AutoUpgradeOptions>): AutoUpgradeOptions {
    return AutoUpgradeOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AutoUpgradeOptions>): AutoUpgradeOptions {
    const message = createBaseAutoUpgradeOptions();
    message.autoUpgradeStartTime = object.autoUpgradeStartTime ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseMaintenancePolicy(): MaintenancePolicy {
  return { window: undefined };
}

export const MaintenancePolicy: MessageFns<MaintenancePolicy> = {
  encode(message: MaintenancePolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.window !== undefined) {
      MaintenanceWindow.encode(message.window, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MaintenancePolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMaintenancePolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.window = MaintenanceWindow.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MaintenancePolicy {
    return { window: isSet(object.window) ? MaintenanceWindow.fromJSON(object.window) : undefined };
  },

  toJSON(message: MaintenancePolicy): unknown {
    const obj: any = {};
    if (message.window !== undefined) {
      obj.window = MaintenanceWindow.toJSON(message.window);
    }
    return obj;
  },

  create(base?: DeepPartial<MaintenancePolicy>): MaintenancePolicy {
    return MaintenancePolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MaintenancePolicy>): MaintenancePolicy {
    const message = createBaseMaintenancePolicy();
    message.window = (object.window !== undefined && object.window !== null)
      ? MaintenanceWindow.fromPartial(object.window)
      : undefined;
    return message;
  },
};

function createBaseMaintenanceWindow(): MaintenanceWindow {
  return { dailyMaintenanceWindow: undefined };
}

export const MaintenanceWindow: MessageFns<MaintenanceWindow> = {
  encode(message: MaintenanceWindow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dailyMaintenanceWindow !== undefined) {
      DailyMaintenanceWindow.encode(message.dailyMaintenanceWindow, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MaintenanceWindow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMaintenanceWindow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dailyMaintenanceWindow = DailyMaintenanceWindow.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MaintenanceWindow {
    return {
      dailyMaintenanceWindow: isSet(object.dailyMaintenanceWindow)
        ? DailyMaintenanceWindow.fromJSON(object.dailyMaintenanceWindow)
        : undefined,
    };
  },

  toJSON(message: MaintenanceWindow): unknown {
    const obj: any = {};
    if (message.dailyMaintenanceWindow !== undefined) {
      obj.dailyMaintenanceWindow = DailyMaintenanceWindow.toJSON(message.dailyMaintenanceWindow);
    }
    return obj;
  },

  create(base?: DeepPartial<MaintenanceWindow>): MaintenanceWindow {
    return MaintenanceWindow.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MaintenanceWindow>): MaintenanceWindow {
    const message = createBaseMaintenanceWindow();
    message.dailyMaintenanceWindow =
      (object.dailyMaintenanceWindow !== undefined && object.dailyMaintenanceWindow !== null)
        ? DailyMaintenanceWindow.fromPartial(object.dailyMaintenanceWindow)
        : undefined;
    return message;
  },
};

function createBaseDailyMaintenanceWindow(): DailyMaintenanceWindow {
  return { startTime: "", duration: "" };
}

export const DailyMaintenanceWindow: MessageFns<DailyMaintenanceWindow> = {
  encode(message: DailyMaintenanceWindow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startTime !== "") {
      writer.uint32(18).string(message.startTime);
    }
    if (message.duration !== "") {
      writer.uint32(26).string(message.duration);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DailyMaintenanceWindow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDailyMaintenanceWindow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.startTime = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.duration = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DailyMaintenanceWindow {
    return {
      startTime: isSet(object.startTime) ? globalThis.String(object.startTime) : "",
      duration: isSet(object.duration) ? globalThis.String(object.duration) : "",
    };
  },

  toJSON(message: DailyMaintenanceWindow): unknown {
    const obj: any = {};
    if (message.startTime !== "") {
      obj.startTime = message.startTime;
    }
    if (message.duration !== "") {
      obj.duration = message.duration;
    }
    return obj;
  },

  create(base?: DeepPartial<DailyMaintenanceWindow>): DailyMaintenanceWindow {
    return DailyMaintenanceWindow.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DailyMaintenanceWindow>): DailyMaintenanceWindow {
    const message = createBaseDailyMaintenanceWindow();
    message.startTime = object.startTime ?? "";
    message.duration = object.duration ?? "";
    return message;
  },
};

function createBaseSetNodePoolManagementRequest(): SetNodePoolManagementRequest {
  return { projectId: "", zone: "", clusterId: "", nodePoolId: "", management: undefined, name: "" };
}

export const SetNodePoolManagementRequest: MessageFns<SetNodePoolManagementRequest> = {
  encode(message: SetNodePoolManagementRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.nodePoolId !== "") {
      writer.uint32(34).string(message.nodePoolId);
    }
    if (message.management !== undefined) {
      NodeManagement.encode(message.management, writer.uint32(42).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(58).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetNodePoolManagementRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetNodePoolManagementRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.nodePoolId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.management = NodeManagement.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetNodePoolManagementRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      nodePoolId: isSet(object.nodePoolId) ? globalThis.String(object.nodePoolId) : "",
      management: isSet(object.management) ? NodeManagement.fromJSON(object.management) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: SetNodePoolManagementRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.nodePoolId !== "") {
      obj.nodePoolId = message.nodePoolId;
    }
    if (message.management !== undefined) {
      obj.management = NodeManagement.toJSON(message.management);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<SetNodePoolManagementRequest>): SetNodePoolManagementRequest {
    return SetNodePoolManagementRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SetNodePoolManagementRequest>): SetNodePoolManagementRequest {
    const message = createBaseSetNodePoolManagementRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.nodePoolId = object.nodePoolId ?? "";
    message.management = (object.management !== undefined && object.management !== null)
      ? NodeManagement.fromPartial(object.management)
      : undefined;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseSetNodePoolSizeRequest(): SetNodePoolSizeRequest {
  return { projectId: "", zone: "", clusterId: "", nodePoolId: "", nodeCount: 0, name: "" };
}

export const SetNodePoolSizeRequest: MessageFns<SetNodePoolSizeRequest> = {
  encode(message: SetNodePoolSizeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.nodePoolId !== "") {
      writer.uint32(34).string(message.nodePoolId);
    }
    if (message.nodeCount !== 0) {
      writer.uint32(40).int32(message.nodeCount);
    }
    if (message.name !== "") {
      writer.uint32(58).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetNodePoolSizeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetNodePoolSizeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.nodePoolId = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.nodeCount = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetNodePoolSizeRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      nodePoolId: isSet(object.nodePoolId) ? globalThis.String(object.nodePoolId) : "",
      nodeCount: isSet(object.nodeCount) ? globalThis.Number(object.nodeCount) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: SetNodePoolSizeRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.nodePoolId !== "") {
      obj.nodePoolId = message.nodePoolId;
    }
    if (message.nodeCount !== 0) {
      obj.nodeCount = Math.round(message.nodeCount);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<SetNodePoolSizeRequest>): SetNodePoolSizeRequest {
    return SetNodePoolSizeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SetNodePoolSizeRequest>): SetNodePoolSizeRequest {
    const message = createBaseSetNodePoolSizeRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.nodePoolId = object.nodePoolId ?? "";
    message.nodeCount = object.nodeCount ?? 0;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseRollbackNodePoolUpgradeRequest(): RollbackNodePoolUpgradeRequest {
  return { projectId: "", zone: "", clusterId: "", nodePoolId: "", name: "" };
}

export const RollbackNodePoolUpgradeRequest: MessageFns<RollbackNodePoolUpgradeRequest> = {
  encode(message: RollbackNodePoolUpgradeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.nodePoolId !== "") {
      writer.uint32(34).string(message.nodePoolId);
    }
    if (message.name !== "") {
      writer.uint32(50).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RollbackNodePoolUpgradeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRollbackNodePoolUpgradeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.nodePoolId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RollbackNodePoolUpgradeRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      nodePoolId: isSet(object.nodePoolId) ? globalThis.String(object.nodePoolId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: RollbackNodePoolUpgradeRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.nodePoolId !== "") {
      obj.nodePoolId = message.nodePoolId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<RollbackNodePoolUpgradeRequest>): RollbackNodePoolUpgradeRequest {
    return RollbackNodePoolUpgradeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RollbackNodePoolUpgradeRequest>): RollbackNodePoolUpgradeRequest {
    const message = createBaseRollbackNodePoolUpgradeRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.nodePoolId = object.nodePoolId ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListNodePoolsResponse(): ListNodePoolsResponse {
  return { nodePools: [] };
}

export const ListNodePoolsResponse: MessageFns<ListNodePoolsResponse> = {
  encode(message: ListNodePoolsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nodePools) {
      NodePool.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNodePoolsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNodePoolsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nodePools.push(NodePool.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNodePoolsResponse {
    return {
      nodePools: globalThis.Array.isArray(object?.nodePools)
        ? object.nodePools.map((e: any) => NodePool.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListNodePoolsResponse): unknown {
    const obj: any = {};
    if (message.nodePools?.length) {
      obj.nodePools = message.nodePools.map((e) => NodePool.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListNodePoolsResponse>): ListNodePoolsResponse {
    return ListNodePoolsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListNodePoolsResponse>): ListNodePoolsResponse {
    const message = createBaseListNodePoolsResponse();
    message.nodePools = object.nodePools?.map((e) => NodePool.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNodePoolAutoscaling(): NodePoolAutoscaling {
  return { enabled: false, minNodeCount: 0, maxNodeCount: 0 };
}

export const NodePoolAutoscaling: MessageFns<NodePoolAutoscaling> = {
  encode(message: NodePoolAutoscaling, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    if (message.minNodeCount !== 0) {
      writer.uint32(16).int32(message.minNodeCount);
    }
    if (message.maxNodeCount !== 0) {
      writer.uint32(24).int32(message.maxNodeCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodePoolAutoscaling {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodePoolAutoscaling();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.minNodeCount = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.maxNodeCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodePoolAutoscaling {
    return {
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      minNodeCount: isSet(object.minNodeCount) ? globalThis.Number(object.minNodeCount) : 0,
      maxNodeCount: isSet(object.maxNodeCount) ? globalThis.Number(object.maxNodeCount) : 0,
    };
  },

  toJSON(message: NodePoolAutoscaling): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.minNodeCount !== 0) {
      obj.minNodeCount = Math.round(message.minNodeCount);
    }
    if (message.maxNodeCount !== 0) {
      obj.maxNodeCount = Math.round(message.maxNodeCount);
    }
    return obj;
  },

  create(base?: DeepPartial<NodePoolAutoscaling>): NodePoolAutoscaling {
    return NodePoolAutoscaling.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodePoolAutoscaling>): NodePoolAutoscaling {
    const message = createBaseNodePoolAutoscaling();
    message.enabled = object.enabled ?? false;
    message.minNodeCount = object.minNodeCount ?? 0;
    message.maxNodeCount = object.maxNodeCount ?? 0;
    return message;
  },
};

function createBaseSetLabelsRequest(): SetLabelsRequest {
  return { projectId: "", zone: "", clusterId: "", resourceLabels: {}, labelFingerprint: "", name: "" };
}

export const SetLabelsRequest: MessageFns<SetLabelsRequest> = {
  encode(message: SetLabelsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    Object.entries(message.resourceLabels).forEach(([key, value]) => {
      SetLabelsRequest_ResourceLabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.labelFingerprint !== "") {
      writer.uint32(42).string(message.labelFingerprint);
    }
    if (message.name !== "") {
      writer.uint32(58).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetLabelsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetLabelsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = SetLabelsRequest_ResourceLabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.resourceLabels[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.labelFingerprint = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetLabelsRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      resourceLabels: isObject(object.resourceLabels)
        ? Object.entries(object.resourceLabels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      labelFingerprint: isSet(object.labelFingerprint) ? globalThis.String(object.labelFingerprint) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: SetLabelsRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.resourceLabels) {
      const entries = Object.entries(message.resourceLabels);
      if (entries.length > 0) {
        obj.resourceLabels = {};
        entries.forEach(([k, v]) => {
          obj.resourceLabels[k] = v;
        });
      }
    }
    if (message.labelFingerprint !== "") {
      obj.labelFingerprint = message.labelFingerprint;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<SetLabelsRequest>): SetLabelsRequest {
    return SetLabelsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SetLabelsRequest>): SetLabelsRequest {
    const message = createBaseSetLabelsRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.resourceLabels = Object.entries(object.resourceLabels ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.labelFingerprint = object.labelFingerprint ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseSetLabelsRequest_ResourceLabelsEntry(): SetLabelsRequest_ResourceLabelsEntry {
  return { key: "", value: "" };
}

export const SetLabelsRequest_ResourceLabelsEntry: MessageFns<SetLabelsRequest_ResourceLabelsEntry> = {
  encode(message: SetLabelsRequest_ResourceLabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetLabelsRequest_ResourceLabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetLabelsRequest_ResourceLabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetLabelsRequest_ResourceLabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SetLabelsRequest_ResourceLabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<SetLabelsRequest_ResourceLabelsEntry>): SetLabelsRequest_ResourceLabelsEntry {
    return SetLabelsRequest_ResourceLabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SetLabelsRequest_ResourceLabelsEntry>): SetLabelsRequest_ResourceLabelsEntry {
    const message = createBaseSetLabelsRequest_ResourceLabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSetLegacyAbacRequest(): SetLegacyAbacRequest {
  return { projectId: "", zone: "", clusterId: "", enabled: false, name: "" };
}

export const SetLegacyAbacRequest: MessageFns<SetLegacyAbacRequest> = {
  encode(message: SetLegacyAbacRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.enabled !== false) {
      writer.uint32(32).bool(message.enabled);
    }
    if (message.name !== "") {
      writer.uint32(50).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetLegacyAbacRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetLegacyAbacRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetLegacyAbacRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: SetLegacyAbacRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<SetLegacyAbacRequest>): SetLegacyAbacRequest {
    return SetLegacyAbacRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SetLegacyAbacRequest>): SetLegacyAbacRequest {
    const message = createBaseSetLegacyAbacRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.enabled = object.enabled ?? false;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseStartIPRotationRequest(): StartIPRotationRequest {
  return { projectId: "", zone: "", clusterId: "", name: "" };
}

export const StartIPRotationRequest: MessageFns<StartIPRotationRequest> = {
  encode(message: StartIPRotationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.name !== "") {
      writer.uint32(50).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartIPRotationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartIPRotationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartIPRotationRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: StartIPRotationRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<StartIPRotationRequest>): StartIPRotationRequest {
    return StartIPRotationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartIPRotationRequest>): StartIPRotationRequest {
    const message = createBaseStartIPRotationRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCompleteIPRotationRequest(): CompleteIPRotationRequest {
  return { projectId: "", zone: "", clusterId: "", name: "" };
}

export const CompleteIPRotationRequest: MessageFns<CompleteIPRotationRequest> = {
  encode(message: CompleteIPRotationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.name !== "") {
      writer.uint32(58).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompleteIPRotationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompleteIPRotationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompleteIPRotationRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: CompleteIPRotationRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<CompleteIPRotationRequest>): CompleteIPRotationRequest {
    return CompleteIPRotationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CompleteIPRotationRequest>): CompleteIPRotationRequest {
    const message = createBaseCompleteIPRotationRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseAcceleratorConfig(): AcceleratorConfig {
  return { acceleratorCount: Long.ZERO, acceleratorType: "" };
}

export const AcceleratorConfig: MessageFns<AcceleratorConfig> = {
  encode(message: AcceleratorConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.acceleratorCount.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.acceleratorCount.toString());
    }
    if (message.acceleratorType !== "") {
      writer.uint32(18).string(message.acceleratorType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AcceleratorConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAcceleratorConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.acceleratorCount = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.acceleratorType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AcceleratorConfig {
    return {
      acceleratorCount: isSet(object.acceleratorCount) ? Long.fromValue(object.acceleratorCount) : Long.ZERO,
      acceleratorType: isSet(object.acceleratorType) ? globalThis.String(object.acceleratorType) : "",
    };
  },

  toJSON(message: AcceleratorConfig): unknown {
    const obj: any = {};
    if (!message.acceleratorCount.equals(Long.ZERO)) {
      obj.acceleratorCount = (message.acceleratorCount || Long.ZERO).toString();
    }
    if (message.acceleratorType !== "") {
      obj.acceleratorType = message.acceleratorType;
    }
    return obj;
  },

  create(base?: DeepPartial<AcceleratorConfig>): AcceleratorConfig {
    return AcceleratorConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AcceleratorConfig>): AcceleratorConfig {
    const message = createBaseAcceleratorConfig();
    message.acceleratorCount = (object.acceleratorCount !== undefined && object.acceleratorCount !== null)
      ? Long.fromValue(object.acceleratorCount)
      : Long.ZERO;
    message.acceleratorType = object.acceleratorType ?? "";
    return message;
  },
};

function createBaseSetNetworkPolicyRequest(): SetNetworkPolicyRequest {
  return { projectId: "", zone: "", clusterId: "", networkPolicy: undefined, name: "" };
}

export const SetNetworkPolicyRequest: MessageFns<SetNetworkPolicyRequest> = {
  encode(message: SetNetworkPolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.networkPolicy !== undefined) {
      NetworkPolicy.encode(message.networkPolicy, writer.uint32(34).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(50).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetNetworkPolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetNetworkPolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.networkPolicy = NetworkPolicy.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetNetworkPolicyRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      networkPolicy: isSet(object.networkPolicy) ? NetworkPolicy.fromJSON(object.networkPolicy) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: SetNetworkPolicyRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.networkPolicy !== undefined) {
      obj.networkPolicy = NetworkPolicy.toJSON(message.networkPolicy);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<SetNetworkPolicyRequest>): SetNetworkPolicyRequest {
    return SetNetworkPolicyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SetNetworkPolicyRequest>): SetNetworkPolicyRequest {
    const message = createBaseSetNetworkPolicyRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.networkPolicy = (object.networkPolicy !== undefined && object.networkPolicy !== null)
      ? NetworkPolicy.fromPartial(object.networkPolicy)
      : undefined;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseSetMaintenancePolicyRequest(): SetMaintenancePolicyRequest {
  return { projectId: "", zone: "", clusterId: "", maintenancePolicy: undefined, name: "" };
}

export const SetMaintenancePolicyRequest: MessageFns<SetMaintenancePolicyRequest> = {
  encode(message: SetMaintenancePolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.maintenancePolicy !== undefined) {
      MaintenancePolicy.encode(message.maintenancePolicy, writer.uint32(34).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(42).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetMaintenancePolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetMaintenancePolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.maintenancePolicy = MaintenancePolicy.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetMaintenancePolicyRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      maintenancePolicy: isSet(object.maintenancePolicy)
        ? MaintenancePolicy.fromJSON(object.maintenancePolicy)
        : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: SetMaintenancePolicyRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.maintenancePolicy !== undefined) {
      obj.maintenancePolicy = MaintenancePolicy.toJSON(message.maintenancePolicy);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<SetMaintenancePolicyRequest>): SetMaintenancePolicyRequest {
    return SetMaintenancePolicyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SetMaintenancePolicyRequest>): SetMaintenancePolicyRequest {
    const message = createBaseSetMaintenancePolicyRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.maintenancePolicy = (object.maintenancePolicy !== undefined && object.maintenancePolicy !== null)
      ? MaintenancePolicy.fromPartial(object.maintenancePolicy)
      : undefined;
    message.name = object.name ?? "";
    return message;
  },
};

/** Google Container Engine Cluster Manager v1alpha1 */
export type ClusterManagerDefinition = typeof ClusterManagerDefinition;
export const ClusterManagerDefinition = {
  name: "ClusterManager",
  fullName: "google.container.v1alpha1.ClusterManager",
  methods: {
    /**
     * Lists all clusters owned by a project in either the specified zone or all
     * zones.
     */
    listClusters: {
      name: "ListClusters",
      requestType: ListClustersRequest,
      requestStream: false,
      responseType: ListClustersResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              52,
              18,
              50,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets the details of a specific cluster. */
    getCluster: {
      name: "GetCluster",
      requestType: GetClusterRequest,
      requestStream: false,
      responseType: Cluster,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              52,
              18,
              50,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Creates a cluster, consisting of the specified number and type of Google
     * Compute Engine instances.
     *
     * By default, the cluster is created in the project's
     * [default network](/compute/docs/networks-and-firewalls#networks).
     *
     * One firewall is added for the cluster. After cluster creation,
     * the cluster creates routes for each node to allow the containers
     * on that node to communicate with all other instances in the
     * cluster.
     *
     * Finally, an entry is added to the project's global metadata indicating
     * which CIDR range is being used by the cluster.
     */
    createCluster: {
      name: "CreateCluster",
      requestType: CreateClusterRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              55,
              58,
              1,
              42,
              34,
              50,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates the settings of a specific cluster. */
    updateCluster: {
      name: "UpdateCluster",
      requestType: UpdateClusterRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              55,
              58,
              1,
              42,
              26,
              50,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Updates the version and/or iamge type of a specific node pool. */
    updateNodePool: {
      name: "UpdateNodePool",
      requestType: UpdateNodePoolRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              67,
              58,
              1,
              42,
              26,
              62,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              110,
              111,
              100,
              101,
              80,
              111,
              111,
              108,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Sets the autoscaling settings of a specific node pool. */
    setNodePoolAutoscaling: {
      name: "SetNodePoolAutoscaling",
      requestType: SetNodePoolAutoscalingRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              82,
              58,
              1,
              42,
              34,
              77,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              110,
              111,
              100,
              101,
              80,
              111,
              111,
              108,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              116,
              65,
              117,
              116,
              111,
              115,
              99,
              97,
              108,
              105,
              110,
              103,
            ]),
          ],
        },
      },
    },
    /** Sets the logging service of a specific cluster. */
    setLoggingService: {
      name: "SetLoggingService",
      requestType: SetLoggingServiceRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              66,
              58,
              1,
              42,
              34,
              61,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              116,
              76,
              111,
              103,
              103,
              105,
              110,
              103,
            ]),
          ],
        },
      },
    },
    /** Sets the monitoring service of a specific cluster. */
    setMonitoringService: {
      name: "SetMonitoringService",
      requestType: SetMonitoringServiceRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              69,
              58,
              1,
              42,
              34,
              64,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              116,
              77,
              111,
              110,
              105,
              116,
              111,
              114,
              105,
              110,
              103,
            ]),
          ],
        },
      },
    },
    /** Sets the addons of a specific cluster. */
    setAddonsConfig: {
      name: "SetAddonsConfig",
      requestType: SetAddonsConfigRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              65,
              58,
              1,
              42,
              34,
              60,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              116,
              65,
              100,
              100,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Sets the locations of a specific cluster. */
    setLocations: {
      name: "SetLocations",
      requestType: SetLocationsRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              68,
              58,
              1,
              42,
              34,
              63,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              116,
              76,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates the master of a specific cluster. */
    updateMaster: {
      name: "UpdateMaster",
      requestType: UpdateMasterRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              68,
              58,
              1,
              42,
              34,
              63,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
              58,
              117,
              112,
              100,
              97,
              116,
              101,
              77,
              97,
              115,
              116,
              101,
              114,
            ]),
          ],
        },
      },
    },
    /**
     * Used to set master auth materials. Currently supports :-
     * Changing the admin password of a specific cluster.
     * This can be either via password generation or explicitly set.
     * Modify basic_auth.csv and reset the K8S API server.
     */
    setMasterAuth: {
      name: "SetMasterAuth",
      requestType: SetMasterAuthRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              69,
              58,
              1,
              42,
              34,
              64,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              116,
              77,
              97,
              115,
              116,
              101,
              114,
              65,
              117,
              116,
              104,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes the cluster, including the Kubernetes endpoint and all worker
     * nodes.
     *
     * Firewalls and routes that were configured during cluster creation
     * are also deleted.
     *
     * Other Google Compute Engine resources that might be in use by the cluster
     * (e.g. load balancer resources) will not be deleted if they weren't present
     * at the initial create time.
     */
    deleteCluster: {
      name: "DeleteCluster",
      requestType: DeleteClusterRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              52,
              42,
              50,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists all operations in a project in a specific zone or all zones. */
    listOperations: {
      name: "ListOperations",
      requestType: ListOperationsRequest,
      requestStream: false,
      responseType: ListOperationsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              54,
              18,
              52,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              111,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets the specified operation. */
    getOperation: {
      name: "GetOperation",
      requestType: GetOperationRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              54,
              18,
              52,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              111,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Cancels the specified operation. */
    cancelOperation: {
      name: "CancelOperation",
      requestType: CancelOperationRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              64,
              58,
              1,
              42,
              34,
              59,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              111,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              99,
              97,
              110,
              99,
              101,
              108,
            ]),
          ],
        },
      },
    },
    /** Returns configuration info about the Container Engine service. */
    getServerConfig: {
      name: "GetServerConfig",
      requestType: GetServerConfigRequest,
      requestStream: false,
      responseType: ServerConfig,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              54,
              18,
              52,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              115,
              101,
              114,
              118,
              101,
              114,
              67,
              111,
              110,
              102,
              105,
              103,
            ]),
          ],
        },
      },
    },
    /** Lists the node pools for a cluster. */
    listNodePools: {
      name: "ListNodePools",
      requestType: ListNodePoolsRequest,
      requestStream: false,
      responseType: ListNodePoolsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              64,
              18,
              62,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
              47,
              110,
              111,
              100,
              101,
              80,
              111,
              111,
              108,
              115,
            ]),
          ],
        },
      },
    },
    /** Retrieves the node pool requested. */
    getNodePool: {
      name: "GetNodePool",
      requestType: GetNodePoolRequest,
      requestStream: false,
      responseType: NodePool,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              64,
              18,
              62,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              110,
              111,
              100,
              101,
              80,
              111,
              111,
              108,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a node pool for a cluster. */
    createNodePool: {
      name: "CreateNodePool",
      requestType: CreateNodePoolRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              67,
              58,
              1,
              42,
              34,
              62,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
              47,
              110,
              111,
              100,
              101,
              80,
              111,
              111,
              108,
              115,
            ]),
          ],
        },
      },
    },
    /** Deletes a node pool from a cluster. */
    deleteNodePool: {
      name: "DeleteNodePool",
      requestType: DeleteNodePoolRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              64,
              42,
              62,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              110,
              111,
              100,
              101,
              80,
              111,
              111,
              108,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Roll back the previously Aborted or Failed NodePool upgrade.
     * This will be an no-op if the last upgrade successfully completed.
     */
    rollbackNodePoolUpgrade: {
      name: "RollbackNodePoolUpgrade",
      requestType: RollbackNodePoolUpgradeRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              76,
              58,
              1,
              42,
              34,
              71,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              110,
              111,
              100,
              101,
              80,
              111,
              111,
              108,
              115,
              47,
              42,
              125,
              58,
              114,
              111,
              108,
              108,
              98,
              97,
              99,
              107,
            ]),
          ],
        },
      },
    },
    /** Sets the NodeManagement options for a node pool. */
    setNodePoolManagement: {
      name: "SetNodePoolManagement",
      requestType: SetNodePoolManagementRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              81,
              58,
              1,
              42,
              34,
              76,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              110,
              111,
              100,
              101,
              80,
              111,
              111,
              108,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              116,
              77,
              97,
              110,
              97,
              103,
              101,
              109,
              101,
              110,
              116,
            ]),
          ],
        },
      },
    },
    /** Sets labels on a cluster. */
    setLabels: {
      name: "SetLabels",
      requestType: SetLabelsRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              73,
              58,
              1,
              42,
              34,
              68,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              116,
              82,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              76,
              97,
              98,
              101,
              108,
              115,
            ]),
          ],
        },
      },
    },
    /** Enables or disables the ABAC authorization mechanism on a cluster. */
    setLegacyAbac: {
      name: "SetLegacyAbac",
      requestType: SetLegacyAbacRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              69,
              58,
              1,
              42,
              34,
              64,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              116,
              76,
              101,
              103,
              97,
              99,
              121,
              65,
              98,
              97,
              99,
            ]),
          ],
        },
      },
    },
    /** Start master IP rotation. */
    startIPRotation: {
      name: "StartIPRotation",
      requestType: StartIPRotationRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              71,
              58,
              1,
              42,
              34,
              66,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
              58,
              115,
              116,
              97,
              114,
              116,
              73,
              112,
              82,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
            ]),
          ],
        },
      },
    },
    /** Completes master IP rotation. */
    completeIPRotation: {
      name: "CompleteIPRotation",
      requestType: CompleteIPRotationRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              74,
              58,
              1,
              42,
              34,
              69,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
              58,
              99,
              111,
              109,
              112,
              108,
              101,
              116,
              101,
              73,
              112,
              82,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
            ]),
          ],
        },
      },
    },
    /** Sets the size of a specific node pool. */
    setNodePoolSize: {
      name: "SetNodePoolSize",
      requestType: SetNodePoolSizeRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              75,
              58,
              1,
              42,
              34,
              70,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              110,
              111,
              100,
              101,
              80,
              111,
              111,
              108,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              116,
              83,
              105,
              122,
              101,
            ]),
          ],
        },
      },
    },
    /** Enables/Disables Network Policy for a cluster. */
    setNetworkPolicy: {
      name: "SetNetworkPolicy",
      requestType: SetNetworkPolicyRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              72,
              58,
              1,
              42,
              34,
              67,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              116,
              78,
              101,
              116,
              119,
              111,
              114,
              107,
              80,
              111,
              108,
              105,
              99,
              121,
            ]),
          ],
        },
      },
    },
    /** Sets the maintenance policy for a cluster. */
    setMaintenancePolicy: {
      name: "SetMaintenancePolicy",
      requestType: SetMaintenancePolicyRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              76,
              58,
              1,
              42,
              34,
              71,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              116,
              77,
              97,
              105,
              110,
              116,
              101,
              110,
              97,
              110,
              99,
              101,
              80,
              111,
              108,
              105,
              99,
              121,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface ClusterManagerServiceImplementation<CallContextExt = {}> {
  /**
   * Lists all clusters owned by a project in either the specified zone or all
   * zones.
   */
  listClusters(
    request: ListClustersRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListClustersResponse>>;
  /** Gets the details of a specific cluster. */
  getCluster(request: GetClusterRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Cluster>>;
  /**
   * Creates a cluster, consisting of the specified number and type of Google
   * Compute Engine instances.
   *
   * By default, the cluster is created in the project's
   * [default network](/compute/docs/networks-and-firewalls#networks).
   *
   * One firewall is added for the cluster. After cluster creation,
   * the cluster creates routes for each node to allow the containers
   * on that node to communicate with all other instances in the
   * cluster.
   *
   * Finally, an entry is added to the project's global metadata indicating
   * which CIDR range is being used by the cluster.
   */
  createCluster(request: CreateClusterRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Updates the settings of a specific cluster. */
  updateCluster(request: UpdateClusterRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Updates the version and/or iamge type of a specific node pool. */
  updateNodePool(
    request: UpdateNodePoolRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Sets the autoscaling settings of a specific node pool. */
  setNodePoolAutoscaling(
    request: SetNodePoolAutoscalingRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Sets the logging service of a specific cluster. */
  setLoggingService(
    request: SetLoggingServiceRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Sets the monitoring service of a specific cluster. */
  setMonitoringService(
    request: SetMonitoringServiceRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Sets the addons of a specific cluster. */
  setAddonsConfig(
    request: SetAddonsConfigRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Sets the locations of a specific cluster. */
  setLocations(request: SetLocationsRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Updates the master of a specific cluster. */
  updateMaster(request: UpdateMasterRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /**
   * Used to set master auth materials. Currently supports :-
   * Changing the admin password of a specific cluster.
   * This can be either via password generation or explicitly set.
   * Modify basic_auth.csv and reset the K8S API server.
   */
  setMasterAuth(request: SetMasterAuthRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /**
   * Deletes the cluster, including the Kubernetes endpoint and all worker
   * nodes.
   *
   * Firewalls and routes that were configured during cluster creation
   * are also deleted.
   *
   * Other Google Compute Engine resources that might be in use by the cluster
   * (e.g. load balancer resources) will not be deleted if they weren't present
   * at the initial create time.
   */
  deleteCluster(request: DeleteClusterRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Lists all operations in a project in a specific zone or all zones. */
  listOperations(
    request: ListOperationsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListOperationsResponse>>;
  /** Gets the specified operation. */
  getOperation(request: GetOperationRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Cancels the specified operation. */
  cancelOperation(request: CancelOperationRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** Returns configuration info about the Container Engine service. */
  getServerConfig(
    request: GetServerConfigRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ServerConfig>>;
  /** Lists the node pools for a cluster. */
  listNodePools(
    request: ListNodePoolsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListNodePoolsResponse>>;
  /** Retrieves the node pool requested. */
  getNodePool(request: GetNodePoolRequest, context: CallContext & CallContextExt): Promise<DeepPartial<NodePool>>;
  /** Creates a node pool for a cluster. */
  createNodePool(
    request: CreateNodePoolRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Deletes a node pool from a cluster. */
  deleteNodePool(
    request: DeleteNodePoolRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Roll back the previously Aborted or Failed NodePool upgrade.
   * This will be an no-op if the last upgrade successfully completed.
   */
  rollbackNodePoolUpgrade(
    request: RollbackNodePoolUpgradeRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Sets the NodeManagement options for a node pool. */
  setNodePoolManagement(
    request: SetNodePoolManagementRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Sets labels on a cluster. */
  setLabels(request: SetLabelsRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Enables or disables the ABAC authorization mechanism on a cluster. */
  setLegacyAbac(request: SetLegacyAbacRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Start master IP rotation. */
  startIPRotation(
    request: StartIPRotationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Completes master IP rotation. */
  completeIPRotation(
    request: CompleteIPRotationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Sets the size of a specific node pool. */
  setNodePoolSize(
    request: SetNodePoolSizeRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Enables/Disables Network Policy for a cluster. */
  setNetworkPolicy(
    request: SetNetworkPolicyRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Sets the maintenance policy for a cluster. */
  setMaintenancePolicy(
    request: SetMaintenancePolicyRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
}

export interface ClusterManagerClient<CallOptionsExt = {}> {
  /**
   * Lists all clusters owned by a project in either the specified zone or all
   * zones.
   */
  listClusters(
    request: DeepPartial<ListClustersRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListClustersResponse>;
  /** Gets the details of a specific cluster. */
  getCluster(request: DeepPartial<GetClusterRequest>, options?: CallOptions & CallOptionsExt): Promise<Cluster>;
  /**
   * Creates a cluster, consisting of the specified number and type of Google
   * Compute Engine instances.
   *
   * By default, the cluster is created in the project's
   * [default network](/compute/docs/networks-and-firewalls#networks).
   *
   * One firewall is added for the cluster. After cluster creation,
   * the cluster creates routes for each node to allow the containers
   * on that node to communicate with all other instances in the
   * cluster.
   *
   * Finally, an entry is added to the project's global metadata indicating
   * which CIDR range is being used by the cluster.
   */
  createCluster(request: DeepPartial<CreateClusterRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Updates the settings of a specific cluster. */
  updateCluster(request: DeepPartial<UpdateClusterRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Updates the version and/or iamge type of a specific node pool. */
  updateNodePool(
    request: DeepPartial<UpdateNodePoolRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Sets the autoscaling settings of a specific node pool. */
  setNodePoolAutoscaling(
    request: DeepPartial<SetNodePoolAutoscalingRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Sets the logging service of a specific cluster. */
  setLoggingService(
    request: DeepPartial<SetLoggingServiceRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Sets the monitoring service of a specific cluster. */
  setMonitoringService(
    request: DeepPartial<SetMonitoringServiceRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Sets the addons of a specific cluster. */
  setAddonsConfig(
    request: DeepPartial<SetAddonsConfigRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Sets the locations of a specific cluster. */
  setLocations(request: DeepPartial<SetLocationsRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Updates the master of a specific cluster. */
  updateMaster(request: DeepPartial<UpdateMasterRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /**
   * Used to set master auth materials. Currently supports :-
   * Changing the admin password of a specific cluster.
   * This can be either via password generation or explicitly set.
   * Modify basic_auth.csv and reset the K8S API server.
   */
  setMasterAuth(request: DeepPartial<SetMasterAuthRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /**
   * Deletes the cluster, including the Kubernetes endpoint and all worker
   * nodes.
   *
   * Firewalls and routes that were configured during cluster creation
   * are also deleted.
   *
   * Other Google Compute Engine resources that might be in use by the cluster
   * (e.g. load balancer resources) will not be deleted if they weren't present
   * at the initial create time.
   */
  deleteCluster(request: DeepPartial<DeleteClusterRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Lists all operations in a project in a specific zone or all zones. */
  listOperations(
    request: DeepPartial<ListOperationsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListOperationsResponse>;
  /** Gets the specified operation. */
  getOperation(request: DeepPartial<GetOperationRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Cancels the specified operation. */
  cancelOperation(request: DeepPartial<CancelOperationRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** Returns configuration info about the Container Engine service. */
  getServerConfig(
    request: DeepPartial<GetServerConfigRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ServerConfig>;
  /** Lists the node pools for a cluster. */
  listNodePools(
    request: DeepPartial<ListNodePoolsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListNodePoolsResponse>;
  /** Retrieves the node pool requested. */
  getNodePool(request: DeepPartial<GetNodePoolRequest>, options?: CallOptions & CallOptionsExt): Promise<NodePool>;
  /** Creates a node pool for a cluster. */
  createNodePool(
    request: DeepPartial<CreateNodePoolRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Deletes a node pool from a cluster. */
  deleteNodePool(
    request: DeepPartial<DeleteNodePoolRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Roll back the previously Aborted or Failed NodePool upgrade.
   * This will be an no-op if the last upgrade successfully completed.
   */
  rollbackNodePoolUpgrade(
    request: DeepPartial<RollbackNodePoolUpgradeRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Sets the NodeManagement options for a node pool. */
  setNodePoolManagement(
    request: DeepPartial<SetNodePoolManagementRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Sets labels on a cluster. */
  setLabels(request: DeepPartial<SetLabelsRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Enables or disables the ABAC authorization mechanism on a cluster. */
  setLegacyAbac(request: DeepPartial<SetLegacyAbacRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Start master IP rotation. */
  startIPRotation(
    request: DeepPartial<StartIPRotationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Completes master IP rotation. */
  completeIPRotation(
    request: DeepPartial<CompleteIPRotationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Sets the size of a specific node pool. */
  setNodePoolSize(
    request: DeepPartial<SetNodePoolSizeRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Enables/Disables Network Policy for a cluster. */
  setNetworkPolicy(
    request: DeepPartial<SetNetworkPolicyRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Sets the maintenance policy for a cluster. */
  setMaintenancePolicy(
    request: DeepPartial<SetMaintenancePolicyRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
