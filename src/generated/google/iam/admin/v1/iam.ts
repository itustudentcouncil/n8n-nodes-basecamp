// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/iam/admin/v1/iam.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Empty } from "../../../protobuf/empty.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Expr } from "../../../type/expr.js";
import {
  GetIamPolicyRequest,
  SetIamPolicyRequest,
  TestIamPermissionsRequest,
  TestIamPermissionsResponse,
} from "../../v1/iam_policy.js";
import { Policy } from "../../v1/policy.js";

export const protobufPackage = "google.iam.admin.v1";

/** Supported key algorithms. */
export enum ServiceAccountKeyAlgorithm {
  /** KEY_ALG_UNSPECIFIED - An unspecified key algorithm. */
  KEY_ALG_UNSPECIFIED = 0,
  /** KEY_ALG_RSA_1024 - 1k RSA Key. */
  KEY_ALG_RSA_1024 = 1,
  /** KEY_ALG_RSA_2048 - 2k RSA Key. */
  KEY_ALG_RSA_2048 = 2,
  UNRECOGNIZED = -1,
}

export function serviceAccountKeyAlgorithmFromJSON(object: any): ServiceAccountKeyAlgorithm {
  switch (object) {
    case 0:
    case "KEY_ALG_UNSPECIFIED":
      return ServiceAccountKeyAlgorithm.KEY_ALG_UNSPECIFIED;
    case 1:
    case "KEY_ALG_RSA_1024":
      return ServiceAccountKeyAlgorithm.KEY_ALG_RSA_1024;
    case 2:
    case "KEY_ALG_RSA_2048":
      return ServiceAccountKeyAlgorithm.KEY_ALG_RSA_2048;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ServiceAccountKeyAlgorithm.UNRECOGNIZED;
  }
}

export function serviceAccountKeyAlgorithmToJSON(object: ServiceAccountKeyAlgorithm): string {
  switch (object) {
    case ServiceAccountKeyAlgorithm.KEY_ALG_UNSPECIFIED:
      return "KEY_ALG_UNSPECIFIED";
    case ServiceAccountKeyAlgorithm.KEY_ALG_RSA_1024:
      return "KEY_ALG_RSA_1024";
    case ServiceAccountKeyAlgorithm.KEY_ALG_RSA_2048:
      return "KEY_ALG_RSA_2048";
    case ServiceAccountKeyAlgorithm.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Supported private key output formats. */
export enum ServiceAccountPrivateKeyType {
  /** TYPE_UNSPECIFIED - Unspecified. Equivalent to `TYPE_GOOGLE_CREDENTIALS_FILE`. */
  TYPE_UNSPECIFIED = 0,
  /**
   * TYPE_PKCS12_FILE - PKCS12 format.
   * The password for the PKCS12 file is `notasecret`.
   * For more information, see https://tools.ietf.org/html/rfc7292.
   */
  TYPE_PKCS12_FILE = 1,
  /** TYPE_GOOGLE_CREDENTIALS_FILE - Google Credentials File format. */
  TYPE_GOOGLE_CREDENTIALS_FILE = 2,
  UNRECOGNIZED = -1,
}

export function serviceAccountPrivateKeyTypeFromJSON(object: any): ServiceAccountPrivateKeyType {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return ServiceAccountPrivateKeyType.TYPE_UNSPECIFIED;
    case 1:
    case "TYPE_PKCS12_FILE":
      return ServiceAccountPrivateKeyType.TYPE_PKCS12_FILE;
    case 2:
    case "TYPE_GOOGLE_CREDENTIALS_FILE":
      return ServiceAccountPrivateKeyType.TYPE_GOOGLE_CREDENTIALS_FILE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ServiceAccountPrivateKeyType.UNRECOGNIZED;
  }
}

export function serviceAccountPrivateKeyTypeToJSON(object: ServiceAccountPrivateKeyType): string {
  switch (object) {
    case ServiceAccountPrivateKeyType.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case ServiceAccountPrivateKeyType.TYPE_PKCS12_FILE:
      return "TYPE_PKCS12_FILE";
    case ServiceAccountPrivateKeyType.TYPE_GOOGLE_CREDENTIALS_FILE:
      return "TYPE_GOOGLE_CREDENTIALS_FILE";
    case ServiceAccountPrivateKeyType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Supported public key output formats. */
export enum ServiceAccountPublicKeyType {
  /** TYPE_NONE - Do not return the public key. */
  TYPE_NONE = 0,
  /** TYPE_X509_PEM_FILE - X509 PEM format. */
  TYPE_X509_PEM_FILE = 1,
  /** TYPE_RAW_PUBLIC_KEY - Raw public key. */
  TYPE_RAW_PUBLIC_KEY = 2,
  UNRECOGNIZED = -1,
}

export function serviceAccountPublicKeyTypeFromJSON(object: any): ServiceAccountPublicKeyType {
  switch (object) {
    case 0:
    case "TYPE_NONE":
      return ServiceAccountPublicKeyType.TYPE_NONE;
    case 1:
    case "TYPE_X509_PEM_FILE":
      return ServiceAccountPublicKeyType.TYPE_X509_PEM_FILE;
    case 2:
    case "TYPE_RAW_PUBLIC_KEY":
      return ServiceAccountPublicKeyType.TYPE_RAW_PUBLIC_KEY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ServiceAccountPublicKeyType.UNRECOGNIZED;
  }
}

export function serviceAccountPublicKeyTypeToJSON(object: ServiceAccountPublicKeyType): string {
  switch (object) {
    case ServiceAccountPublicKeyType.TYPE_NONE:
      return "TYPE_NONE";
    case ServiceAccountPublicKeyType.TYPE_X509_PEM_FILE:
      return "TYPE_X509_PEM_FILE";
    case ServiceAccountPublicKeyType.TYPE_RAW_PUBLIC_KEY:
      return "TYPE_RAW_PUBLIC_KEY";
    case ServiceAccountPublicKeyType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Service Account Key Origin. */
export enum ServiceAccountKeyOrigin {
  /** ORIGIN_UNSPECIFIED - Unspecified key origin. */
  ORIGIN_UNSPECIFIED = 0,
  /** USER_PROVIDED - Key is provided by user. */
  USER_PROVIDED = 1,
  /** GOOGLE_PROVIDED - Key is provided by Google. */
  GOOGLE_PROVIDED = 2,
  UNRECOGNIZED = -1,
}

export function serviceAccountKeyOriginFromJSON(object: any): ServiceAccountKeyOrigin {
  switch (object) {
    case 0:
    case "ORIGIN_UNSPECIFIED":
      return ServiceAccountKeyOrigin.ORIGIN_UNSPECIFIED;
    case 1:
    case "USER_PROVIDED":
      return ServiceAccountKeyOrigin.USER_PROVIDED;
    case 2:
    case "GOOGLE_PROVIDED":
      return ServiceAccountKeyOrigin.GOOGLE_PROVIDED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ServiceAccountKeyOrigin.UNRECOGNIZED;
  }
}

export function serviceAccountKeyOriginToJSON(object: ServiceAccountKeyOrigin): string {
  switch (object) {
    case ServiceAccountKeyOrigin.ORIGIN_UNSPECIFIED:
      return "ORIGIN_UNSPECIFIED";
    case ServiceAccountKeyOrigin.USER_PROVIDED:
      return "USER_PROVIDED";
    case ServiceAccountKeyOrigin.GOOGLE_PROVIDED:
      return "GOOGLE_PROVIDED";
    case ServiceAccountKeyOrigin.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A view for Role objects. */
export enum RoleView {
  /**
   * BASIC - Omits the `included_permissions` field.
   * This is the default value.
   */
  BASIC = 0,
  /** FULL - Returns all fields. */
  FULL = 1,
  UNRECOGNIZED = -1,
}

export function roleViewFromJSON(object: any): RoleView {
  switch (object) {
    case 0:
    case "BASIC":
      return RoleView.BASIC;
    case 1:
    case "FULL":
      return RoleView.FULL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RoleView.UNRECOGNIZED;
  }
}

export function roleViewToJSON(object: RoleView): string {
  switch (object) {
    case RoleView.BASIC:
      return "BASIC";
    case RoleView.FULL:
      return "FULL";
    case RoleView.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * An IAM service account.
 *
 * A service account is an account for an application or a virtual machine (VM)
 * instance, not a person. You can use a service account to call Google APIs. To
 * learn more, read the [overview of service
 * accounts](https://cloud.google.com/iam/help/service-accounts/overview).
 *
 * When you create a service account, you specify the project ID that owns the
 * service account, as well as a name that must be unique within the project.
 * IAM uses these values to create an email address that identifies the service
 * account.
 */
export interface ServiceAccount {
  /**
   * The resource name of the service account.
   *
   * Use one of the following formats:
   *
   * * `projects/{PROJECT_ID}/serviceAccounts/{EMAIL_ADDRESS}`
   * * `projects/{PROJECT_ID}/serviceAccounts/{UNIQUE_ID}`
   *
   * As an alternative, you can use the `-` wildcard character instead of the
   * project ID:
   *
   * * `projects/-/serviceAccounts/{EMAIL_ADDRESS}`
   * * `projects/-/serviceAccounts/{UNIQUE_ID}`
   *
   * When possible, avoid using the `-` wildcard character, because it can cause
   * response messages to contain misleading error codes. For example, if you
   * try to get the service account
   * `projects/-/serviceAccounts/fake@example.com`, which does not exist, the
   * response contains an HTTP `403 Forbidden` error instead of a `404 Not
   * Found` error.
   */
  name: string;
  /** Output only. The ID of the project that owns the service account. */
  projectId: string;
  /**
   * Output only. The unique, stable numeric ID for the service account.
   *
   * Each service account retains its unique ID even if you delete the service
   * account. For example, if you delete a service account, then create a new
   * service account with the same name, the new service account has a different
   * unique ID than the deleted service account.
   */
  uniqueId: string;
  /** Output only. The email address of the service account. */
  email: string;
  /**
   * Optional. A user-specified, human-readable name for the service account. The maximum
   * length is 100 UTF-8 bytes.
   */
  displayName: string;
  /**
   * Deprecated. Do not use.
   *
   * @deprecated
   */
  etag: Buffer;
  /**
   * Optional. A user-specified, human-readable description of the service account. The
   * maximum length is 256 UTF-8 bytes.
   */
  description: string;
  /** Output only. The OAuth 2.0 client ID for the service account. */
  oauth2ClientId: string;
  /** Output only. Whether the service account is disabled. */
  disabled: boolean;
}

/** The service account create request. */
export interface CreateServiceAccountRequest {
  /**
   * Required. The resource name of the project associated with the service
   * accounts, such as `projects/my-project-123`.
   */
  name: string;
  /**
   * Required. The account id that is used to generate the service account
   * email address and a stable unique id. It is unique within a project,
   * must be 6-30 characters long, and match the regular expression
   * `[a-z]([-a-z0-9]*[a-z0-9])` to comply with RFC1035.
   */
  accountId: string;
  /**
   * The [ServiceAccount][google.iam.admin.v1.ServiceAccount] resource to
   * create. Currently, only the following values are user assignable:
   * `display_name` and `description`.
   */
  serviceAccount: ServiceAccount | undefined;
}

/** The service account list request. */
export interface ListServiceAccountsRequest {
  /**
   * Required. The resource name of the project associated with the service
   * accounts, such as `projects/my-project-123`.
   */
  name: string;
  /**
   * Optional limit on the number of service accounts to include in the
   * response. Further accounts can subsequently be obtained by including the
   * [ListServiceAccountsResponse.next_page_token][google.iam.admin.v1.ListServiceAccountsResponse.next_page_token]
   * in a subsequent request.
   *
   * The default is 20, and the maximum is 100.
   */
  pageSize: number;
  /**
   * Optional pagination token returned in an earlier
   * [ListServiceAccountsResponse.next_page_token][google.iam.admin.v1.ListServiceAccountsResponse.next_page_token].
   */
  pageToken: string;
}

/** The service account list response. */
export interface ListServiceAccountsResponse {
  /** The list of matching service accounts. */
  accounts: ServiceAccount[];
  /**
   * To retrieve the next page of results, set
   * [ListServiceAccountsRequest.page_token][google.iam.admin.v1.ListServiceAccountsRequest.page_token]
   * to this value.
   */
  nextPageToken: string;
}

/** The service account get request. */
export interface GetServiceAccountRequest {
  /**
   * Required. The resource name of the service account in the following format:
   * `projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}`.
   * Using `-` as a wildcard for the `PROJECT_ID` will infer the project from
   * the account. The `ACCOUNT` value can be the `email` address or the
   * `unique_id` of the service account.
   */
  name: string;
}

/** The service account delete request. */
export interface DeleteServiceAccountRequest {
  /**
   * Required. The resource name of the service account in the following format:
   * `projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}`.
   * Using `-` as a wildcard for the `PROJECT_ID` will infer the project from
   * the account. The `ACCOUNT` value can be the `email` address or the
   * `unique_id` of the service account.
   */
  name: string;
}

/**
 * The service account patch request.
 *
 * You can patch only the `display_name` and `description` fields. You must use
 * the `update_mask` field to specify which of these fields you want to patch.
 *
 * Only the fields specified in the request are guaranteed to be returned in
 * the response. Other fields may be empty in the response.
 */
export interface PatchServiceAccountRequest {
  serviceAccount: ServiceAccount | undefined;
  updateMask: string[] | undefined;
}

/** The service account undelete request. */
export interface UndeleteServiceAccountRequest {
  /**
   * The resource name of the service account in the following format:
   * `projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT_UNIQUE_ID}`.
   * Using `-` as a wildcard for the `PROJECT_ID` will infer the project from
   * the account.
   */
  name: string;
}

export interface UndeleteServiceAccountResponse {
  /** Metadata for the restored service account. */
  restoredAccount: ServiceAccount | undefined;
}

/** The service account enable request. */
export interface EnableServiceAccountRequest {
  /**
   * The resource name of the service account in the following format:
   * `projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}`.
   * Using `-` as a wildcard for the `PROJECT_ID` will infer the project from
   * the account. The `ACCOUNT` value can be the `email` address or the
   * `unique_id` of the service account.
   */
  name: string;
}

/** The service account disable request. */
export interface DisableServiceAccountRequest {
  /**
   * The resource name of the service account in the following format:
   * `projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}`.
   * Using `-` as a wildcard for the `PROJECT_ID` will infer the project from
   * the account. The `ACCOUNT` value can be the `email` address or the
   * `unique_id` of the service account.
   */
  name: string;
}

/** The service account keys list request. */
export interface ListServiceAccountKeysRequest {
  /**
   * Required. The resource name of the service account in the following format:
   * `projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}`.
   *
   * Using `-` as a wildcard for the `PROJECT_ID`, will infer the project from
   * the account. The `ACCOUNT` value can be the `email` address or the
   * `unique_id` of the service account.
   */
  name: string;
  /**
   * Filters the types of keys the user wants to include in the list
   * response. Duplicate key types are not allowed. If no key type
   * is provided, all keys are returned.
   */
  keyTypes: ListServiceAccountKeysRequest_KeyType[];
}

/**
 * `KeyType` filters to selectively retrieve certain varieties
 * of keys.
 */
export enum ListServiceAccountKeysRequest_KeyType {
  /**
   * KEY_TYPE_UNSPECIFIED - Unspecified key type. The presence of this in the
   * message will immediately result in an error.
   */
  KEY_TYPE_UNSPECIFIED = 0,
  /** USER_MANAGED - User-managed keys (managed and rotated by the user). */
  USER_MANAGED = 1,
  /** SYSTEM_MANAGED - System-managed keys (managed and rotated by Google). */
  SYSTEM_MANAGED = 2,
  UNRECOGNIZED = -1,
}

export function listServiceAccountKeysRequest_KeyTypeFromJSON(object: any): ListServiceAccountKeysRequest_KeyType {
  switch (object) {
    case 0:
    case "KEY_TYPE_UNSPECIFIED":
      return ListServiceAccountKeysRequest_KeyType.KEY_TYPE_UNSPECIFIED;
    case 1:
    case "USER_MANAGED":
      return ListServiceAccountKeysRequest_KeyType.USER_MANAGED;
    case 2:
    case "SYSTEM_MANAGED":
      return ListServiceAccountKeysRequest_KeyType.SYSTEM_MANAGED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ListServiceAccountKeysRequest_KeyType.UNRECOGNIZED;
  }
}

export function listServiceAccountKeysRequest_KeyTypeToJSON(object: ListServiceAccountKeysRequest_KeyType): string {
  switch (object) {
    case ListServiceAccountKeysRequest_KeyType.KEY_TYPE_UNSPECIFIED:
      return "KEY_TYPE_UNSPECIFIED";
    case ListServiceAccountKeysRequest_KeyType.USER_MANAGED:
      return "USER_MANAGED";
    case ListServiceAccountKeysRequest_KeyType.SYSTEM_MANAGED:
      return "SYSTEM_MANAGED";
    case ListServiceAccountKeysRequest_KeyType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The service account keys list response. */
export interface ListServiceAccountKeysResponse {
  /** The public keys for the service account. */
  keys: ServiceAccountKey[];
}

/** The service account key get by id request. */
export interface GetServiceAccountKeyRequest {
  /**
   * Required. The resource name of the service account key in the following format:
   * `projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}/keys/{key}`.
   *
   * Using `-` as a wildcard for the `PROJECT_ID` will infer the project from
   * the account. The `ACCOUNT` value can be the `email` address or the
   * `unique_id` of the service account.
   */
  name: string;
  /**
   * Optional. The output format of the public key. The default is `TYPE_NONE`, which
   * means that the public key is not returned.
   */
  publicKeyType: ServiceAccountPublicKeyType;
}

/**
 * Represents a service account key.
 *
 * A service account has two sets of key-pairs: user-managed, and
 * system-managed.
 *
 * User-managed key-pairs can be created and deleted by users.  Users are
 * responsible for rotating these keys periodically to ensure security of
 * their service accounts.  Users retain the private key of these key-pairs,
 * and Google retains ONLY the public key.
 *
 * System-managed keys are automatically rotated by Google, and are used for
 * signing for a maximum of two weeks. The rotation process is probabilistic,
 * and usage of the new key will gradually ramp up and down over the key's
 * lifetime.
 *
 * If you cache the public key set for a service account, we recommend that you
 * update the cache every 15 minutes. User-managed keys can be added and removed
 * at any time, so it is important to update the cache frequently. For
 * Google-managed keys, Google will publish a key at least 6 hours before it is
 * first used for signing and will keep publishing it for at least 6 hours after
 * it was last used for signing.
 *
 * Public keys for all service accounts are also published at the OAuth2
 * Service Account API.
 */
export interface ServiceAccountKey {
  /**
   * The resource name of the service account key in the following format
   * `projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}/keys/{key}`.
   */
  name: string;
  /**
   * The output format for the private key.
   * Only provided in `CreateServiceAccountKey` responses, not
   * in `GetServiceAccountKey` or `ListServiceAccountKey` responses.
   *
   * Google never exposes system-managed private keys, and never retains
   * user-managed private keys.
   */
  privateKeyType: ServiceAccountPrivateKeyType;
  /** Specifies the algorithm (and possibly key size) for the key. */
  keyAlgorithm: ServiceAccountKeyAlgorithm;
  /**
   * The private key data. Only provided in `CreateServiceAccountKey`
   * responses. Make sure to keep the private key data secure because it
   * allows for the assertion of the service account identity.
   * When base64 decoded, the private key data can be used to authenticate with
   * Google API client libraries and with
   * <a href="/sdk/gcloud/reference/auth/activate-service-account">gcloud
   * auth activate-service-account</a>.
   */
  privateKeyData: Buffer;
  /** The public key data. Only provided in `GetServiceAccountKey` responses. */
  publicKeyData: Buffer;
  /** The key can be used after this timestamp. */
  validAfterTime:
    | Date
    | undefined;
  /**
   * The key can be used before this timestamp.
   * For system-managed key pairs, this timestamp is the end time for the
   * private key signing operation. The public key could still be used
   * for verification for a few hours after this time.
   */
  validBeforeTime:
    | Date
    | undefined;
  /** The key origin. */
  keyOrigin: ServiceAccountKeyOrigin;
  /** The key type. */
  keyType: ListServiceAccountKeysRequest_KeyType;
  /** The key status. */
  disabled: boolean;
}

/** The service account key create request. */
export interface CreateServiceAccountKeyRequest {
  /**
   * Required. The resource name of the service account in the following format:
   * `projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}`.
   * Using `-` as a wildcard for the `PROJECT_ID` will infer the project from
   * the account. The `ACCOUNT` value can be the `email` address or the
   * `unique_id` of the service account.
   */
  name: string;
  /**
   * The output format of the private key. The default value is
   * `TYPE_GOOGLE_CREDENTIALS_FILE`, which is the Google Credentials File
   * format.
   */
  privateKeyType: ServiceAccountPrivateKeyType;
  /**
   * Which type of key and algorithm to use for the key.
   * The default is currently a 2K RSA key.  However this may change in the
   * future.
   */
  keyAlgorithm: ServiceAccountKeyAlgorithm;
}

/** The service account key upload request. */
export interface UploadServiceAccountKeyRequest {
  /**
   * The resource name of the service account in the following format:
   * `projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}`.
   * Using `-` as a wildcard for the `PROJECT_ID` will infer the project from
   * the account. The `ACCOUNT` value can be the `email` address or the
   * `unique_id` of the service account.
   */
  name: string;
  /**
   * The public key to associate with the service account. Must be an RSA public
   * key that is wrapped in an X.509 v3 certificate. Include the first line,
   * `-----BEGIN CERTIFICATE-----`, and the last line,
   * `-----END CERTIFICATE-----`.
   */
  publicKeyData: Buffer;
}

/** The service account key delete request. */
export interface DeleteServiceAccountKeyRequest {
  /**
   * Required. The resource name of the service account key in the following format:
   * `projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}/keys/{key}`.
   * Using `-` as a wildcard for the `PROJECT_ID` will infer the project from
   * the account. The `ACCOUNT` value can be the `email` address or the
   * `unique_id` of the service account.
   */
  name: string;
}

/** The service account key disable request. */
export interface DisableServiceAccountKeyRequest {
  /**
   * Required. The resource name of the service account key in the following format:
   * `projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}/keys/{key}`.
   *
   * Using `-` as a wildcard for the `PROJECT_ID` will infer the project from
   * the account. The `ACCOUNT` value can be the `email` address or the
   * `unique_id` of the service account.
   */
  name: string;
}

/** The service account key enable request. */
export interface EnableServiceAccountKeyRequest {
  /**
   * Required. The resource name of the service account key in the following format:
   * `projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}/keys/{key}`.
   *
   * Using `-` as a wildcard for the `PROJECT_ID` will infer the project from
   * the account. The `ACCOUNT` value can be the `email` address or the
   * `unique_id` of the service account.
   */
  name: string;
}

/**
 * Deprecated. [Migrate to Service Account Credentials
 * API](https://cloud.google.com/iam/help/credentials/migrate-api).
 *
 * The service account sign blob request.
 */
export interface SignBlobRequest {
  /**
   * Required. Deprecated. [Migrate to Service Account Credentials
   * API](https://cloud.google.com/iam/help/credentials/migrate-api).
   *
   * The resource name of the service account in the following format:
   * `projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}`.
   * Using `-` as a wildcard for the `PROJECT_ID` will infer the project from
   * the account. The `ACCOUNT` value can be the `email` address or the
   * `unique_id` of the service account.
   *
   * @deprecated
   */
  name: string;
  /**
   * Required. Deprecated. [Migrate to Service Account Credentials
   * API](https://cloud.google.com/iam/help/credentials/migrate-api).
   *
   * The bytes to sign.
   *
   * @deprecated
   */
  bytesToSign: Buffer;
}

/**
 * Deprecated. [Migrate to Service Account Credentials
 * API](https://cloud.google.com/iam/help/credentials/migrate-api).
 *
 * The service account sign blob response.
 */
export interface SignBlobResponse {
  /**
   * Deprecated. [Migrate to Service Account Credentials
   * API](https://cloud.google.com/iam/help/credentials/migrate-api).
   *
   * The id of the key used to sign the blob.
   *
   * @deprecated
   */
  keyId: string;
  /**
   * Deprecated. [Migrate to Service Account Credentials
   * API](https://cloud.google.com/iam/help/credentials/migrate-api).
   *
   * The signed blob.
   *
   * @deprecated
   */
  signature: Buffer;
}

/**
 * Deprecated. [Migrate to Service Account Credentials
 * API](https://cloud.google.com/iam/help/credentials/migrate-api).
 *
 * The service account sign JWT request.
 */
export interface SignJwtRequest {
  /**
   * Required. Deprecated. [Migrate to Service Account Credentials
   * API](https://cloud.google.com/iam/help/credentials/migrate-api).
   *
   * The resource name of the service account in the following format:
   * `projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}`.
   * Using `-` as a wildcard for the `PROJECT_ID` will infer the project from
   * the account. The `ACCOUNT` value can be the `email` address or the
   * `unique_id` of the service account.
   *
   * @deprecated
   */
  name: string;
  /**
   * Required. Deprecated. [Migrate to Service Account Credentials
   * API](https://cloud.google.com/iam/help/credentials/migrate-api).
   *
   * The JWT payload to sign. Must be a serialized JSON object that contains a
   * JWT Claims Set. For example: `{"sub": "user@example.com", "iat": 313435}`
   *
   * If the JWT Claims Set contains an expiration time (`exp`) claim, it must be
   * an integer timestamp that is not in the past and no more than 12 hours in
   * the future.
   *
   * If the JWT Claims Set does not contain an expiration time (`exp`) claim,
   * this claim is added automatically, with a timestamp that is 1 hour in the
   * future.
   *
   * @deprecated
   */
  payload: string;
}

/**
 * Deprecated. [Migrate to Service Account Credentials
 * API](https://cloud.google.com/iam/help/credentials/migrate-api).
 *
 * The service account sign JWT response.
 */
export interface SignJwtResponse {
  /**
   * Deprecated. [Migrate to Service Account Credentials
   * API](https://cloud.google.com/iam/help/credentials/migrate-api).
   *
   * The id of the key used to sign the JWT.
   *
   * @deprecated
   */
  keyId: string;
  /**
   * Deprecated. [Migrate to Service Account Credentials
   * API](https://cloud.google.com/iam/help/credentials/migrate-api).
   *
   * The signed JWT.
   *
   * @deprecated
   */
  signedJwt: string;
}

/** A role in the Identity and Access Management API. */
export interface Role {
  /**
   * The name of the role.
   *
   * When Role is used in CreateRole, the role name must not be set.
   *
   * When Role is used in output and other input such as UpdateRole, the role
   * name is the complete path, e.g., roles/logging.viewer for predefined roles
   * and organizations/{ORGANIZATION_ID}/roles/logging.viewer for custom roles.
   */
  name: string;
  /**
   * Optional. A human-readable title for the role.  Typically this
   * is limited to 100 UTF-8 bytes.
   */
  title: string;
  /** Optional. A human-readable description for the role. */
  description: string;
  /** The names of the permissions this role grants when bound in an IAM policy. */
  includedPermissions: string[];
  /**
   * The current launch stage of the role. If the `ALPHA` launch stage has been
   * selected for a role, the `stage` field will not be included in the
   * returned definition for the role.
   */
  stage: Role_RoleLaunchStage;
  /** Used to perform a consistent read-modify-write. */
  etag: Buffer;
  /**
   * The current deleted state of the role. This field is read only.
   * It will be ignored in calls to CreateRole and UpdateRole.
   */
  deleted: boolean;
}

/** A stage representing a role's lifecycle phase. */
export enum Role_RoleLaunchStage {
  /**
   * ALPHA - The user has indicated this role is currently in an Alpha phase. If this
   * launch stage is selected, the `stage` field will not be included when
   * requesting the definition for a given role.
   */
  ALPHA = 0,
  /** BETA - The user has indicated this role is currently in a Beta phase. */
  BETA = 1,
  /** GA - The user has indicated this role is generally available. */
  GA = 2,
  /** DEPRECATED - The user has indicated this role is being deprecated. */
  DEPRECATED = 4,
  /**
   * DISABLED - This role is disabled and will not contribute permissions to any
   * principals it is granted to in policies.
   */
  DISABLED = 5,
  /** EAP - The user has indicated this role is currently in an EAP phase. */
  EAP = 6,
  UNRECOGNIZED = -1,
}

export function role_RoleLaunchStageFromJSON(object: any): Role_RoleLaunchStage {
  switch (object) {
    case 0:
    case "ALPHA":
      return Role_RoleLaunchStage.ALPHA;
    case 1:
    case "BETA":
      return Role_RoleLaunchStage.BETA;
    case 2:
    case "GA":
      return Role_RoleLaunchStage.GA;
    case 4:
    case "DEPRECATED":
      return Role_RoleLaunchStage.DEPRECATED;
    case 5:
    case "DISABLED":
      return Role_RoleLaunchStage.DISABLED;
    case 6:
    case "EAP":
      return Role_RoleLaunchStage.EAP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Role_RoleLaunchStage.UNRECOGNIZED;
  }
}

export function role_RoleLaunchStageToJSON(object: Role_RoleLaunchStage): string {
  switch (object) {
    case Role_RoleLaunchStage.ALPHA:
      return "ALPHA";
    case Role_RoleLaunchStage.BETA:
      return "BETA";
    case Role_RoleLaunchStage.GA:
      return "GA";
    case Role_RoleLaunchStage.DEPRECATED:
      return "DEPRECATED";
    case Role_RoleLaunchStage.DISABLED:
      return "DISABLED";
    case Role_RoleLaunchStage.EAP:
      return "EAP";
    case Role_RoleLaunchStage.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The grantable role query request. */
export interface QueryGrantableRolesRequest {
  /**
   * Required. The full resource name to query from the list of grantable roles.
   *
   * The name follows the Google Cloud Platform resource format.
   * For example, a Cloud Platform project with id `my-project` will be named
   * `//cloudresourcemanager.googleapis.com/projects/my-project`.
   */
  fullResourceName: string;
  view: RoleView;
  /**
   * Optional limit on the number of roles to include in the response.
   *
   * The default is 300, and the maximum is 1,000.
   */
  pageSize: number;
  /**
   * Optional pagination token returned in an earlier
   * QueryGrantableRolesResponse.
   */
  pageToken: string;
}

/** The grantable role query response. */
export interface QueryGrantableRolesResponse {
  /** The list of matching roles. */
  roles: Role[];
  /**
   * To retrieve the next page of results, set
   * `QueryGrantableRolesRequest.page_token` to this value.
   */
  nextPageToken: string;
}

/** The request to get all roles defined under a resource. */
export interface ListRolesRequest {
  /**
   * The `parent` parameter's value depends on the target resource for the
   * request, namely
   * [`roles`](https://cloud.google.com/iam/reference/rest/v1/roles),
   * [`projects`](https://cloud.google.com/iam/reference/rest/v1/projects.roles),
   * or
   * [`organizations`](https://cloud.google.com/iam/reference/rest/v1/organizations.roles).
   * Each resource type's `parent` value format is described below:
   *
   * * [`roles.list()`](https://cloud.google.com/iam/reference/rest/v1/roles/list): An empty string.
   *   This method doesn't require a resource; it simply returns all
   *   [predefined
   *   roles](https://cloud.google.com/iam/docs/understanding-roles#predefined_roles)
   *   in Cloud IAM. Example request URL: `https://iam.googleapis.com/v1/roles`
   *
   * * [`projects.roles.list()`](https://cloud.google.com/iam/reference/rest/v1/projects.roles/list):
   *   `projects/{PROJECT_ID}`. This method lists all project-level
   *   [custom
   *   roles](https://cloud.google.com/iam/docs/understanding-custom-roles).
   *   Example request URL:
   *   `https://iam.googleapis.com/v1/projects/{PROJECT_ID}/roles`
   *
   * * [`organizations.roles.list()`](https://cloud.google.com/iam/reference/rest/v1/organizations.roles/list):
   *   `organizations/{ORGANIZATION_ID}`. This method lists all
   *   organization-level [custom
   *   roles](https://cloud.google.com/iam/docs/understanding-custom-roles).
   *   Example request URL:
   *   `https://iam.googleapis.com/v1/organizations/{ORGANIZATION_ID}/roles`
   *
   * Note: Wildcard (*) values are invalid; you must specify a complete project
   * ID or organization ID.
   */
  parent: string;
  /**
   * Optional limit on the number of roles to include in the response.
   *
   * The default is 300, and the maximum is 1,000.
   */
  pageSize: number;
  /** Optional pagination token returned in an earlier ListRolesResponse. */
  pageToken: string;
  /**
   * Optional view for the returned Role objects. When `FULL` is specified,
   * the `includedPermissions` field is returned, which includes a list of all
   * permissions in the role. The default value is `BASIC`, which does not
   * return the `includedPermissions` field.
   */
  view: RoleView;
  /** Include Roles that have been deleted. */
  showDeleted: boolean;
}

/** The response containing the roles defined under a resource. */
export interface ListRolesResponse {
  /** The Roles defined on this resource. */
  roles: Role[];
  /**
   * To retrieve the next page of results, set
   * `ListRolesRequest.page_token` to this value.
   */
  nextPageToken: string;
}

/** The request to get the definition of an existing role. */
export interface GetRoleRequest {
  /**
   * The `name` parameter's value depends on the target resource for the
   * request, namely
   * [`roles`](https://cloud.google.com/iam/reference/rest/v1/roles),
   * [`projects`](https://cloud.google.com/iam/reference/rest/v1/projects.roles),
   * or
   * [`organizations`](https://cloud.google.com/iam/reference/rest/v1/organizations.roles).
   * Each resource type's `name` value format is described below:
   *
   * * [`roles.get()`](https://cloud.google.com/iam/reference/rest/v1/roles/get): `roles/{ROLE_NAME}`.
   *   This method returns results from all
   *   [predefined
   *   roles](https://cloud.google.com/iam/docs/understanding-roles#predefined_roles)
   *   in Cloud IAM. Example request URL:
   *   `https://iam.googleapis.com/v1/roles/{ROLE_NAME}`
   *
   * * [`projects.roles.get()`](https://cloud.google.com/iam/reference/rest/v1/projects.roles/get):
   *   `projects/{PROJECT_ID}/roles/{CUSTOM_ROLE_ID}`. This method returns only
   *   [custom
   *   roles](https://cloud.google.com/iam/docs/understanding-custom-roles) that
   *   have been created at the project level. Example request URL:
   *   `https://iam.googleapis.com/v1/projects/{PROJECT_ID}/roles/{CUSTOM_ROLE_ID}`
   *
   * * [`organizations.roles.get()`](https://cloud.google.com/iam/reference/rest/v1/organizations.roles/get):
   *   `organizations/{ORGANIZATION_ID}/roles/{CUSTOM_ROLE_ID}`. This method
   *   returns only [custom
   *   roles](https://cloud.google.com/iam/docs/understanding-custom-roles) that
   *   have been created at the organization level. Example request URL:
   *   `https://iam.googleapis.com/v1/organizations/{ORGANIZATION_ID}/roles/{CUSTOM_ROLE_ID}`
   *
   * Note: Wildcard (*) values are invalid; you must specify a complete project
   * ID or organization ID.
   */
  name: string;
}

/** The request to create a new role. */
export interface CreateRoleRequest {
  /**
   * The `parent` parameter's value depends on the target resource for the
   * request, namely
   * [`projects`](https://cloud.google.com/iam/reference/rest/v1/projects.roles)
   * or
   * [`organizations`](https://cloud.google.com/iam/reference/rest/v1/organizations.roles).
   * Each resource type's `parent` value format is described below:
   *
   * * [`projects.roles.create()`](https://cloud.google.com/iam/reference/rest/v1/projects.roles/create):
   *   `projects/{PROJECT_ID}`. This method creates project-level
   *   [custom
   *   roles](https://cloud.google.com/iam/docs/understanding-custom-roles).
   *   Example request URL:
   *   `https://iam.googleapis.com/v1/projects/{PROJECT_ID}/roles`
   *
   * * [`organizations.roles.create()`](https://cloud.google.com/iam/reference/rest/v1/organizations.roles/create):
   *   `organizations/{ORGANIZATION_ID}`. This method creates organization-level
   *   [custom
   *   roles](https://cloud.google.com/iam/docs/understanding-custom-roles).
   *   Example request URL:
   *   `https://iam.googleapis.com/v1/organizations/{ORGANIZATION_ID}/roles`
   *
   * Note: Wildcard (*) values are invalid; you must specify a complete project
   * ID or organization ID.
   */
  parent: string;
  /**
   * The role ID to use for this role.
   *
   * A role ID may contain alphanumeric characters, underscores (`_`), and
   * periods (`.`). It must contain a minimum of 3 characters and a maximum of
   * 64 characters.
   */
  roleId: string;
  /** The Role resource to create. */
  role: Role | undefined;
}

/** The request to update a role. */
export interface UpdateRoleRequest {
  /**
   * The `name` parameter's value depends on the target resource for the
   * request, namely
   * [`projects`](https://cloud.google.com/iam/reference/rest/v1/projects.roles)
   * or
   * [`organizations`](https://cloud.google.com/iam/reference/rest/v1/organizations.roles).
   * Each resource type's `name` value format is described below:
   *
   * * [`projects.roles.patch()`](https://cloud.google.com/iam/reference/rest/v1/projects.roles/patch):
   *   `projects/{PROJECT_ID}/roles/{CUSTOM_ROLE_ID}`. This method updates only
   *   [custom
   *   roles](https://cloud.google.com/iam/docs/understanding-custom-roles) that
   *   have been created at the project level. Example request URL:
   *   `https://iam.googleapis.com/v1/projects/{PROJECT_ID}/roles/{CUSTOM_ROLE_ID}`
   *
   * * [`organizations.roles.patch()`](https://cloud.google.com/iam/reference/rest/v1/organizations.roles/patch):
   *   `organizations/{ORGANIZATION_ID}/roles/{CUSTOM_ROLE_ID}`. This method
   *   updates only [custom
   *   roles](https://cloud.google.com/iam/docs/understanding-custom-roles) that
   *   have been created at the organization level. Example request URL:
   *   `https://iam.googleapis.com/v1/organizations/{ORGANIZATION_ID}/roles/{CUSTOM_ROLE_ID}`
   *
   * Note: Wildcard (*) values are invalid; you must specify a complete project
   * ID or organization ID.
   */
  name: string;
  /** The updated role. */
  role:
    | Role
    | undefined;
  /** A mask describing which fields in the Role have changed. */
  updateMask: string[] | undefined;
}

/** The request to delete an existing role. */
export interface DeleteRoleRequest {
  /**
   * The `name` parameter's value depends on the target resource for the
   * request, namely
   * [`projects`](https://cloud.google.com/iam/reference/rest/v1/projects.roles)
   * or
   * [`organizations`](https://cloud.google.com/iam/reference/rest/v1/organizations.roles).
   * Each resource type's `name` value format is described below:
   *
   * * [`projects.roles.delete()`](https://cloud.google.com/iam/reference/rest/v1/projects.roles/delete):
   *   `projects/{PROJECT_ID}/roles/{CUSTOM_ROLE_ID}`. This method deletes only
   *   [custom
   *   roles](https://cloud.google.com/iam/docs/understanding-custom-roles) that
   *   have been created at the project level. Example request URL:
   *   `https://iam.googleapis.com/v1/projects/{PROJECT_ID}/roles/{CUSTOM_ROLE_ID}`
   *
   * * [`organizations.roles.delete()`](https://cloud.google.com/iam/reference/rest/v1/organizations.roles/delete):
   *   `organizations/{ORGANIZATION_ID}/roles/{CUSTOM_ROLE_ID}`. This method
   *   deletes only [custom
   *   roles](https://cloud.google.com/iam/docs/understanding-custom-roles) that
   *   have been created at the organization level. Example request URL:
   *   `https://iam.googleapis.com/v1/organizations/{ORGANIZATION_ID}/roles/{CUSTOM_ROLE_ID}`
   *
   * Note: Wildcard (*) values are invalid; you must specify a complete project
   * ID or organization ID.
   */
  name: string;
  /** Used to perform a consistent read-modify-write. */
  etag: Buffer;
}

/** The request to undelete an existing role. */
export interface UndeleteRoleRequest {
  /**
   * The `name` parameter's value depends on the target resource for the
   * request, namely
   * [`projects`](https://cloud.google.com/iam/reference/rest/v1/projects.roles)
   * or
   * [`organizations`](https://cloud.google.com/iam/reference/rest/v1/organizations.roles).
   * Each resource type's `name` value format is described below:
   *
   * * [`projects.roles.undelete()`](https://cloud.google.com/iam/reference/rest/v1/projects.roles/undelete):
   *   `projects/{PROJECT_ID}/roles/{CUSTOM_ROLE_ID}`. This method undeletes
   *   only [custom
   *   roles](https://cloud.google.com/iam/docs/understanding-custom-roles) that
   *   have been created at the project level. Example request URL:
   *   `https://iam.googleapis.com/v1/projects/{PROJECT_ID}/roles/{CUSTOM_ROLE_ID}`
   *
   * * [`organizations.roles.undelete()`](https://cloud.google.com/iam/reference/rest/v1/organizations.roles/undelete):
   *   `organizations/{ORGANIZATION_ID}/roles/{CUSTOM_ROLE_ID}`. This method
   *   undeletes only [custom
   *   roles](https://cloud.google.com/iam/docs/understanding-custom-roles) that
   *   have been created at the organization level. Example request URL:
   *   `https://iam.googleapis.com/v1/organizations/{ORGANIZATION_ID}/roles/{CUSTOM_ROLE_ID}`
   *
   * Note: Wildcard (*) values are invalid; you must specify a complete project
   * ID or organization ID.
   */
  name: string;
  /** Used to perform a consistent read-modify-write. */
  etag: Buffer;
}

/** A permission which can be included by a role. */
export interface Permission {
  /** The name of this Permission. */
  name: string;
  /** The title of this Permission. */
  title: string;
  /**
   * A brief description of what this Permission is used for.
   * This permission can ONLY be used in predefined roles.
   */
  description: string;
  /** @deprecated */
  onlyInPredefinedRoles: boolean;
  /** The current launch stage of the permission. */
  stage: Permission_PermissionLaunchStage;
  /** The current custom role support level. */
  customRolesSupportLevel: Permission_CustomRolesSupportLevel;
  /** The service API associated with the permission is not enabled. */
  apiDisabled: boolean;
  /**
   * The preferred name for this permission. If present, then this permission is
   * an alias of, and equivalent to, the listed primary_permission.
   */
  primaryPermission: string;
}

/** A stage representing a permission's lifecycle phase. */
export enum Permission_PermissionLaunchStage {
  /** ALPHA - The permission is currently in an alpha phase. */
  ALPHA = 0,
  /** BETA - The permission is currently in a beta phase. */
  BETA = 1,
  /** GA - The permission is generally available. */
  GA = 2,
  /** DEPRECATED - The permission is being deprecated. */
  DEPRECATED = 3,
  UNRECOGNIZED = -1,
}

export function permission_PermissionLaunchStageFromJSON(object: any): Permission_PermissionLaunchStage {
  switch (object) {
    case 0:
    case "ALPHA":
      return Permission_PermissionLaunchStage.ALPHA;
    case 1:
    case "BETA":
      return Permission_PermissionLaunchStage.BETA;
    case 2:
    case "GA":
      return Permission_PermissionLaunchStage.GA;
    case 3:
    case "DEPRECATED":
      return Permission_PermissionLaunchStage.DEPRECATED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Permission_PermissionLaunchStage.UNRECOGNIZED;
  }
}

export function permission_PermissionLaunchStageToJSON(object: Permission_PermissionLaunchStage): string {
  switch (object) {
    case Permission_PermissionLaunchStage.ALPHA:
      return "ALPHA";
    case Permission_PermissionLaunchStage.BETA:
      return "BETA";
    case Permission_PermissionLaunchStage.GA:
      return "GA";
    case Permission_PermissionLaunchStage.DEPRECATED:
      return "DEPRECATED";
    case Permission_PermissionLaunchStage.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The state of the permission with regards to custom roles. */
export enum Permission_CustomRolesSupportLevel {
  /** SUPPORTED - Default state. Permission is fully supported for custom role use. */
  SUPPORTED = 0,
  /** TESTING - Permission is being tested to check custom role compatibility. */
  TESTING = 1,
  /** NOT_SUPPORTED - Permission is not supported for custom role use. */
  NOT_SUPPORTED = 2,
  UNRECOGNIZED = -1,
}

export function permission_CustomRolesSupportLevelFromJSON(object: any): Permission_CustomRolesSupportLevel {
  switch (object) {
    case 0:
    case "SUPPORTED":
      return Permission_CustomRolesSupportLevel.SUPPORTED;
    case 1:
    case "TESTING":
      return Permission_CustomRolesSupportLevel.TESTING;
    case 2:
    case "NOT_SUPPORTED":
      return Permission_CustomRolesSupportLevel.NOT_SUPPORTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Permission_CustomRolesSupportLevel.UNRECOGNIZED;
  }
}

export function permission_CustomRolesSupportLevelToJSON(object: Permission_CustomRolesSupportLevel): string {
  switch (object) {
    case Permission_CustomRolesSupportLevel.SUPPORTED:
      return "SUPPORTED";
    case Permission_CustomRolesSupportLevel.TESTING:
      return "TESTING";
    case Permission_CustomRolesSupportLevel.NOT_SUPPORTED:
      return "NOT_SUPPORTED";
    case Permission_CustomRolesSupportLevel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A request to get permissions which can be tested on a resource. */
export interface QueryTestablePermissionsRequest {
  /**
   * Required. The full resource name to query from the list of testable
   * permissions.
   *
   * The name follows the Google Cloud Platform resource format.
   * For example, a Cloud Platform project with id `my-project` will be named
   * `//cloudresourcemanager.googleapis.com/projects/my-project`.
   */
  fullResourceName: string;
  /**
   * Optional limit on the number of permissions to include in the response.
   *
   * The default is 100, and the maximum is 1,000.
   */
  pageSize: number;
  /**
   * Optional pagination token returned in an earlier
   * QueryTestablePermissionsRequest.
   */
  pageToken: string;
}

/** The response containing permissions which can be tested on a resource. */
export interface QueryTestablePermissionsResponse {
  /** The Permissions testable on the requested resource. */
  permissions: Permission[];
  /**
   * To retrieve the next page of results, set
   * `QueryTestableRolesRequest.page_token` to this value.
   */
  nextPageToken: string;
}

/** A request to get the list of auditable services for a resource. */
export interface QueryAuditableServicesRequest {
  /**
   * Required. The full resource name to query from the list of auditable
   * services.
   *
   * The name follows the Google Cloud Platform resource format.
   * For example, a Cloud Platform project with id `my-project` will be named
   * `//cloudresourcemanager.googleapis.com/projects/my-project`.
   */
  fullResourceName: string;
}

/** A response containing a list of auditable services for a resource. */
export interface QueryAuditableServicesResponse {
  /** The auditable services for a resource. */
  services: QueryAuditableServicesResponse_AuditableService[];
}

/** Contains information about an auditable service. */
export interface QueryAuditableServicesResponse_AuditableService {
  /**
   * Public name of the service.
   * For example, the service name for Cloud IAM is 'iam.googleapis.com'.
   */
  name: string;
}

/** The request to lint a Cloud IAM policy object. */
export interface LintPolicyRequest {
  /**
   * The full resource name of the policy this lint request is about.
   *
   * The name follows the Google Cloud Platform (GCP) resource format.
   * For example, a GCP project with ID `my-project` will be named
   * `//cloudresourcemanager.googleapis.com/projects/my-project`.
   *
   * The resource name is not used to read the policy instance from the Cloud
   * IAM database. The candidate policy for lint has to be provided in the same
   * request object.
   */
  fullResourceName: string;
  /** [google.iam.v1.Binding.condition] [google.iam.v1.Binding.condition] object to be linted. */
  condition?: Expr | undefined;
}

/** Structured response of a single validation unit. */
export interface LintResult {
  /** The validation unit level. */
  level: LintResult_Level;
  /**
   * The validation unit name, for instance
   * "lintValidationUnits/ConditionComplexityCheck".
   */
  validationUnitName: string;
  /** The validation unit severity. */
  severity: LintResult_Severity;
  /**
   * The name of the field for which this lint result is about.
   *
   * For nested messages `field_name` consists of names of the embedded fields
   * separated by period character. The top-level qualifier is the input object
   * to lint in the request. For example, the `field_name` value
   * `condition.expression` identifies a lint result for the `expression` field
   * of the provided condition.
   */
  fieldName: string;
  /**
   * 0-based character position of problematic construct within the object
   * identified by `field_name`. Currently, this is populated only for condition
   * expression.
   */
  locationOffset: number;
  /** Human readable debug message associated with the issue. */
  debugMessage: string;
}

/**
 * Possible Level values of a validation unit corresponding to its domain
 * of discourse.
 */
export enum LintResult_Level {
  /** LEVEL_UNSPECIFIED - Level is unspecified. */
  LEVEL_UNSPECIFIED = 0,
  /**
   * CONDITION - A validation unit which operates on an individual condition within a
   * binding.
   */
  CONDITION = 3,
  UNRECOGNIZED = -1,
}

export function lintResult_LevelFromJSON(object: any): LintResult_Level {
  switch (object) {
    case 0:
    case "LEVEL_UNSPECIFIED":
      return LintResult_Level.LEVEL_UNSPECIFIED;
    case 3:
    case "CONDITION":
      return LintResult_Level.CONDITION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LintResult_Level.UNRECOGNIZED;
  }
}

export function lintResult_LevelToJSON(object: LintResult_Level): string {
  switch (object) {
    case LintResult_Level.LEVEL_UNSPECIFIED:
      return "LEVEL_UNSPECIFIED";
    case LintResult_Level.CONDITION:
      return "CONDITION";
    case LintResult_Level.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Possible Severity values of an issued result. */
export enum LintResult_Severity {
  /** SEVERITY_UNSPECIFIED - Severity is unspecified. */
  SEVERITY_UNSPECIFIED = 0,
  /**
   * ERROR - A validation unit returns an error only for critical issues. If an
   * attempt is made to set the problematic policy without rectifying the
   * critical issue, it causes the `setPolicy` operation to fail.
   */
  ERROR = 1,
  /**
   * WARNING - Any issue which is severe enough but does not cause an error.
   * For example, suspicious constructs in the input object will not
   * necessarily fail `setPolicy`, but there is a high likelihood that they
   * won't behave as expected during policy evaluation in `checkPolicy`.
   * This includes the following common scenarios:
   *
   * - Unsatisfiable condition: Expired timestamp in date/time condition.
   * - Ineffective condition: Condition on a <principal, role> pair which is
   *   granted unconditionally in another binding of the same policy.
   */
  WARNING = 2,
  /**
   * NOTICE - Reserved for the issues that are not severe as `ERROR`/`WARNING`, but
   * need special handling. For instance, messages about skipped validation
   * units are issued as `NOTICE`.
   */
  NOTICE = 3,
  /**
   * INFO - Any informative statement which is not severe enough to raise
   * `ERROR`/`WARNING`/`NOTICE`, like auto-correction recommendations on the
   * input content. Note that current version of the linter does not utilize
   * `INFO`.
   */
  INFO = 4,
  /** DEPRECATED - Deprecated severity level. */
  DEPRECATED = 5,
  UNRECOGNIZED = -1,
}

export function lintResult_SeverityFromJSON(object: any): LintResult_Severity {
  switch (object) {
    case 0:
    case "SEVERITY_UNSPECIFIED":
      return LintResult_Severity.SEVERITY_UNSPECIFIED;
    case 1:
    case "ERROR":
      return LintResult_Severity.ERROR;
    case 2:
    case "WARNING":
      return LintResult_Severity.WARNING;
    case 3:
    case "NOTICE":
      return LintResult_Severity.NOTICE;
    case 4:
    case "INFO":
      return LintResult_Severity.INFO;
    case 5:
    case "DEPRECATED":
      return LintResult_Severity.DEPRECATED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LintResult_Severity.UNRECOGNIZED;
  }
}

export function lintResult_SeverityToJSON(object: LintResult_Severity): string {
  switch (object) {
    case LintResult_Severity.SEVERITY_UNSPECIFIED:
      return "SEVERITY_UNSPECIFIED";
    case LintResult_Severity.ERROR:
      return "ERROR";
    case LintResult_Severity.WARNING:
      return "WARNING";
    case LintResult_Severity.NOTICE:
      return "NOTICE";
    case LintResult_Severity.INFO:
      return "INFO";
    case LintResult_Severity.DEPRECATED:
      return "DEPRECATED";
    case LintResult_Severity.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The response of a lint operation. An empty response indicates
 * the operation was able to fully execute and no lint issue was found.
 */
export interface LintPolicyResponse {
  /** List of lint results sorted by `severity` in descending order. */
  lintResults: LintResult[];
}

function createBaseServiceAccount(): ServiceAccount {
  return {
    name: "",
    projectId: "",
    uniqueId: "",
    email: "",
    displayName: "",
    etag: Buffer.alloc(0),
    description: "",
    oauth2ClientId: "",
    disabled: false,
  };
}

export const ServiceAccount: MessageFns<ServiceAccount> = {
  encode(message: ServiceAccount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.projectId !== "") {
      writer.uint32(18).string(message.projectId);
    }
    if (message.uniqueId !== "") {
      writer.uint32(34).string(message.uniqueId);
    }
    if (message.email !== "") {
      writer.uint32(42).string(message.email);
    }
    if (message.displayName !== "") {
      writer.uint32(50).string(message.displayName);
    }
    if (message.etag.length !== 0) {
      writer.uint32(58).bytes(message.etag);
    }
    if (message.description !== "") {
      writer.uint32(66).string(message.description);
    }
    if (message.oauth2ClientId !== "") {
      writer.uint32(74).string(message.oauth2ClientId);
    }
    if (message.disabled !== false) {
      writer.uint32(88).bool(message.disabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceAccount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.uniqueId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.email = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.etag = Buffer.from(reader.bytes());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.description = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.oauth2ClientId = reader.string();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.disabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceAccount {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      uniqueId: isSet(object.uniqueId) ? globalThis.String(object.uniqueId) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      etag: isSet(object.etag) ? Buffer.from(bytesFromBase64(object.etag)) : Buffer.alloc(0),
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      oauth2ClientId: isSet(object.oauth2ClientId) ? globalThis.String(object.oauth2ClientId) : "",
      disabled: isSet(object.disabled) ? globalThis.Boolean(object.disabled) : false,
    };
  },

  toJSON(message: ServiceAccount): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.uniqueId !== "") {
      obj.uniqueId = message.uniqueId;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.etag.length !== 0) {
      obj.etag = base64FromBytes(message.etag);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.oauth2ClientId !== "") {
      obj.oauth2ClientId = message.oauth2ClientId;
    }
    if (message.disabled !== false) {
      obj.disabled = message.disabled;
    }
    return obj;
  },

  create(base?: DeepPartial<ServiceAccount>): ServiceAccount {
    return ServiceAccount.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ServiceAccount>): ServiceAccount {
    const message = createBaseServiceAccount();
    message.name = object.name ?? "";
    message.projectId = object.projectId ?? "";
    message.uniqueId = object.uniqueId ?? "";
    message.email = object.email ?? "";
    message.displayName = object.displayName ?? "";
    message.etag = object.etag ?? Buffer.alloc(0);
    message.description = object.description ?? "";
    message.oauth2ClientId = object.oauth2ClientId ?? "";
    message.disabled = object.disabled ?? false;
    return message;
  },
};

function createBaseCreateServiceAccountRequest(): CreateServiceAccountRequest {
  return { name: "", accountId: "", serviceAccount: undefined };
}

export const CreateServiceAccountRequest: MessageFns<CreateServiceAccountRequest> = {
  encode(message: CreateServiceAccountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.accountId !== "") {
      writer.uint32(18).string(message.accountId);
    }
    if (message.serviceAccount !== undefined) {
      ServiceAccount.encode(message.serviceAccount, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateServiceAccountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateServiceAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.serviceAccount = ServiceAccount.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateServiceAccountRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      accountId: isSet(object.accountId) ? globalThis.String(object.accountId) : "",
      serviceAccount: isSet(object.serviceAccount) ? ServiceAccount.fromJSON(object.serviceAccount) : undefined,
    };
  },

  toJSON(message: CreateServiceAccountRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.accountId !== "") {
      obj.accountId = message.accountId;
    }
    if (message.serviceAccount !== undefined) {
      obj.serviceAccount = ServiceAccount.toJSON(message.serviceAccount);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateServiceAccountRequest>): CreateServiceAccountRequest {
    return CreateServiceAccountRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateServiceAccountRequest>): CreateServiceAccountRequest {
    const message = createBaseCreateServiceAccountRequest();
    message.name = object.name ?? "";
    message.accountId = object.accountId ?? "";
    message.serviceAccount = (object.serviceAccount !== undefined && object.serviceAccount !== null)
      ? ServiceAccount.fromPartial(object.serviceAccount)
      : undefined;
    return message;
  },
};

function createBaseListServiceAccountsRequest(): ListServiceAccountsRequest {
  return { name: "", pageSize: 0, pageToken: "" };
}

export const ListServiceAccountsRequest: MessageFns<ListServiceAccountsRequest> = {
  encode(message: ListServiceAccountsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListServiceAccountsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListServiceAccountsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListServiceAccountsRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListServiceAccountsRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListServiceAccountsRequest>): ListServiceAccountsRequest {
    return ListServiceAccountsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListServiceAccountsRequest>): ListServiceAccountsRequest {
    const message = createBaseListServiceAccountsRequest();
    message.name = object.name ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListServiceAccountsResponse(): ListServiceAccountsResponse {
  return { accounts: [], nextPageToken: "" };
}

export const ListServiceAccountsResponse: MessageFns<ListServiceAccountsResponse> = {
  encode(message: ListServiceAccountsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.accounts) {
      ServiceAccount.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListServiceAccountsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListServiceAccountsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accounts.push(ServiceAccount.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListServiceAccountsResponse {
    return {
      accounts: globalThis.Array.isArray(object?.accounts)
        ? object.accounts.map((e: any) => ServiceAccount.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListServiceAccountsResponse): unknown {
    const obj: any = {};
    if (message.accounts?.length) {
      obj.accounts = message.accounts.map((e) => ServiceAccount.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListServiceAccountsResponse>): ListServiceAccountsResponse {
    return ListServiceAccountsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListServiceAccountsResponse>): ListServiceAccountsResponse {
    const message = createBaseListServiceAccountsResponse();
    message.accounts = object.accounts?.map((e) => ServiceAccount.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetServiceAccountRequest(): GetServiceAccountRequest {
  return { name: "" };
}

export const GetServiceAccountRequest: MessageFns<GetServiceAccountRequest> = {
  encode(message: GetServiceAccountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetServiceAccountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetServiceAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetServiceAccountRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetServiceAccountRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetServiceAccountRequest>): GetServiceAccountRequest {
    return GetServiceAccountRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetServiceAccountRequest>): GetServiceAccountRequest {
    const message = createBaseGetServiceAccountRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteServiceAccountRequest(): DeleteServiceAccountRequest {
  return { name: "" };
}

export const DeleteServiceAccountRequest: MessageFns<DeleteServiceAccountRequest> = {
  encode(message: DeleteServiceAccountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteServiceAccountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteServiceAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteServiceAccountRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteServiceAccountRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteServiceAccountRequest>): DeleteServiceAccountRequest {
    return DeleteServiceAccountRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteServiceAccountRequest>): DeleteServiceAccountRequest {
    const message = createBaseDeleteServiceAccountRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBasePatchServiceAccountRequest(): PatchServiceAccountRequest {
  return { serviceAccount: undefined, updateMask: undefined };
}

export const PatchServiceAccountRequest: MessageFns<PatchServiceAccountRequest> = {
  encode(message: PatchServiceAccountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceAccount !== undefined) {
      ServiceAccount.encode(message.serviceAccount, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchServiceAccountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchServiceAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.serviceAccount = ServiceAccount.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchServiceAccountRequest {
    return {
      serviceAccount: isSet(object.serviceAccount) ? ServiceAccount.fromJSON(object.serviceAccount) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: PatchServiceAccountRequest): unknown {
    const obj: any = {};
    if (message.serviceAccount !== undefined) {
      obj.serviceAccount = ServiceAccount.toJSON(message.serviceAccount);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<PatchServiceAccountRequest>): PatchServiceAccountRequest {
    return PatchServiceAccountRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PatchServiceAccountRequest>): PatchServiceAccountRequest {
    const message = createBasePatchServiceAccountRequest();
    message.serviceAccount = (object.serviceAccount !== undefined && object.serviceAccount !== null)
      ? ServiceAccount.fromPartial(object.serviceAccount)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseUndeleteServiceAccountRequest(): UndeleteServiceAccountRequest {
  return { name: "" };
}

export const UndeleteServiceAccountRequest: MessageFns<UndeleteServiceAccountRequest> = {
  encode(message: UndeleteServiceAccountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UndeleteServiceAccountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUndeleteServiceAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UndeleteServiceAccountRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: UndeleteServiceAccountRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<UndeleteServiceAccountRequest>): UndeleteServiceAccountRequest {
    return UndeleteServiceAccountRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UndeleteServiceAccountRequest>): UndeleteServiceAccountRequest {
    const message = createBaseUndeleteServiceAccountRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUndeleteServiceAccountResponse(): UndeleteServiceAccountResponse {
  return { restoredAccount: undefined };
}

export const UndeleteServiceAccountResponse: MessageFns<UndeleteServiceAccountResponse> = {
  encode(message: UndeleteServiceAccountResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.restoredAccount !== undefined) {
      ServiceAccount.encode(message.restoredAccount, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UndeleteServiceAccountResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUndeleteServiceAccountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.restoredAccount = ServiceAccount.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UndeleteServiceAccountResponse {
    return {
      restoredAccount: isSet(object.restoredAccount) ? ServiceAccount.fromJSON(object.restoredAccount) : undefined,
    };
  },

  toJSON(message: UndeleteServiceAccountResponse): unknown {
    const obj: any = {};
    if (message.restoredAccount !== undefined) {
      obj.restoredAccount = ServiceAccount.toJSON(message.restoredAccount);
    }
    return obj;
  },

  create(base?: DeepPartial<UndeleteServiceAccountResponse>): UndeleteServiceAccountResponse {
    return UndeleteServiceAccountResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UndeleteServiceAccountResponse>): UndeleteServiceAccountResponse {
    const message = createBaseUndeleteServiceAccountResponse();
    message.restoredAccount = (object.restoredAccount !== undefined && object.restoredAccount !== null)
      ? ServiceAccount.fromPartial(object.restoredAccount)
      : undefined;
    return message;
  },
};

function createBaseEnableServiceAccountRequest(): EnableServiceAccountRequest {
  return { name: "" };
}

export const EnableServiceAccountRequest: MessageFns<EnableServiceAccountRequest> = {
  encode(message: EnableServiceAccountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnableServiceAccountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnableServiceAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnableServiceAccountRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: EnableServiceAccountRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<EnableServiceAccountRequest>): EnableServiceAccountRequest {
    return EnableServiceAccountRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EnableServiceAccountRequest>): EnableServiceAccountRequest {
    const message = createBaseEnableServiceAccountRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDisableServiceAccountRequest(): DisableServiceAccountRequest {
  return { name: "" };
}

export const DisableServiceAccountRequest: MessageFns<DisableServiceAccountRequest> = {
  encode(message: DisableServiceAccountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DisableServiceAccountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDisableServiceAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DisableServiceAccountRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DisableServiceAccountRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DisableServiceAccountRequest>): DisableServiceAccountRequest {
    return DisableServiceAccountRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DisableServiceAccountRequest>): DisableServiceAccountRequest {
    const message = createBaseDisableServiceAccountRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListServiceAccountKeysRequest(): ListServiceAccountKeysRequest {
  return { name: "", keyTypes: [] };
}

export const ListServiceAccountKeysRequest: MessageFns<ListServiceAccountKeysRequest> = {
  encode(message: ListServiceAccountKeysRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    writer.uint32(18).fork();
    for (const v of message.keyTypes) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListServiceAccountKeysRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListServiceAccountKeysRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag === 16) {
            message.keyTypes.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.keyTypes.push(reader.int32() as any);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListServiceAccountKeysRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      keyTypes: globalThis.Array.isArray(object?.keyTypes)
        ? object.keyTypes.map((e: any) => listServiceAccountKeysRequest_KeyTypeFromJSON(e))
        : [],
    };
  },

  toJSON(message: ListServiceAccountKeysRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.keyTypes?.length) {
      obj.keyTypes = message.keyTypes.map((e) => listServiceAccountKeysRequest_KeyTypeToJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListServiceAccountKeysRequest>): ListServiceAccountKeysRequest {
    return ListServiceAccountKeysRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListServiceAccountKeysRequest>): ListServiceAccountKeysRequest {
    const message = createBaseListServiceAccountKeysRequest();
    message.name = object.name ?? "";
    message.keyTypes = object.keyTypes?.map((e) => e) || [];
    return message;
  },
};

function createBaseListServiceAccountKeysResponse(): ListServiceAccountKeysResponse {
  return { keys: [] };
}

export const ListServiceAccountKeysResponse: MessageFns<ListServiceAccountKeysResponse> = {
  encode(message: ListServiceAccountKeysResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.keys) {
      ServiceAccountKey.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListServiceAccountKeysResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListServiceAccountKeysResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.keys.push(ServiceAccountKey.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListServiceAccountKeysResponse {
    return {
      keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e: any) => ServiceAccountKey.fromJSON(e)) : [],
    };
  },

  toJSON(message: ListServiceAccountKeysResponse): unknown {
    const obj: any = {};
    if (message.keys?.length) {
      obj.keys = message.keys.map((e) => ServiceAccountKey.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListServiceAccountKeysResponse>): ListServiceAccountKeysResponse {
    return ListServiceAccountKeysResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListServiceAccountKeysResponse>): ListServiceAccountKeysResponse {
    const message = createBaseListServiceAccountKeysResponse();
    message.keys = object.keys?.map((e) => ServiceAccountKey.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetServiceAccountKeyRequest(): GetServiceAccountKeyRequest {
  return { name: "", publicKeyType: 0 };
}

export const GetServiceAccountKeyRequest: MessageFns<GetServiceAccountKeyRequest> = {
  encode(message: GetServiceAccountKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.publicKeyType !== 0) {
      writer.uint32(16).int32(message.publicKeyType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetServiceAccountKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetServiceAccountKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.publicKeyType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetServiceAccountKeyRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      publicKeyType: isSet(object.publicKeyType) ? serviceAccountPublicKeyTypeFromJSON(object.publicKeyType) : 0,
    };
  },

  toJSON(message: GetServiceAccountKeyRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.publicKeyType !== 0) {
      obj.publicKeyType = serviceAccountPublicKeyTypeToJSON(message.publicKeyType);
    }
    return obj;
  },

  create(base?: DeepPartial<GetServiceAccountKeyRequest>): GetServiceAccountKeyRequest {
    return GetServiceAccountKeyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetServiceAccountKeyRequest>): GetServiceAccountKeyRequest {
    const message = createBaseGetServiceAccountKeyRequest();
    message.name = object.name ?? "";
    message.publicKeyType = object.publicKeyType ?? 0;
    return message;
  },
};

function createBaseServiceAccountKey(): ServiceAccountKey {
  return {
    name: "",
    privateKeyType: 0,
    keyAlgorithm: 0,
    privateKeyData: Buffer.alloc(0),
    publicKeyData: Buffer.alloc(0),
    validAfterTime: undefined,
    validBeforeTime: undefined,
    keyOrigin: 0,
    keyType: 0,
    disabled: false,
  };
}

export const ServiceAccountKey: MessageFns<ServiceAccountKey> = {
  encode(message: ServiceAccountKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.privateKeyType !== 0) {
      writer.uint32(16).int32(message.privateKeyType);
    }
    if (message.keyAlgorithm !== 0) {
      writer.uint32(64).int32(message.keyAlgorithm);
    }
    if (message.privateKeyData.length !== 0) {
      writer.uint32(26).bytes(message.privateKeyData);
    }
    if (message.publicKeyData.length !== 0) {
      writer.uint32(58).bytes(message.publicKeyData);
    }
    if (message.validAfterTime !== undefined) {
      Timestamp.encode(toTimestamp(message.validAfterTime), writer.uint32(34).fork()).join();
    }
    if (message.validBeforeTime !== undefined) {
      Timestamp.encode(toTimestamp(message.validBeforeTime), writer.uint32(42).fork()).join();
    }
    if (message.keyOrigin !== 0) {
      writer.uint32(72).int32(message.keyOrigin);
    }
    if (message.keyType !== 0) {
      writer.uint32(80).int32(message.keyType);
    }
    if (message.disabled !== false) {
      writer.uint32(88).bool(message.disabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceAccountKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceAccountKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.privateKeyType = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.keyAlgorithm = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.privateKeyData = Buffer.from(reader.bytes());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.publicKeyData = Buffer.from(reader.bytes());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.validAfterTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.validBeforeTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.keyOrigin = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.keyType = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.disabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceAccountKey {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      privateKeyType: isSet(object.privateKeyType) ? serviceAccountPrivateKeyTypeFromJSON(object.privateKeyType) : 0,
      keyAlgorithm: isSet(object.keyAlgorithm) ? serviceAccountKeyAlgorithmFromJSON(object.keyAlgorithm) : 0,
      privateKeyData: isSet(object.privateKeyData)
        ? Buffer.from(bytesFromBase64(object.privateKeyData))
        : Buffer.alloc(0),
      publicKeyData: isSet(object.publicKeyData) ? Buffer.from(bytesFromBase64(object.publicKeyData)) : Buffer.alloc(0),
      validAfterTime: isSet(object.validAfterTime) ? fromJsonTimestamp(object.validAfterTime) : undefined,
      validBeforeTime: isSet(object.validBeforeTime) ? fromJsonTimestamp(object.validBeforeTime) : undefined,
      keyOrigin: isSet(object.keyOrigin) ? serviceAccountKeyOriginFromJSON(object.keyOrigin) : 0,
      keyType: isSet(object.keyType) ? listServiceAccountKeysRequest_KeyTypeFromJSON(object.keyType) : 0,
      disabled: isSet(object.disabled) ? globalThis.Boolean(object.disabled) : false,
    };
  },

  toJSON(message: ServiceAccountKey): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.privateKeyType !== 0) {
      obj.privateKeyType = serviceAccountPrivateKeyTypeToJSON(message.privateKeyType);
    }
    if (message.keyAlgorithm !== 0) {
      obj.keyAlgorithm = serviceAccountKeyAlgorithmToJSON(message.keyAlgorithm);
    }
    if (message.privateKeyData.length !== 0) {
      obj.privateKeyData = base64FromBytes(message.privateKeyData);
    }
    if (message.publicKeyData.length !== 0) {
      obj.publicKeyData = base64FromBytes(message.publicKeyData);
    }
    if (message.validAfterTime !== undefined) {
      obj.validAfterTime = message.validAfterTime.toISOString();
    }
    if (message.validBeforeTime !== undefined) {
      obj.validBeforeTime = message.validBeforeTime.toISOString();
    }
    if (message.keyOrigin !== 0) {
      obj.keyOrigin = serviceAccountKeyOriginToJSON(message.keyOrigin);
    }
    if (message.keyType !== 0) {
      obj.keyType = listServiceAccountKeysRequest_KeyTypeToJSON(message.keyType);
    }
    if (message.disabled !== false) {
      obj.disabled = message.disabled;
    }
    return obj;
  },

  create(base?: DeepPartial<ServiceAccountKey>): ServiceAccountKey {
    return ServiceAccountKey.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ServiceAccountKey>): ServiceAccountKey {
    const message = createBaseServiceAccountKey();
    message.name = object.name ?? "";
    message.privateKeyType = object.privateKeyType ?? 0;
    message.keyAlgorithm = object.keyAlgorithm ?? 0;
    message.privateKeyData = object.privateKeyData ?? Buffer.alloc(0);
    message.publicKeyData = object.publicKeyData ?? Buffer.alloc(0);
    message.validAfterTime = object.validAfterTime ?? undefined;
    message.validBeforeTime = object.validBeforeTime ?? undefined;
    message.keyOrigin = object.keyOrigin ?? 0;
    message.keyType = object.keyType ?? 0;
    message.disabled = object.disabled ?? false;
    return message;
  },
};

function createBaseCreateServiceAccountKeyRequest(): CreateServiceAccountKeyRequest {
  return { name: "", privateKeyType: 0, keyAlgorithm: 0 };
}

export const CreateServiceAccountKeyRequest: MessageFns<CreateServiceAccountKeyRequest> = {
  encode(message: CreateServiceAccountKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.privateKeyType !== 0) {
      writer.uint32(16).int32(message.privateKeyType);
    }
    if (message.keyAlgorithm !== 0) {
      writer.uint32(24).int32(message.keyAlgorithm);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateServiceAccountKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateServiceAccountKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.privateKeyType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.keyAlgorithm = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateServiceAccountKeyRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      privateKeyType: isSet(object.privateKeyType) ? serviceAccountPrivateKeyTypeFromJSON(object.privateKeyType) : 0,
      keyAlgorithm: isSet(object.keyAlgorithm) ? serviceAccountKeyAlgorithmFromJSON(object.keyAlgorithm) : 0,
    };
  },

  toJSON(message: CreateServiceAccountKeyRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.privateKeyType !== 0) {
      obj.privateKeyType = serviceAccountPrivateKeyTypeToJSON(message.privateKeyType);
    }
    if (message.keyAlgorithm !== 0) {
      obj.keyAlgorithm = serviceAccountKeyAlgorithmToJSON(message.keyAlgorithm);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateServiceAccountKeyRequest>): CreateServiceAccountKeyRequest {
    return CreateServiceAccountKeyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateServiceAccountKeyRequest>): CreateServiceAccountKeyRequest {
    const message = createBaseCreateServiceAccountKeyRequest();
    message.name = object.name ?? "";
    message.privateKeyType = object.privateKeyType ?? 0;
    message.keyAlgorithm = object.keyAlgorithm ?? 0;
    return message;
  },
};

function createBaseUploadServiceAccountKeyRequest(): UploadServiceAccountKeyRequest {
  return { name: "", publicKeyData: Buffer.alloc(0) };
}

export const UploadServiceAccountKeyRequest: MessageFns<UploadServiceAccountKeyRequest> = {
  encode(message: UploadServiceAccountKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.publicKeyData.length !== 0) {
      writer.uint32(18).bytes(message.publicKeyData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UploadServiceAccountKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadServiceAccountKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.publicKeyData = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UploadServiceAccountKeyRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      publicKeyData: isSet(object.publicKeyData) ? Buffer.from(bytesFromBase64(object.publicKeyData)) : Buffer.alloc(0),
    };
  },

  toJSON(message: UploadServiceAccountKeyRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.publicKeyData.length !== 0) {
      obj.publicKeyData = base64FromBytes(message.publicKeyData);
    }
    return obj;
  },

  create(base?: DeepPartial<UploadServiceAccountKeyRequest>): UploadServiceAccountKeyRequest {
    return UploadServiceAccountKeyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UploadServiceAccountKeyRequest>): UploadServiceAccountKeyRequest {
    const message = createBaseUploadServiceAccountKeyRequest();
    message.name = object.name ?? "";
    message.publicKeyData = object.publicKeyData ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseDeleteServiceAccountKeyRequest(): DeleteServiceAccountKeyRequest {
  return { name: "" };
}

export const DeleteServiceAccountKeyRequest: MessageFns<DeleteServiceAccountKeyRequest> = {
  encode(message: DeleteServiceAccountKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteServiceAccountKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteServiceAccountKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteServiceAccountKeyRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteServiceAccountKeyRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteServiceAccountKeyRequest>): DeleteServiceAccountKeyRequest {
    return DeleteServiceAccountKeyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteServiceAccountKeyRequest>): DeleteServiceAccountKeyRequest {
    const message = createBaseDeleteServiceAccountKeyRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDisableServiceAccountKeyRequest(): DisableServiceAccountKeyRequest {
  return { name: "" };
}

export const DisableServiceAccountKeyRequest: MessageFns<DisableServiceAccountKeyRequest> = {
  encode(message: DisableServiceAccountKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DisableServiceAccountKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDisableServiceAccountKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DisableServiceAccountKeyRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DisableServiceAccountKeyRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DisableServiceAccountKeyRequest>): DisableServiceAccountKeyRequest {
    return DisableServiceAccountKeyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DisableServiceAccountKeyRequest>): DisableServiceAccountKeyRequest {
    const message = createBaseDisableServiceAccountKeyRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseEnableServiceAccountKeyRequest(): EnableServiceAccountKeyRequest {
  return { name: "" };
}

export const EnableServiceAccountKeyRequest: MessageFns<EnableServiceAccountKeyRequest> = {
  encode(message: EnableServiceAccountKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnableServiceAccountKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnableServiceAccountKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnableServiceAccountKeyRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: EnableServiceAccountKeyRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<EnableServiceAccountKeyRequest>): EnableServiceAccountKeyRequest {
    return EnableServiceAccountKeyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EnableServiceAccountKeyRequest>): EnableServiceAccountKeyRequest {
    const message = createBaseEnableServiceAccountKeyRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseSignBlobRequest(): SignBlobRequest {
  return { name: "", bytesToSign: Buffer.alloc(0) };
}

export const SignBlobRequest: MessageFns<SignBlobRequest> = {
  encode(message: SignBlobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.bytesToSign.length !== 0) {
      writer.uint32(18).bytes(message.bytesToSign);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignBlobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignBlobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.bytesToSign = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignBlobRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      bytesToSign: isSet(object.bytesToSign) ? Buffer.from(bytesFromBase64(object.bytesToSign)) : Buffer.alloc(0),
    };
  },

  toJSON(message: SignBlobRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.bytesToSign.length !== 0) {
      obj.bytesToSign = base64FromBytes(message.bytesToSign);
    }
    return obj;
  },

  create(base?: DeepPartial<SignBlobRequest>): SignBlobRequest {
    return SignBlobRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SignBlobRequest>): SignBlobRequest {
    const message = createBaseSignBlobRequest();
    message.name = object.name ?? "";
    message.bytesToSign = object.bytesToSign ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseSignBlobResponse(): SignBlobResponse {
  return { keyId: "", signature: Buffer.alloc(0) };
}

export const SignBlobResponse: MessageFns<SignBlobResponse> = {
  encode(message: SignBlobResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyId !== "") {
      writer.uint32(10).string(message.keyId);
    }
    if (message.signature.length !== 0) {
      writer.uint32(18).bytes(message.signature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignBlobResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignBlobResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.keyId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.signature = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignBlobResponse {
    return {
      keyId: isSet(object.keyId) ? globalThis.String(object.keyId) : "",
      signature: isSet(object.signature) ? Buffer.from(bytesFromBase64(object.signature)) : Buffer.alloc(0),
    };
  },

  toJSON(message: SignBlobResponse): unknown {
    const obj: any = {};
    if (message.keyId !== "") {
      obj.keyId = message.keyId;
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    return obj;
  },

  create(base?: DeepPartial<SignBlobResponse>): SignBlobResponse {
    return SignBlobResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SignBlobResponse>): SignBlobResponse {
    const message = createBaseSignBlobResponse();
    message.keyId = object.keyId ?? "";
    message.signature = object.signature ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseSignJwtRequest(): SignJwtRequest {
  return { name: "", payload: "" };
}

export const SignJwtRequest: MessageFns<SignJwtRequest> = {
  encode(message: SignJwtRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.payload !== "") {
      writer.uint32(18).string(message.payload);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignJwtRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignJwtRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.payload = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignJwtRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      payload: isSet(object.payload) ? globalThis.String(object.payload) : "",
    };
  },

  toJSON(message: SignJwtRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.payload !== "") {
      obj.payload = message.payload;
    }
    return obj;
  },

  create(base?: DeepPartial<SignJwtRequest>): SignJwtRequest {
    return SignJwtRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SignJwtRequest>): SignJwtRequest {
    const message = createBaseSignJwtRequest();
    message.name = object.name ?? "";
    message.payload = object.payload ?? "";
    return message;
  },
};

function createBaseSignJwtResponse(): SignJwtResponse {
  return { keyId: "", signedJwt: "" };
}

export const SignJwtResponse: MessageFns<SignJwtResponse> = {
  encode(message: SignJwtResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyId !== "") {
      writer.uint32(10).string(message.keyId);
    }
    if (message.signedJwt !== "") {
      writer.uint32(18).string(message.signedJwt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignJwtResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignJwtResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.keyId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.signedJwt = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignJwtResponse {
    return {
      keyId: isSet(object.keyId) ? globalThis.String(object.keyId) : "",
      signedJwt: isSet(object.signedJwt) ? globalThis.String(object.signedJwt) : "",
    };
  },

  toJSON(message: SignJwtResponse): unknown {
    const obj: any = {};
    if (message.keyId !== "") {
      obj.keyId = message.keyId;
    }
    if (message.signedJwt !== "") {
      obj.signedJwt = message.signedJwt;
    }
    return obj;
  },

  create(base?: DeepPartial<SignJwtResponse>): SignJwtResponse {
    return SignJwtResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SignJwtResponse>): SignJwtResponse {
    const message = createBaseSignJwtResponse();
    message.keyId = object.keyId ?? "";
    message.signedJwt = object.signedJwt ?? "";
    return message;
  },
};

function createBaseRole(): Role {
  return {
    name: "",
    title: "",
    description: "",
    includedPermissions: [],
    stage: 0,
    etag: Buffer.alloc(0),
    deleted: false,
  };
}

export const Role: MessageFns<Role> = {
  encode(message: Role, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    for (const v of message.includedPermissions) {
      writer.uint32(58).string(v!);
    }
    if (message.stage !== 0) {
      writer.uint32(64).int32(message.stage);
    }
    if (message.etag.length !== 0) {
      writer.uint32(74).bytes(message.etag);
    }
    if (message.deleted !== false) {
      writer.uint32(88).bool(message.deleted);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Role {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRole();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.includedPermissions.push(reader.string());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.stage = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.etag = Buffer.from(reader.bytes());
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.deleted = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Role {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      includedPermissions: globalThis.Array.isArray(object?.includedPermissions)
        ? object.includedPermissions.map((e: any) => globalThis.String(e))
        : [],
      stage: isSet(object.stage) ? role_RoleLaunchStageFromJSON(object.stage) : 0,
      etag: isSet(object.etag) ? Buffer.from(bytesFromBase64(object.etag)) : Buffer.alloc(0),
      deleted: isSet(object.deleted) ? globalThis.Boolean(object.deleted) : false,
    };
  },

  toJSON(message: Role): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.includedPermissions?.length) {
      obj.includedPermissions = message.includedPermissions;
    }
    if (message.stage !== 0) {
      obj.stage = role_RoleLaunchStageToJSON(message.stage);
    }
    if (message.etag.length !== 0) {
      obj.etag = base64FromBytes(message.etag);
    }
    if (message.deleted !== false) {
      obj.deleted = message.deleted;
    }
    return obj;
  },

  create(base?: DeepPartial<Role>): Role {
    return Role.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Role>): Role {
    const message = createBaseRole();
    message.name = object.name ?? "";
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.includedPermissions = object.includedPermissions?.map((e) => e) || [];
    message.stage = object.stage ?? 0;
    message.etag = object.etag ?? Buffer.alloc(0);
    message.deleted = object.deleted ?? false;
    return message;
  },
};

function createBaseQueryGrantableRolesRequest(): QueryGrantableRolesRequest {
  return { fullResourceName: "", view: 0, pageSize: 0, pageToken: "" };
}

export const QueryGrantableRolesRequest: MessageFns<QueryGrantableRolesRequest> = {
  encode(message: QueryGrantableRolesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fullResourceName !== "") {
      writer.uint32(10).string(message.fullResourceName);
    }
    if (message.view !== 0) {
      writer.uint32(16).int32(message.view);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGrantableRolesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGrantableRolesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fullResourceName = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGrantableRolesRequest {
    return {
      fullResourceName: isSet(object.fullResourceName) ? globalThis.String(object.fullResourceName) : "",
      view: isSet(object.view) ? roleViewFromJSON(object.view) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: QueryGrantableRolesRequest): unknown {
    const obj: any = {};
    if (message.fullResourceName !== "") {
      obj.fullResourceName = message.fullResourceName;
    }
    if (message.view !== 0) {
      obj.view = roleViewToJSON(message.view);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryGrantableRolesRequest>): QueryGrantableRolesRequest {
    return QueryGrantableRolesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryGrantableRolesRequest>): QueryGrantableRolesRequest {
    const message = createBaseQueryGrantableRolesRequest();
    message.fullResourceName = object.fullResourceName ?? "";
    message.view = object.view ?? 0;
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseQueryGrantableRolesResponse(): QueryGrantableRolesResponse {
  return { roles: [], nextPageToken: "" };
}

export const QueryGrantableRolesResponse: MessageFns<QueryGrantableRolesResponse> = {
  encode(message: QueryGrantableRolesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.roles) {
      Role.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGrantableRolesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGrantableRolesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.roles.push(Role.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGrantableRolesResponse {
    return {
      roles: globalThis.Array.isArray(object?.roles) ? object.roles.map((e: any) => Role.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: QueryGrantableRolesResponse): unknown {
    const obj: any = {};
    if (message.roles?.length) {
      obj.roles = message.roles.map((e) => Role.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryGrantableRolesResponse>): QueryGrantableRolesResponse {
    return QueryGrantableRolesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryGrantableRolesResponse>): QueryGrantableRolesResponse {
    const message = createBaseQueryGrantableRolesResponse();
    message.roles = object.roles?.map((e) => Role.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseListRolesRequest(): ListRolesRequest {
  return { parent: "", pageSize: 0, pageToken: "", view: 0, showDeleted: false };
}

export const ListRolesRequest: MessageFns<ListRolesRequest> = {
  encode(message: ListRolesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.view !== 0) {
      writer.uint32(32).int32(message.view);
    }
    if (message.showDeleted !== false) {
      writer.uint32(48).bool(message.showDeleted);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRolesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRolesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.showDeleted = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRolesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      view: isSet(object.view) ? roleViewFromJSON(object.view) : 0,
      showDeleted: isSet(object.showDeleted) ? globalThis.Boolean(object.showDeleted) : false,
    };
  },

  toJSON(message: ListRolesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.view !== 0) {
      obj.view = roleViewToJSON(message.view);
    }
    if (message.showDeleted !== false) {
      obj.showDeleted = message.showDeleted;
    }
    return obj;
  },

  create(base?: DeepPartial<ListRolesRequest>): ListRolesRequest {
    return ListRolesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRolesRequest>): ListRolesRequest {
    const message = createBaseListRolesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.view = object.view ?? 0;
    message.showDeleted = object.showDeleted ?? false;
    return message;
  },
};

function createBaseListRolesResponse(): ListRolesResponse {
  return { roles: [], nextPageToken: "" };
}

export const ListRolesResponse: MessageFns<ListRolesResponse> = {
  encode(message: ListRolesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.roles) {
      Role.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRolesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRolesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.roles.push(Role.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRolesResponse {
    return {
      roles: globalThis.Array.isArray(object?.roles) ? object.roles.map((e: any) => Role.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListRolesResponse): unknown {
    const obj: any = {};
    if (message.roles?.length) {
      obj.roles = message.roles.map((e) => Role.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListRolesResponse>): ListRolesResponse {
    return ListRolesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRolesResponse>): ListRolesResponse {
    const message = createBaseListRolesResponse();
    message.roles = object.roles?.map((e) => Role.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetRoleRequest(): GetRoleRequest {
  return { name: "" };
}

export const GetRoleRequest: MessageFns<GetRoleRequest> = {
  encode(message: GetRoleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRoleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRoleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRoleRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetRoleRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetRoleRequest>): GetRoleRequest {
    return GetRoleRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetRoleRequest>): GetRoleRequest {
    const message = createBaseGetRoleRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateRoleRequest(): CreateRoleRequest {
  return { parent: "", roleId: "", role: undefined };
}

export const CreateRoleRequest: MessageFns<CreateRoleRequest> = {
  encode(message: CreateRoleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.roleId !== "") {
      writer.uint32(18).string(message.roleId);
    }
    if (message.role !== undefined) {
      Role.encode(message.role, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateRoleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateRoleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.roleId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.role = Role.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateRoleRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      roleId: isSet(object.roleId) ? globalThis.String(object.roleId) : "",
      role: isSet(object.role) ? Role.fromJSON(object.role) : undefined,
    };
  },

  toJSON(message: CreateRoleRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.roleId !== "") {
      obj.roleId = message.roleId;
    }
    if (message.role !== undefined) {
      obj.role = Role.toJSON(message.role);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateRoleRequest>): CreateRoleRequest {
    return CreateRoleRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateRoleRequest>): CreateRoleRequest {
    const message = createBaseCreateRoleRequest();
    message.parent = object.parent ?? "";
    message.roleId = object.roleId ?? "";
    message.role = (object.role !== undefined && object.role !== null) ? Role.fromPartial(object.role) : undefined;
    return message;
  },
};

function createBaseUpdateRoleRequest(): UpdateRoleRequest {
  return { name: "", role: undefined, updateMask: undefined };
}

export const UpdateRoleRequest: MessageFns<UpdateRoleRequest> = {
  encode(message: UpdateRoleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.role !== undefined) {
      Role.encode(message.role, writer.uint32(18).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateRoleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateRoleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.role = Role.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateRoleRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      role: isSet(object.role) ? Role.fromJSON(object.role) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateRoleRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.role !== undefined) {
      obj.role = Role.toJSON(message.role);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateRoleRequest>): UpdateRoleRequest {
    return UpdateRoleRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateRoleRequest>): UpdateRoleRequest {
    const message = createBaseUpdateRoleRequest();
    message.name = object.name ?? "";
    message.role = (object.role !== undefined && object.role !== null) ? Role.fromPartial(object.role) : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseDeleteRoleRequest(): DeleteRoleRequest {
  return { name: "", etag: Buffer.alloc(0) };
}

export const DeleteRoleRequest: MessageFns<DeleteRoleRequest> = {
  encode(message: DeleteRoleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.etag.length !== 0) {
      writer.uint32(18).bytes(message.etag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteRoleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteRoleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.etag = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteRoleRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      etag: isSet(object.etag) ? Buffer.from(bytesFromBase64(object.etag)) : Buffer.alloc(0),
    };
  },

  toJSON(message: DeleteRoleRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.etag.length !== 0) {
      obj.etag = base64FromBytes(message.etag);
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteRoleRequest>): DeleteRoleRequest {
    return DeleteRoleRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteRoleRequest>): DeleteRoleRequest {
    const message = createBaseDeleteRoleRequest();
    message.name = object.name ?? "";
    message.etag = object.etag ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseUndeleteRoleRequest(): UndeleteRoleRequest {
  return { name: "", etag: Buffer.alloc(0) };
}

export const UndeleteRoleRequest: MessageFns<UndeleteRoleRequest> = {
  encode(message: UndeleteRoleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.etag.length !== 0) {
      writer.uint32(18).bytes(message.etag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UndeleteRoleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUndeleteRoleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.etag = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UndeleteRoleRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      etag: isSet(object.etag) ? Buffer.from(bytesFromBase64(object.etag)) : Buffer.alloc(0),
    };
  },

  toJSON(message: UndeleteRoleRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.etag.length !== 0) {
      obj.etag = base64FromBytes(message.etag);
    }
    return obj;
  },

  create(base?: DeepPartial<UndeleteRoleRequest>): UndeleteRoleRequest {
    return UndeleteRoleRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UndeleteRoleRequest>): UndeleteRoleRequest {
    const message = createBaseUndeleteRoleRequest();
    message.name = object.name ?? "";
    message.etag = object.etag ?? Buffer.alloc(0);
    return message;
  },
};

function createBasePermission(): Permission {
  return {
    name: "",
    title: "",
    description: "",
    onlyInPredefinedRoles: false,
    stage: 0,
    customRolesSupportLevel: 0,
    apiDisabled: false,
    primaryPermission: "",
  };
}

export const Permission: MessageFns<Permission> = {
  encode(message: Permission, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.onlyInPredefinedRoles !== false) {
      writer.uint32(32).bool(message.onlyInPredefinedRoles);
    }
    if (message.stage !== 0) {
      writer.uint32(40).int32(message.stage);
    }
    if (message.customRolesSupportLevel !== 0) {
      writer.uint32(48).int32(message.customRolesSupportLevel);
    }
    if (message.apiDisabled !== false) {
      writer.uint32(56).bool(message.apiDisabled);
    }
    if (message.primaryPermission !== "") {
      writer.uint32(66).string(message.primaryPermission);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Permission {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePermission();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.onlyInPredefinedRoles = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.stage = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.customRolesSupportLevel = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.apiDisabled = reader.bool();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.primaryPermission = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Permission {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      onlyInPredefinedRoles: isSet(object.onlyInPredefinedRoles)
        ? globalThis.Boolean(object.onlyInPredefinedRoles)
        : false,
      stage: isSet(object.stage) ? permission_PermissionLaunchStageFromJSON(object.stage) : 0,
      customRolesSupportLevel: isSet(object.customRolesSupportLevel)
        ? permission_CustomRolesSupportLevelFromJSON(object.customRolesSupportLevel)
        : 0,
      apiDisabled: isSet(object.apiDisabled) ? globalThis.Boolean(object.apiDisabled) : false,
      primaryPermission: isSet(object.primaryPermission) ? globalThis.String(object.primaryPermission) : "",
    };
  },

  toJSON(message: Permission): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.onlyInPredefinedRoles !== false) {
      obj.onlyInPredefinedRoles = message.onlyInPredefinedRoles;
    }
    if (message.stage !== 0) {
      obj.stage = permission_PermissionLaunchStageToJSON(message.stage);
    }
    if (message.customRolesSupportLevel !== 0) {
      obj.customRolesSupportLevel = permission_CustomRolesSupportLevelToJSON(message.customRolesSupportLevel);
    }
    if (message.apiDisabled !== false) {
      obj.apiDisabled = message.apiDisabled;
    }
    if (message.primaryPermission !== "") {
      obj.primaryPermission = message.primaryPermission;
    }
    return obj;
  },

  create(base?: DeepPartial<Permission>): Permission {
    return Permission.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Permission>): Permission {
    const message = createBasePermission();
    message.name = object.name ?? "";
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.onlyInPredefinedRoles = object.onlyInPredefinedRoles ?? false;
    message.stage = object.stage ?? 0;
    message.customRolesSupportLevel = object.customRolesSupportLevel ?? 0;
    message.apiDisabled = object.apiDisabled ?? false;
    message.primaryPermission = object.primaryPermission ?? "";
    return message;
  },
};

function createBaseQueryTestablePermissionsRequest(): QueryTestablePermissionsRequest {
  return { fullResourceName: "", pageSize: 0, pageToken: "" };
}

export const QueryTestablePermissionsRequest: MessageFns<QueryTestablePermissionsRequest> = {
  encode(message: QueryTestablePermissionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fullResourceName !== "") {
      writer.uint32(10).string(message.fullResourceName);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryTestablePermissionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTestablePermissionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fullResourceName = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTestablePermissionsRequest {
    return {
      fullResourceName: isSet(object.fullResourceName) ? globalThis.String(object.fullResourceName) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: QueryTestablePermissionsRequest): unknown {
    const obj: any = {};
    if (message.fullResourceName !== "") {
      obj.fullResourceName = message.fullResourceName;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryTestablePermissionsRequest>): QueryTestablePermissionsRequest {
    return QueryTestablePermissionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryTestablePermissionsRequest>): QueryTestablePermissionsRequest {
    const message = createBaseQueryTestablePermissionsRequest();
    message.fullResourceName = object.fullResourceName ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseQueryTestablePermissionsResponse(): QueryTestablePermissionsResponse {
  return { permissions: [], nextPageToken: "" };
}

export const QueryTestablePermissionsResponse: MessageFns<QueryTestablePermissionsResponse> = {
  encode(message: QueryTestablePermissionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.permissions) {
      Permission.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryTestablePermissionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTestablePermissionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.permissions.push(Permission.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTestablePermissionsResponse {
    return {
      permissions: globalThis.Array.isArray(object?.permissions)
        ? object.permissions.map((e: any) => Permission.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: QueryTestablePermissionsResponse): unknown {
    const obj: any = {};
    if (message.permissions?.length) {
      obj.permissions = message.permissions.map((e) => Permission.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryTestablePermissionsResponse>): QueryTestablePermissionsResponse {
    return QueryTestablePermissionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryTestablePermissionsResponse>): QueryTestablePermissionsResponse {
    const message = createBaseQueryTestablePermissionsResponse();
    message.permissions = object.permissions?.map((e) => Permission.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseQueryAuditableServicesRequest(): QueryAuditableServicesRequest {
  return { fullResourceName: "" };
}

export const QueryAuditableServicesRequest: MessageFns<QueryAuditableServicesRequest> = {
  encode(message: QueryAuditableServicesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fullResourceName !== "") {
      writer.uint32(10).string(message.fullResourceName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAuditableServicesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAuditableServicesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fullResourceName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAuditableServicesRequest {
    return { fullResourceName: isSet(object.fullResourceName) ? globalThis.String(object.fullResourceName) : "" };
  },

  toJSON(message: QueryAuditableServicesRequest): unknown {
    const obj: any = {};
    if (message.fullResourceName !== "") {
      obj.fullResourceName = message.fullResourceName;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryAuditableServicesRequest>): QueryAuditableServicesRequest {
    return QueryAuditableServicesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryAuditableServicesRequest>): QueryAuditableServicesRequest {
    const message = createBaseQueryAuditableServicesRequest();
    message.fullResourceName = object.fullResourceName ?? "";
    return message;
  },
};

function createBaseQueryAuditableServicesResponse(): QueryAuditableServicesResponse {
  return { services: [] };
}

export const QueryAuditableServicesResponse: MessageFns<QueryAuditableServicesResponse> = {
  encode(message: QueryAuditableServicesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.services) {
      QueryAuditableServicesResponse_AuditableService.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAuditableServicesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAuditableServicesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.services.push(QueryAuditableServicesResponse_AuditableService.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAuditableServicesResponse {
    return {
      services: globalThis.Array.isArray(object?.services)
        ? object.services.map((e: any) => QueryAuditableServicesResponse_AuditableService.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryAuditableServicesResponse): unknown {
    const obj: any = {};
    if (message.services?.length) {
      obj.services = message.services.map((e) => QueryAuditableServicesResponse_AuditableService.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<QueryAuditableServicesResponse>): QueryAuditableServicesResponse {
    return QueryAuditableServicesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryAuditableServicesResponse>): QueryAuditableServicesResponse {
    const message = createBaseQueryAuditableServicesResponse();
    message.services = object.services?.map((e) => QueryAuditableServicesResponse_AuditableService.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseQueryAuditableServicesResponse_AuditableService(): QueryAuditableServicesResponse_AuditableService {
  return { name: "" };
}

export const QueryAuditableServicesResponse_AuditableService: MessageFns<
  QueryAuditableServicesResponse_AuditableService
> = {
  encode(
    message: QueryAuditableServicesResponse_AuditableService,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAuditableServicesResponse_AuditableService {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAuditableServicesResponse_AuditableService();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAuditableServicesResponse_AuditableService {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: QueryAuditableServicesResponse_AuditableService): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(
    base?: DeepPartial<QueryAuditableServicesResponse_AuditableService>,
  ): QueryAuditableServicesResponse_AuditableService {
    return QueryAuditableServicesResponse_AuditableService.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<QueryAuditableServicesResponse_AuditableService>,
  ): QueryAuditableServicesResponse_AuditableService {
    const message = createBaseQueryAuditableServicesResponse_AuditableService();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseLintPolicyRequest(): LintPolicyRequest {
  return { fullResourceName: "", condition: undefined };
}

export const LintPolicyRequest: MessageFns<LintPolicyRequest> = {
  encode(message: LintPolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fullResourceName !== "") {
      writer.uint32(10).string(message.fullResourceName);
    }
    if (message.condition !== undefined) {
      Expr.encode(message.condition, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LintPolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLintPolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fullResourceName = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.condition = Expr.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LintPolicyRequest {
    return {
      fullResourceName: isSet(object.fullResourceName) ? globalThis.String(object.fullResourceName) : "",
      condition: isSet(object.condition) ? Expr.fromJSON(object.condition) : undefined,
    };
  },

  toJSON(message: LintPolicyRequest): unknown {
    const obj: any = {};
    if (message.fullResourceName !== "") {
      obj.fullResourceName = message.fullResourceName;
    }
    if (message.condition !== undefined) {
      obj.condition = Expr.toJSON(message.condition);
    }
    return obj;
  },

  create(base?: DeepPartial<LintPolicyRequest>): LintPolicyRequest {
    return LintPolicyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LintPolicyRequest>): LintPolicyRequest {
    const message = createBaseLintPolicyRequest();
    message.fullResourceName = object.fullResourceName ?? "";
    message.condition = (object.condition !== undefined && object.condition !== null)
      ? Expr.fromPartial(object.condition)
      : undefined;
    return message;
  },
};

function createBaseLintResult(): LintResult {
  return { level: 0, validationUnitName: "", severity: 0, fieldName: "", locationOffset: 0, debugMessage: "" };
}

export const LintResult: MessageFns<LintResult> = {
  encode(message: LintResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.level !== 0) {
      writer.uint32(8).int32(message.level);
    }
    if (message.validationUnitName !== "") {
      writer.uint32(18).string(message.validationUnitName);
    }
    if (message.severity !== 0) {
      writer.uint32(24).int32(message.severity);
    }
    if (message.fieldName !== "") {
      writer.uint32(42).string(message.fieldName);
    }
    if (message.locationOffset !== 0) {
      writer.uint32(48).int32(message.locationOffset);
    }
    if (message.debugMessage !== "") {
      writer.uint32(58).string(message.debugMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LintResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLintResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.level = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.validationUnitName = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.severity = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.fieldName = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.locationOffset = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.debugMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LintResult {
    return {
      level: isSet(object.level) ? lintResult_LevelFromJSON(object.level) : 0,
      validationUnitName: isSet(object.validationUnitName) ? globalThis.String(object.validationUnitName) : "",
      severity: isSet(object.severity) ? lintResult_SeverityFromJSON(object.severity) : 0,
      fieldName: isSet(object.fieldName) ? globalThis.String(object.fieldName) : "",
      locationOffset: isSet(object.locationOffset) ? globalThis.Number(object.locationOffset) : 0,
      debugMessage: isSet(object.debugMessage) ? globalThis.String(object.debugMessage) : "",
    };
  },

  toJSON(message: LintResult): unknown {
    const obj: any = {};
    if (message.level !== 0) {
      obj.level = lintResult_LevelToJSON(message.level);
    }
    if (message.validationUnitName !== "") {
      obj.validationUnitName = message.validationUnitName;
    }
    if (message.severity !== 0) {
      obj.severity = lintResult_SeverityToJSON(message.severity);
    }
    if (message.fieldName !== "") {
      obj.fieldName = message.fieldName;
    }
    if (message.locationOffset !== 0) {
      obj.locationOffset = Math.round(message.locationOffset);
    }
    if (message.debugMessage !== "") {
      obj.debugMessage = message.debugMessage;
    }
    return obj;
  },

  create(base?: DeepPartial<LintResult>): LintResult {
    return LintResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LintResult>): LintResult {
    const message = createBaseLintResult();
    message.level = object.level ?? 0;
    message.validationUnitName = object.validationUnitName ?? "";
    message.severity = object.severity ?? 0;
    message.fieldName = object.fieldName ?? "";
    message.locationOffset = object.locationOffset ?? 0;
    message.debugMessage = object.debugMessage ?? "";
    return message;
  },
};

function createBaseLintPolicyResponse(): LintPolicyResponse {
  return { lintResults: [] };
}

export const LintPolicyResponse: MessageFns<LintPolicyResponse> = {
  encode(message: LintPolicyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.lintResults) {
      LintResult.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LintPolicyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLintPolicyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.lintResults.push(LintResult.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LintPolicyResponse {
    return {
      lintResults: globalThis.Array.isArray(object?.lintResults)
        ? object.lintResults.map((e: any) => LintResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: LintPolicyResponse): unknown {
    const obj: any = {};
    if (message.lintResults?.length) {
      obj.lintResults = message.lintResults.map((e) => LintResult.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<LintPolicyResponse>): LintPolicyResponse {
    return LintPolicyResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LintPolicyResponse>): LintPolicyResponse {
    const message = createBaseLintPolicyResponse();
    message.lintResults = object.lintResults?.map((e) => LintResult.fromPartial(e)) || [];
    return message;
  },
};

/**
 * Creates and manages Identity and Access Management (IAM) resources.
 *
 * You can use this service to work with all of the following resources:
 *
 * * **Service accounts**, which identify an application or a virtual machine
 *   (VM) instance rather than a person
 * * **Service account keys**, which service accounts use to authenticate with
 *   Google APIs
 * * **IAM policies for service accounts**, which specify the roles that a
 *   principal has for the service account
 * * **IAM custom roles**, which help you limit the number of permissions that
 *   you grant to principals
 *
 * In addition, you can use this service to complete the following tasks, among
 * others:
 *
 * * Test whether a service account can use specific permissions
 * * Check which roles you can grant for a specific resource
 * * Lint, or validate, condition expressions in an IAM policy
 *
 * When you read data from the IAM API, each read is eventually consistent. In
 * other words, if you write data with the IAM API, then immediately read that
 * data, the read operation might return an older version of the data. To deal
 * with this behavior, your application can retry the request with truncated
 * exponential backoff.
 *
 * In contrast, writing data to the IAM API is sequentially consistent. In other
 * words, write operations are always processed in the order in which they were
 * received.
 */
export type IAMDefinition = typeof IAMDefinition;
export const IAMDefinition = {
  name: "IAM",
  fullName: "google.iam.admin.v1.IAM",
  methods: {
    /** Lists every [ServiceAccount][google.iam.admin.v1.ServiceAccount] that belongs to a specific project. */
    listServiceAccounts: {
      name: "ListServiceAccounts",
      requestType: ListServiceAccountsRequest,
      requestStream: false,
      responseType: ListServiceAccountsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              39,
              18,
              37,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              65,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets a [ServiceAccount][google.iam.admin.v1.ServiceAccount]. */
    getServiceAccount: {
      name: "GetServiceAccount",
      requestType: GetServiceAccountRequest,
      requestStream: false,
      responseType: ServiceAccount,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              41,
              18,
              39,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              65,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a [ServiceAccount][google.iam.admin.v1.ServiceAccount]. */
    createServiceAccount: {
      name: "CreateServiceAccount",
      requestType: CreateServiceAccountRequest,
      requestStream: false,
      responseType: ServiceAccount,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              31,
              110,
              97,
              109,
              101,
              44,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              95,
              105,
              100,
              44,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              95,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
            ]),
          ],
          578365826: [
            Buffer.from([
              42,
              58,
              1,
              42,
              34,
              37,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              65,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * *Note:** We are in the process of deprecating this method. Use
     * [PatchServiceAccount][google.iam.admin.v1.IAM.PatchServiceAccount] instead.
     *
     * Updates a [ServiceAccount][google.iam.admin.v1.ServiceAccount].
     *
     * You can update only the `display_name` field.
     */
    updateServiceAccount: {
      name: "UpdateServiceAccount",
      requestType: ServiceAccount,
      requestStream: false,
      responseType: ServiceAccount,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              44,
              58,
              1,
              42,
              26,
              39,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              65,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Patches a [ServiceAccount][google.iam.admin.v1.ServiceAccount]. */
    patchServiceAccount: {
      name: "PatchServiceAccount",
      requestType: PatchServiceAccountRequest,
      requestStream: false,
      responseType: ServiceAccount,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              60,
              58,
              1,
              42,
              50,
              55,
              47,
              118,
              49,
              47,
              123,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              95,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              65,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes a [ServiceAccount][google.iam.admin.v1.ServiceAccount].
     *
     * **Warning:** After you delete a service account, you might not be able to
     * undelete it. If you know that you need to re-enable the service account in
     * the future, use [DisableServiceAccount][google.iam.admin.v1.IAM.DisableServiceAccount] instead.
     *
     * If you delete a service account, IAM permanently removes the service
     * account 30 days later. Google Cloud cannot recover the service account
     * after it is permanently removed, even if you file a support request.
     *
     * To help avoid unplanned outages, we recommend that you disable the service
     * account before you delete it. Use [DisableServiceAccount][google.iam.admin.v1.IAM.DisableServiceAccount] to disable the
     * service account, then wait at least 24 hours and watch for unintended
     * consequences. If there are no unintended consequences, you can delete the
     * service account.
     */
    deleteServiceAccount: {
      name: "DeleteServiceAccount",
      requestType: DeleteServiceAccountRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              41,
              42,
              39,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              65,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Restores a deleted [ServiceAccount][google.iam.admin.v1.ServiceAccount].
     *
     * **Important:** It is not always possible to restore a deleted service
     * account. Use this method only as a last resort.
     *
     * After you delete a service account, IAM permanently removes the service
     * account 30 days later. There is no way to restore a deleted service account
     * that has been permanently removed.
     */
    undeleteServiceAccount: {
      name: "UndeleteServiceAccount",
      requestType: UndeleteServiceAccountRequest,
      requestStream: false,
      responseType: UndeleteServiceAccountResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              53,
              58,
              1,
              42,
              34,
              48,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              65,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              117,
              110,
              100,
              101,
              108,
              101,
              116,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Enables a [ServiceAccount][google.iam.admin.v1.ServiceAccount] that was disabled by
     * [DisableServiceAccount][google.iam.admin.v1.IAM.DisableServiceAccount].
     *
     * If the service account is already enabled, then this method has no effect.
     *
     * If the service account was disabled by other meansfor example, if Google
     * disabled the service account because it was compromisedyou cannot use this
     * method to enable the service account.
     */
    enableServiceAccount: {
      name: "EnableServiceAccount",
      requestType: EnableServiceAccountRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              51,
              58,
              1,
              42,
              34,
              46,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              65,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              101,
              110,
              97,
              98,
              108,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Disables a [ServiceAccount][google.iam.admin.v1.ServiceAccount] immediately.
     *
     * If an application uses the service account to authenticate, that
     * application can no longer call Google APIs or access Google Cloud
     * resources. Existing access tokens for the service account are rejected, and
     * requests for new access tokens will fail.
     *
     * To re-enable the service account, use [EnableServiceAccount][google.iam.admin.v1.IAM.EnableServiceAccount]. After you
     * re-enable the service account, its existing access tokens will be accepted,
     * and you can request new access tokens.
     *
     * To help avoid unplanned outages, we recommend that you disable the service
     * account before you delete it. Use this method to disable the service
     * account, then wait at least 24 hours and watch for unintended consequences.
     * If there are no unintended consequences, you can delete the service account
     * with [DeleteServiceAccount][google.iam.admin.v1.IAM.DeleteServiceAccount].
     */
    disableServiceAccount: {
      name: "DisableServiceAccount",
      requestType: DisableServiceAccountRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              52,
              58,
              1,
              42,
              34,
              47,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              65,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              100,
              105,
              115,
              97,
              98,
              108,
              101,
            ]),
          ],
        },
      },
    },
    /** Lists every [ServiceAccountKey][google.iam.admin.v1.ServiceAccountKey] for a service account. */
    listServiceAccountKeys: {
      name: "ListServiceAccountKeys",
      requestType: ListServiceAccountKeysRequest,
      requestStream: false,
      responseType: ListServiceAccountKeysResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([14, 110, 97, 109, 101, 44, 107, 101, 121, 95, 116, 121, 112, 101, 115])],
          578365826: [
            Buffer.from([
              46,
              18,
              44,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              65,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              107,
              101,
              121,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets a [ServiceAccountKey][google.iam.admin.v1.ServiceAccountKey]. */
    getServiceAccountKey: {
      name: "GetServiceAccountKey",
      requestType: GetServiceAccountKeyRequest,
      requestStream: false,
      responseType: ServiceAccountKey,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              20,
              110,
              97,
              109,
              101,
              44,
              112,
              117,
              98,
              108,
              105,
              99,
              95,
              107,
              101,
              121,
              95,
              116,
              121,
              112,
              101,
            ]),
          ],
          578365826: [
            Buffer.from([
              48,
              18,
              46,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              65,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              107,
              101,
              121,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a [ServiceAccountKey][google.iam.admin.v1.ServiceAccountKey]. */
    createServiceAccountKey: {
      name: "CreateServiceAccountKey",
      requestType: CreateServiceAccountKeyRequest,
      requestStream: false,
      responseType: ServiceAccountKey,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              35,
              110,
              97,
              109,
              101,
              44,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              95,
              107,
              101,
              121,
              95,
              116,
              121,
              112,
              101,
              44,
              107,
              101,
              121,
              95,
              97,
              108,
              103,
              111,
              114,
              105,
              116,
              104,
              109,
            ]),
          ],
          578365826: [
            Buffer.from([
              49,
              58,
              1,
              42,
              34,
              44,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              65,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              107,
              101,
              121,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Uploads the public key portion of a key pair that you manage, and
     * associates the public key with a [ServiceAccount][google.iam.admin.v1.ServiceAccount].
     *
     * After you upload the public key, you can use the private key from the key
     * pair as a service account key.
     */
    uploadServiceAccountKey: {
      name: "UploadServiceAccountKey",
      requestType: UploadServiceAccountKeyRequest,
      requestStream: false,
      responseType: ServiceAccountKey,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              56,
              58,
              1,
              42,
              34,
              51,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              65,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              107,
              101,
              121,
              115,
              58,
              117,
              112,
              108,
              111,
              97,
              100,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes a [ServiceAccountKey][google.iam.admin.v1.ServiceAccountKey]. Deleting a service account key does not
     * revoke short-lived credentials that have been issued based on the service
     * account key.
     */
    deleteServiceAccountKey: {
      name: "DeleteServiceAccountKey",
      requestType: DeleteServiceAccountKeyRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              48,
              42,
              46,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              65,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              107,
              101,
              121,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Disable a [ServiceAccountKey][google.iam.admin.v1.ServiceAccountKey]. A disabled service account key can be
     * re-enabled with [EnableServiceAccountKey][google.iam.admin.v1.IAM.EnableServiceAccountKey].
     */
    disableServiceAccountKey: {
      name: "DisableServiceAccountKey",
      requestType: DisableServiceAccountKeyRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              59,
              58,
              1,
              42,
              34,
              54,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              65,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              107,
              101,
              121,
              115,
              47,
              42,
              125,
              58,
              100,
              105,
              115,
              97,
              98,
              108,
              101,
            ]),
          ],
        },
      },
    },
    /** Enable a [ServiceAccountKey][google.iam.admin.v1.ServiceAccountKey]. */
    enableServiceAccountKey: {
      name: "EnableServiceAccountKey",
      requestType: EnableServiceAccountKeyRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              58,
              58,
              1,
              42,
              34,
              53,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              65,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              107,
              101,
              121,
              115,
              47,
              42,
              125,
              58,
              101,
              110,
              97,
              98,
              108,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * *Note:** This method is deprecated. Use the
     * [`signBlob`](https://cloud.google.com/iam/help/rest-credentials/v1/projects.serviceAccounts/signBlob)
     * method in the IAM Service Account Credentials API instead. If you currently
     * use this method, see the [migration
     * guide](https://cloud.google.com/iam/help/credentials/migrate-api) for
     * instructions.
     *
     * Signs a blob using the system-managed private key for a [ServiceAccount][google.iam.admin.v1.ServiceAccount].
     *
     * @deprecated
     */
    signBlob: {
      name: "SignBlob",
      requestType: SignBlobRequest,
      requestStream: false,
      responseType: SignBlobResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([18, 110, 97, 109, 101, 44, 98, 121, 116, 101, 115, 95, 116, 111, 95, 115, 105, 103, 110]),
          ],
          578365826: [
            Buffer.from([
              53,
              58,
              1,
              42,
              34,
              48,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              65,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              115,
              105,
              103,
              110,
              66,
              108,
              111,
              98,
            ]),
          ],
        },
      },
    },
    /**
     * *Note:** This method is deprecated. Use the
     * [`signJwt`](https://cloud.google.com/iam/help/rest-credentials/v1/projects.serviceAccounts/signJwt)
     * method in the IAM Service Account Credentials API instead. If you currently
     * use this method, see the [migration
     * guide](https://cloud.google.com/iam/help/credentials/migrate-api) for
     * instructions.
     *
     * Signs a JSON Web Token (JWT) using the system-managed private key for a
     * [ServiceAccount][google.iam.admin.v1.ServiceAccount].
     *
     * @deprecated
     */
    signJwt: {
      name: "SignJwt",
      requestType: SignJwtRequest,
      requestStream: false,
      responseType: SignJwtResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([12, 110, 97, 109, 101, 44, 112, 97, 121, 108, 111, 97, 100])],
          578365826: [
            Buffer.from([
              52,
              58,
              1,
              42,
              34,
              47,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              65,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              115,
              105,
              103,
              110,
              74,
              119,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * Gets the IAM policy that is attached to a [ServiceAccount][google.iam.admin.v1.ServiceAccount]. This IAM
     * policy specifies which principals have access to the service account.
     *
     * This method does not tell you whether the service account has been granted
     * any roles on other resources. To check whether a service account has role
     * grants on a resource, use the `getIamPolicy` method for that resource. For
     * example, to view the role grants for a project, call the Resource Manager
     * API's
     * [`projects.getIamPolicy`](https://cloud.google.com/resource-manager/reference/rest/v1/projects/getIamPolicy)
     * method.
     */
    getIamPolicy: {
      name: "GetIamPolicy",
      requestType: GetIamPolicyRequest,
      requestStream: false,
      responseType: Policy,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([8, 114, 101, 115, 111, 117, 114, 99, 101])],
          578365826: [
            Buffer.from([
              58,
              34,
              56,
              47,
              118,
              49,
              47,
              123,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              65,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              103,
              101,
              116,
              73,
              97,
              109,
              80,
              111,
              108,
              105,
              99,
              121,
            ]),
          ],
        },
      },
    },
    /**
     * Sets the IAM policy that is attached to a [ServiceAccount][google.iam.admin.v1.ServiceAccount].
     *
     * Use this method to grant or revoke access to the service account. For
     * example, you could grant a principal the ability to impersonate the service
     * account.
     *
     * This method does not enable the service account to access other resources.
     * To grant roles to a service account on a resource, follow these steps:
     *
     * 1. Call the resource's `getIamPolicy` method to get its current IAM policy.
     * 2. Edit the policy so that it binds the service account to an IAM role for
     * the resource.
     * 3. Call the resource's `setIamPolicy` method to update its IAM policy.
     *
     * For detailed instructions, see
     * [Manage access to project, folders, and
     * organizations](https://cloud.google.com/iam/help/service-accounts/granting-access-to-service-accounts)
     * or [Manage access to other
     * resources](https://cloud.google.com/iam/help/access/manage-other-resources).
     */
    setIamPolicy: {
      name: "SetIamPolicy",
      requestType: SetIamPolicyRequest,
      requestStream: false,
      responseType: Policy,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([15, 114, 101, 115, 111, 117, 114, 99, 101, 44, 112, 111, 108, 105, 99, 121])],
          578365826: [
            Buffer.from([
              61,
              58,
              1,
              42,
              34,
              56,
              47,
              118,
              49,
              47,
              123,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              65,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              116,
              73,
              97,
              109,
              80,
              111,
              108,
              105,
              99,
              121,
            ]),
          ],
        },
      },
    },
    /**
     * Tests whether the caller has the specified permissions on a
     * [ServiceAccount][google.iam.admin.v1.ServiceAccount].
     */
    testIamPermissions: {
      name: "TestIamPermissions",
      requestType: TestIamPermissionsRequest,
      requestStream: false,
      responseType: TestIamPermissionsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              20,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              44,
              112,
              101,
              114,
              109,
              105,
              115,
              115,
              105,
              111,
              110,
              115,
            ]),
          ],
          578365826: [
            Buffer.from([
              67,
              58,
              1,
              42,
              34,
              62,
              47,
              118,
              49,
              47,
              123,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              65,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              116,
              101,
              115,
              116,
              73,
              97,
              109,
              80,
              101,
              114,
              109,
              105,
              115,
              115,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Lists roles that can be granted on a Google Cloud resource. A role is
     * grantable if the IAM policy for the resource can contain bindings to the
     * role.
     */
    queryGrantableRoles: {
      name: "QueryGrantableRoles",
      requestType: QueryGrantableRolesRequest,
      requestStream: false,
      responseType: QueryGrantableRolesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([18, 102, 117, 108, 108, 95, 114, 101, 115, 111, 117, 114, 99, 101, 95, 110, 97, 109, 101]),
          ],
          578365826: [
            Buffer.from([
              34,
              58,
              1,
              42,
              34,
              29,
              47,
              118,
              49,
              47,
              114,
              111,
              108,
              101,
              115,
              58,
              113,
              117,
              101,
              114,
              121,
              71,
              114,
              97,
              110,
              116,
              97,
              98,
              108,
              101,
              82,
              111,
              108,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Lists every predefined [Role][google.iam.admin.v1.Role] that IAM supports, or every custom role
     * that is defined for an organization or project.
     */
    listRoles: {
      name: "ListRoles",
      requestType: ListRolesRequest,
      requestStream: false,
      responseType: ListRolesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              82,
              90,
              36,
              18,
              34,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              114,
              111,
              108,
              101,
              115,
              90,
              31,
              18,
              29,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              114,
              111,
              108,
              101,
              115,
              18,
              9,
              47,
              118,
              49,
              47,
              114,
              111,
              108,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets the definition of a [Role][google.iam.admin.v1.Role]. */
    getRole: {
      name: "GetRole",
      requestType: GetRoleRequest,
      requestStream: false,
      responseType: Role,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              91,
              90,
              36,
              18,
              34,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              111,
              108,
              101,
              115,
              47,
              42,
              125,
              90,
              31,
              18,
              29,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              114,
              111,
              108,
              101,
              115,
              47,
              42,
              125,
              18,
              18,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              114,
              111,
              108,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a new custom [Role][google.iam.admin.v1.Role]. */
    createRole: {
      name: "CreateRole",
      requestType: CreateRoleRequest,
      requestStream: false,
      responseType: Role,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              75,
              58,
              1,
              42,
              90,
              34,
              58,
              1,
              42,
              34,
              29,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              114,
              111,
              108,
              101,
              115,
              34,
              34,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              114,
              111,
              108,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates the definition of a custom [Role][google.iam.admin.v1.Role]. */
    updateRole: {
      name: "UpdateRole",
      requestType: UpdateRoleRequest,
      requestStream: false,
      responseType: Role,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              81,
              58,
              4,
              114,
              111,
              108,
              101,
              90,
              37,
              58,
              4,
              114,
              111,
              108,
              101,
              50,
              29,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              114,
              111,
              108,
              101,
              115,
              47,
              42,
              125,
              50,
              34,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              111,
              108,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes a custom [Role][google.iam.admin.v1.Role].
     *
     * When you delete a custom role, the following changes occur immediately:
     *
     * * You cannot bind a principal to the custom role in an IAM
     * [Policy][google.iam.v1.Policy].
     * * Existing bindings to the custom role are not changed, but they have no
     * effect.
     * * By default, the response from [ListRoles][google.iam.admin.v1.IAM.ListRoles] does not include the custom
     * role.
     *
     * You have 7 days to undelete the custom role. After 7 days, the following
     * changes occur:
     *
     * * The custom role is permanently deleted and cannot be recovered.
     * * If an IAM policy contains a binding to the custom role, the binding is
     * permanently removed.
     */
    deleteRole: {
      name: "DeleteRole",
      requestType: DeleteRoleRequest,
      requestStream: false,
      responseType: Role,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              69,
              90,
              31,
              42,
              29,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              114,
              111,
              108,
              101,
              115,
              47,
              42,
              125,
              42,
              34,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              111,
              108,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Undeletes a custom [Role][google.iam.admin.v1.Role]. */
    undeleteRole: {
      name: "UndeleteRole",
      requestType: UndeleteRoleRequest,
      requestStream: false,
      responseType: Role,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              93,
              58,
              1,
              42,
              90,
              43,
              58,
              1,
              42,
              34,
              38,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              114,
              111,
              108,
              101,
              115,
              47,
              42,
              125,
              58,
              117,
              110,
              100,
              101,
              108,
              101,
              116,
              101,
              34,
              43,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              111,
              108,
              101,
              115,
              47,
              42,
              125,
              58,
              117,
              110,
              100,
              101,
              108,
              101,
              116,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Lists every permission that you can test on a resource. A permission is
     * testable if you can check whether a principal has that permission on the
     * resource.
     */
    queryTestablePermissions: {
      name: "QueryTestablePermissions",
      requestType: QueryTestablePermissionsRequest,
      requestStream: false,
      responseType: QueryTestablePermissionsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              45,
              58,
              1,
              42,
              34,
              40,
              47,
              118,
              49,
              47,
              112,
              101,
              114,
              109,
              105,
              115,
              115,
              105,
              111,
              110,
              115,
              58,
              113,
              117,
              101,
              114,
              121,
              84,
              101,
              115,
              116,
              97,
              98,
              108,
              101,
              80,
              101,
              114,
              109,
              105,
              115,
              115,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Returns a list of services that allow you to opt into audit logs that are
     * not generated by default.
     *
     * To learn more about audit logs, see the [Logging
     * documentation](https://cloud.google.com/logging/docs/audit).
     */
    queryAuditableServices: {
      name: "QueryAuditableServices",
      requestType: QueryAuditableServicesRequest,
      requestStream: false,
      responseType: QueryAuditableServicesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              43,
              58,
              1,
              42,
              34,
              38,
              47,
              118,
              49,
              47,
              105,
              97,
              109,
              80,
              111,
              108,
              105,
              99,
              105,
              101,
              115,
              58,
              113,
              117,
              101,
              114,
              121,
              65,
              117,
              100,
              105,
              116,
              97,
              98,
              108,
              101,
              83,
              101,
              114,
              118,
              105,
              99,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Lints, or validates, an IAM policy. Currently checks the
     * [google.iam.v1.Binding.condition][google.iam.v1.Binding.condition] field, which contains a condition
     * expression for a role binding.
     *
     * Successful calls to this method always return an HTTP `200 OK` status code,
     * even if the linter detects an issue in the IAM policy.
     */
    lintPolicy: {
      name: "LintPolicy",
      requestType: LintPolicyRequest,
      requestStream: false,
      responseType: LintPolicyResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              31,
              58,
              1,
              42,
              34,
              26,
              47,
              118,
              49,
              47,
              105,
              97,
              109,
              80,
              111,
              108,
              105,
              99,
              105,
              101,
              115,
              58,
              108,
              105,
              110,
              116,
              80,
              111,
              108,
              105,
              99,
              121,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface IAMServiceImplementation<CallContextExt = {}> {
  /** Lists every [ServiceAccount][google.iam.admin.v1.ServiceAccount] that belongs to a specific project. */
  listServiceAccounts(
    request: ListServiceAccountsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListServiceAccountsResponse>>;
  /** Gets a [ServiceAccount][google.iam.admin.v1.ServiceAccount]. */
  getServiceAccount(
    request: GetServiceAccountRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ServiceAccount>>;
  /** Creates a [ServiceAccount][google.iam.admin.v1.ServiceAccount]. */
  createServiceAccount(
    request: CreateServiceAccountRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ServiceAccount>>;
  /**
   * *Note:** We are in the process of deprecating this method. Use
   * [PatchServiceAccount][google.iam.admin.v1.IAM.PatchServiceAccount] instead.
   *
   * Updates a [ServiceAccount][google.iam.admin.v1.ServiceAccount].
   *
   * You can update only the `display_name` field.
   */
  updateServiceAccount(
    request: ServiceAccount,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ServiceAccount>>;
  /** Patches a [ServiceAccount][google.iam.admin.v1.ServiceAccount]. */
  patchServiceAccount(
    request: PatchServiceAccountRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ServiceAccount>>;
  /**
   * Deletes a [ServiceAccount][google.iam.admin.v1.ServiceAccount].
   *
   * **Warning:** After you delete a service account, you might not be able to
   * undelete it. If you know that you need to re-enable the service account in
   * the future, use [DisableServiceAccount][google.iam.admin.v1.IAM.DisableServiceAccount] instead.
   *
   * If you delete a service account, IAM permanently removes the service
   * account 30 days later. Google Cloud cannot recover the service account
   * after it is permanently removed, even if you file a support request.
   *
   * To help avoid unplanned outages, we recommend that you disable the service
   * account before you delete it. Use [DisableServiceAccount][google.iam.admin.v1.IAM.DisableServiceAccount] to disable the
   * service account, then wait at least 24 hours and watch for unintended
   * consequences. If there are no unintended consequences, you can delete the
   * service account.
   */
  deleteServiceAccount(
    request: DeleteServiceAccountRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /**
   * Restores a deleted [ServiceAccount][google.iam.admin.v1.ServiceAccount].
   *
   * **Important:** It is not always possible to restore a deleted service
   * account. Use this method only as a last resort.
   *
   * After you delete a service account, IAM permanently removes the service
   * account 30 days later. There is no way to restore a deleted service account
   * that has been permanently removed.
   */
  undeleteServiceAccount(
    request: UndeleteServiceAccountRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<UndeleteServiceAccountResponse>>;
  /**
   * Enables a [ServiceAccount][google.iam.admin.v1.ServiceAccount] that was disabled by
   * [DisableServiceAccount][google.iam.admin.v1.IAM.DisableServiceAccount].
   *
   * If the service account is already enabled, then this method has no effect.
   *
   * If the service account was disabled by other meansfor example, if Google
   * disabled the service account because it was compromisedyou cannot use this
   * method to enable the service account.
   */
  enableServiceAccount(
    request: EnableServiceAccountRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /**
   * Disables a [ServiceAccount][google.iam.admin.v1.ServiceAccount] immediately.
   *
   * If an application uses the service account to authenticate, that
   * application can no longer call Google APIs or access Google Cloud
   * resources. Existing access tokens for the service account are rejected, and
   * requests for new access tokens will fail.
   *
   * To re-enable the service account, use [EnableServiceAccount][google.iam.admin.v1.IAM.EnableServiceAccount]. After you
   * re-enable the service account, its existing access tokens will be accepted,
   * and you can request new access tokens.
   *
   * To help avoid unplanned outages, we recommend that you disable the service
   * account before you delete it. Use this method to disable the service
   * account, then wait at least 24 hours and watch for unintended consequences.
   * If there are no unintended consequences, you can delete the service account
   * with [DeleteServiceAccount][google.iam.admin.v1.IAM.DeleteServiceAccount].
   */
  disableServiceAccount(
    request: DisableServiceAccountRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** Lists every [ServiceAccountKey][google.iam.admin.v1.ServiceAccountKey] for a service account. */
  listServiceAccountKeys(
    request: ListServiceAccountKeysRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListServiceAccountKeysResponse>>;
  /** Gets a [ServiceAccountKey][google.iam.admin.v1.ServiceAccountKey]. */
  getServiceAccountKey(
    request: GetServiceAccountKeyRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ServiceAccountKey>>;
  /** Creates a [ServiceAccountKey][google.iam.admin.v1.ServiceAccountKey]. */
  createServiceAccountKey(
    request: CreateServiceAccountKeyRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ServiceAccountKey>>;
  /**
   * Uploads the public key portion of a key pair that you manage, and
   * associates the public key with a [ServiceAccount][google.iam.admin.v1.ServiceAccount].
   *
   * After you upload the public key, you can use the private key from the key
   * pair as a service account key.
   */
  uploadServiceAccountKey(
    request: UploadServiceAccountKeyRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ServiceAccountKey>>;
  /**
   * Deletes a [ServiceAccountKey][google.iam.admin.v1.ServiceAccountKey]. Deleting a service account key does not
   * revoke short-lived credentials that have been issued based on the service
   * account key.
   */
  deleteServiceAccountKey(
    request: DeleteServiceAccountKeyRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /**
   * Disable a [ServiceAccountKey][google.iam.admin.v1.ServiceAccountKey]. A disabled service account key can be
   * re-enabled with [EnableServiceAccountKey][google.iam.admin.v1.IAM.EnableServiceAccountKey].
   */
  disableServiceAccountKey(
    request: DisableServiceAccountKeyRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** Enable a [ServiceAccountKey][google.iam.admin.v1.ServiceAccountKey]. */
  enableServiceAccountKey(
    request: EnableServiceAccountKeyRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /**
   * *Note:** This method is deprecated. Use the
   * [`signBlob`](https://cloud.google.com/iam/help/rest-credentials/v1/projects.serviceAccounts/signBlob)
   * method in the IAM Service Account Credentials API instead. If you currently
   * use this method, see the [migration
   * guide](https://cloud.google.com/iam/help/credentials/migrate-api) for
   * instructions.
   *
   * Signs a blob using the system-managed private key for a [ServiceAccount][google.iam.admin.v1.ServiceAccount].
   *
   * @deprecated
   */
  signBlob(request: SignBlobRequest, context: CallContext & CallContextExt): Promise<DeepPartial<SignBlobResponse>>;
  /**
   * *Note:** This method is deprecated. Use the
   * [`signJwt`](https://cloud.google.com/iam/help/rest-credentials/v1/projects.serviceAccounts/signJwt)
   * method in the IAM Service Account Credentials API instead. If you currently
   * use this method, see the [migration
   * guide](https://cloud.google.com/iam/help/credentials/migrate-api) for
   * instructions.
   *
   * Signs a JSON Web Token (JWT) using the system-managed private key for a
   * [ServiceAccount][google.iam.admin.v1.ServiceAccount].
   *
   * @deprecated
   */
  signJwt(request: SignJwtRequest, context: CallContext & CallContextExt): Promise<DeepPartial<SignJwtResponse>>;
  /**
   * Gets the IAM policy that is attached to a [ServiceAccount][google.iam.admin.v1.ServiceAccount]. This IAM
   * policy specifies which principals have access to the service account.
   *
   * This method does not tell you whether the service account has been granted
   * any roles on other resources. To check whether a service account has role
   * grants on a resource, use the `getIamPolicy` method for that resource. For
   * example, to view the role grants for a project, call the Resource Manager
   * API's
   * [`projects.getIamPolicy`](https://cloud.google.com/resource-manager/reference/rest/v1/projects/getIamPolicy)
   * method.
   */
  getIamPolicy(request: GetIamPolicyRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Policy>>;
  /**
   * Sets the IAM policy that is attached to a [ServiceAccount][google.iam.admin.v1.ServiceAccount].
   *
   * Use this method to grant or revoke access to the service account. For
   * example, you could grant a principal the ability to impersonate the service
   * account.
   *
   * This method does not enable the service account to access other resources.
   * To grant roles to a service account on a resource, follow these steps:
   *
   * 1. Call the resource's `getIamPolicy` method to get its current IAM policy.
   * 2. Edit the policy so that it binds the service account to an IAM role for
   * the resource.
   * 3. Call the resource's `setIamPolicy` method to update its IAM policy.
   *
   * For detailed instructions, see
   * [Manage access to project, folders, and
   * organizations](https://cloud.google.com/iam/help/service-accounts/granting-access-to-service-accounts)
   * or [Manage access to other
   * resources](https://cloud.google.com/iam/help/access/manage-other-resources).
   */
  setIamPolicy(request: SetIamPolicyRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Policy>>;
  /**
   * Tests whether the caller has the specified permissions on a
   * [ServiceAccount][google.iam.admin.v1.ServiceAccount].
   */
  testIamPermissions(
    request: TestIamPermissionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<TestIamPermissionsResponse>>;
  /**
   * Lists roles that can be granted on a Google Cloud resource. A role is
   * grantable if the IAM policy for the resource can contain bindings to the
   * role.
   */
  queryGrantableRoles(
    request: QueryGrantableRolesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<QueryGrantableRolesResponse>>;
  /**
   * Lists every predefined [Role][google.iam.admin.v1.Role] that IAM supports, or every custom role
   * that is defined for an organization or project.
   */
  listRoles(request: ListRolesRequest, context: CallContext & CallContextExt): Promise<DeepPartial<ListRolesResponse>>;
  /** Gets the definition of a [Role][google.iam.admin.v1.Role]. */
  getRole(request: GetRoleRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Role>>;
  /** Creates a new custom [Role][google.iam.admin.v1.Role]. */
  createRole(request: CreateRoleRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Role>>;
  /** Updates the definition of a custom [Role][google.iam.admin.v1.Role]. */
  updateRole(request: UpdateRoleRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Role>>;
  /**
   * Deletes a custom [Role][google.iam.admin.v1.Role].
   *
   * When you delete a custom role, the following changes occur immediately:
   *
   * * You cannot bind a principal to the custom role in an IAM
   * [Policy][google.iam.v1.Policy].
   * * Existing bindings to the custom role are not changed, but they have no
   * effect.
   * * By default, the response from [ListRoles][google.iam.admin.v1.IAM.ListRoles] does not include the custom
   * role.
   *
   * You have 7 days to undelete the custom role. After 7 days, the following
   * changes occur:
   *
   * * The custom role is permanently deleted and cannot be recovered.
   * * If an IAM policy contains a binding to the custom role, the binding is
   * permanently removed.
   */
  deleteRole(request: DeleteRoleRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Role>>;
  /** Undeletes a custom [Role][google.iam.admin.v1.Role]. */
  undeleteRole(request: UndeleteRoleRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Role>>;
  /**
   * Lists every permission that you can test on a resource. A permission is
   * testable if you can check whether a principal has that permission on the
   * resource.
   */
  queryTestablePermissions(
    request: QueryTestablePermissionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<QueryTestablePermissionsResponse>>;
  /**
   * Returns a list of services that allow you to opt into audit logs that are
   * not generated by default.
   *
   * To learn more about audit logs, see the [Logging
   * documentation](https://cloud.google.com/logging/docs/audit).
   */
  queryAuditableServices(
    request: QueryAuditableServicesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<QueryAuditableServicesResponse>>;
  /**
   * Lints, or validates, an IAM policy. Currently checks the
   * [google.iam.v1.Binding.condition][google.iam.v1.Binding.condition] field, which contains a condition
   * expression for a role binding.
   *
   * Successful calls to this method always return an HTTP `200 OK` status code,
   * even if the linter detects an issue in the IAM policy.
   */
  lintPolicy(
    request: LintPolicyRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<LintPolicyResponse>>;
}

export interface IAMClient<CallOptionsExt = {}> {
  /** Lists every [ServiceAccount][google.iam.admin.v1.ServiceAccount] that belongs to a specific project. */
  listServiceAccounts(
    request: DeepPartial<ListServiceAccountsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListServiceAccountsResponse>;
  /** Gets a [ServiceAccount][google.iam.admin.v1.ServiceAccount]. */
  getServiceAccount(
    request: DeepPartial<GetServiceAccountRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ServiceAccount>;
  /** Creates a [ServiceAccount][google.iam.admin.v1.ServiceAccount]. */
  createServiceAccount(
    request: DeepPartial<CreateServiceAccountRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ServiceAccount>;
  /**
   * *Note:** We are in the process of deprecating this method. Use
   * [PatchServiceAccount][google.iam.admin.v1.IAM.PatchServiceAccount] instead.
   *
   * Updates a [ServiceAccount][google.iam.admin.v1.ServiceAccount].
   *
   * You can update only the `display_name` field.
   */
  updateServiceAccount(
    request: DeepPartial<ServiceAccount>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ServiceAccount>;
  /** Patches a [ServiceAccount][google.iam.admin.v1.ServiceAccount]. */
  patchServiceAccount(
    request: DeepPartial<PatchServiceAccountRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ServiceAccount>;
  /**
   * Deletes a [ServiceAccount][google.iam.admin.v1.ServiceAccount].
   *
   * **Warning:** After you delete a service account, you might not be able to
   * undelete it. If you know that you need to re-enable the service account in
   * the future, use [DisableServiceAccount][google.iam.admin.v1.IAM.DisableServiceAccount] instead.
   *
   * If you delete a service account, IAM permanently removes the service
   * account 30 days later. Google Cloud cannot recover the service account
   * after it is permanently removed, even if you file a support request.
   *
   * To help avoid unplanned outages, we recommend that you disable the service
   * account before you delete it. Use [DisableServiceAccount][google.iam.admin.v1.IAM.DisableServiceAccount] to disable the
   * service account, then wait at least 24 hours and watch for unintended
   * consequences. If there are no unintended consequences, you can delete the
   * service account.
   */
  deleteServiceAccount(
    request: DeepPartial<DeleteServiceAccountRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /**
   * Restores a deleted [ServiceAccount][google.iam.admin.v1.ServiceAccount].
   *
   * **Important:** It is not always possible to restore a deleted service
   * account. Use this method only as a last resort.
   *
   * After you delete a service account, IAM permanently removes the service
   * account 30 days later. There is no way to restore a deleted service account
   * that has been permanently removed.
   */
  undeleteServiceAccount(
    request: DeepPartial<UndeleteServiceAccountRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<UndeleteServiceAccountResponse>;
  /**
   * Enables a [ServiceAccount][google.iam.admin.v1.ServiceAccount] that was disabled by
   * [DisableServiceAccount][google.iam.admin.v1.IAM.DisableServiceAccount].
   *
   * If the service account is already enabled, then this method has no effect.
   *
   * If the service account was disabled by other meansfor example, if Google
   * disabled the service account because it was compromisedyou cannot use this
   * method to enable the service account.
   */
  enableServiceAccount(
    request: DeepPartial<EnableServiceAccountRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /**
   * Disables a [ServiceAccount][google.iam.admin.v1.ServiceAccount] immediately.
   *
   * If an application uses the service account to authenticate, that
   * application can no longer call Google APIs or access Google Cloud
   * resources. Existing access tokens for the service account are rejected, and
   * requests for new access tokens will fail.
   *
   * To re-enable the service account, use [EnableServiceAccount][google.iam.admin.v1.IAM.EnableServiceAccount]. After you
   * re-enable the service account, its existing access tokens will be accepted,
   * and you can request new access tokens.
   *
   * To help avoid unplanned outages, we recommend that you disable the service
   * account before you delete it. Use this method to disable the service
   * account, then wait at least 24 hours and watch for unintended consequences.
   * If there are no unintended consequences, you can delete the service account
   * with [DeleteServiceAccount][google.iam.admin.v1.IAM.DeleteServiceAccount].
   */
  disableServiceAccount(
    request: DeepPartial<DisableServiceAccountRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** Lists every [ServiceAccountKey][google.iam.admin.v1.ServiceAccountKey] for a service account. */
  listServiceAccountKeys(
    request: DeepPartial<ListServiceAccountKeysRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListServiceAccountKeysResponse>;
  /** Gets a [ServiceAccountKey][google.iam.admin.v1.ServiceAccountKey]. */
  getServiceAccountKey(
    request: DeepPartial<GetServiceAccountKeyRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ServiceAccountKey>;
  /** Creates a [ServiceAccountKey][google.iam.admin.v1.ServiceAccountKey]. */
  createServiceAccountKey(
    request: DeepPartial<CreateServiceAccountKeyRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ServiceAccountKey>;
  /**
   * Uploads the public key portion of a key pair that you manage, and
   * associates the public key with a [ServiceAccount][google.iam.admin.v1.ServiceAccount].
   *
   * After you upload the public key, you can use the private key from the key
   * pair as a service account key.
   */
  uploadServiceAccountKey(
    request: DeepPartial<UploadServiceAccountKeyRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ServiceAccountKey>;
  /**
   * Deletes a [ServiceAccountKey][google.iam.admin.v1.ServiceAccountKey]. Deleting a service account key does not
   * revoke short-lived credentials that have been issued based on the service
   * account key.
   */
  deleteServiceAccountKey(
    request: DeepPartial<DeleteServiceAccountKeyRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /**
   * Disable a [ServiceAccountKey][google.iam.admin.v1.ServiceAccountKey]. A disabled service account key can be
   * re-enabled with [EnableServiceAccountKey][google.iam.admin.v1.IAM.EnableServiceAccountKey].
   */
  disableServiceAccountKey(
    request: DeepPartial<DisableServiceAccountKeyRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** Enable a [ServiceAccountKey][google.iam.admin.v1.ServiceAccountKey]. */
  enableServiceAccountKey(
    request: DeepPartial<EnableServiceAccountKeyRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /**
   * *Note:** This method is deprecated. Use the
   * [`signBlob`](https://cloud.google.com/iam/help/rest-credentials/v1/projects.serviceAccounts/signBlob)
   * method in the IAM Service Account Credentials API instead. If you currently
   * use this method, see the [migration
   * guide](https://cloud.google.com/iam/help/credentials/migrate-api) for
   * instructions.
   *
   * Signs a blob using the system-managed private key for a [ServiceAccount][google.iam.admin.v1.ServiceAccount].
   *
   * @deprecated
   */
  signBlob(request: DeepPartial<SignBlobRequest>, options?: CallOptions & CallOptionsExt): Promise<SignBlobResponse>;
  /**
   * *Note:** This method is deprecated. Use the
   * [`signJwt`](https://cloud.google.com/iam/help/rest-credentials/v1/projects.serviceAccounts/signJwt)
   * method in the IAM Service Account Credentials API instead. If you currently
   * use this method, see the [migration
   * guide](https://cloud.google.com/iam/help/credentials/migrate-api) for
   * instructions.
   *
   * Signs a JSON Web Token (JWT) using the system-managed private key for a
   * [ServiceAccount][google.iam.admin.v1.ServiceAccount].
   *
   * @deprecated
   */
  signJwt(request: DeepPartial<SignJwtRequest>, options?: CallOptions & CallOptionsExt): Promise<SignJwtResponse>;
  /**
   * Gets the IAM policy that is attached to a [ServiceAccount][google.iam.admin.v1.ServiceAccount]. This IAM
   * policy specifies which principals have access to the service account.
   *
   * This method does not tell you whether the service account has been granted
   * any roles on other resources. To check whether a service account has role
   * grants on a resource, use the `getIamPolicy` method for that resource. For
   * example, to view the role grants for a project, call the Resource Manager
   * API's
   * [`projects.getIamPolicy`](https://cloud.google.com/resource-manager/reference/rest/v1/projects/getIamPolicy)
   * method.
   */
  getIamPolicy(request: DeepPartial<GetIamPolicyRequest>, options?: CallOptions & CallOptionsExt): Promise<Policy>;
  /**
   * Sets the IAM policy that is attached to a [ServiceAccount][google.iam.admin.v1.ServiceAccount].
   *
   * Use this method to grant or revoke access to the service account. For
   * example, you could grant a principal the ability to impersonate the service
   * account.
   *
   * This method does not enable the service account to access other resources.
   * To grant roles to a service account on a resource, follow these steps:
   *
   * 1. Call the resource's `getIamPolicy` method to get its current IAM policy.
   * 2. Edit the policy so that it binds the service account to an IAM role for
   * the resource.
   * 3. Call the resource's `setIamPolicy` method to update its IAM policy.
   *
   * For detailed instructions, see
   * [Manage access to project, folders, and
   * organizations](https://cloud.google.com/iam/help/service-accounts/granting-access-to-service-accounts)
   * or [Manage access to other
   * resources](https://cloud.google.com/iam/help/access/manage-other-resources).
   */
  setIamPolicy(request: DeepPartial<SetIamPolicyRequest>, options?: CallOptions & CallOptionsExt): Promise<Policy>;
  /**
   * Tests whether the caller has the specified permissions on a
   * [ServiceAccount][google.iam.admin.v1.ServiceAccount].
   */
  testIamPermissions(
    request: DeepPartial<TestIamPermissionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<TestIamPermissionsResponse>;
  /**
   * Lists roles that can be granted on a Google Cloud resource. A role is
   * grantable if the IAM policy for the resource can contain bindings to the
   * role.
   */
  queryGrantableRoles(
    request: DeepPartial<QueryGrantableRolesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<QueryGrantableRolesResponse>;
  /**
   * Lists every predefined [Role][google.iam.admin.v1.Role] that IAM supports, or every custom role
   * that is defined for an organization or project.
   */
  listRoles(request: DeepPartial<ListRolesRequest>, options?: CallOptions & CallOptionsExt): Promise<ListRolesResponse>;
  /** Gets the definition of a [Role][google.iam.admin.v1.Role]. */
  getRole(request: DeepPartial<GetRoleRequest>, options?: CallOptions & CallOptionsExt): Promise<Role>;
  /** Creates a new custom [Role][google.iam.admin.v1.Role]. */
  createRole(request: DeepPartial<CreateRoleRequest>, options?: CallOptions & CallOptionsExt): Promise<Role>;
  /** Updates the definition of a custom [Role][google.iam.admin.v1.Role]. */
  updateRole(request: DeepPartial<UpdateRoleRequest>, options?: CallOptions & CallOptionsExt): Promise<Role>;
  /**
   * Deletes a custom [Role][google.iam.admin.v1.Role].
   *
   * When you delete a custom role, the following changes occur immediately:
   *
   * * You cannot bind a principal to the custom role in an IAM
   * [Policy][google.iam.v1.Policy].
   * * Existing bindings to the custom role are not changed, but they have no
   * effect.
   * * By default, the response from [ListRoles][google.iam.admin.v1.IAM.ListRoles] does not include the custom
   * role.
   *
   * You have 7 days to undelete the custom role. After 7 days, the following
   * changes occur:
   *
   * * The custom role is permanently deleted and cannot be recovered.
   * * If an IAM policy contains a binding to the custom role, the binding is
   * permanently removed.
   */
  deleteRole(request: DeepPartial<DeleteRoleRequest>, options?: CallOptions & CallOptionsExt): Promise<Role>;
  /** Undeletes a custom [Role][google.iam.admin.v1.Role]. */
  undeleteRole(request: DeepPartial<UndeleteRoleRequest>, options?: CallOptions & CallOptionsExt): Promise<Role>;
  /**
   * Lists every permission that you can test on a resource. A permission is
   * testable if you can check whether a principal has that permission on the
   * resource.
   */
  queryTestablePermissions(
    request: DeepPartial<QueryTestablePermissionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<QueryTestablePermissionsResponse>;
  /**
   * Returns a list of services that allow you to opt into audit logs that are
   * not generated by default.
   *
   * To learn more about audit logs, see the [Logging
   * documentation](https://cloud.google.com/logging/docs/audit).
   */
  queryAuditableServices(
    request: DeepPartial<QueryAuditableServicesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<QueryAuditableServicesResponse>;
  /**
   * Lints, or validates, an IAM policy. Currently checks the
   * [google.iam.v1.Binding.condition][google.iam.v1.Binding.condition] field, which contains a condition
   * expression for a role binding.
   *
   * Successful calls to this method always return an HTTP `200 OK` status code,
   * even if the linter detects an issue in the IAM policy.
   */
  lintPolicy(
    request: DeepPartial<LintPolicyRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<LintPolicyResponse>;
}

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
