// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/maps/areainsights/v1/area_insights_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { LatLng } from "../../../type/latlng.js";

export const protobufPackage = "google.maps.areainsights.v1";

/** Supported insights. */
export enum Insight {
  /** INSIGHT_UNSPECIFIED - Not Specified. */
  INSIGHT_UNSPECIFIED = 0,
  /**
   * INSIGHT_COUNT - Count insight.
   *
   * When this insight is specified ComputeInsights returns the number of
   * places that match the specified filter criteria.
   * ```
   * For example if the request is:
   * ComputeInsightsRequest {
   *   insights: INSIGHT_COUNT
   *   filter {
   *     location_filter {region: <PlaceId of state of CA>}
   *     type_filter {included_types: "restaurant"}
   *     operating_status: OPERATING_STATUS_OPERATIONAL
   *     price_levels: PRICE_LEVEL_FREE
   *     price_levels: PRICE_LEVEL_INEXPENSIVE
   *     min_rating: 4.0
   *   }
   * }
   *
   * The method will return the count of restaurants in California that are
   * operational, with price level free or inexpensive and have an average
   * rating of at least 4 starts.
   *
   * Example response:
   * ComputeInsightsResponse {
   *   count: <number of places>
   * }
   * ```
   */
  INSIGHT_COUNT = 1,
  /**
   * INSIGHT_PLACES - Return Places
   *
   * When this insight is specified ComputeInsights returns Places
   * that match the specified filter criteria.
   * ```
   * For example if the request is:
   * ComputeInsightsRequest {
   *   insights: INSIGHT_PLACES
   *   filter {
   *     location_filter {region: <PlaceId of state of CA>}
   *     type_filter {included_types: "restaurant"}
   *     operating_status: OPERATING_STATUS_OPERATIONAL
   *     price_levels: PRICE_LEVEL_FREE
   *     price_levels: PRICE_LEVEL_INEXPENSIVE
   *     min_rating: 4.0
   *   }
   * }
   *
   * The method will return list of places of restaurants in
   * California that are operational, with price level free or inexpensive and
   * have an average rating of at least 4 stars.
   *
   * Example response:
   * ComputeInsightsResponse {
   *   place_insights { place: "places/ABC" }
   *   place_insights { place: "places/PQR" }
   *   place_insights { place: "places/XYZ" }
   * }
   * ```
   */
  INSIGHT_PLACES = 2,
  UNRECOGNIZED = -1,
}

export function insightFromJSON(object: any): Insight {
  switch (object) {
    case 0:
    case "INSIGHT_UNSPECIFIED":
      return Insight.INSIGHT_UNSPECIFIED;
    case 1:
    case "INSIGHT_COUNT":
      return Insight.INSIGHT_COUNT;
    case 2:
    case "INSIGHT_PLACES":
      return Insight.INSIGHT_PLACES;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Insight.UNRECOGNIZED;
  }
}

export function insightToJSON(object: Insight): string {
  switch (object) {
    case Insight.INSIGHT_UNSPECIFIED:
      return "INSIGHT_UNSPECIFIED";
    case Insight.INSIGHT_COUNT:
      return "INSIGHT_COUNT";
    case Insight.INSIGHT_PLACES:
      return "INSIGHT_PLACES";
    case Insight.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Operating status of the place. */
export enum OperatingStatus {
  /** OPERATING_STATUS_UNSPECIFIED - Not Specified. */
  OPERATING_STATUS_UNSPECIFIED = 0,
  /** OPERATING_STATUS_OPERATIONAL - The place is operational and its open during its defined hours. */
  OPERATING_STATUS_OPERATIONAL = 1,
  /** OPERATING_STATUS_PERMANENTLY_CLOSED - The Place is no longer in business. */
  OPERATING_STATUS_PERMANENTLY_CLOSED = 3,
  /** OPERATING_STATUS_TEMPORARILY_CLOSED - The Place is temporarily closed and expected to reopen in the future. */
  OPERATING_STATUS_TEMPORARILY_CLOSED = 4,
  UNRECOGNIZED = -1,
}

export function operatingStatusFromJSON(object: any): OperatingStatus {
  switch (object) {
    case 0:
    case "OPERATING_STATUS_UNSPECIFIED":
      return OperatingStatus.OPERATING_STATUS_UNSPECIFIED;
    case 1:
    case "OPERATING_STATUS_OPERATIONAL":
      return OperatingStatus.OPERATING_STATUS_OPERATIONAL;
    case 3:
    case "OPERATING_STATUS_PERMANENTLY_CLOSED":
      return OperatingStatus.OPERATING_STATUS_PERMANENTLY_CLOSED;
    case 4:
    case "OPERATING_STATUS_TEMPORARILY_CLOSED":
      return OperatingStatus.OPERATING_STATUS_TEMPORARILY_CLOSED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OperatingStatus.UNRECOGNIZED;
  }
}

export function operatingStatusToJSON(object: OperatingStatus): string {
  switch (object) {
    case OperatingStatus.OPERATING_STATUS_UNSPECIFIED:
      return "OPERATING_STATUS_UNSPECIFIED";
    case OperatingStatus.OPERATING_STATUS_OPERATIONAL:
      return "OPERATING_STATUS_OPERATIONAL";
    case OperatingStatus.OPERATING_STATUS_PERMANENTLY_CLOSED:
      return "OPERATING_STATUS_PERMANENTLY_CLOSED";
    case OperatingStatus.OPERATING_STATUS_TEMPORARILY_CLOSED:
      return "OPERATING_STATUS_TEMPORARILY_CLOSED";
    case OperatingStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Price level of the place. */
export enum PriceLevel {
  /** PRICE_LEVEL_UNSPECIFIED - Place price level is unspecified or unknown. */
  PRICE_LEVEL_UNSPECIFIED = 0,
  /** PRICE_LEVEL_FREE - Place provides free services. */
  PRICE_LEVEL_FREE = 1,
  /** PRICE_LEVEL_INEXPENSIVE - Place provides inexpensive services. */
  PRICE_LEVEL_INEXPENSIVE = 2,
  /** PRICE_LEVEL_MODERATE - Place provides moderately priced services. */
  PRICE_LEVEL_MODERATE = 3,
  /** PRICE_LEVEL_EXPENSIVE - Place provides expensive services. */
  PRICE_LEVEL_EXPENSIVE = 4,
  /** PRICE_LEVEL_VERY_EXPENSIVE - Place provides very expensive services. */
  PRICE_LEVEL_VERY_EXPENSIVE = 5,
  UNRECOGNIZED = -1,
}

export function priceLevelFromJSON(object: any): PriceLevel {
  switch (object) {
    case 0:
    case "PRICE_LEVEL_UNSPECIFIED":
      return PriceLevel.PRICE_LEVEL_UNSPECIFIED;
    case 1:
    case "PRICE_LEVEL_FREE":
      return PriceLevel.PRICE_LEVEL_FREE;
    case 2:
    case "PRICE_LEVEL_INEXPENSIVE":
      return PriceLevel.PRICE_LEVEL_INEXPENSIVE;
    case 3:
    case "PRICE_LEVEL_MODERATE":
      return PriceLevel.PRICE_LEVEL_MODERATE;
    case 4:
    case "PRICE_LEVEL_EXPENSIVE":
      return PriceLevel.PRICE_LEVEL_EXPENSIVE;
    case 5:
    case "PRICE_LEVEL_VERY_EXPENSIVE":
      return PriceLevel.PRICE_LEVEL_VERY_EXPENSIVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PriceLevel.UNRECOGNIZED;
  }
}

export function priceLevelToJSON(object: PriceLevel): string {
  switch (object) {
    case PriceLevel.PRICE_LEVEL_UNSPECIFIED:
      return "PRICE_LEVEL_UNSPECIFIED";
    case PriceLevel.PRICE_LEVEL_FREE:
      return "PRICE_LEVEL_FREE";
    case PriceLevel.PRICE_LEVEL_INEXPENSIVE:
      return "PRICE_LEVEL_INEXPENSIVE";
    case PriceLevel.PRICE_LEVEL_MODERATE:
      return "PRICE_LEVEL_MODERATE";
    case PriceLevel.PRICE_LEVEL_EXPENSIVE:
      return "PRICE_LEVEL_EXPENSIVE";
    case PriceLevel.PRICE_LEVEL_VERY_EXPENSIVE:
      return "PRICE_LEVEL_VERY_EXPENSIVE";
    case PriceLevel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Request for the ComputeInsights RPC. */
export interface ComputeInsightsRequest {
  /**
   * Required. Insights to compute. Currently only INSIGHT_COUNT and
   * INSIGHT_PLACES are supported.
   */
  insights: Insight[];
  /** Required. Insight filter. */
  filter: Filter | undefined;
}

/** Response for the ComputeInsights RPC. */
export interface ComputeInsightsResponse {
  /** Result for Insights.INSIGHT_COUNT. */
  count?:
    | Long
    | undefined;
  /** Result for Insights.INSIGHT_PLACES. */
  placeInsights: PlaceInsight[];
}

/** Holds information about a place */
export interface PlaceInsight {
  /**
   * The resource name of a place. This resource name can be used to retrieve
   * details about the place using the [Places
   * API](https://developers.google.com/maps/documentation/places/web-service/reference/rest/v1/places/get).
   */
  place: string;
}

/** Filters for the ComputeInsights RPC. */
export interface Filter {
  /**
   * Required. Restricts results to places which are located in the area
   * specified by location filters.
   */
  locationFilter:
    | LocationFilter
    | undefined;
  /** Required. Place type filters. */
  typeFilter:
    | TypeFilter
    | undefined;
  /**
   * Optional. Restricts results to places whose operating status is included on
   * this list. If operating_status is not set, OPERATING_STATUS_OPERATIONAL is
   * used as default.
   */
  operatingStatus: OperatingStatus[];
  /**
   * Optional. Restricts results to places whose price level is included on this
   * list. If price_level is not set, all price levels are included in the
   * results.
   */
  priceLevels: PriceLevel[];
  /**
   * Optional. Restricts results to places whose average user ratings are in the
   * range specified by rating_filter. If rating_filter is not set, all ratings
   * are included in the result.
   */
  ratingFilter: RatingFilter | undefined;
}

/**
 * Location filters.
 *
 * Specifies the area of interest for the insight.
 */
export interface LocationFilter {
  /** Area as a circle. */
  circle?:
    | LocationFilter_Circle
    | undefined;
  /** Area as region. */
  region?:
    | LocationFilter_Region
    | undefined;
  /** Custom area specified by a polygon. */
  customArea?: LocationFilter_CustomArea | undefined;
}

/** A circle is defined by a center point and radius in meters. */
export interface LocationFilter_Circle {
  /** The latitude and longitude of the center of the circle. */
  latLng?:
    | LatLng
    | undefined;
  /**
   * The Place resource name of the center of the circle. Only point places
   * are supported.
   */
  place?:
    | string
    | undefined;
  /** Optional. The radius of the circle in meters */
  radius: number;
}

/**
 * A region is a geographic boundary such as: cities, postal codes, counties,
 * states, etc.
 */
export interface LocationFilter_Region {
  /** The Place resource name of a region. */
  place?: string | undefined;
}

/** Custom Area. */
export interface LocationFilter_CustomArea {
  /** Required. The custom area represented as a polygon */
  polygon: LocationFilter_CustomArea_Polygon | undefined;
}

/**
 * A polygon is represented by a series of connected coordinates in an
 * counterclockwise ordered sequence. The coordinates form a closed loop and
 * define a filled region. The first and last coordinates are equivalent,
 * and they must contain identical values. The format is a simplified
 * version of GeoJSON polygons (we only support one counterclockwise
 * exterior ring).
 */
export interface LocationFilter_CustomArea_Polygon {
  /** Optional. The coordinates that define the polygon. */
  coordinates: LatLng[];
}

/**
 * Place type filters.
 *
 * Only Place types from
 * [Table
 * a](https://developers.google.com/maps/documentation/places/web-service/place-types#table-a)
 * are supported.
 *
 * A place can only have a single primary type associated with it. For example,
 * the primary type might be "mexican_restaurant" or "steak_house". Use
 * included_primary_types and excluded_primary_types to filter the results on a
 * place's primary type.
 *
 * A place can also have multiple type values associated with it. For example a
 * restaurant might have the following types: "seafood_restaurant",
 * "restaurant", "food", "point_of_interest", "establishment". Use
 * included_types and excluded_types to filter the results on the list of types
 * associated with a place.
 *
 * If a search is specified with multiple type restrictions, only places that
 * satisfy all of the restrictions are returned. For example, if you specify
 * {"included_types": ["restaurant"], "excluded_primary_types":
 * ["steak_house"]}, the returned places provide "restaurant" related services
 * but do not operate primarily as a "steak_house".
 *
 * If there are any conflicting types, i.e. a type appears in both
 * included_types and excluded_types types or included_primary_types and
 * excluded_primary_types, an INVALID_ARGUMENT error is returned.
 *
 * One of included_types or included_primary_types must be set.
 */
export interface TypeFilter {
  /** Optional. Included Place types. */
  includedTypes: string[];
  /** Optional. Excluded Place types. */
  excludedTypes: string[];
  /** Optional. Included primary Place types. */
  includedPrimaryTypes: string[];
  /** Optional. Excluded primary Place types. */
  excludedPrimaryTypes: string[];
}

/** Average user rating filters. */
export interface RatingFilter {
  /**
   * Optional. Restricts results to places whose average user rating is greater
   * than or equal to min_rating. Values must be between 1.0 and 5.0.
   */
  minRating?:
    | number
    | undefined;
  /**
   * Optional. Restricts results to places whose average user rating is strictly
   * less than or equal to max_rating. Values must be between 1.0 and 5.0.
   */
  maxRating?: number | undefined;
}

function createBaseComputeInsightsRequest(): ComputeInsightsRequest {
  return { insights: [], filter: undefined };
}

export const ComputeInsightsRequest: MessageFns<ComputeInsightsRequest> = {
  encode(message: ComputeInsightsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(34).fork();
    for (const v of message.insights) {
      writer.int32(v);
    }
    writer.join();
    if (message.filter !== undefined) {
      Filter.encode(message.filter, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComputeInsightsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComputeInsightsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag === 32) {
            message.insights.push(reader.int32() as any);

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.insights.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.filter = Filter.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComputeInsightsRequest {
    return {
      insights: globalThis.Array.isArray(object?.insights) ? object.insights.map((e: any) => insightFromJSON(e)) : [],
      filter: isSet(object.filter) ? Filter.fromJSON(object.filter) : undefined,
    };
  },

  toJSON(message: ComputeInsightsRequest): unknown {
    const obj: any = {};
    if (message.insights?.length) {
      obj.insights = message.insights.map((e) => insightToJSON(e));
    }
    if (message.filter !== undefined) {
      obj.filter = Filter.toJSON(message.filter);
    }
    return obj;
  },

  create(base?: DeepPartial<ComputeInsightsRequest>): ComputeInsightsRequest {
    return ComputeInsightsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ComputeInsightsRequest>): ComputeInsightsRequest {
    const message = createBaseComputeInsightsRequest();
    message.insights = object.insights?.map((e) => e) || [];
    message.filter = (object.filter !== undefined && object.filter !== null)
      ? Filter.fromPartial(object.filter)
      : undefined;
    return message;
  },
};

function createBaseComputeInsightsResponse(): ComputeInsightsResponse {
  return { count: undefined, placeInsights: [] };
}

export const ComputeInsightsResponse: MessageFns<ComputeInsightsResponse> = {
  encode(message: ComputeInsightsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.count !== undefined) {
      writer.uint32(8).int64(message.count.toString());
    }
    for (const v of message.placeInsights) {
      PlaceInsight.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComputeInsightsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComputeInsightsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.count = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.placeInsights.push(PlaceInsight.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComputeInsightsResponse {
    return {
      count: isSet(object.count) ? Long.fromValue(object.count) : undefined,
      placeInsights: globalThis.Array.isArray(object?.placeInsights)
        ? object.placeInsights.map((e: any) => PlaceInsight.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ComputeInsightsResponse): unknown {
    const obj: any = {};
    if (message.count !== undefined) {
      obj.count = (message.count || Long.ZERO).toString();
    }
    if (message.placeInsights?.length) {
      obj.placeInsights = message.placeInsights.map((e) => PlaceInsight.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ComputeInsightsResponse>): ComputeInsightsResponse {
    return ComputeInsightsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ComputeInsightsResponse>): ComputeInsightsResponse {
    const message = createBaseComputeInsightsResponse();
    message.count = (object.count !== undefined && object.count !== null) ? Long.fromValue(object.count) : undefined;
    message.placeInsights = object.placeInsights?.map((e) => PlaceInsight.fromPartial(e)) || [];
    return message;
  },
};

function createBasePlaceInsight(): PlaceInsight {
  return { place: "" };
}

export const PlaceInsight: MessageFns<PlaceInsight> = {
  encode(message: PlaceInsight, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.place !== "") {
      writer.uint32(10).string(message.place);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlaceInsight {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlaceInsight();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.place = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlaceInsight {
    return { place: isSet(object.place) ? globalThis.String(object.place) : "" };
  },

  toJSON(message: PlaceInsight): unknown {
    const obj: any = {};
    if (message.place !== "") {
      obj.place = message.place;
    }
    return obj;
  },

  create(base?: DeepPartial<PlaceInsight>): PlaceInsight {
    return PlaceInsight.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlaceInsight>): PlaceInsight {
    const message = createBasePlaceInsight();
    message.place = object.place ?? "";
    return message;
  },
};

function createBaseFilter(): Filter {
  return {
    locationFilter: undefined,
    typeFilter: undefined,
    operatingStatus: [],
    priceLevels: [],
    ratingFilter: undefined,
  };
}

export const Filter: MessageFns<Filter> = {
  encode(message: Filter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.locationFilter !== undefined) {
      LocationFilter.encode(message.locationFilter, writer.uint32(10).fork()).join();
    }
    if (message.typeFilter !== undefined) {
      TypeFilter.encode(message.typeFilter, writer.uint32(18).fork()).join();
    }
    writer.uint32(26).fork();
    for (const v of message.operatingStatus) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(34).fork();
    for (const v of message.priceLevels) {
      writer.int32(v);
    }
    writer.join();
    if (message.ratingFilter !== undefined) {
      RatingFilter.encode(message.ratingFilter, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Filter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.locationFilter = LocationFilter.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.typeFilter = TypeFilter.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag === 24) {
            message.operatingStatus.push(reader.int32() as any);

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.operatingStatus.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 4:
          if (tag === 32) {
            message.priceLevels.push(reader.int32() as any);

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.priceLevels.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.ratingFilter = RatingFilter.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Filter {
    return {
      locationFilter: isSet(object.locationFilter) ? LocationFilter.fromJSON(object.locationFilter) : undefined,
      typeFilter: isSet(object.typeFilter) ? TypeFilter.fromJSON(object.typeFilter) : undefined,
      operatingStatus: globalThis.Array.isArray(object?.operatingStatus)
        ? object.operatingStatus.map((e: any) => operatingStatusFromJSON(e))
        : [],
      priceLevels: globalThis.Array.isArray(object?.priceLevels)
        ? object.priceLevels.map((e: any) => priceLevelFromJSON(e))
        : [],
      ratingFilter: isSet(object.ratingFilter) ? RatingFilter.fromJSON(object.ratingFilter) : undefined,
    };
  },

  toJSON(message: Filter): unknown {
    const obj: any = {};
    if (message.locationFilter !== undefined) {
      obj.locationFilter = LocationFilter.toJSON(message.locationFilter);
    }
    if (message.typeFilter !== undefined) {
      obj.typeFilter = TypeFilter.toJSON(message.typeFilter);
    }
    if (message.operatingStatus?.length) {
      obj.operatingStatus = message.operatingStatus.map((e) => operatingStatusToJSON(e));
    }
    if (message.priceLevels?.length) {
      obj.priceLevels = message.priceLevels.map((e) => priceLevelToJSON(e));
    }
    if (message.ratingFilter !== undefined) {
      obj.ratingFilter = RatingFilter.toJSON(message.ratingFilter);
    }
    return obj;
  },

  create(base?: DeepPartial<Filter>): Filter {
    return Filter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Filter>): Filter {
    const message = createBaseFilter();
    message.locationFilter = (object.locationFilter !== undefined && object.locationFilter !== null)
      ? LocationFilter.fromPartial(object.locationFilter)
      : undefined;
    message.typeFilter = (object.typeFilter !== undefined && object.typeFilter !== null)
      ? TypeFilter.fromPartial(object.typeFilter)
      : undefined;
    message.operatingStatus = object.operatingStatus?.map((e) => e) || [];
    message.priceLevels = object.priceLevels?.map((e) => e) || [];
    message.ratingFilter = (object.ratingFilter !== undefined && object.ratingFilter !== null)
      ? RatingFilter.fromPartial(object.ratingFilter)
      : undefined;
    return message;
  },
};

function createBaseLocationFilter(): LocationFilter {
  return { circle: undefined, region: undefined, customArea: undefined };
}

export const LocationFilter: MessageFns<LocationFilter> = {
  encode(message: LocationFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.circle !== undefined) {
      LocationFilter_Circle.encode(message.circle, writer.uint32(10).fork()).join();
    }
    if (message.region !== undefined) {
      LocationFilter_Region.encode(message.region, writer.uint32(18).fork()).join();
    }
    if (message.customArea !== undefined) {
      LocationFilter_CustomArea.encode(message.customArea, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LocationFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocationFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.circle = LocationFilter_Circle.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.region = LocationFilter_Region.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.customArea = LocationFilter_CustomArea.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LocationFilter {
    return {
      circle: isSet(object.circle) ? LocationFilter_Circle.fromJSON(object.circle) : undefined,
      region: isSet(object.region) ? LocationFilter_Region.fromJSON(object.region) : undefined,
      customArea: isSet(object.customArea) ? LocationFilter_CustomArea.fromJSON(object.customArea) : undefined,
    };
  },

  toJSON(message: LocationFilter): unknown {
    const obj: any = {};
    if (message.circle !== undefined) {
      obj.circle = LocationFilter_Circle.toJSON(message.circle);
    }
    if (message.region !== undefined) {
      obj.region = LocationFilter_Region.toJSON(message.region);
    }
    if (message.customArea !== undefined) {
      obj.customArea = LocationFilter_CustomArea.toJSON(message.customArea);
    }
    return obj;
  },

  create(base?: DeepPartial<LocationFilter>): LocationFilter {
    return LocationFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LocationFilter>): LocationFilter {
    const message = createBaseLocationFilter();
    message.circle = (object.circle !== undefined && object.circle !== null)
      ? LocationFilter_Circle.fromPartial(object.circle)
      : undefined;
    message.region = (object.region !== undefined && object.region !== null)
      ? LocationFilter_Region.fromPartial(object.region)
      : undefined;
    message.customArea = (object.customArea !== undefined && object.customArea !== null)
      ? LocationFilter_CustomArea.fromPartial(object.customArea)
      : undefined;
    return message;
  },
};

function createBaseLocationFilter_Circle(): LocationFilter_Circle {
  return { latLng: undefined, place: undefined, radius: 0 };
}

export const LocationFilter_Circle: MessageFns<LocationFilter_Circle> = {
  encode(message: LocationFilter_Circle, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.latLng !== undefined) {
      LatLng.encode(message.latLng, writer.uint32(10).fork()).join();
    }
    if (message.place !== undefined) {
      writer.uint32(18).string(message.place);
    }
    if (message.radius !== 0) {
      writer.uint32(24).int32(message.radius);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LocationFilter_Circle {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocationFilter_Circle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.latLng = LatLng.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.place = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.radius = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LocationFilter_Circle {
    return {
      latLng: isSet(object.latLng) ? LatLng.fromJSON(object.latLng) : undefined,
      place: isSet(object.place) ? globalThis.String(object.place) : undefined,
      radius: isSet(object.radius) ? globalThis.Number(object.radius) : 0,
    };
  },

  toJSON(message: LocationFilter_Circle): unknown {
    const obj: any = {};
    if (message.latLng !== undefined) {
      obj.latLng = LatLng.toJSON(message.latLng);
    }
    if (message.place !== undefined) {
      obj.place = message.place;
    }
    if (message.radius !== 0) {
      obj.radius = Math.round(message.radius);
    }
    return obj;
  },

  create(base?: DeepPartial<LocationFilter_Circle>): LocationFilter_Circle {
    return LocationFilter_Circle.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LocationFilter_Circle>): LocationFilter_Circle {
    const message = createBaseLocationFilter_Circle();
    message.latLng = (object.latLng !== undefined && object.latLng !== null)
      ? LatLng.fromPartial(object.latLng)
      : undefined;
    message.place = object.place ?? undefined;
    message.radius = object.radius ?? 0;
    return message;
  },
};

function createBaseLocationFilter_Region(): LocationFilter_Region {
  return { place: undefined };
}

export const LocationFilter_Region: MessageFns<LocationFilter_Region> = {
  encode(message: LocationFilter_Region, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.place !== undefined) {
      writer.uint32(10).string(message.place);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LocationFilter_Region {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocationFilter_Region();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.place = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LocationFilter_Region {
    return { place: isSet(object.place) ? globalThis.String(object.place) : undefined };
  },

  toJSON(message: LocationFilter_Region): unknown {
    const obj: any = {};
    if (message.place !== undefined) {
      obj.place = message.place;
    }
    return obj;
  },

  create(base?: DeepPartial<LocationFilter_Region>): LocationFilter_Region {
    return LocationFilter_Region.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LocationFilter_Region>): LocationFilter_Region {
    const message = createBaseLocationFilter_Region();
    message.place = object.place ?? undefined;
    return message;
  },
};

function createBaseLocationFilter_CustomArea(): LocationFilter_CustomArea {
  return { polygon: undefined };
}

export const LocationFilter_CustomArea: MessageFns<LocationFilter_CustomArea> = {
  encode(message: LocationFilter_CustomArea, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.polygon !== undefined) {
      LocationFilter_CustomArea_Polygon.encode(message.polygon, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LocationFilter_CustomArea {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocationFilter_CustomArea();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.polygon = LocationFilter_CustomArea_Polygon.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LocationFilter_CustomArea {
    return { polygon: isSet(object.polygon) ? LocationFilter_CustomArea_Polygon.fromJSON(object.polygon) : undefined };
  },

  toJSON(message: LocationFilter_CustomArea): unknown {
    const obj: any = {};
    if (message.polygon !== undefined) {
      obj.polygon = LocationFilter_CustomArea_Polygon.toJSON(message.polygon);
    }
    return obj;
  },

  create(base?: DeepPartial<LocationFilter_CustomArea>): LocationFilter_CustomArea {
    return LocationFilter_CustomArea.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LocationFilter_CustomArea>): LocationFilter_CustomArea {
    const message = createBaseLocationFilter_CustomArea();
    message.polygon = (object.polygon !== undefined && object.polygon !== null)
      ? LocationFilter_CustomArea_Polygon.fromPartial(object.polygon)
      : undefined;
    return message;
  },
};

function createBaseLocationFilter_CustomArea_Polygon(): LocationFilter_CustomArea_Polygon {
  return { coordinates: [] };
}

export const LocationFilter_CustomArea_Polygon: MessageFns<LocationFilter_CustomArea_Polygon> = {
  encode(message: LocationFilter_CustomArea_Polygon, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.coordinates) {
      LatLng.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LocationFilter_CustomArea_Polygon {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocationFilter_CustomArea_Polygon();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.coordinates.push(LatLng.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LocationFilter_CustomArea_Polygon {
    return {
      coordinates: globalThis.Array.isArray(object?.coordinates)
        ? object.coordinates.map((e: any) => LatLng.fromJSON(e))
        : [],
    };
  },

  toJSON(message: LocationFilter_CustomArea_Polygon): unknown {
    const obj: any = {};
    if (message.coordinates?.length) {
      obj.coordinates = message.coordinates.map((e) => LatLng.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<LocationFilter_CustomArea_Polygon>): LocationFilter_CustomArea_Polygon {
    return LocationFilter_CustomArea_Polygon.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LocationFilter_CustomArea_Polygon>): LocationFilter_CustomArea_Polygon {
    const message = createBaseLocationFilter_CustomArea_Polygon();
    message.coordinates = object.coordinates?.map((e) => LatLng.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTypeFilter(): TypeFilter {
  return { includedTypes: [], excludedTypes: [], includedPrimaryTypes: [], excludedPrimaryTypes: [] };
}

export const TypeFilter: MessageFns<TypeFilter> = {
  encode(message: TypeFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.includedTypes) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.excludedTypes) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.includedPrimaryTypes) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.excludedPrimaryTypes) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TypeFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTypeFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.includedTypes.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.excludedTypes.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.includedPrimaryTypes.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.excludedPrimaryTypes.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TypeFilter {
    return {
      includedTypes: globalThis.Array.isArray(object?.includedTypes)
        ? object.includedTypes.map((e: any) => globalThis.String(e))
        : [],
      excludedTypes: globalThis.Array.isArray(object?.excludedTypes)
        ? object.excludedTypes.map((e: any) => globalThis.String(e))
        : [],
      includedPrimaryTypes: globalThis.Array.isArray(object?.includedPrimaryTypes)
        ? object.includedPrimaryTypes.map((e: any) => globalThis.String(e))
        : [],
      excludedPrimaryTypes: globalThis.Array.isArray(object?.excludedPrimaryTypes)
        ? object.excludedPrimaryTypes.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: TypeFilter): unknown {
    const obj: any = {};
    if (message.includedTypes?.length) {
      obj.includedTypes = message.includedTypes;
    }
    if (message.excludedTypes?.length) {
      obj.excludedTypes = message.excludedTypes;
    }
    if (message.includedPrimaryTypes?.length) {
      obj.includedPrimaryTypes = message.includedPrimaryTypes;
    }
    if (message.excludedPrimaryTypes?.length) {
      obj.excludedPrimaryTypes = message.excludedPrimaryTypes;
    }
    return obj;
  },

  create(base?: DeepPartial<TypeFilter>): TypeFilter {
    return TypeFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TypeFilter>): TypeFilter {
    const message = createBaseTypeFilter();
    message.includedTypes = object.includedTypes?.map((e) => e) || [];
    message.excludedTypes = object.excludedTypes?.map((e) => e) || [];
    message.includedPrimaryTypes = object.includedPrimaryTypes?.map((e) => e) || [];
    message.excludedPrimaryTypes = object.excludedPrimaryTypes?.map((e) => e) || [];
    return message;
  },
};

function createBaseRatingFilter(): RatingFilter {
  return { minRating: undefined, maxRating: undefined };
}

export const RatingFilter: MessageFns<RatingFilter> = {
  encode(message: RatingFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.minRating !== undefined) {
      writer.uint32(45).float(message.minRating);
    }
    if (message.maxRating !== undefined) {
      writer.uint32(53).float(message.maxRating);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RatingFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRatingFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5:
          if (tag !== 45) {
            break;
          }

          message.minRating = reader.float();
          continue;
        case 6:
          if (tag !== 53) {
            break;
          }

          message.maxRating = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RatingFilter {
    return {
      minRating: isSet(object.minRating) ? globalThis.Number(object.minRating) : undefined,
      maxRating: isSet(object.maxRating) ? globalThis.Number(object.maxRating) : undefined,
    };
  },

  toJSON(message: RatingFilter): unknown {
    const obj: any = {};
    if (message.minRating !== undefined) {
      obj.minRating = message.minRating;
    }
    if (message.maxRating !== undefined) {
      obj.maxRating = message.maxRating;
    }
    return obj;
  },

  create(base?: DeepPartial<RatingFilter>): RatingFilter {
    return RatingFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RatingFilter>): RatingFilter {
    const message = createBaseRatingFilter();
    message.minRating = object.minRating ?? undefined;
    message.maxRating = object.maxRating ?? undefined;
    return message;
  },
};

/** Service definition for the Places Insights API. */
export type AreaInsightsDefinition = typeof AreaInsightsDefinition;
export const AreaInsightsDefinition = {
  name: "AreaInsights",
  fullName: "google.maps.areainsights.v1.AreaInsights",
  methods: {
    /**
     * Compute Insights RPC
     *
     * This method lets you retrieve insights about areas using a variaty of
     * filter such as: area, place type, operating status, price level
     * and ratings. Currently "count" and "places" insights are supported. With
     * "count" insights you can answer questions such as "How many restaurant are
     * located in California that are operational, are inexpensive and have an
     * average rating of at least 4 stars" (see `insight` enum for more details).
     * With "places" insights, you can determine which places match the
     * requested filter. Clients can then use those place resource names to fetch
     * more details about each individual place using the Places API.
     */
    computeInsights: {
      name: "ComputeInsights",
      requestType: ComputeInsightsRequest,
      requestStream: false,
      responseType: ComputeInsightsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              24,
              58,
              1,
              42,
              34,
              19,
              47,
              118,
              49,
              58,
              99,
              111,
              109,
              112,
              117,
              116,
              101,
              73,
              110,
              115,
              105,
              103,
              104,
              116,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface AreaInsightsServiceImplementation<CallContextExt = {}> {
  /**
   * Compute Insights RPC
   *
   * This method lets you retrieve insights about areas using a variaty of
   * filter such as: area, place type, operating status, price level
   * and ratings. Currently "count" and "places" insights are supported. With
   * "count" insights you can answer questions such as "How many restaurant are
   * located in California that are operational, are inexpensive and have an
   * average rating of at least 4 stars" (see `insight` enum for more details).
   * With "places" insights, you can determine which places match the
   * requested filter. Clients can then use those place resource names to fetch
   * more details about each individual place using the Places API.
   */
  computeInsights(
    request: ComputeInsightsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ComputeInsightsResponse>>;
}

export interface AreaInsightsClient<CallOptionsExt = {}> {
  /**
   * Compute Insights RPC
   *
   * This method lets you retrieve insights about areas using a variaty of
   * filter such as: area, place type, operating status, price level
   * and ratings. Currently "count" and "places" insights are supported. With
   * "count" insights you can answer questions such as "How many restaurant are
   * located in California that are operational, are inexpensive and have an
   * average rating of at least 4 stars" (see `insight` enum for more details).
   * With "places" insights, you can determine which places match the
   * requested filter. Clients can then use those place resource names to fetch
   * more details about each individual place using the Places API.
   */
  computeInsights(
    request: DeepPartial<ComputeInsightsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ComputeInsightsResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
