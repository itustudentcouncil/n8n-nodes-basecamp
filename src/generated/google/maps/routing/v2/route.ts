// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/maps/routing/v2/route.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Viewport } from "../../../geo/type/viewport.js";
import { Duration } from "../../../protobuf/duration.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { LocalizedText } from "../../../type/localized_text.js";
import { Money } from "../../../type/money.js";
import { LocalizedTime } from "./localized_time.js";
import { Location } from "./location.js";
import { NavigationInstruction } from "./navigation_instruction.js";
import { Polyline } from "./polyline.js";
import { RouteLabel, routeLabelFromJSON, routeLabelToJSON } from "./route_label.js";
import { RouteTravelMode, routeTravelModeFromJSON, routeTravelModeToJSON } from "./route_travel_mode.js";
import { SpeedReadingInterval } from "./speed_reading_interval.js";
import { TollInfo } from "./toll_info.js";
import { TransitLine, TransitStop } from "./transit.js";

export const protobufPackage = "google.maps.routing.v2";

/**
 * Contains a route, which consists of a series of connected road segments
 * that join beginning, ending, and intermediate waypoints.
 */
export interface Route {
  /**
   * Labels for the `Route` that are useful to identify specific properties
   * of the route to compare against others.
   */
  routeLabels: RouteLabel[];
  /**
   * A collection of legs (path segments between waypoints) that make up the
   * route. Each leg corresponds to the trip between two non-`via`
   * [`Waypoints`][google.maps.routing.v2.Waypoint]. For example, a route with
   * no intermediate waypoints has only one leg. A route that includes one
   * non-`via` intermediate waypoint has two legs. A route that includes one
   * `via` intermediate waypoint has one leg. The order of the legs matches the
   * order of waypoints from `origin` to `intermediates` to `destination`.
   */
  legs: RouteLeg[];
  /** The travel distance of the route, in meters. */
  distanceMeters: number;
  /**
   * The length of time needed to navigate the route. If you set the
   * `routing_preference` to `TRAFFIC_UNAWARE`, then this value is the same as
   * `static_duration`. If you set the `routing_preference` to either
   * `TRAFFIC_AWARE` or `TRAFFIC_AWARE_OPTIMAL`, then this value is calculated
   * taking traffic conditions into account.
   */
  duration:
    | Duration
    | undefined;
  /**
   * The duration of travel through the route without taking traffic
   * conditions into consideration.
   */
  staticDuration:
    | Duration
    | undefined;
  /**
   * The overall route polyline. This polyline is the combined polyline of
   * all `legs`.
   */
  polyline:
    | Polyline
    | undefined;
  /** A description of the route. */
  description: string;
  /** An array of warnings to show when displaying the route. */
  warnings: string[];
  /** The viewport bounding box of the polyline. */
  viewport:
    | Viewport
    | undefined;
  /** Additional information about the route. */
  travelAdvisory:
    | RouteTravelAdvisory
    | undefined;
  /**
   * If you set
   * [`optimize_waypoint_order`][google.maps.routing.v2.ComputeRoutesRequest.optimize_waypoint_order]
   * to true, this field contains the optimized ordering of intermediate
   * waypoints. Otherwise, this field is empty.
   * For example, if you give an input of Origin: LA; Intermediate waypoints:
   * Dallas, Bangor, Phoenix; Destination: New York; and the optimized
   * intermediate waypoint order is Phoenix, Dallas, Bangor, then this field
   * contains the values [2, 0, 1]. The index starts with 0 for the first
   * intermediate waypoint provided in the input.
   */
  optimizedIntermediateWaypointIndex: number[];
  /** Text representations of properties of the `Route`. */
  localizedValues:
    | Route_RouteLocalizedValues
    | undefined;
  /**
   * A web-safe, base64-encoded route token that can be passed to the Navigation
   * SDK, that allows the Navigation SDK to reconstruct the route during
   * navigation, and, in the event of rerouting, honor the original intention
   * when you created the route by calling ComputeRoutes. Customers should treat
   * this token as an opaque blob. It is not meant for reading or mutating.
   * NOTE: `Route.route_token` is only available for requests that have set
   * `ComputeRoutesRequest.routing_preference` to `TRAFFIC_AWARE` or
   * `TRAFFIC_AWARE_OPTIMAL`. `Route.route_token` is not supported for requests
   * that have Via waypoints.
   */
  routeToken: string;
}

/** Text representations of certain properties. */
export interface Route_RouteLocalizedValues {
  /** Travel distance represented in text form. */
  distance:
    | LocalizedText
    | undefined;
  /**
   * Duration taking traffic conditions into consideration, represented in
   * text form. Note: If you did not request traffic information, this value
   * will be the same value as `static_duration`.
   */
  duration:
    | LocalizedText
    | undefined;
  /**
   * Duration without taking traffic conditions into consideration,
   * represented in text form.
   */
  staticDuration:
    | LocalizedText
    | undefined;
  /** Transit fare represented in text form. */
  transitFare: LocalizedText | undefined;
}

/**
 * Contains the additional information that the user should be informed
 * about, such as possible traffic zone restrictions.
 */
export interface RouteTravelAdvisory {
  /**
   * Contains information about tolls on the route. This field is only populated
   * if tolls are expected on the route. If this field is set, but the
   * `estimatedPrice` subfield is not populated, then the route contains tolls,
   * but the estimated price is unknown. If this field is not set, then there
   * are no tolls expected on the route.
   */
  tollInfo:
    | TollInfo
    | undefined;
  /**
   * Speed reading intervals detailing traffic density. Applicable in case of
   * `TRAFFIC_AWARE` and `TRAFFIC_AWARE_OPTIMAL` routing preferences.
   * The intervals cover the entire polyline of the route without overlap.
   * The start point of a specified interval is the same as the end point of the
   * preceding interval.
   *
   * Example:
   *
   *     polyline: A ---- B ---- C ---- D ---- E ---- F ---- G
   *     speed_reading_intervals: [A,C), [C,D), [D,G).
   */
  speedReadingIntervals: SpeedReadingInterval[];
  /** The predicted fuel consumption in microliters. */
  fuelConsumptionMicroliters: Long;
  /**
   * Returned route may have restrictions that are not suitable for requested
   * travel mode or route modifiers.
   */
  routeRestrictionsPartiallyIgnored: boolean;
  /**
   * If present, contains the total fare or ticket costs on this route
   * This property is only returned for `TRANSIT` requests and only
   * for routes where fare information is available for all transit steps.
   */
  transitFare: Money | undefined;
}

/**
 * Contains the additional information that the user should be informed
 * about on a leg step, such as possible traffic zone restrictions.
 */
export interface RouteLegTravelAdvisory {
  /**
   * Contains information about tolls on the specific `RouteLeg`.
   * This field is only populated if we expect there are tolls on the
   * `RouteLeg`. If this field is set but the estimated_price subfield is not
   * populated, we expect that road contains tolls but we do not know an
   * estimated price. If this field does not exist, then there is no toll on the
   * `RouteLeg`.
   */
  tollInfo:
    | TollInfo
    | undefined;
  /**
   * Speed reading intervals detailing traffic density. Applicable in case of
   * `TRAFFIC_AWARE` and `TRAFFIC_AWARE_OPTIMAL` routing preferences.
   * The intervals cover the entire polyline of the `RouteLeg` without overlap.
   * The start point of a specified interval is the same as the end point of the
   * preceding interval.
   *
   * Example:
   *
   *     polyline: A ---- B ---- C ---- D ---- E ---- F ---- G
   *     speed_reading_intervals: [A,C), [C,D), [D,G).
   */
  speedReadingIntervals: SpeedReadingInterval[];
}

/**
 * Contains the additional information that the user should be informed
 * about, such as possible traffic zone restrictions on a leg step.
 */
export interface RouteLegStepTravelAdvisory {
  /** NOTE: This field is not currently populated. */
  speedReadingIntervals: SpeedReadingInterval[];
}

/** Contains a segment between non-`via` waypoints. */
export interface RouteLeg {
  /** The travel distance of the route leg, in meters. */
  distanceMeters: number;
  /**
   * The length of time needed to navigate the leg. If the `route_preference`
   * is set to `TRAFFIC_UNAWARE`, then this value is the same as
   * `static_duration`. If the `route_preference` is either `TRAFFIC_AWARE` or
   * `TRAFFIC_AWARE_OPTIMAL`, then this value is calculated taking traffic
   * conditions into account.
   */
  duration:
    | Duration
    | undefined;
  /**
   * The duration of travel through the leg, calculated without taking
   * traffic conditions into consideration.
   */
  staticDuration:
    | Duration
    | undefined;
  /**
   * The overall polyline for this leg that includes each `step`'s
   * polyline.
   */
  polyline:
    | Polyline
    | undefined;
  /**
   * The start location of this leg. This location might be different from the
   * provided `origin`. For example, when the provided `origin` is not near a
   * road, this is a point on the road.
   */
  startLocation:
    | Location
    | undefined;
  /**
   * The end location of this leg. This location might be different from the
   * provided `destination`. For example, when the provided `destination` is not
   * near a road, this is a point on the road.
   */
  endLocation:
    | Location
    | undefined;
  /**
   * An array of steps denoting segments within this leg. Each step represents
   * one navigation instruction.
   */
  steps: RouteLegStep[];
  /**
   * Contains the additional information that the user should be informed
   * about, such as possible traffic zone restrictions, on a route leg.
   */
  travelAdvisory:
    | RouteLegTravelAdvisory
    | undefined;
  /** Text representations of properties of the `RouteLeg`. */
  localizedValues:
    | RouteLeg_RouteLegLocalizedValues
    | undefined;
  /**
   * Overview information about the steps in this `RouteLeg`. This field is only
   * populated for TRANSIT routes.
   */
  stepsOverview: RouteLeg_StepsOverview | undefined;
}

/** Text representations of certain properties. */
export interface RouteLeg_RouteLegLocalizedValues {
  /** Travel distance represented in text form. */
  distance:
    | LocalizedText
    | undefined;
  /**
   * Duration taking traffic conditions into consideration represented in text
   * form. Note: If you did not request traffic information, this value will
   * be the same value as static_duration.
   */
  duration:
    | LocalizedText
    | undefined;
  /**
   * Duration without taking traffic conditions into
   * consideration, represented in text form.
   */
  staticDuration: LocalizedText | undefined;
}

/** Provides overview information about a list of `RouteLegStep`s. */
export interface RouteLeg_StepsOverview {
  /**
   * Summarized information about different multi-modal segments of
   * the `RouteLeg.steps`. This field is not populated if the `RouteLeg` does
   * not contain any multi-modal segments in the steps.
   */
  multiModalSegments: RouteLeg_StepsOverview_MultiModalSegment[];
}

/**
 * Provides summarized information about different multi-modal segments of
 * the `RouteLeg.steps`. A multi-modal segment is defined as one or more
 * contiguous `RouteLegStep` that have the same `RouteTravelMode`.
 * This field is not populated if the `RouteLeg` does not contain any
 * multi-modal segments in the steps.
 */
export interface RouteLeg_StepsOverview_MultiModalSegment {
  /**
   * The corresponding `RouteLegStep` index that is the start of a
   * multi-modal segment.
   */
  stepStartIndex?:
    | number
    | undefined;
  /**
   * The corresponding `RouteLegStep` index that is the end of a
   * multi-modal segment.
   */
  stepEndIndex?:
    | number
    | undefined;
  /** NavigationInstruction for the multi-modal segment. */
  navigationInstruction:
    | NavigationInstruction
    | undefined;
  /** The travel mode of the multi-modal segment. */
  travelMode: RouteTravelMode;
}

/**
 * Contains a segment of a [`RouteLeg`][google.maps.routing.v2.RouteLeg]. A
 * step corresponds to a single navigation instruction. Route legs are made up
 * of steps.
 */
export interface RouteLegStep {
  /**
   * The travel distance of this step, in meters. In some circumstances, this
   * field might not have a value.
   */
  distanceMeters: number;
  /**
   * The duration of travel through this step without taking traffic conditions
   * into consideration. In some circumstances, this field might not have a
   * value.
   */
  staticDuration:
    | Duration
    | undefined;
  /** The polyline associated with this step. */
  polyline:
    | Polyline
    | undefined;
  /** The start location of this step. */
  startLocation:
    | Location
    | undefined;
  /** The end location of this step. */
  endLocation:
    | Location
    | undefined;
  /** Navigation instructions. */
  navigationInstruction:
    | NavigationInstruction
    | undefined;
  /**
   * Contains the additional information that the user should be informed
   * about, such as possible traffic zone restrictions, on a leg step.
   */
  travelAdvisory:
    | RouteLegStepTravelAdvisory
    | undefined;
  /** Text representations of properties of the `RouteLegStep`. */
  localizedValues:
    | RouteLegStep_RouteLegStepLocalizedValues
    | undefined;
  /** Details pertaining to this step if the travel mode is `TRANSIT`. */
  transitDetails:
    | RouteLegStepTransitDetails
    | undefined;
  /** The travel mode used for this step. */
  travelMode: RouteTravelMode;
}

/** Text representations of certain properties. */
export interface RouteLegStep_RouteLegStepLocalizedValues {
  /** Travel distance represented in text form. */
  distance:
    | LocalizedText
    | undefined;
  /**
   * Duration without taking traffic conditions into
   * consideration, represented in text form.
   */
  staticDuration: LocalizedText | undefined;
}

/** Additional information for the `RouteLegStep` related to `TRANSIT` routes. */
export interface RouteLegStepTransitDetails {
  /** Information about the arrival and departure stops for the step. */
  stopDetails:
    | RouteLegStepTransitDetails_TransitStopDetails
    | undefined;
  /** Text representations of properties of the `RouteLegStepTransitDetails`. */
  localizedValues:
    | RouteLegStepTransitDetails_TransitDetailsLocalizedValues
    | undefined;
  /**
   * Specifies the direction in which to travel on this line as marked on
   * the vehicle or at the departure stop. The direction is often the terminus
   * station.
   */
  headsign: string;
  /**
   * Specifies the expected time as a duration between departures from the same
   * stop at this time. For example, with a headway seconds value of 600, you
   * would expect a ten minute wait if you should miss your bus.
   */
  headway:
    | Duration
    | undefined;
  /** Information about the transit line used in this step. */
  transitLine:
    | TransitLine
    | undefined;
  /**
   * The number of stops from the departure to the arrival stop. This count
   * includes the arrival stop, but excludes the departure stop. For example, if
   * your route leaves from Stop A, passes through stops B and C, and arrives at
   * stop D, stop_count will return 3.
   */
  stopCount: number;
  /**
   * The text that appears in schedules and sign boards to identify a transit
   * trip to passengers. The text should uniquely identify a trip within a
   * service day. For example, "538" is the `trip_short_text` of the Amtrak
   * train that leaves San Jose, CA at 15:10 on weekdays to Sacramento, CA.
   */
  tripShortText: string;
}

/** Details about the transit stops for the `RouteLegStep`. */
export interface RouteLegStepTransitDetails_TransitStopDetails {
  /** Information about the arrival stop for the step. */
  arrivalStop:
    | TransitStop
    | undefined;
  /** The estimated time of arrival for the step. */
  arrivalTime:
    | Date
    | undefined;
  /** Information about the departure stop for the step. */
  departureStop:
    | TransitStop
    | undefined;
  /** The estimated time of departure for the step. */
  departureTime: Date | undefined;
}

/** Localized descriptions of values for `RouteTransitDetails`. */
export interface RouteLegStepTransitDetails_TransitDetailsLocalizedValues {
  /** Time in its formatted text representation with a corresponding time zone. */
  arrivalTime:
    | LocalizedTime
    | undefined;
  /** Time in its formatted text representation with a corresponding time zone. */
  departureTime: LocalizedTime | undefined;
}

function createBaseRoute(): Route {
  return {
    routeLabels: [],
    legs: [],
    distanceMeters: 0,
    duration: undefined,
    staticDuration: undefined,
    polyline: undefined,
    description: "",
    warnings: [],
    viewport: undefined,
    travelAdvisory: undefined,
    optimizedIntermediateWaypointIndex: [],
    localizedValues: undefined,
    routeToken: "",
  };
}

export const Route: MessageFns<Route> = {
  encode(message: Route, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(106).fork();
    for (const v of message.routeLabels) {
      writer.int32(v);
    }
    writer.join();
    for (const v of message.legs) {
      RouteLeg.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.distanceMeters !== 0) {
      writer.uint32(16).int32(message.distanceMeters);
    }
    if (message.duration !== undefined) {
      Duration.encode(message.duration, writer.uint32(26).fork()).join();
    }
    if (message.staticDuration !== undefined) {
      Duration.encode(message.staticDuration, writer.uint32(34).fork()).join();
    }
    if (message.polyline !== undefined) {
      Polyline.encode(message.polyline, writer.uint32(42).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(50).string(message.description);
    }
    for (const v of message.warnings) {
      writer.uint32(58).string(v!);
    }
    if (message.viewport !== undefined) {
      Viewport.encode(message.viewport, writer.uint32(66).fork()).join();
    }
    if (message.travelAdvisory !== undefined) {
      RouteTravelAdvisory.encode(message.travelAdvisory, writer.uint32(74).fork()).join();
    }
    writer.uint32(82).fork();
    for (const v of message.optimizedIntermediateWaypointIndex) {
      writer.int32(v);
    }
    writer.join();
    if (message.localizedValues !== undefined) {
      Route_RouteLocalizedValues.encode(message.localizedValues, writer.uint32(90).fork()).join();
    }
    if (message.routeToken !== "") {
      writer.uint32(98).string(message.routeToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Route {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 13:
          if (tag === 104) {
            message.routeLabels.push(reader.int32() as any);

            continue;
          }

          if (tag === 106) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.routeLabels.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.legs.push(RouteLeg.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.distanceMeters = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.duration = Duration.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.staticDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.polyline = Polyline.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.warnings.push(reader.string());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.viewport = Viewport.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.travelAdvisory = RouteTravelAdvisory.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag === 80) {
            message.optimizedIntermediateWaypointIndex.push(reader.int32());

            continue;
          }

          if (tag === 82) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.optimizedIntermediateWaypointIndex.push(reader.int32());
            }

            continue;
          }

          break;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.localizedValues = Route_RouteLocalizedValues.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.routeToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Route {
    return {
      routeLabels: globalThis.Array.isArray(object?.routeLabels)
        ? object.routeLabels.map((e: any) => routeLabelFromJSON(e))
        : [],
      legs: globalThis.Array.isArray(object?.legs) ? object.legs.map((e: any) => RouteLeg.fromJSON(e)) : [],
      distanceMeters: isSet(object.distanceMeters) ? globalThis.Number(object.distanceMeters) : 0,
      duration: isSet(object.duration) ? Duration.fromJSON(object.duration) : undefined,
      staticDuration: isSet(object.staticDuration) ? Duration.fromJSON(object.staticDuration) : undefined,
      polyline: isSet(object.polyline) ? Polyline.fromJSON(object.polyline) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      warnings: globalThis.Array.isArray(object?.warnings) ? object.warnings.map((e: any) => globalThis.String(e)) : [],
      viewport: isSet(object.viewport) ? Viewport.fromJSON(object.viewport) : undefined,
      travelAdvisory: isSet(object.travelAdvisory) ? RouteTravelAdvisory.fromJSON(object.travelAdvisory) : undefined,
      optimizedIntermediateWaypointIndex: globalThis.Array.isArray(object?.optimizedIntermediateWaypointIndex)
        ? object.optimizedIntermediateWaypointIndex.map((e: any) => globalThis.Number(e))
        : [],
      localizedValues: isSet(object.localizedValues)
        ? Route_RouteLocalizedValues.fromJSON(object.localizedValues)
        : undefined,
      routeToken: isSet(object.routeToken) ? globalThis.String(object.routeToken) : "",
    };
  },

  toJSON(message: Route): unknown {
    const obj: any = {};
    if (message.routeLabels?.length) {
      obj.routeLabels = message.routeLabels.map((e) => routeLabelToJSON(e));
    }
    if (message.legs?.length) {
      obj.legs = message.legs.map((e) => RouteLeg.toJSON(e));
    }
    if (message.distanceMeters !== 0) {
      obj.distanceMeters = Math.round(message.distanceMeters);
    }
    if (message.duration !== undefined) {
      obj.duration = Duration.toJSON(message.duration);
    }
    if (message.staticDuration !== undefined) {
      obj.staticDuration = Duration.toJSON(message.staticDuration);
    }
    if (message.polyline !== undefined) {
      obj.polyline = Polyline.toJSON(message.polyline);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.warnings?.length) {
      obj.warnings = message.warnings;
    }
    if (message.viewport !== undefined) {
      obj.viewport = Viewport.toJSON(message.viewport);
    }
    if (message.travelAdvisory !== undefined) {
      obj.travelAdvisory = RouteTravelAdvisory.toJSON(message.travelAdvisory);
    }
    if (message.optimizedIntermediateWaypointIndex?.length) {
      obj.optimizedIntermediateWaypointIndex = message.optimizedIntermediateWaypointIndex.map((e) => Math.round(e));
    }
    if (message.localizedValues !== undefined) {
      obj.localizedValues = Route_RouteLocalizedValues.toJSON(message.localizedValues);
    }
    if (message.routeToken !== "") {
      obj.routeToken = message.routeToken;
    }
    return obj;
  },

  create(base?: DeepPartial<Route>): Route {
    return Route.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Route>): Route {
    const message = createBaseRoute();
    message.routeLabels = object.routeLabels?.map((e) => e) || [];
    message.legs = object.legs?.map((e) => RouteLeg.fromPartial(e)) || [];
    message.distanceMeters = object.distanceMeters ?? 0;
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? Duration.fromPartial(object.duration)
      : undefined;
    message.staticDuration = (object.staticDuration !== undefined && object.staticDuration !== null)
      ? Duration.fromPartial(object.staticDuration)
      : undefined;
    message.polyline = (object.polyline !== undefined && object.polyline !== null)
      ? Polyline.fromPartial(object.polyline)
      : undefined;
    message.description = object.description ?? "";
    message.warnings = object.warnings?.map((e) => e) || [];
    message.viewport = (object.viewport !== undefined && object.viewport !== null)
      ? Viewport.fromPartial(object.viewport)
      : undefined;
    message.travelAdvisory = (object.travelAdvisory !== undefined && object.travelAdvisory !== null)
      ? RouteTravelAdvisory.fromPartial(object.travelAdvisory)
      : undefined;
    message.optimizedIntermediateWaypointIndex = object.optimizedIntermediateWaypointIndex?.map((e) => e) || [];
    message.localizedValues = (object.localizedValues !== undefined && object.localizedValues !== null)
      ? Route_RouteLocalizedValues.fromPartial(object.localizedValues)
      : undefined;
    message.routeToken = object.routeToken ?? "";
    return message;
  },
};

function createBaseRoute_RouteLocalizedValues(): Route_RouteLocalizedValues {
  return { distance: undefined, duration: undefined, staticDuration: undefined, transitFare: undefined };
}

export const Route_RouteLocalizedValues: MessageFns<Route_RouteLocalizedValues> = {
  encode(message: Route_RouteLocalizedValues, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.distance !== undefined) {
      LocalizedText.encode(message.distance, writer.uint32(10).fork()).join();
    }
    if (message.duration !== undefined) {
      LocalizedText.encode(message.duration, writer.uint32(18).fork()).join();
    }
    if (message.staticDuration !== undefined) {
      LocalizedText.encode(message.staticDuration, writer.uint32(26).fork()).join();
    }
    if (message.transitFare !== undefined) {
      LocalizedText.encode(message.transitFare, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Route_RouteLocalizedValues {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoute_RouteLocalizedValues();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.distance = LocalizedText.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.duration = LocalizedText.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.staticDuration = LocalizedText.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.transitFare = LocalizedText.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Route_RouteLocalizedValues {
    return {
      distance: isSet(object.distance) ? LocalizedText.fromJSON(object.distance) : undefined,
      duration: isSet(object.duration) ? LocalizedText.fromJSON(object.duration) : undefined,
      staticDuration: isSet(object.staticDuration) ? LocalizedText.fromJSON(object.staticDuration) : undefined,
      transitFare: isSet(object.transitFare) ? LocalizedText.fromJSON(object.transitFare) : undefined,
    };
  },

  toJSON(message: Route_RouteLocalizedValues): unknown {
    const obj: any = {};
    if (message.distance !== undefined) {
      obj.distance = LocalizedText.toJSON(message.distance);
    }
    if (message.duration !== undefined) {
      obj.duration = LocalizedText.toJSON(message.duration);
    }
    if (message.staticDuration !== undefined) {
      obj.staticDuration = LocalizedText.toJSON(message.staticDuration);
    }
    if (message.transitFare !== undefined) {
      obj.transitFare = LocalizedText.toJSON(message.transitFare);
    }
    return obj;
  },

  create(base?: DeepPartial<Route_RouteLocalizedValues>): Route_RouteLocalizedValues {
    return Route_RouteLocalizedValues.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Route_RouteLocalizedValues>): Route_RouteLocalizedValues {
    const message = createBaseRoute_RouteLocalizedValues();
    message.distance = (object.distance !== undefined && object.distance !== null)
      ? LocalizedText.fromPartial(object.distance)
      : undefined;
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? LocalizedText.fromPartial(object.duration)
      : undefined;
    message.staticDuration = (object.staticDuration !== undefined && object.staticDuration !== null)
      ? LocalizedText.fromPartial(object.staticDuration)
      : undefined;
    message.transitFare = (object.transitFare !== undefined && object.transitFare !== null)
      ? LocalizedText.fromPartial(object.transitFare)
      : undefined;
    return message;
  },
};

function createBaseRouteTravelAdvisory(): RouteTravelAdvisory {
  return {
    tollInfo: undefined,
    speedReadingIntervals: [],
    fuelConsumptionMicroliters: Long.ZERO,
    routeRestrictionsPartiallyIgnored: false,
    transitFare: undefined,
  };
}

export const RouteTravelAdvisory: MessageFns<RouteTravelAdvisory> = {
  encode(message: RouteTravelAdvisory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tollInfo !== undefined) {
      TollInfo.encode(message.tollInfo, writer.uint32(18).fork()).join();
    }
    for (const v of message.speedReadingIntervals) {
      SpeedReadingInterval.encode(v!, writer.uint32(26).fork()).join();
    }
    if (!message.fuelConsumptionMicroliters.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.fuelConsumptionMicroliters.toString());
    }
    if (message.routeRestrictionsPartiallyIgnored !== false) {
      writer.uint32(48).bool(message.routeRestrictionsPartiallyIgnored);
    }
    if (message.transitFare !== undefined) {
      Money.encode(message.transitFare, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteTravelAdvisory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteTravelAdvisory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tollInfo = TollInfo.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.speedReadingIntervals.push(SpeedReadingInterval.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.fuelConsumptionMicroliters = Long.fromString(reader.int64().toString());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.routeRestrictionsPartiallyIgnored = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.transitFare = Money.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteTravelAdvisory {
    return {
      tollInfo: isSet(object.tollInfo) ? TollInfo.fromJSON(object.tollInfo) : undefined,
      speedReadingIntervals: globalThis.Array.isArray(object?.speedReadingIntervals)
        ? object.speedReadingIntervals.map((e: any) => SpeedReadingInterval.fromJSON(e))
        : [],
      fuelConsumptionMicroliters: isSet(object.fuelConsumptionMicroliters)
        ? Long.fromValue(object.fuelConsumptionMicroliters)
        : Long.ZERO,
      routeRestrictionsPartiallyIgnored: isSet(object.routeRestrictionsPartiallyIgnored)
        ? globalThis.Boolean(object.routeRestrictionsPartiallyIgnored)
        : false,
      transitFare: isSet(object.transitFare) ? Money.fromJSON(object.transitFare) : undefined,
    };
  },

  toJSON(message: RouteTravelAdvisory): unknown {
    const obj: any = {};
    if (message.tollInfo !== undefined) {
      obj.tollInfo = TollInfo.toJSON(message.tollInfo);
    }
    if (message.speedReadingIntervals?.length) {
      obj.speedReadingIntervals = message.speedReadingIntervals.map((e) => SpeedReadingInterval.toJSON(e));
    }
    if (!message.fuelConsumptionMicroliters.equals(Long.ZERO)) {
      obj.fuelConsumptionMicroliters = (message.fuelConsumptionMicroliters || Long.ZERO).toString();
    }
    if (message.routeRestrictionsPartiallyIgnored !== false) {
      obj.routeRestrictionsPartiallyIgnored = message.routeRestrictionsPartiallyIgnored;
    }
    if (message.transitFare !== undefined) {
      obj.transitFare = Money.toJSON(message.transitFare);
    }
    return obj;
  },

  create(base?: DeepPartial<RouteTravelAdvisory>): RouteTravelAdvisory {
    return RouteTravelAdvisory.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RouteTravelAdvisory>): RouteTravelAdvisory {
    const message = createBaseRouteTravelAdvisory();
    message.tollInfo = (object.tollInfo !== undefined && object.tollInfo !== null)
      ? TollInfo.fromPartial(object.tollInfo)
      : undefined;
    message.speedReadingIntervals = object.speedReadingIntervals?.map((e) => SpeedReadingInterval.fromPartial(e)) || [];
    message.fuelConsumptionMicroliters =
      (object.fuelConsumptionMicroliters !== undefined && object.fuelConsumptionMicroliters !== null)
        ? Long.fromValue(object.fuelConsumptionMicroliters)
        : Long.ZERO;
    message.routeRestrictionsPartiallyIgnored = object.routeRestrictionsPartiallyIgnored ?? false;
    message.transitFare = (object.transitFare !== undefined && object.transitFare !== null)
      ? Money.fromPartial(object.transitFare)
      : undefined;
    return message;
  },
};

function createBaseRouteLegTravelAdvisory(): RouteLegTravelAdvisory {
  return { tollInfo: undefined, speedReadingIntervals: [] };
}

export const RouteLegTravelAdvisory: MessageFns<RouteLegTravelAdvisory> = {
  encode(message: RouteLegTravelAdvisory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tollInfo !== undefined) {
      TollInfo.encode(message.tollInfo, writer.uint32(10).fork()).join();
    }
    for (const v of message.speedReadingIntervals) {
      SpeedReadingInterval.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteLegTravelAdvisory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteLegTravelAdvisory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tollInfo = TollInfo.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.speedReadingIntervals.push(SpeedReadingInterval.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteLegTravelAdvisory {
    return {
      tollInfo: isSet(object.tollInfo) ? TollInfo.fromJSON(object.tollInfo) : undefined,
      speedReadingIntervals: globalThis.Array.isArray(object?.speedReadingIntervals)
        ? object.speedReadingIntervals.map((e: any) => SpeedReadingInterval.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RouteLegTravelAdvisory): unknown {
    const obj: any = {};
    if (message.tollInfo !== undefined) {
      obj.tollInfo = TollInfo.toJSON(message.tollInfo);
    }
    if (message.speedReadingIntervals?.length) {
      obj.speedReadingIntervals = message.speedReadingIntervals.map((e) => SpeedReadingInterval.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RouteLegTravelAdvisory>): RouteLegTravelAdvisory {
    return RouteLegTravelAdvisory.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RouteLegTravelAdvisory>): RouteLegTravelAdvisory {
    const message = createBaseRouteLegTravelAdvisory();
    message.tollInfo = (object.tollInfo !== undefined && object.tollInfo !== null)
      ? TollInfo.fromPartial(object.tollInfo)
      : undefined;
    message.speedReadingIntervals = object.speedReadingIntervals?.map((e) => SpeedReadingInterval.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRouteLegStepTravelAdvisory(): RouteLegStepTravelAdvisory {
  return { speedReadingIntervals: [] };
}

export const RouteLegStepTravelAdvisory: MessageFns<RouteLegStepTravelAdvisory> = {
  encode(message: RouteLegStepTravelAdvisory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.speedReadingIntervals) {
      SpeedReadingInterval.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteLegStepTravelAdvisory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteLegStepTravelAdvisory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.speedReadingIntervals.push(SpeedReadingInterval.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteLegStepTravelAdvisory {
    return {
      speedReadingIntervals: globalThis.Array.isArray(object?.speedReadingIntervals)
        ? object.speedReadingIntervals.map((e: any) => SpeedReadingInterval.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RouteLegStepTravelAdvisory): unknown {
    const obj: any = {};
    if (message.speedReadingIntervals?.length) {
      obj.speedReadingIntervals = message.speedReadingIntervals.map((e) => SpeedReadingInterval.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RouteLegStepTravelAdvisory>): RouteLegStepTravelAdvisory {
    return RouteLegStepTravelAdvisory.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RouteLegStepTravelAdvisory>): RouteLegStepTravelAdvisory {
    const message = createBaseRouteLegStepTravelAdvisory();
    message.speedReadingIntervals = object.speedReadingIntervals?.map((e) => SpeedReadingInterval.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRouteLeg(): RouteLeg {
  return {
    distanceMeters: 0,
    duration: undefined,
    staticDuration: undefined,
    polyline: undefined,
    startLocation: undefined,
    endLocation: undefined,
    steps: [],
    travelAdvisory: undefined,
    localizedValues: undefined,
    stepsOverview: undefined,
  };
}

export const RouteLeg: MessageFns<RouteLeg> = {
  encode(message: RouteLeg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.distanceMeters !== 0) {
      writer.uint32(8).int32(message.distanceMeters);
    }
    if (message.duration !== undefined) {
      Duration.encode(message.duration, writer.uint32(18).fork()).join();
    }
    if (message.staticDuration !== undefined) {
      Duration.encode(message.staticDuration, writer.uint32(26).fork()).join();
    }
    if (message.polyline !== undefined) {
      Polyline.encode(message.polyline, writer.uint32(34).fork()).join();
    }
    if (message.startLocation !== undefined) {
      Location.encode(message.startLocation, writer.uint32(42).fork()).join();
    }
    if (message.endLocation !== undefined) {
      Location.encode(message.endLocation, writer.uint32(50).fork()).join();
    }
    for (const v of message.steps) {
      RouteLegStep.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.travelAdvisory !== undefined) {
      RouteLegTravelAdvisory.encode(message.travelAdvisory, writer.uint32(66).fork()).join();
    }
    if (message.localizedValues !== undefined) {
      RouteLeg_RouteLegLocalizedValues.encode(message.localizedValues, writer.uint32(74).fork()).join();
    }
    if (message.stepsOverview !== undefined) {
      RouteLeg_StepsOverview.encode(message.stepsOverview, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteLeg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteLeg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.distanceMeters = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.duration = Duration.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.staticDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.polyline = Polyline.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.startLocation = Location.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.endLocation = Location.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.steps.push(RouteLegStep.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.travelAdvisory = RouteLegTravelAdvisory.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.localizedValues = RouteLeg_RouteLegLocalizedValues.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.stepsOverview = RouteLeg_StepsOverview.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteLeg {
    return {
      distanceMeters: isSet(object.distanceMeters) ? globalThis.Number(object.distanceMeters) : 0,
      duration: isSet(object.duration) ? Duration.fromJSON(object.duration) : undefined,
      staticDuration: isSet(object.staticDuration) ? Duration.fromJSON(object.staticDuration) : undefined,
      polyline: isSet(object.polyline) ? Polyline.fromJSON(object.polyline) : undefined,
      startLocation: isSet(object.startLocation) ? Location.fromJSON(object.startLocation) : undefined,
      endLocation: isSet(object.endLocation) ? Location.fromJSON(object.endLocation) : undefined,
      steps: globalThis.Array.isArray(object?.steps) ? object.steps.map((e: any) => RouteLegStep.fromJSON(e)) : [],
      travelAdvisory: isSet(object.travelAdvisory) ? RouteLegTravelAdvisory.fromJSON(object.travelAdvisory) : undefined,
      localizedValues: isSet(object.localizedValues)
        ? RouteLeg_RouteLegLocalizedValues.fromJSON(object.localizedValues)
        : undefined,
      stepsOverview: isSet(object.stepsOverview) ? RouteLeg_StepsOverview.fromJSON(object.stepsOverview) : undefined,
    };
  },

  toJSON(message: RouteLeg): unknown {
    const obj: any = {};
    if (message.distanceMeters !== 0) {
      obj.distanceMeters = Math.round(message.distanceMeters);
    }
    if (message.duration !== undefined) {
      obj.duration = Duration.toJSON(message.duration);
    }
    if (message.staticDuration !== undefined) {
      obj.staticDuration = Duration.toJSON(message.staticDuration);
    }
    if (message.polyline !== undefined) {
      obj.polyline = Polyline.toJSON(message.polyline);
    }
    if (message.startLocation !== undefined) {
      obj.startLocation = Location.toJSON(message.startLocation);
    }
    if (message.endLocation !== undefined) {
      obj.endLocation = Location.toJSON(message.endLocation);
    }
    if (message.steps?.length) {
      obj.steps = message.steps.map((e) => RouteLegStep.toJSON(e));
    }
    if (message.travelAdvisory !== undefined) {
      obj.travelAdvisory = RouteLegTravelAdvisory.toJSON(message.travelAdvisory);
    }
    if (message.localizedValues !== undefined) {
      obj.localizedValues = RouteLeg_RouteLegLocalizedValues.toJSON(message.localizedValues);
    }
    if (message.stepsOverview !== undefined) {
      obj.stepsOverview = RouteLeg_StepsOverview.toJSON(message.stepsOverview);
    }
    return obj;
  },

  create(base?: DeepPartial<RouteLeg>): RouteLeg {
    return RouteLeg.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RouteLeg>): RouteLeg {
    const message = createBaseRouteLeg();
    message.distanceMeters = object.distanceMeters ?? 0;
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? Duration.fromPartial(object.duration)
      : undefined;
    message.staticDuration = (object.staticDuration !== undefined && object.staticDuration !== null)
      ? Duration.fromPartial(object.staticDuration)
      : undefined;
    message.polyline = (object.polyline !== undefined && object.polyline !== null)
      ? Polyline.fromPartial(object.polyline)
      : undefined;
    message.startLocation = (object.startLocation !== undefined && object.startLocation !== null)
      ? Location.fromPartial(object.startLocation)
      : undefined;
    message.endLocation = (object.endLocation !== undefined && object.endLocation !== null)
      ? Location.fromPartial(object.endLocation)
      : undefined;
    message.steps = object.steps?.map((e) => RouteLegStep.fromPartial(e)) || [];
    message.travelAdvisory = (object.travelAdvisory !== undefined && object.travelAdvisory !== null)
      ? RouteLegTravelAdvisory.fromPartial(object.travelAdvisory)
      : undefined;
    message.localizedValues = (object.localizedValues !== undefined && object.localizedValues !== null)
      ? RouteLeg_RouteLegLocalizedValues.fromPartial(object.localizedValues)
      : undefined;
    message.stepsOverview = (object.stepsOverview !== undefined && object.stepsOverview !== null)
      ? RouteLeg_StepsOverview.fromPartial(object.stepsOverview)
      : undefined;
    return message;
  },
};

function createBaseRouteLeg_RouteLegLocalizedValues(): RouteLeg_RouteLegLocalizedValues {
  return { distance: undefined, duration: undefined, staticDuration: undefined };
}

export const RouteLeg_RouteLegLocalizedValues: MessageFns<RouteLeg_RouteLegLocalizedValues> = {
  encode(message: RouteLeg_RouteLegLocalizedValues, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.distance !== undefined) {
      LocalizedText.encode(message.distance, writer.uint32(10).fork()).join();
    }
    if (message.duration !== undefined) {
      LocalizedText.encode(message.duration, writer.uint32(18).fork()).join();
    }
    if (message.staticDuration !== undefined) {
      LocalizedText.encode(message.staticDuration, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteLeg_RouteLegLocalizedValues {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteLeg_RouteLegLocalizedValues();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.distance = LocalizedText.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.duration = LocalizedText.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.staticDuration = LocalizedText.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteLeg_RouteLegLocalizedValues {
    return {
      distance: isSet(object.distance) ? LocalizedText.fromJSON(object.distance) : undefined,
      duration: isSet(object.duration) ? LocalizedText.fromJSON(object.duration) : undefined,
      staticDuration: isSet(object.staticDuration) ? LocalizedText.fromJSON(object.staticDuration) : undefined,
    };
  },

  toJSON(message: RouteLeg_RouteLegLocalizedValues): unknown {
    const obj: any = {};
    if (message.distance !== undefined) {
      obj.distance = LocalizedText.toJSON(message.distance);
    }
    if (message.duration !== undefined) {
      obj.duration = LocalizedText.toJSON(message.duration);
    }
    if (message.staticDuration !== undefined) {
      obj.staticDuration = LocalizedText.toJSON(message.staticDuration);
    }
    return obj;
  },

  create(base?: DeepPartial<RouteLeg_RouteLegLocalizedValues>): RouteLeg_RouteLegLocalizedValues {
    return RouteLeg_RouteLegLocalizedValues.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RouteLeg_RouteLegLocalizedValues>): RouteLeg_RouteLegLocalizedValues {
    const message = createBaseRouteLeg_RouteLegLocalizedValues();
    message.distance = (object.distance !== undefined && object.distance !== null)
      ? LocalizedText.fromPartial(object.distance)
      : undefined;
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? LocalizedText.fromPartial(object.duration)
      : undefined;
    message.staticDuration = (object.staticDuration !== undefined && object.staticDuration !== null)
      ? LocalizedText.fromPartial(object.staticDuration)
      : undefined;
    return message;
  },
};

function createBaseRouteLeg_StepsOverview(): RouteLeg_StepsOverview {
  return { multiModalSegments: [] };
}

export const RouteLeg_StepsOverview: MessageFns<RouteLeg_StepsOverview> = {
  encode(message: RouteLeg_StepsOverview, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.multiModalSegments) {
      RouteLeg_StepsOverview_MultiModalSegment.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteLeg_StepsOverview {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteLeg_StepsOverview();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.multiModalSegments.push(RouteLeg_StepsOverview_MultiModalSegment.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteLeg_StepsOverview {
    return {
      multiModalSegments: globalThis.Array.isArray(object?.multiModalSegments)
        ? object.multiModalSegments.map((e: any) => RouteLeg_StepsOverview_MultiModalSegment.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RouteLeg_StepsOverview): unknown {
    const obj: any = {};
    if (message.multiModalSegments?.length) {
      obj.multiModalSegments = message.multiModalSegments.map((e) =>
        RouteLeg_StepsOverview_MultiModalSegment.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<RouteLeg_StepsOverview>): RouteLeg_StepsOverview {
    return RouteLeg_StepsOverview.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RouteLeg_StepsOverview>): RouteLeg_StepsOverview {
    const message = createBaseRouteLeg_StepsOverview();
    message.multiModalSegments =
      object.multiModalSegments?.map((e) => RouteLeg_StepsOverview_MultiModalSegment.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRouteLeg_StepsOverview_MultiModalSegment(): RouteLeg_StepsOverview_MultiModalSegment {
  return { stepStartIndex: undefined, stepEndIndex: undefined, navigationInstruction: undefined, travelMode: 0 };
}

export const RouteLeg_StepsOverview_MultiModalSegment: MessageFns<RouteLeg_StepsOverview_MultiModalSegment> = {
  encode(message: RouteLeg_StepsOverview_MultiModalSegment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stepStartIndex !== undefined) {
      writer.uint32(8).int32(message.stepStartIndex);
    }
    if (message.stepEndIndex !== undefined) {
      writer.uint32(16).int32(message.stepEndIndex);
    }
    if (message.navigationInstruction !== undefined) {
      NavigationInstruction.encode(message.navigationInstruction, writer.uint32(26).fork()).join();
    }
    if (message.travelMode !== 0) {
      writer.uint32(32).int32(message.travelMode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteLeg_StepsOverview_MultiModalSegment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteLeg_StepsOverview_MultiModalSegment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.stepStartIndex = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.stepEndIndex = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.navigationInstruction = NavigationInstruction.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.travelMode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteLeg_StepsOverview_MultiModalSegment {
    return {
      stepStartIndex: isSet(object.stepStartIndex) ? globalThis.Number(object.stepStartIndex) : undefined,
      stepEndIndex: isSet(object.stepEndIndex) ? globalThis.Number(object.stepEndIndex) : undefined,
      navigationInstruction: isSet(object.navigationInstruction)
        ? NavigationInstruction.fromJSON(object.navigationInstruction)
        : undefined,
      travelMode: isSet(object.travelMode) ? routeTravelModeFromJSON(object.travelMode) : 0,
    };
  },

  toJSON(message: RouteLeg_StepsOverview_MultiModalSegment): unknown {
    const obj: any = {};
    if (message.stepStartIndex !== undefined) {
      obj.stepStartIndex = Math.round(message.stepStartIndex);
    }
    if (message.stepEndIndex !== undefined) {
      obj.stepEndIndex = Math.round(message.stepEndIndex);
    }
    if (message.navigationInstruction !== undefined) {
      obj.navigationInstruction = NavigationInstruction.toJSON(message.navigationInstruction);
    }
    if (message.travelMode !== 0) {
      obj.travelMode = routeTravelModeToJSON(message.travelMode);
    }
    return obj;
  },

  create(base?: DeepPartial<RouteLeg_StepsOverview_MultiModalSegment>): RouteLeg_StepsOverview_MultiModalSegment {
    return RouteLeg_StepsOverview_MultiModalSegment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RouteLeg_StepsOverview_MultiModalSegment>): RouteLeg_StepsOverview_MultiModalSegment {
    const message = createBaseRouteLeg_StepsOverview_MultiModalSegment();
    message.stepStartIndex = object.stepStartIndex ?? undefined;
    message.stepEndIndex = object.stepEndIndex ?? undefined;
    message.navigationInstruction =
      (object.navigationInstruction !== undefined && object.navigationInstruction !== null)
        ? NavigationInstruction.fromPartial(object.navigationInstruction)
        : undefined;
    message.travelMode = object.travelMode ?? 0;
    return message;
  },
};

function createBaseRouteLegStep(): RouteLegStep {
  return {
    distanceMeters: 0,
    staticDuration: undefined,
    polyline: undefined,
    startLocation: undefined,
    endLocation: undefined,
    navigationInstruction: undefined,
    travelAdvisory: undefined,
    localizedValues: undefined,
    transitDetails: undefined,
    travelMode: 0,
  };
}

export const RouteLegStep: MessageFns<RouteLegStep> = {
  encode(message: RouteLegStep, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.distanceMeters !== 0) {
      writer.uint32(8).int32(message.distanceMeters);
    }
    if (message.staticDuration !== undefined) {
      Duration.encode(message.staticDuration, writer.uint32(18).fork()).join();
    }
    if (message.polyline !== undefined) {
      Polyline.encode(message.polyline, writer.uint32(26).fork()).join();
    }
    if (message.startLocation !== undefined) {
      Location.encode(message.startLocation, writer.uint32(34).fork()).join();
    }
    if (message.endLocation !== undefined) {
      Location.encode(message.endLocation, writer.uint32(42).fork()).join();
    }
    if (message.navigationInstruction !== undefined) {
      NavigationInstruction.encode(message.navigationInstruction, writer.uint32(50).fork()).join();
    }
    if (message.travelAdvisory !== undefined) {
      RouteLegStepTravelAdvisory.encode(message.travelAdvisory, writer.uint32(58).fork()).join();
    }
    if (message.localizedValues !== undefined) {
      RouteLegStep_RouteLegStepLocalizedValues.encode(message.localizedValues, writer.uint32(66).fork()).join();
    }
    if (message.transitDetails !== undefined) {
      RouteLegStepTransitDetails.encode(message.transitDetails, writer.uint32(74).fork()).join();
    }
    if (message.travelMode !== 0) {
      writer.uint32(80).int32(message.travelMode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteLegStep {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteLegStep();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.distanceMeters = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.staticDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.polyline = Polyline.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.startLocation = Location.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.endLocation = Location.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.navigationInstruction = NavigationInstruction.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.travelAdvisory = RouteLegStepTravelAdvisory.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.localizedValues = RouteLegStep_RouteLegStepLocalizedValues.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.transitDetails = RouteLegStepTransitDetails.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.travelMode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteLegStep {
    return {
      distanceMeters: isSet(object.distanceMeters) ? globalThis.Number(object.distanceMeters) : 0,
      staticDuration: isSet(object.staticDuration) ? Duration.fromJSON(object.staticDuration) : undefined,
      polyline: isSet(object.polyline) ? Polyline.fromJSON(object.polyline) : undefined,
      startLocation: isSet(object.startLocation) ? Location.fromJSON(object.startLocation) : undefined,
      endLocation: isSet(object.endLocation) ? Location.fromJSON(object.endLocation) : undefined,
      navigationInstruction: isSet(object.navigationInstruction)
        ? NavigationInstruction.fromJSON(object.navigationInstruction)
        : undefined,
      travelAdvisory: isSet(object.travelAdvisory)
        ? RouteLegStepTravelAdvisory.fromJSON(object.travelAdvisory)
        : undefined,
      localizedValues: isSet(object.localizedValues)
        ? RouteLegStep_RouteLegStepLocalizedValues.fromJSON(object.localizedValues)
        : undefined,
      transitDetails: isSet(object.transitDetails)
        ? RouteLegStepTransitDetails.fromJSON(object.transitDetails)
        : undefined,
      travelMode: isSet(object.travelMode) ? routeTravelModeFromJSON(object.travelMode) : 0,
    };
  },

  toJSON(message: RouteLegStep): unknown {
    const obj: any = {};
    if (message.distanceMeters !== 0) {
      obj.distanceMeters = Math.round(message.distanceMeters);
    }
    if (message.staticDuration !== undefined) {
      obj.staticDuration = Duration.toJSON(message.staticDuration);
    }
    if (message.polyline !== undefined) {
      obj.polyline = Polyline.toJSON(message.polyline);
    }
    if (message.startLocation !== undefined) {
      obj.startLocation = Location.toJSON(message.startLocation);
    }
    if (message.endLocation !== undefined) {
      obj.endLocation = Location.toJSON(message.endLocation);
    }
    if (message.navigationInstruction !== undefined) {
      obj.navigationInstruction = NavigationInstruction.toJSON(message.navigationInstruction);
    }
    if (message.travelAdvisory !== undefined) {
      obj.travelAdvisory = RouteLegStepTravelAdvisory.toJSON(message.travelAdvisory);
    }
    if (message.localizedValues !== undefined) {
      obj.localizedValues = RouteLegStep_RouteLegStepLocalizedValues.toJSON(message.localizedValues);
    }
    if (message.transitDetails !== undefined) {
      obj.transitDetails = RouteLegStepTransitDetails.toJSON(message.transitDetails);
    }
    if (message.travelMode !== 0) {
      obj.travelMode = routeTravelModeToJSON(message.travelMode);
    }
    return obj;
  },

  create(base?: DeepPartial<RouteLegStep>): RouteLegStep {
    return RouteLegStep.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RouteLegStep>): RouteLegStep {
    const message = createBaseRouteLegStep();
    message.distanceMeters = object.distanceMeters ?? 0;
    message.staticDuration = (object.staticDuration !== undefined && object.staticDuration !== null)
      ? Duration.fromPartial(object.staticDuration)
      : undefined;
    message.polyline = (object.polyline !== undefined && object.polyline !== null)
      ? Polyline.fromPartial(object.polyline)
      : undefined;
    message.startLocation = (object.startLocation !== undefined && object.startLocation !== null)
      ? Location.fromPartial(object.startLocation)
      : undefined;
    message.endLocation = (object.endLocation !== undefined && object.endLocation !== null)
      ? Location.fromPartial(object.endLocation)
      : undefined;
    message.navigationInstruction =
      (object.navigationInstruction !== undefined && object.navigationInstruction !== null)
        ? NavigationInstruction.fromPartial(object.navigationInstruction)
        : undefined;
    message.travelAdvisory = (object.travelAdvisory !== undefined && object.travelAdvisory !== null)
      ? RouteLegStepTravelAdvisory.fromPartial(object.travelAdvisory)
      : undefined;
    message.localizedValues = (object.localizedValues !== undefined && object.localizedValues !== null)
      ? RouteLegStep_RouteLegStepLocalizedValues.fromPartial(object.localizedValues)
      : undefined;
    message.transitDetails = (object.transitDetails !== undefined && object.transitDetails !== null)
      ? RouteLegStepTransitDetails.fromPartial(object.transitDetails)
      : undefined;
    message.travelMode = object.travelMode ?? 0;
    return message;
  },
};

function createBaseRouteLegStep_RouteLegStepLocalizedValues(): RouteLegStep_RouteLegStepLocalizedValues {
  return { distance: undefined, staticDuration: undefined };
}

export const RouteLegStep_RouteLegStepLocalizedValues: MessageFns<RouteLegStep_RouteLegStepLocalizedValues> = {
  encode(message: RouteLegStep_RouteLegStepLocalizedValues, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.distance !== undefined) {
      LocalizedText.encode(message.distance, writer.uint32(10).fork()).join();
    }
    if (message.staticDuration !== undefined) {
      LocalizedText.encode(message.staticDuration, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteLegStep_RouteLegStepLocalizedValues {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteLegStep_RouteLegStepLocalizedValues();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.distance = LocalizedText.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.staticDuration = LocalizedText.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteLegStep_RouteLegStepLocalizedValues {
    return {
      distance: isSet(object.distance) ? LocalizedText.fromJSON(object.distance) : undefined,
      staticDuration: isSet(object.staticDuration) ? LocalizedText.fromJSON(object.staticDuration) : undefined,
    };
  },

  toJSON(message: RouteLegStep_RouteLegStepLocalizedValues): unknown {
    const obj: any = {};
    if (message.distance !== undefined) {
      obj.distance = LocalizedText.toJSON(message.distance);
    }
    if (message.staticDuration !== undefined) {
      obj.staticDuration = LocalizedText.toJSON(message.staticDuration);
    }
    return obj;
  },

  create(base?: DeepPartial<RouteLegStep_RouteLegStepLocalizedValues>): RouteLegStep_RouteLegStepLocalizedValues {
    return RouteLegStep_RouteLegStepLocalizedValues.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RouteLegStep_RouteLegStepLocalizedValues>): RouteLegStep_RouteLegStepLocalizedValues {
    const message = createBaseRouteLegStep_RouteLegStepLocalizedValues();
    message.distance = (object.distance !== undefined && object.distance !== null)
      ? LocalizedText.fromPartial(object.distance)
      : undefined;
    message.staticDuration = (object.staticDuration !== undefined && object.staticDuration !== null)
      ? LocalizedText.fromPartial(object.staticDuration)
      : undefined;
    return message;
  },
};

function createBaseRouteLegStepTransitDetails(): RouteLegStepTransitDetails {
  return {
    stopDetails: undefined,
    localizedValues: undefined,
    headsign: "",
    headway: undefined,
    transitLine: undefined,
    stopCount: 0,
    tripShortText: "",
  };
}

export const RouteLegStepTransitDetails: MessageFns<RouteLegStepTransitDetails> = {
  encode(message: RouteLegStepTransitDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stopDetails !== undefined) {
      RouteLegStepTransitDetails_TransitStopDetails.encode(message.stopDetails, writer.uint32(10).fork()).join();
    }
    if (message.localizedValues !== undefined) {
      RouteLegStepTransitDetails_TransitDetailsLocalizedValues.encode(message.localizedValues, writer.uint32(18).fork())
        .join();
    }
    if (message.headsign !== "") {
      writer.uint32(26).string(message.headsign);
    }
    if (message.headway !== undefined) {
      Duration.encode(message.headway, writer.uint32(34).fork()).join();
    }
    if (message.transitLine !== undefined) {
      TransitLine.encode(message.transitLine, writer.uint32(42).fork()).join();
    }
    if (message.stopCount !== 0) {
      writer.uint32(48).int32(message.stopCount);
    }
    if (message.tripShortText !== "") {
      writer.uint32(58).string(message.tripShortText);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteLegStepTransitDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteLegStepTransitDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.stopDetails = RouteLegStepTransitDetails_TransitStopDetails.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.localizedValues = RouteLegStepTransitDetails_TransitDetailsLocalizedValues.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.headsign = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.headway = Duration.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.transitLine = TransitLine.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.stopCount = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.tripShortText = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteLegStepTransitDetails {
    return {
      stopDetails: isSet(object.stopDetails)
        ? RouteLegStepTransitDetails_TransitStopDetails.fromJSON(object.stopDetails)
        : undefined,
      localizedValues: isSet(object.localizedValues)
        ? RouteLegStepTransitDetails_TransitDetailsLocalizedValues.fromJSON(object.localizedValues)
        : undefined,
      headsign: isSet(object.headsign) ? globalThis.String(object.headsign) : "",
      headway: isSet(object.headway) ? Duration.fromJSON(object.headway) : undefined,
      transitLine: isSet(object.transitLine) ? TransitLine.fromJSON(object.transitLine) : undefined,
      stopCount: isSet(object.stopCount) ? globalThis.Number(object.stopCount) : 0,
      tripShortText: isSet(object.tripShortText) ? globalThis.String(object.tripShortText) : "",
    };
  },

  toJSON(message: RouteLegStepTransitDetails): unknown {
    const obj: any = {};
    if (message.stopDetails !== undefined) {
      obj.stopDetails = RouteLegStepTransitDetails_TransitStopDetails.toJSON(message.stopDetails);
    }
    if (message.localizedValues !== undefined) {
      obj.localizedValues = RouteLegStepTransitDetails_TransitDetailsLocalizedValues.toJSON(message.localizedValues);
    }
    if (message.headsign !== "") {
      obj.headsign = message.headsign;
    }
    if (message.headway !== undefined) {
      obj.headway = Duration.toJSON(message.headway);
    }
    if (message.transitLine !== undefined) {
      obj.transitLine = TransitLine.toJSON(message.transitLine);
    }
    if (message.stopCount !== 0) {
      obj.stopCount = Math.round(message.stopCount);
    }
    if (message.tripShortText !== "") {
      obj.tripShortText = message.tripShortText;
    }
    return obj;
  },

  create(base?: DeepPartial<RouteLegStepTransitDetails>): RouteLegStepTransitDetails {
    return RouteLegStepTransitDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RouteLegStepTransitDetails>): RouteLegStepTransitDetails {
    const message = createBaseRouteLegStepTransitDetails();
    message.stopDetails = (object.stopDetails !== undefined && object.stopDetails !== null)
      ? RouteLegStepTransitDetails_TransitStopDetails.fromPartial(object.stopDetails)
      : undefined;
    message.localizedValues = (object.localizedValues !== undefined && object.localizedValues !== null)
      ? RouteLegStepTransitDetails_TransitDetailsLocalizedValues.fromPartial(object.localizedValues)
      : undefined;
    message.headsign = object.headsign ?? "";
    message.headway = (object.headway !== undefined && object.headway !== null)
      ? Duration.fromPartial(object.headway)
      : undefined;
    message.transitLine = (object.transitLine !== undefined && object.transitLine !== null)
      ? TransitLine.fromPartial(object.transitLine)
      : undefined;
    message.stopCount = object.stopCount ?? 0;
    message.tripShortText = object.tripShortText ?? "";
    return message;
  },
};

function createBaseRouteLegStepTransitDetails_TransitStopDetails(): RouteLegStepTransitDetails_TransitStopDetails {
  return { arrivalStop: undefined, arrivalTime: undefined, departureStop: undefined, departureTime: undefined };
}

export const RouteLegStepTransitDetails_TransitStopDetails: MessageFns<RouteLegStepTransitDetails_TransitStopDetails> =
  {
    encode(
      message: RouteLegStepTransitDetails_TransitStopDetails,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.arrivalStop !== undefined) {
        TransitStop.encode(message.arrivalStop, writer.uint32(10).fork()).join();
      }
      if (message.arrivalTime !== undefined) {
        Timestamp.encode(toTimestamp(message.arrivalTime), writer.uint32(18).fork()).join();
      }
      if (message.departureStop !== undefined) {
        TransitStop.encode(message.departureStop, writer.uint32(26).fork()).join();
      }
      if (message.departureTime !== undefined) {
        Timestamp.encode(toTimestamp(message.departureTime), writer.uint32(34).fork()).join();
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): RouteLegStepTransitDetails_TransitStopDetails {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseRouteLegStepTransitDetails_TransitStopDetails();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.arrivalStop = TransitStop.decode(reader, reader.uint32());
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.arrivalTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
            continue;
          case 3:
            if (tag !== 26) {
              break;
            }

            message.departureStop = TransitStop.decode(reader, reader.uint32());
            continue;
          case 4:
            if (tag !== 34) {
              break;
            }

            message.departureTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): RouteLegStepTransitDetails_TransitStopDetails {
      return {
        arrivalStop: isSet(object.arrivalStop) ? TransitStop.fromJSON(object.arrivalStop) : undefined,
        arrivalTime: isSet(object.arrivalTime) ? fromJsonTimestamp(object.arrivalTime) : undefined,
        departureStop: isSet(object.departureStop) ? TransitStop.fromJSON(object.departureStop) : undefined,
        departureTime: isSet(object.departureTime) ? fromJsonTimestamp(object.departureTime) : undefined,
      };
    },

    toJSON(message: RouteLegStepTransitDetails_TransitStopDetails): unknown {
      const obj: any = {};
      if (message.arrivalStop !== undefined) {
        obj.arrivalStop = TransitStop.toJSON(message.arrivalStop);
      }
      if (message.arrivalTime !== undefined) {
        obj.arrivalTime = message.arrivalTime.toISOString();
      }
      if (message.departureStop !== undefined) {
        obj.departureStop = TransitStop.toJSON(message.departureStop);
      }
      if (message.departureTime !== undefined) {
        obj.departureTime = message.departureTime.toISOString();
      }
      return obj;
    },

    create(
      base?: DeepPartial<RouteLegStepTransitDetails_TransitStopDetails>,
    ): RouteLegStepTransitDetails_TransitStopDetails {
      return RouteLegStepTransitDetails_TransitStopDetails.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<RouteLegStepTransitDetails_TransitStopDetails>,
    ): RouteLegStepTransitDetails_TransitStopDetails {
      const message = createBaseRouteLegStepTransitDetails_TransitStopDetails();
      message.arrivalStop = (object.arrivalStop !== undefined && object.arrivalStop !== null)
        ? TransitStop.fromPartial(object.arrivalStop)
        : undefined;
      message.arrivalTime = object.arrivalTime ?? undefined;
      message.departureStop = (object.departureStop !== undefined && object.departureStop !== null)
        ? TransitStop.fromPartial(object.departureStop)
        : undefined;
      message.departureTime = object.departureTime ?? undefined;
      return message;
    },
  };

function createBaseRouteLegStepTransitDetails_TransitDetailsLocalizedValues(): RouteLegStepTransitDetails_TransitDetailsLocalizedValues {
  return { arrivalTime: undefined, departureTime: undefined };
}

export const RouteLegStepTransitDetails_TransitDetailsLocalizedValues: MessageFns<
  RouteLegStepTransitDetails_TransitDetailsLocalizedValues
> = {
  encode(
    message: RouteLegStepTransitDetails_TransitDetailsLocalizedValues,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.arrivalTime !== undefined) {
      LocalizedTime.encode(message.arrivalTime, writer.uint32(10).fork()).join();
    }
    if (message.departureTime !== undefined) {
      LocalizedTime.encode(message.departureTime, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteLegStepTransitDetails_TransitDetailsLocalizedValues {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteLegStepTransitDetails_TransitDetailsLocalizedValues();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.arrivalTime = LocalizedTime.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.departureTime = LocalizedTime.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteLegStepTransitDetails_TransitDetailsLocalizedValues {
    return {
      arrivalTime: isSet(object.arrivalTime) ? LocalizedTime.fromJSON(object.arrivalTime) : undefined,
      departureTime: isSet(object.departureTime) ? LocalizedTime.fromJSON(object.departureTime) : undefined,
    };
  },

  toJSON(message: RouteLegStepTransitDetails_TransitDetailsLocalizedValues): unknown {
    const obj: any = {};
    if (message.arrivalTime !== undefined) {
      obj.arrivalTime = LocalizedTime.toJSON(message.arrivalTime);
    }
    if (message.departureTime !== undefined) {
      obj.departureTime = LocalizedTime.toJSON(message.departureTime);
    }
    return obj;
  },

  create(
    base?: DeepPartial<RouteLegStepTransitDetails_TransitDetailsLocalizedValues>,
  ): RouteLegStepTransitDetails_TransitDetailsLocalizedValues {
    return RouteLegStepTransitDetails_TransitDetailsLocalizedValues.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<RouteLegStepTransitDetails_TransitDetailsLocalizedValues>,
  ): RouteLegStepTransitDetails_TransitDetailsLocalizedValues {
    const message = createBaseRouteLegStepTransitDetails_TransitDetailsLocalizedValues();
    message.arrivalTime = (object.arrivalTime !== undefined && object.arrivalTime !== null)
      ? LocalizedTime.fromPartial(object.arrivalTime)
      : undefined;
    message.departureTime = (object.departureTime !== undefined && object.departureTime !== null)
      ? LocalizedTime.fromPartial(object.departureTime)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
