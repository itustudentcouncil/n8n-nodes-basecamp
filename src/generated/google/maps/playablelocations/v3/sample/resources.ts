// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/maps/playablelocations/v3/sample/resources.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { FieldMask } from "../../../../protobuf/field_mask.js";
import { LatLng } from "../../../../type/latlng.js";

export const protobufPackage = "google.maps.playablelocations.v3.sample";

/**
 * A geographical point suitable for placing game objects in location-based
 * games.
 */
export interface PlayableLocation {
  /** Required. The name of this playable location. */
  name: string;
  /** A [place ID] (https://developers.google.com/places/place-id) */
  placeId?:
    | string
    | undefined;
  /** A [plus code] (http://openlocationcode.com) */
  plusCode?:
    | string
    | undefined;
  /**
   * A collection of [Playable Location Types](/maps/tt/games/types) for this
   * playable location. The first type in the collection is the primary type.
   *
   * Type information might not be available for all playable locations.
   */
  types: string[];
  /**
   * Required. The latitude and longitude associated with the center of the
   * playable location.
   *
   * By default, the set of playable locations returned from
   * [SamplePlayableLocations][google.maps.playablelocations.v3.PlayableLocations.SamplePlayableLocations]
   * use center-point coordinates.
   */
  centerPoint:
    | LatLng
    | undefined;
  /**
   * The playable location's coordinates, snapped to the sidewalk of the
   * nearest road, if a nearby road exists.
   */
  snappedPoint: LatLng | undefined;
}

/** A set of options that specifies the separation between playable locations. */
export interface SpacingOptions {
  /**
   * Required. The minimum spacing between any two playable locations, measured
   * in meters. The minimum value is 30. The maximum value is 1000.
   *
   * Inputs will be rounded up to the next 10 meter interval.
   *
   * The default value is 200m.
   *
   * Set this field to remove tight clusters of playable locations.
   *
   * Note:
   *
   * The spacing is a greedy algorithm. It optimizes for selecting the highest
   * ranking locations first, not to maximize the number of locations selected.
   * Consider the following scenario:
   *
   *   * Rank: A: 2, B: 1, C: 3.
   *   * Distance: A--200m--B--200m--C
   *
   * If spacing=250, it will pick the highest ranked location [B], not [A, C].
   *
   * Note:
   *
   * Spacing works within the game object type itself, as well as the previous
   * ones.
   * Suppose three game object types, each with the following spacing:
   *
   *   * X: 400m, Y: undefined, Z: 200m.
   *
   * 1. Add locations for X, within 400m of each other.
   * 2. Add locations for Y, without any spacing.
   * 3. Finally, add locations for Z within 200m of each other as well X and Y.
   *
   * The distance diagram between those locations end up as:
   *
   *   * From->To.
   *   * X->X: 400m
   *   * Y->X, Y->Y: unspecified.
   *   * Z->X, Z->Y, Z->Z: 200m.
   */
  minSpacingMeters: number;
  /**
   * Specifies whether the minimum spacing constraint applies to the
   * center-point or to the snapped point of playable locations. The default
   * value is `CENTER_POINT`.
   *
   * If a snapped point is not available for a playable location, its
   * center-point is used instead.
   *
   * Set this to the point type used in your game.
   */
  pointType: SpacingOptions_PointType;
}

/**
 * Specifies whether the playable location's geographic coordinates (latitude
 * and longitude) correspond to its center-point, or to its location snapped
 * to the sidewalk of the nearest road.
 */
export enum SpacingOptions_PointType {
  /** POINT_TYPE_UNSPECIFIED - Unspecified point type. Do not use this value. */
  POINT_TYPE_UNSPECIFIED = 0,
  /** CENTER_POINT - The geographic coordinates correspond to the center of the location. */
  CENTER_POINT = 1,
  /**
   * SNAPPED_POINT - The geographic coordinates correspond to the location snapped to the
   * sidewalk of the nearest road (when a nearby road exists).
   */
  SNAPPED_POINT = 2,
  UNRECOGNIZED = -1,
}

export function spacingOptions_PointTypeFromJSON(object: any): SpacingOptions_PointType {
  switch (object) {
    case 0:
    case "POINT_TYPE_UNSPECIFIED":
      return SpacingOptions_PointType.POINT_TYPE_UNSPECIFIED;
    case 1:
    case "CENTER_POINT":
      return SpacingOptions_PointType.CENTER_POINT;
    case 2:
    case "SNAPPED_POINT":
      return SpacingOptions_PointType.SNAPPED_POINT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SpacingOptions_PointType.UNRECOGNIZED;
  }
}

export function spacingOptions_PointTypeToJSON(object: SpacingOptions_PointType): string {
  switch (object) {
    case SpacingOptions_PointType.POINT_TYPE_UNSPECIFIED:
      return "POINT_TYPE_UNSPECIFIED";
    case SpacingOptions_PointType.CENTER_POINT:
      return "CENTER_POINT";
    case SpacingOptions_PointType.SNAPPED_POINT:
      return "SNAPPED_POINT";
    case SpacingOptions_PointType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Specifies the filters to use when searching for playable locations. */
export interface Filter {
  /**
   * Specifies the maximum number of playable locations to return. This value
   * must not be greater than 1000. The default value is 100.
   *
   * Only the top-ranking playable locations are returned.
   */
  maxLocationCount: number;
  /**
   * A set of options that control the spacing between playable locations. By
   * default the minimum distance between locations is 200m.
   */
  spacing:
    | SpacingOptions
    | undefined;
  /**
   * Restricts the set of playable locations to just the
   * [types](/maps/tt/games/types) that you want.
   */
  includedTypes: string[];
}

/**
 * Encapsulates a filter criterion for searching for a set of playable
 * locations.
 */
export interface Criterion {
  /**
   * Required. An arbitrary, developer-defined identifier of the type of game
   * object that the playable location is used for. This field allows you to
   * specify criteria per game object type when searching for playable
   * locations.
   *
   * You should assign a unique `game_object_type` ID across all
   * `request_criteria` to represent a distinct type of game object. For
   * example, 1=monster location, 2=powerup location.
   *
   * The response contains a map<game_object_type, Response>.
   */
  gameObjectType: number;
  /**
   * Specifies filtering options, and specifies what will be included in the
   * result set.
   */
  filter:
    | Filter
    | undefined;
  /**
   * Specifies which `PlayableLocation` fields are returned.
   *
   * `name` (which is used for logging impressions), `center_point` and
   * `place_id` (or `plus_code`) are always returned.
   *
   * The following fields are omitted unless you specify them here:
   *
   *   * snapped_point
   *   * types
   *
   * Note: The more fields you include, the more expensive in terms of data and
   * associated latency your query will be.
   */
  fieldsToReturn: string[] | undefined;
}

/** Specifies the area to search for playable locations. */
export interface AreaFilter {
  /**
   * Required. The S2 cell ID of the area you want. This must be between cell
   * level 11 and 14 (inclusive).
   *
   * S2 cells are 64-bit integers that identify areas on the Earth. They are
   * hierarchical, and can therefore be used for spatial indexing.
   *
   * The S2 geometry library is available in a number of languages:
   *
   *   * [C++](https://github.com/google/s2geometry)
   *   * [Java](https://github.com/google/s2-geometry-library-java)
   *   * [Go](https://github.com/golang/geo)
   *   * [Python](https://github.com/google/s2geometry/tree/master/src/python)
   */
  s2CellId: Long;
}

/** A list of PlayableLocation objects that satisfies a single Criterion. */
export interface PlayableLocationList {
  /** A list of playable locations for this game object type. */
  locations: PlayableLocation[];
}

function createBasePlayableLocation(): PlayableLocation {
  return {
    name: "",
    placeId: undefined,
    plusCode: undefined,
    types: [],
    centerPoint: undefined,
    snappedPoint: undefined,
  };
}

export const PlayableLocation: MessageFns<PlayableLocation> = {
  encode(message: PlayableLocation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.placeId !== undefined) {
      writer.uint32(18).string(message.placeId);
    }
    if (message.plusCode !== undefined) {
      writer.uint32(26).string(message.plusCode);
    }
    for (const v of message.types) {
      writer.uint32(34).string(v!);
    }
    if (message.centerPoint !== undefined) {
      LatLng.encode(message.centerPoint, writer.uint32(42).fork()).join();
    }
    if (message.snappedPoint !== undefined) {
      LatLng.encode(message.snappedPoint, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayableLocation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayableLocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.placeId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.plusCode = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.types.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.centerPoint = LatLng.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.snappedPoint = LatLng.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlayableLocation {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      placeId: isSet(object.placeId) ? globalThis.String(object.placeId) : undefined,
      plusCode: isSet(object.plusCode) ? globalThis.String(object.plusCode) : undefined,
      types: globalThis.Array.isArray(object?.types) ? object.types.map((e: any) => globalThis.String(e)) : [],
      centerPoint: isSet(object.centerPoint) ? LatLng.fromJSON(object.centerPoint) : undefined,
      snappedPoint: isSet(object.snappedPoint) ? LatLng.fromJSON(object.snappedPoint) : undefined,
    };
  },

  toJSON(message: PlayableLocation): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.placeId !== undefined) {
      obj.placeId = message.placeId;
    }
    if (message.plusCode !== undefined) {
      obj.plusCode = message.plusCode;
    }
    if (message.types?.length) {
      obj.types = message.types;
    }
    if (message.centerPoint !== undefined) {
      obj.centerPoint = LatLng.toJSON(message.centerPoint);
    }
    if (message.snappedPoint !== undefined) {
      obj.snappedPoint = LatLng.toJSON(message.snappedPoint);
    }
    return obj;
  },

  create(base?: DeepPartial<PlayableLocation>): PlayableLocation {
    return PlayableLocation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlayableLocation>): PlayableLocation {
    const message = createBasePlayableLocation();
    message.name = object.name ?? "";
    message.placeId = object.placeId ?? undefined;
    message.plusCode = object.plusCode ?? undefined;
    message.types = object.types?.map((e) => e) || [];
    message.centerPoint = (object.centerPoint !== undefined && object.centerPoint !== null)
      ? LatLng.fromPartial(object.centerPoint)
      : undefined;
    message.snappedPoint = (object.snappedPoint !== undefined && object.snappedPoint !== null)
      ? LatLng.fromPartial(object.snappedPoint)
      : undefined;
    return message;
  },
};

function createBaseSpacingOptions(): SpacingOptions {
  return { minSpacingMeters: 0, pointType: 0 };
}

export const SpacingOptions: MessageFns<SpacingOptions> = {
  encode(message: SpacingOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.minSpacingMeters !== 0) {
      writer.uint32(9).double(message.minSpacingMeters);
    }
    if (message.pointType !== 0) {
      writer.uint32(16).int32(message.pointType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpacingOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpacingOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.minSpacingMeters = reader.double();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pointType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpacingOptions {
    return {
      minSpacingMeters: isSet(object.minSpacingMeters) ? globalThis.Number(object.minSpacingMeters) : 0,
      pointType: isSet(object.pointType) ? spacingOptions_PointTypeFromJSON(object.pointType) : 0,
    };
  },

  toJSON(message: SpacingOptions): unknown {
    const obj: any = {};
    if (message.minSpacingMeters !== 0) {
      obj.minSpacingMeters = message.minSpacingMeters;
    }
    if (message.pointType !== 0) {
      obj.pointType = spacingOptions_PointTypeToJSON(message.pointType);
    }
    return obj;
  },

  create(base?: DeepPartial<SpacingOptions>): SpacingOptions {
    return SpacingOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SpacingOptions>): SpacingOptions {
    const message = createBaseSpacingOptions();
    message.minSpacingMeters = object.minSpacingMeters ?? 0;
    message.pointType = object.pointType ?? 0;
    return message;
  },
};

function createBaseFilter(): Filter {
  return { maxLocationCount: 0, spacing: undefined, includedTypes: [] };
}

export const Filter: MessageFns<Filter> = {
  encode(message: Filter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.maxLocationCount !== 0) {
      writer.uint32(8).int32(message.maxLocationCount);
    }
    if (message.spacing !== undefined) {
      SpacingOptions.encode(message.spacing, writer.uint32(18).fork()).join();
    }
    for (const v of message.includedTypes) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Filter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.maxLocationCount = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.spacing = SpacingOptions.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.includedTypes.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Filter {
    return {
      maxLocationCount: isSet(object.maxLocationCount) ? globalThis.Number(object.maxLocationCount) : 0,
      spacing: isSet(object.spacing) ? SpacingOptions.fromJSON(object.spacing) : undefined,
      includedTypes: globalThis.Array.isArray(object?.includedTypes)
        ? object.includedTypes.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Filter): unknown {
    const obj: any = {};
    if (message.maxLocationCount !== 0) {
      obj.maxLocationCount = Math.round(message.maxLocationCount);
    }
    if (message.spacing !== undefined) {
      obj.spacing = SpacingOptions.toJSON(message.spacing);
    }
    if (message.includedTypes?.length) {
      obj.includedTypes = message.includedTypes;
    }
    return obj;
  },

  create(base?: DeepPartial<Filter>): Filter {
    return Filter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Filter>): Filter {
    const message = createBaseFilter();
    message.maxLocationCount = object.maxLocationCount ?? 0;
    message.spacing = (object.spacing !== undefined && object.spacing !== null)
      ? SpacingOptions.fromPartial(object.spacing)
      : undefined;
    message.includedTypes = object.includedTypes?.map((e) => e) || [];
    return message;
  },
};

function createBaseCriterion(): Criterion {
  return { gameObjectType: 0, filter: undefined, fieldsToReturn: undefined };
}

export const Criterion: MessageFns<Criterion> = {
  encode(message: Criterion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gameObjectType !== 0) {
      writer.uint32(8).int32(message.gameObjectType);
    }
    if (message.filter !== undefined) {
      Filter.encode(message.filter, writer.uint32(18).fork()).join();
    }
    if (message.fieldsToReturn !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.fieldsToReturn), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Criterion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCriterion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.gameObjectType = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filter = Filter.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.fieldsToReturn = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Criterion {
    return {
      gameObjectType: isSet(object.gameObjectType) ? globalThis.Number(object.gameObjectType) : 0,
      filter: isSet(object.filter) ? Filter.fromJSON(object.filter) : undefined,
      fieldsToReturn: isSet(object.fieldsToReturn)
        ? FieldMask.unwrap(FieldMask.fromJSON(object.fieldsToReturn))
        : undefined,
    };
  },

  toJSON(message: Criterion): unknown {
    const obj: any = {};
    if (message.gameObjectType !== 0) {
      obj.gameObjectType = Math.round(message.gameObjectType);
    }
    if (message.filter !== undefined) {
      obj.filter = Filter.toJSON(message.filter);
    }
    if (message.fieldsToReturn !== undefined) {
      obj.fieldsToReturn = FieldMask.toJSON(FieldMask.wrap(message.fieldsToReturn));
    }
    return obj;
  },

  create(base?: DeepPartial<Criterion>): Criterion {
    return Criterion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Criterion>): Criterion {
    const message = createBaseCriterion();
    message.gameObjectType = object.gameObjectType ?? 0;
    message.filter = (object.filter !== undefined && object.filter !== null)
      ? Filter.fromPartial(object.filter)
      : undefined;
    message.fieldsToReturn = object.fieldsToReturn ?? undefined;
    return message;
  },
};

function createBaseAreaFilter(): AreaFilter {
  return { s2CellId: Long.UZERO };
}

export const AreaFilter: MessageFns<AreaFilter> = {
  encode(message: AreaFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.s2CellId.equals(Long.UZERO)) {
      writer.uint32(9).fixed64(message.s2CellId.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AreaFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAreaFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.s2CellId = Long.fromString(reader.fixed64().toString(), true);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AreaFilter {
    return { s2CellId: isSet(object.s2CellId) ? Long.fromValue(object.s2CellId) : Long.UZERO };
  },

  toJSON(message: AreaFilter): unknown {
    const obj: any = {};
    if (!message.s2CellId.equals(Long.UZERO)) {
      obj.s2CellId = (message.s2CellId || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<AreaFilter>): AreaFilter {
    return AreaFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AreaFilter>): AreaFilter {
    const message = createBaseAreaFilter();
    message.s2CellId = (object.s2CellId !== undefined && object.s2CellId !== null)
      ? Long.fromValue(object.s2CellId)
      : Long.UZERO;
    return message;
  },
};

function createBasePlayableLocationList(): PlayableLocationList {
  return { locations: [] };
}

export const PlayableLocationList: MessageFns<PlayableLocationList> = {
  encode(message: PlayableLocationList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.locations) {
      PlayableLocation.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayableLocationList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayableLocationList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.locations.push(PlayableLocation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlayableLocationList {
    return {
      locations: globalThis.Array.isArray(object?.locations)
        ? object.locations.map((e: any) => PlayableLocation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PlayableLocationList): unknown {
    const obj: any = {};
    if (message.locations?.length) {
      obj.locations = message.locations.map((e) => PlayableLocation.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<PlayableLocationList>): PlayableLocationList {
    return PlayableLocationList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlayableLocationList>): PlayableLocationList {
    const message = createBasePlayableLocationList();
    message.locations = object.locations?.map((e) => PlayableLocation.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
