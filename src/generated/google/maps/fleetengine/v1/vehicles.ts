// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/maps/fleetengine/v1/vehicles.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Int32Value } from "../../../protobuf/wrappers.js";
import {
  NavigationStatus,
  navigationStatusFromJSON,
  navigationStatusToJSON,
  TerminalLocation,
  TripType,
  tripTypeFromJSON,
  tripTypeToJSON,
  TripWaypoint,
  VehicleAttribute,
  VehicleLocation,
} from "./fleetengine.js";

export const protobufPackage = "maps.fleetengine.v1";

/** The state of a `Vehicle`. */
export enum VehicleState {
  /** UNKNOWN_VEHICLE_STATE - Default, used for unspecified or unrecognized vehicle states. */
  UNKNOWN_VEHICLE_STATE = 0,
  /**
   * OFFLINE - The vehicle is not accepting new trips. Note: the vehicle may continue to
   * operate in this state while completing a trip assigned to it.
   */
  OFFLINE = 1,
  /** ONLINE - The vehicle is accepting new trips. */
  ONLINE = 2,
  UNRECOGNIZED = -1,
}

export function vehicleStateFromJSON(object: any): VehicleState {
  switch (object) {
    case 0:
    case "UNKNOWN_VEHICLE_STATE":
      return VehicleState.UNKNOWN_VEHICLE_STATE;
    case 1:
    case "OFFLINE":
      return VehicleState.OFFLINE;
    case 2:
    case "ONLINE":
      return VehicleState.ONLINE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VehicleState.UNRECOGNIZED;
  }
}

export function vehicleStateToJSON(object: VehicleState): string {
  switch (object) {
    case VehicleState.UNKNOWN_VEHICLE_STATE:
      return "UNKNOWN_VEHICLE_STATE";
    case VehicleState.OFFLINE:
      return "OFFLINE";
    case VehicleState.ONLINE:
      return "ONLINE";
    case VehicleState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * How location features are configured to behave on the mobile device when the
 * devices "battery saver" feature is on.
 * (https://developer.android.com/reference/android/os/PowerManager#getLocationPowerSaveMode())
 */
export enum LocationPowerSaveMode {
  /** UNKNOWN_LOCATION_POWER_SAVE_MODE - Undefined LocationPowerSaveMode */
  UNKNOWN_LOCATION_POWER_SAVE_MODE = 0,
  /**
   * LOCATION_MODE_NO_CHANGE - Either the location providers shouldn't be affected by battery saver, or
   * battery saver is off.
   */
  LOCATION_MODE_NO_CHANGE = 1,
  /**
   * LOCATION_MODE_GPS_DISABLED_WHEN_SCREEN_OFF - The GPS based location provider should be disabled when battery saver is on
   * and the device is non-interactive.
   */
  LOCATION_MODE_GPS_DISABLED_WHEN_SCREEN_OFF = 2,
  /**
   * LOCATION_MODE_ALL_DISABLED_WHEN_SCREEN_OFF - All location providers should be disabled when battery saver is on and the
   * device is non-interactive.
   */
  LOCATION_MODE_ALL_DISABLED_WHEN_SCREEN_OFF = 3,
  /**
   * LOCATION_MODE_FOREGROUND_ONLY - All the location providers will be kept available, but location fixes
   * should only be provided to foreground apps.
   */
  LOCATION_MODE_FOREGROUND_ONLY = 4,
  /**
   * LOCATION_MODE_THROTTLE_REQUESTS_WHEN_SCREEN_OFF - Location will not be turned off, but LocationManager will throttle all
   * requests to providers when the device is non-interactive.
   */
  LOCATION_MODE_THROTTLE_REQUESTS_WHEN_SCREEN_OFF = 5,
  UNRECOGNIZED = -1,
}

export function locationPowerSaveModeFromJSON(object: any): LocationPowerSaveMode {
  switch (object) {
    case 0:
    case "UNKNOWN_LOCATION_POWER_SAVE_MODE":
      return LocationPowerSaveMode.UNKNOWN_LOCATION_POWER_SAVE_MODE;
    case 1:
    case "LOCATION_MODE_NO_CHANGE":
      return LocationPowerSaveMode.LOCATION_MODE_NO_CHANGE;
    case 2:
    case "LOCATION_MODE_GPS_DISABLED_WHEN_SCREEN_OFF":
      return LocationPowerSaveMode.LOCATION_MODE_GPS_DISABLED_WHEN_SCREEN_OFF;
    case 3:
    case "LOCATION_MODE_ALL_DISABLED_WHEN_SCREEN_OFF":
      return LocationPowerSaveMode.LOCATION_MODE_ALL_DISABLED_WHEN_SCREEN_OFF;
    case 4:
    case "LOCATION_MODE_FOREGROUND_ONLY":
      return LocationPowerSaveMode.LOCATION_MODE_FOREGROUND_ONLY;
    case 5:
    case "LOCATION_MODE_THROTTLE_REQUESTS_WHEN_SCREEN_OFF":
      return LocationPowerSaveMode.LOCATION_MODE_THROTTLE_REQUESTS_WHEN_SCREEN_OFF;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LocationPowerSaveMode.UNRECOGNIZED;
  }
}

export function locationPowerSaveModeToJSON(object: LocationPowerSaveMode): string {
  switch (object) {
    case LocationPowerSaveMode.UNKNOWN_LOCATION_POWER_SAVE_MODE:
      return "UNKNOWN_LOCATION_POWER_SAVE_MODE";
    case LocationPowerSaveMode.LOCATION_MODE_NO_CHANGE:
      return "LOCATION_MODE_NO_CHANGE";
    case LocationPowerSaveMode.LOCATION_MODE_GPS_DISABLED_WHEN_SCREEN_OFF:
      return "LOCATION_MODE_GPS_DISABLED_WHEN_SCREEN_OFF";
    case LocationPowerSaveMode.LOCATION_MODE_ALL_DISABLED_WHEN_SCREEN_OFF:
      return "LOCATION_MODE_ALL_DISABLED_WHEN_SCREEN_OFF";
    case LocationPowerSaveMode.LOCATION_MODE_FOREGROUND_ONLY:
      return "LOCATION_MODE_FOREGROUND_ONLY";
    case LocationPowerSaveMode.LOCATION_MODE_THROTTLE_REQUESTS_WHEN_SCREEN_OFF:
      return "LOCATION_MODE_THROTTLE_REQUESTS_WHEN_SCREEN_OFF";
    case LocationPowerSaveMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Status of the battery, whether full or charging etc. */
export enum BatteryStatus {
  /** UNKNOWN_BATTERY_STATUS - Battery status unknown. */
  UNKNOWN_BATTERY_STATUS = 0,
  /** BATTERY_STATUS_CHARGING - Battery is being charged. */
  BATTERY_STATUS_CHARGING = 1,
  /** BATTERY_STATUS_DISCHARGING - Battery is discharging. */
  BATTERY_STATUS_DISCHARGING = 2,
  /** BATTERY_STATUS_FULL - Battery is full. */
  BATTERY_STATUS_FULL = 3,
  /** BATTERY_STATUS_NOT_CHARGING - Battery is not charging. */
  BATTERY_STATUS_NOT_CHARGING = 4,
  /** BATTERY_STATUS_POWER_LOW - Battery is low on power. */
  BATTERY_STATUS_POWER_LOW = 5,
  UNRECOGNIZED = -1,
}

export function batteryStatusFromJSON(object: any): BatteryStatus {
  switch (object) {
    case 0:
    case "UNKNOWN_BATTERY_STATUS":
      return BatteryStatus.UNKNOWN_BATTERY_STATUS;
    case 1:
    case "BATTERY_STATUS_CHARGING":
      return BatteryStatus.BATTERY_STATUS_CHARGING;
    case 2:
    case "BATTERY_STATUS_DISCHARGING":
      return BatteryStatus.BATTERY_STATUS_DISCHARGING;
    case 3:
    case "BATTERY_STATUS_FULL":
      return BatteryStatus.BATTERY_STATUS_FULL;
    case 4:
    case "BATTERY_STATUS_NOT_CHARGING":
      return BatteryStatus.BATTERY_STATUS_NOT_CHARGING;
    case 5:
    case "BATTERY_STATUS_POWER_LOW":
      return BatteryStatus.BATTERY_STATUS_POWER_LOW;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BatteryStatus.UNRECOGNIZED;
  }
}

export function batteryStatusToJSON(object: BatteryStatus): string {
  switch (object) {
    case BatteryStatus.UNKNOWN_BATTERY_STATUS:
      return "UNKNOWN_BATTERY_STATUS";
    case BatteryStatus.BATTERY_STATUS_CHARGING:
      return "BATTERY_STATUS_CHARGING";
    case BatteryStatus.BATTERY_STATUS_DISCHARGING:
      return "BATTERY_STATUS_DISCHARGING";
    case BatteryStatus.BATTERY_STATUS_FULL:
      return "BATTERY_STATUS_FULL";
    case BatteryStatus.BATTERY_STATUS_NOT_CHARGING:
      return "BATTERY_STATUS_NOT_CHARGING";
    case BatteryStatus.BATTERY_STATUS_POWER_LOW:
      return "BATTERY_STATUS_POWER_LOW";
    case BatteryStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Type of the charger being used to charge the battery. */
export enum PowerSource {
  /** UNKNOWN_POWER_SOURCE - Power source unknown. */
  UNKNOWN_POWER_SOURCE = 0,
  /** POWER_SOURCE_AC - Power source is an AC charger. */
  POWER_SOURCE_AC = 1,
  /** POWER_SOURCE_USB - Power source is a USB port. */
  POWER_SOURCE_USB = 2,
  /** POWER_SOURCE_WIRELESS - Power source is wireless. */
  POWER_SOURCE_WIRELESS = 3,
  /** POWER_SOURCE_UNPLUGGED - Battery is unplugged. */
  POWER_SOURCE_UNPLUGGED = 4,
  UNRECOGNIZED = -1,
}

export function powerSourceFromJSON(object: any): PowerSource {
  switch (object) {
    case 0:
    case "UNKNOWN_POWER_SOURCE":
      return PowerSource.UNKNOWN_POWER_SOURCE;
    case 1:
    case "POWER_SOURCE_AC":
      return PowerSource.POWER_SOURCE_AC;
    case 2:
    case "POWER_SOURCE_USB":
      return PowerSource.POWER_SOURCE_USB;
    case 3:
    case "POWER_SOURCE_WIRELESS":
      return PowerSource.POWER_SOURCE_WIRELESS;
    case 4:
    case "POWER_SOURCE_UNPLUGGED":
      return PowerSource.POWER_SOURCE_UNPLUGGED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PowerSource.UNRECOGNIZED;
  }
}

export function powerSourceToJSON(object: PowerSource): string {
  switch (object) {
    case PowerSource.UNKNOWN_POWER_SOURCE:
      return "UNKNOWN_POWER_SOURCE";
    case PowerSource.POWER_SOURCE_AC:
      return "POWER_SOURCE_AC";
    case PowerSource.POWER_SOURCE_USB:
      return "POWER_SOURCE_USB";
    case PowerSource.POWER_SOURCE_WIRELESS:
      return "POWER_SOURCE_WIRELESS";
    case PowerSource.POWER_SOURCE_UNPLUGGED:
      return "POWER_SOURCE_UNPLUGGED";
    case PowerSource.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Vehicle metadata. */
export interface Vehicle {
  /**
   * Output only. The unique name for this vehicle.
   * The format is `providers/{provider}/vehicles/{vehicle}`.
   */
  name: string;
  /** The vehicle state. */
  vehicleState: VehicleState;
  /** Trip types supported by this vehicle. */
  supportedTripTypes: TripType[];
  /**
   * Output only. List of `trip_id`'s for trips currently assigned to this
   * vehicle.
   */
  currentTrips: string[];
  /** Last reported location of the vehicle. */
  lastLocation:
    | VehicleLocation
    | undefined;
  /**
   * The total numbers of riders this vehicle can carry.  The driver is not
   * considered in this value. This value must be greater than or equal to one.
   */
  maximumCapacity: number;
  /**
   * List of vehicle attributes. A vehicle can have at most 100
   * attributes, and each attribute must have a unique key.
   */
  attributes: VehicleAttribute[];
  /**
   * Required. The type of this vehicle.  Can be used to filter vehicles in
   * `SearchVehicles` results.  Also influences ETA and route calculations.
   */
  vehicleType:
    | Vehicle_VehicleType
    | undefined;
  /** License plate information for the vehicle. */
  licensePlate:
    | LicensePlate
    | undefined;
  /**
   * Deprecated: Use `Vehicle.waypoints` instead.
   *
   * @deprecated
   */
  route: TerminalLocation[];
  /**
   * The polyline specifying the route the driver app intends to take to
   * the next waypoint. This list is also returned in
   * `Trip.current_route_segment` for all active trips assigned to the vehicle.
   *
   * Note: This field is intended only for use by the Driver SDK. Decoding is
   * not yet supported.
   */
  currentRouteSegment: string;
  /**
   * Input only. Fleet Engine uses this information to improve journey sharing.
   * Note: This field is intended only for use by the Driver SDK.
   */
  currentRouteSegmentTraffic:
    | TrafficPolylineData
    | undefined;
  /**
   * Output only. Time when `current_route_segment` was set. It can be stored by
   * the client and passed in future `GetVehicle` requests to prevent returning
   * routes that haven't changed.
   */
  currentRouteSegmentVersion:
    | Date
    | undefined;
  /**
   * The waypoint where `current_route_segment` ends. This can be supplied by
   * drivers on `UpdateVehicle` calls either as a full trip waypoint, a waypoint
   * `LatLng`, or as the last `LatLng` of the `current_route_segment`. Fleet
   * Engine will then do its best to interpolate to an actual waypoint if it is
   * not fully specified. This field is ignored in `UpdateVehicle` calls unless
   * `current_route_segment` is also specified.
   */
  currentRouteSegmentEndPoint:
    | TripWaypoint
    | undefined;
  /**
   * The remaining driving distance for the `current_route_segment`.
   * This value is also returned in `Trip.remaining_distance_meters` for all
   * active trips assigned to the vehicle. The value is unspecified if the
   * `current_route_segment` field is empty.
   */
  remainingDistanceMeters:
    | number
    | undefined;
  /**
   * The ETA to the first entry in the `waypoints` field.  The value is
   * unspecified if the `waypoints` field is empty or the
   * `Vehicle.current_route_segment` field is empty.
   *
   * When updating a vehicle, `remaining_time_seconds` takes precedence over
   * `eta_to_first_waypoint` in the same request.
   */
  etaToFirstWaypoint:
    | Date
    | undefined;
  /**
   * Input only. The remaining driving time for the `current_route_segment`. The
   * value is unspecified if the `waypoints` field is empty or the
   * `Vehicle.current_route_segment` field is empty. This value should match
   * `eta_to_first_waypoint` - `current_time` if all parties are using the same
   * clock.
   *
   * When updating a vehicle, `remaining_time_seconds` takes precedence over
   * `eta_to_first_waypoint` in the same request.
   */
  remainingTimeSeconds:
    | number
    | undefined;
  /** The remaining waypoints assigned to this Vehicle. */
  waypoints: TripWaypoint[];
  /**
   * Output only. Last time the `waypoints` field was updated. Clients should
   * cache this value and pass it in `GetVehicleRequest` to ensure the
   * `waypoints` field is only returned if it is updated.
   */
  waypointsVersion:
    | Date
    | undefined;
  /**
   * Indicates if the driver accepts back-to-back trips. If `true`,
   * `SearchVehicles` may include the vehicle even if it is currently assigned
   * to a trip. The default value is `false`.
   */
  backToBackEnabled: boolean;
  /** The vehicle's navigation status. */
  navigationStatus: NavigationStatus;
  /**
   * Input only. Information about settings in the mobile device being used by
   * the driver.
   */
  deviceSettings: DeviceSettings | undefined;
}

/** The type of vehicle. */
export interface Vehicle_VehicleType {
  /** Vehicle type category */
  category: Vehicle_VehicleType_Category;
}

/** Vehicle type categories */
export enum Vehicle_VehicleType_Category {
  /** UNKNOWN - Default, used for unspecified or unrecognized vehicle categories. */
  UNKNOWN = 0,
  /** AUTO - An automobile. */
  AUTO = 1,
  /** TAXI - Any vehicle that acts as a taxi (typically licensed or regulated). */
  TAXI = 2,
  /** TRUCK - Generally, a vehicle with a large storage capacity. */
  TRUCK = 3,
  /** TWO_WHEELER - A motorcycle, moped, or other two-wheeled vehicle */
  TWO_WHEELER = 4,
  /** BICYCLE - Human-powered transport. */
  BICYCLE = 5,
  /**
   * PEDESTRIAN - A human transporter, typically walking or running, traveling along
   * pedestrian pathways.
   */
  PEDESTRIAN = 6,
  UNRECOGNIZED = -1,
}

export function vehicle_VehicleType_CategoryFromJSON(object: any): Vehicle_VehicleType_Category {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return Vehicle_VehicleType_Category.UNKNOWN;
    case 1:
    case "AUTO":
      return Vehicle_VehicleType_Category.AUTO;
    case 2:
    case "TAXI":
      return Vehicle_VehicleType_Category.TAXI;
    case 3:
    case "TRUCK":
      return Vehicle_VehicleType_Category.TRUCK;
    case 4:
    case "TWO_WHEELER":
      return Vehicle_VehicleType_Category.TWO_WHEELER;
    case 5:
    case "BICYCLE":
      return Vehicle_VehicleType_Category.BICYCLE;
    case 6:
    case "PEDESTRIAN":
      return Vehicle_VehicleType_Category.PEDESTRIAN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Vehicle_VehicleType_Category.UNRECOGNIZED;
  }
}

export function vehicle_VehicleType_CategoryToJSON(object: Vehicle_VehicleType_Category): string {
  switch (object) {
    case Vehicle_VehicleType_Category.UNKNOWN:
      return "UNKNOWN";
    case Vehicle_VehicleType_Category.AUTO:
      return "AUTO";
    case Vehicle_VehicleType_Category.TAXI:
      return "TAXI";
    case Vehicle_VehicleType_Category.TRUCK:
      return "TRUCK";
    case Vehicle_VehicleType_Category.TWO_WHEELER:
      return "TWO_WHEELER";
    case Vehicle_VehicleType_Category.BICYCLE:
      return "BICYCLE";
    case Vehicle_VehicleType_Category.PEDESTRIAN:
      return "PEDESTRIAN";
    case Vehicle_VehicleType_Category.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Information about the device's battery. */
export interface BatteryInfo {
  /** Status of the battery, whether full or charging etc. */
  batteryStatus: BatteryStatus;
  /** Status of battery power source. */
  powerSource: PowerSource;
  /** Current battery percentage [0-100]. */
  batteryPercentage: number;
}

/** Information about various settings on the mobile device. */
export interface DeviceSettings {
  /**
   * How location features are set to behave on the device when battery saver is
   * on.
   */
  locationPowerSaveMode: LocationPowerSaveMode;
  /** Whether the device is currently in power save mode. */
  isPowerSaveMode: boolean;
  /** Whether the device is in an interactive state. */
  isInteractive: boolean;
  /** Information about the battery state. */
  batteryInfo: BatteryInfo | undefined;
}

/**
 * The license plate information of the Vehicle.  To avoid storing
 * personally-identifiable information, only the minimum information
 * about the license plate is stored as part of the entity.
 */
export interface LicensePlate {
  /**
   * Required. CLDR Country/Region Code.  For example, `US` for United States,
   * or `IN` for India.
   */
  countryCode: string;
  /**
   * The last digit of the license plate or "-1" to denote no numeric value
   * is present in the license plate.
   *
   * * "ABC 1234" -> "4"
   * * "AB 123 CD" -> "3"
   * * "ABCDEF" -> "-1"
   */
  lastCharacter: string;
}

/**
 * Describes how clients should color one portion of the polyline along the
 * route.
 */
export interface VisualTrafficReportPolylineRendering {
  /**
   * Optional. Road stretches that should be rendered along the polyline.
   * Stretches are guaranteed to not overlap, and do not necessarily span the
   * full route.
   *
   * In the absence of a road stretch to style, the client should apply the
   * default for the route.
   */
  roadStretch: VisualTrafficReportPolylineRendering_RoadStretch[];
}

/** One road stretch that should be rendered. */
export interface VisualTrafficReportPolylineRendering_RoadStretch {
  /** Required. The style to apply. */
  style: VisualTrafficReportPolylineRendering_RoadStretch_Style;
  /**
   * Required. The style should be applied between `[offset_meters,
   * offset_meters + length_meters)`.
   */
  offsetMeters: number;
  /** Required. The length of the path where to apply the style. */
  lengthMeters: number;
}

/** The traffic style, indicating traffic speed. */
export enum VisualTrafficReportPolylineRendering_RoadStretch_Style {
  /** STYLE_UNSPECIFIED - No style selected. */
  STYLE_UNSPECIFIED = 0,
  /** SLOWER_TRAFFIC - Traffic is slowing down. */
  SLOWER_TRAFFIC = 1,
  /** TRAFFIC_JAM - There is a traffic jam. */
  TRAFFIC_JAM = 2,
  UNRECOGNIZED = -1,
}

export function visualTrafficReportPolylineRendering_RoadStretch_StyleFromJSON(
  object: any,
): VisualTrafficReportPolylineRendering_RoadStretch_Style {
  switch (object) {
    case 0:
    case "STYLE_UNSPECIFIED":
      return VisualTrafficReportPolylineRendering_RoadStretch_Style.STYLE_UNSPECIFIED;
    case 1:
    case "SLOWER_TRAFFIC":
      return VisualTrafficReportPolylineRendering_RoadStretch_Style.SLOWER_TRAFFIC;
    case 2:
    case "TRAFFIC_JAM":
      return VisualTrafficReportPolylineRendering_RoadStretch_Style.TRAFFIC_JAM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VisualTrafficReportPolylineRendering_RoadStretch_Style.UNRECOGNIZED;
  }
}

export function visualTrafficReportPolylineRendering_RoadStretch_StyleToJSON(
  object: VisualTrafficReportPolylineRendering_RoadStretch_Style,
): string {
  switch (object) {
    case VisualTrafficReportPolylineRendering_RoadStretch_Style.STYLE_UNSPECIFIED:
      return "STYLE_UNSPECIFIED";
    case VisualTrafficReportPolylineRendering_RoadStretch_Style.SLOWER_TRAFFIC:
      return "SLOWER_TRAFFIC";
    case VisualTrafficReportPolylineRendering_RoadStretch_Style.TRAFFIC_JAM:
      return "TRAFFIC_JAM";
    case VisualTrafficReportPolylineRendering_RoadStretch_Style.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Traffic conditions along the expected vehicle route. */
export interface TrafficPolylineData {
  /**
   * A polyline rendering of how fast traffic is for all regions along
   * one stretch of a customer ride.
   */
  trafficRendering: VisualTrafficReportPolylineRendering | undefined;
}

function createBaseVehicle(): Vehicle {
  return {
    name: "",
    vehicleState: 0,
    supportedTripTypes: [],
    currentTrips: [],
    lastLocation: undefined,
    maximumCapacity: 0,
    attributes: [],
    vehicleType: undefined,
    licensePlate: undefined,
    route: [],
    currentRouteSegment: "",
    currentRouteSegmentTraffic: undefined,
    currentRouteSegmentVersion: undefined,
    currentRouteSegmentEndPoint: undefined,
    remainingDistanceMeters: undefined,
    etaToFirstWaypoint: undefined,
    remainingTimeSeconds: undefined,
    waypoints: [],
    waypointsVersion: undefined,
    backToBackEnabled: false,
    navigationStatus: 0,
    deviceSettings: undefined,
  };
}

export const Vehicle: MessageFns<Vehicle> = {
  encode(message: Vehicle, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.vehicleState !== 0) {
      writer.uint32(16).int32(message.vehicleState);
    }
    writer.uint32(26).fork();
    for (const v of message.supportedTripTypes) {
      writer.int32(v);
    }
    writer.join();
    for (const v of message.currentTrips) {
      writer.uint32(34).string(v!);
    }
    if (message.lastLocation !== undefined) {
      VehicleLocation.encode(message.lastLocation, writer.uint32(42).fork()).join();
    }
    if (message.maximumCapacity !== 0) {
      writer.uint32(48).int32(message.maximumCapacity);
    }
    for (const v of message.attributes) {
      VehicleAttribute.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.vehicleType !== undefined) {
      Vehicle_VehicleType.encode(message.vehicleType, writer.uint32(74).fork()).join();
    }
    if (message.licensePlate !== undefined) {
      LicensePlate.encode(message.licensePlate, writer.uint32(82).fork()).join();
    }
    for (const v of message.route) {
      TerminalLocation.encode(v!, writer.uint32(98).fork()).join();
    }
    if (message.currentRouteSegment !== "") {
      writer.uint32(162).string(message.currentRouteSegment);
    }
    if (message.currentRouteSegmentTraffic !== undefined) {
      TrafficPolylineData.encode(message.currentRouteSegmentTraffic, writer.uint32(226).fork()).join();
    }
    if (message.currentRouteSegmentVersion !== undefined) {
      Timestamp.encode(toTimestamp(message.currentRouteSegmentVersion), writer.uint32(122).fork()).join();
    }
    if (message.currentRouteSegmentEndPoint !== undefined) {
      TripWaypoint.encode(message.currentRouteSegmentEndPoint, writer.uint32(194).fork()).join();
    }
    if (message.remainingDistanceMeters !== undefined) {
      Int32Value.encode({ value: message.remainingDistanceMeters! }, writer.uint32(146).fork()).join();
    }
    if (message.etaToFirstWaypoint !== undefined) {
      Timestamp.encode(toTimestamp(message.etaToFirstWaypoint), writer.uint32(154).fork()).join();
    }
    if (message.remainingTimeSeconds !== undefined) {
      Int32Value.encode({ value: message.remainingTimeSeconds! }, writer.uint32(202).fork()).join();
    }
    for (const v of message.waypoints) {
      TripWaypoint.encode(v!, writer.uint32(178).fork()).join();
    }
    if (message.waypointsVersion !== undefined) {
      Timestamp.encode(toTimestamp(message.waypointsVersion), writer.uint32(130).fork()).join();
    }
    if (message.backToBackEnabled !== false) {
      writer.uint32(184).bool(message.backToBackEnabled);
    }
    if (message.navigationStatus !== 0) {
      writer.uint32(208).int32(message.navigationStatus);
    }
    if (message.deviceSettings !== undefined) {
      DeviceSettings.encode(message.deviceSettings, writer.uint32(218).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Vehicle {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVehicle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.vehicleState = reader.int32() as any;
          continue;
        case 3:
          if (tag === 24) {
            message.supportedTripTypes.push(reader.int32() as any);

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.supportedTripTypes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.currentTrips.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.lastLocation = VehicleLocation.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.maximumCapacity = reader.int32();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.attributes.push(VehicleAttribute.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.vehicleType = Vehicle_VehicleType.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.licensePlate = LicensePlate.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.route.push(TerminalLocation.decode(reader, reader.uint32()));
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.currentRouteSegment = reader.string();
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }

          message.currentRouteSegmentTraffic = TrafficPolylineData.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.currentRouteSegmentVersion = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.currentRouteSegmentEndPoint = TripWaypoint.decode(reader, reader.uint32());
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.remainingDistanceMeters = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.etaToFirstWaypoint = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.remainingTimeSeconds = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.waypoints.push(TripWaypoint.decode(reader, reader.uint32()));
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.waypointsVersion = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 23:
          if (tag !== 184) {
            break;
          }

          message.backToBackEnabled = reader.bool();
          continue;
        case 26:
          if (tag !== 208) {
            break;
          }

          message.navigationStatus = reader.int32() as any;
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }

          message.deviceSettings = DeviceSettings.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Vehicle {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      vehicleState: isSet(object.vehicleState) ? vehicleStateFromJSON(object.vehicleState) : 0,
      supportedTripTypes: globalThis.Array.isArray(object?.supportedTripTypes)
        ? object.supportedTripTypes.map((e: any) => tripTypeFromJSON(e))
        : [],
      currentTrips: globalThis.Array.isArray(object?.currentTrips)
        ? object.currentTrips.map((e: any) => globalThis.String(e))
        : [],
      lastLocation: isSet(object.lastLocation) ? VehicleLocation.fromJSON(object.lastLocation) : undefined,
      maximumCapacity: isSet(object.maximumCapacity) ? globalThis.Number(object.maximumCapacity) : 0,
      attributes: globalThis.Array.isArray(object?.attributes)
        ? object.attributes.map((e: any) => VehicleAttribute.fromJSON(e))
        : [],
      vehicleType: isSet(object.vehicleType) ? Vehicle_VehicleType.fromJSON(object.vehicleType) : undefined,
      licensePlate: isSet(object.licensePlate) ? LicensePlate.fromJSON(object.licensePlate) : undefined,
      route: globalThis.Array.isArray(object?.route) ? object.route.map((e: any) => TerminalLocation.fromJSON(e)) : [],
      currentRouteSegment: isSet(object.currentRouteSegment) ? globalThis.String(object.currentRouteSegment) : "",
      currentRouteSegmentTraffic: isSet(object.currentRouteSegmentTraffic)
        ? TrafficPolylineData.fromJSON(object.currentRouteSegmentTraffic)
        : undefined,
      currentRouteSegmentVersion: isSet(object.currentRouteSegmentVersion)
        ? fromJsonTimestamp(object.currentRouteSegmentVersion)
        : undefined,
      currentRouteSegmentEndPoint: isSet(object.currentRouteSegmentEndPoint)
        ? TripWaypoint.fromJSON(object.currentRouteSegmentEndPoint)
        : undefined,
      remainingDistanceMeters: isSet(object.remainingDistanceMeters)
        ? Number(object.remainingDistanceMeters)
        : undefined,
      etaToFirstWaypoint: isSet(object.etaToFirstWaypoint) ? fromJsonTimestamp(object.etaToFirstWaypoint) : undefined,
      remainingTimeSeconds: isSet(object.remainingTimeSeconds) ? Number(object.remainingTimeSeconds) : undefined,
      waypoints: globalThis.Array.isArray(object?.waypoints)
        ? object.waypoints.map((e: any) => TripWaypoint.fromJSON(e))
        : [],
      waypointsVersion: isSet(object.waypointsVersion) ? fromJsonTimestamp(object.waypointsVersion) : undefined,
      backToBackEnabled: isSet(object.backToBackEnabled) ? globalThis.Boolean(object.backToBackEnabled) : false,
      navigationStatus: isSet(object.navigationStatus) ? navigationStatusFromJSON(object.navigationStatus) : 0,
      deviceSettings: isSet(object.deviceSettings) ? DeviceSettings.fromJSON(object.deviceSettings) : undefined,
    };
  },

  toJSON(message: Vehicle): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.vehicleState !== 0) {
      obj.vehicleState = vehicleStateToJSON(message.vehicleState);
    }
    if (message.supportedTripTypes?.length) {
      obj.supportedTripTypes = message.supportedTripTypes.map((e) => tripTypeToJSON(e));
    }
    if (message.currentTrips?.length) {
      obj.currentTrips = message.currentTrips;
    }
    if (message.lastLocation !== undefined) {
      obj.lastLocation = VehicleLocation.toJSON(message.lastLocation);
    }
    if (message.maximumCapacity !== 0) {
      obj.maximumCapacity = Math.round(message.maximumCapacity);
    }
    if (message.attributes?.length) {
      obj.attributes = message.attributes.map((e) => VehicleAttribute.toJSON(e));
    }
    if (message.vehicleType !== undefined) {
      obj.vehicleType = Vehicle_VehicleType.toJSON(message.vehicleType);
    }
    if (message.licensePlate !== undefined) {
      obj.licensePlate = LicensePlate.toJSON(message.licensePlate);
    }
    if (message.route?.length) {
      obj.route = message.route.map((e) => TerminalLocation.toJSON(e));
    }
    if (message.currentRouteSegment !== "") {
      obj.currentRouteSegment = message.currentRouteSegment;
    }
    if (message.currentRouteSegmentTraffic !== undefined) {
      obj.currentRouteSegmentTraffic = TrafficPolylineData.toJSON(message.currentRouteSegmentTraffic);
    }
    if (message.currentRouteSegmentVersion !== undefined) {
      obj.currentRouteSegmentVersion = message.currentRouteSegmentVersion.toISOString();
    }
    if (message.currentRouteSegmentEndPoint !== undefined) {
      obj.currentRouteSegmentEndPoint = TripWaypoint.toJSON(message.currentRouteSegmentEndPoint);
    }
    if (message.remainingDistanceMeters !== undefined) {
      obj.remainingDistanceMeters = message.remainingDistanceMeters;
    }
    if (message.etaToFirstWaypoint !== undefined) {
      obj.etaToFirstWaypoint = message.etaToFirstWaypoint.toISOString();
    }
    if (message.remainingTimeSeconds !== undefined) {
      obj.remainingTimeSeconds = message.remainingTimeSeconds;
    }
    if (message.waypoints?.length) {
      obj.waypoints = message.waypoints.map((e) => TripWaypoint.toJSON(e));
    }
    if (message.waypointsVersion !== undefined) {
      obj.waypointsVersion = message.waypointsVersion.toISOString();
    }
    if (message.backToBackEnabled !== false) {
      obj.backToBackEnabled = message.backToBackEnabled;
    }
    if (message.navigationStatus !== 0) {
      obj.navigationStatus = navigationStatusToJSON(message.navigationStatus);
    }
    if (message.deviceSettings !== undefined) {
      obj.deviceSettings = DeviceSettings.toJSON(message.deviceSettings);
    }
    return obj;
  },

  create(base?: DeepPartial<Vehicle>): Vehicle {
    return Vehicle.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Vehicle>): Vehicle {
    const message = createBaseVehicle();
    message.name = object.name ?? "";
    message.vehicleState = object.vehicleState ?? 0;
    message.supportedTripTypes = object.supportedTripTypes?.map((e) => e) || [];
    message.currentTrips = object.currentTrips?.map((e) => e) || [];
    message.lastLocation = (object.lastLocation !== undefined && object.lastLocation !== null)
      ? VehicleLocation.fromPartial(object.lastLocation)
      : undefined;
    message.maximumCapacity = object.maximumCapacity ?? 0;
    message.attributes = object.attributes?.map((e) => VehicleAttribute.fromPartial(e)) || [];
    message.vehicleType = (object.vehicleType !== undefined && object.vehicleType !== null)
      ? Vehicle_VehicleType.fromPartial(object.vehicleType)
      : undefined;
    message.licensePlate = (object.licensePlate !== undefined && object.licensePlate !== null)
      ? LicensePlate.fromPartial(object.licensePlate)
      : undefined;
    message.route = object.route?.map((e) => TerminalLocation.fromPartial(e)) || [];
    message.currentRouteSegment = object.currentRouteSegment ?? "";
    message.currentRouteSegmentTraffic =
      (object.currentRouteSegmentTraffic !== undefined && object.currentRouteSegmentTraffic !== null)
        ? TrafficPolylineData.fromPartial(object.currentRouteSegmentTraffic)
        : undefined;
    message.currentRouteSegmentVersion = object.currentRouteSegmentVersion ?? undefined;
    message.currentRouteSegmentEndPoint =
      (object.currentRouteSegmentEndPoint !== undefined && object.currentRouteSegmentEndPoint !== null)
        ? TripWaypoint.fromPartial(object.currentRouteSegmentEndPoint)
        : undefined;
    message.remainingDistanceMeters = object.remainingDistanceMeters ?? undefined;
    message.etaToFirstWaypoint = object.etaToFirstWaypoint ?? undefined;
    message.remainingTimeSeconds = object.remainingTimeSeconds ?? undefined;
    message.waypoints = object.waypoints?.map((e) => TripWaypoint.fromPartial(e)) || [];
    message.waypointsVersion = object.waypointsVersion ?? undefined;
    message.backToBackEnabled = object.backToBackEnabled ?? false;
    message.navigationStatus = object.navigationStatus ?? 0;
    message.deviceSettings = (object.deviceSettings !== undefined && object.deviceSettings !== null)
      ? DeviceSettings.fromPartial(object.deviceSettings)
      : undefined;
    return message;
  },
};

function createBaseVehicle_VehicleType(): Vehicle_VehicleType {
  return { category: 0 };
}

export const Vehicle_VehicleType: MessageFns<Vehicle_VehicleType> = {
  encode(message: Vehicle_VehicleType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.category !== 0) {
      writer.uint32(8).int32(message.category);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Vehicle_VehicleType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVehicle_VehicleType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.category = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Vehicle_VehicleType {
    return { category: isSet(object.category) ? vehicle_VehicleType_CategoryFromJSON(object.category) : 0 };
  },

  toJSON(message: Vehicle_VehicleType): unknown {
    const obj: any = {};
    if (message.category !== 0) {
      obj.category = vehicle_VehicleType_CategoryToJSON(message.category);
    }
    return obj;
  },

  create(base?: DeepPartial<Vehicle_VehicleType>): Vehicle_VehicleType {
    return Vehicle_VehicleType.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Vehicle_VehicleType>): Vehicle_VehicleType {
    const message = createBaseVehicle_VehicleType();
    message.category = object.category ?? 0;
    return message;
  },
};

function createBaseBatteryInfo(): BatteryInfo {
  return { batteryStatus: 0, powerSource: 0, batteryPercentage: 0 };
}

export const BatteryInfo: MessageFns<BatteryInfo> = {
  encode(message: BatteryInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.batteryStatus !== 0) {
      writer.uint32(8).int32(message.batteryStatus);
    }
    if (message.powerSource !== 0) {
      writer.uint32(16).int32(message.powerSource);
    }
    if (message.batteryPercentage !== 0) {
      writer.uint32(29).float(message.batteryPercentage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatteryInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatteryInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.batteryStatus = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.powerSource = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.batteryPercentage = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatteryInfo {
    return {
      batteryStatus: isSet(object.batteryStatus) ? batteryStatusFromJSON(object.batteryStatus) : 0,
      powerSource: isSet(object.powerSource) ? powerSourceFromJSON(object.powerSource) : 0,
      batteryPercentage: isSet(object.batteryPercentage) ? globalThis.Number(object.batteryPercentage) : 0,
    };
  },

  toJSON(message: BatteryInfo): unknown {
    const obj: any = {};
    if (message.batteryStatus !== 0) {
      obj.batteryStatus = batteryStatusToJSON(message.batteryStatus);
    }
    if (message.powerSource !== 0) {
      obj.powerSource = powerSourceToJSON(message.powerSource);
    }
    if (message.batteryPercentage !== 0) {
      obj.batteryPercentage = message.batteryPercentage;
    }
    return obj;
  },

  create(base?: DeepPartial<BatteryInfo>): BatteryInfo {
    return BatteryInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatteryInfo>): BatteryInfo {
    const message = createBaseBatteryInfo();
    message.batteryStatus = object.batteryStatus ?? 0;
    message.powerSource = object.powerSource ?? 0;
    message.batteryPercentage = object.batteryPercentage ?? 0;
    return message;
  },
};

function createBaseDeviceSettings(): DeviceSettings {
  return { locationPowerSaveMode: 0, isPowerSaveMode: false, isInteractive: false, batteryInfo: undefined };
}

export const DeviceSettings: MessageFns<DeviceSettings> = {
  encode(message: DeviceSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.locationPowerSaveMode !== 0) {
      writer.uint32(8).int32(message.locationPowerSaveMode);
    }
    if (message.isPowerSaveMode !== false) {
      writer.uint32(16).bool(message.isPowerSaveMode);
    }
    if (message.isInteractive !== false) {
      writer.uint32(24).bool(message.isInteractive);
    }
    if (message.batteryInfo !== undefined) {
      BatteryInfo.encode(message.batteryInfo, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeviceSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeviceSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.locationPowerSaveMode = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.isPowerSaveMode = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.isInteractive = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.batteryInfo = BatteryInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeviceSettings {
    return {
      locationPowerSaveMode: isSet(object.locationPowerSaveMode)
        ? locationPowerSaveModeFromJSON(object.locationPowerSaveMode)
        : 0,
      isPowerSaveMode: isSet(object.isPowerSaveMode) ? globalThis.Boolean(object.isPowerSaveMode) : false,
      isInteractive: isSet(object.isInteractive) ? globalThis.Boolean(object.isInteractive) : false,
      batteryInfo: isSet(object.batteryInfo) ? BatteryInfo.fromJSON(object.batteryInfo) : undefined,
    };
  },

  toJSON(message: DeviceSettings): unknown {
    const obj: any = {};
    if (message.locationPowerSaveMode !== 0) {
      obj.locationPowerSaveMode = locationPowerSaveModeToJSON(message.locationPowerSaveMode);
    }
    if (message.isPowerSaveMode !== false) {
      obj.isPowerSaveMode = message.isPowerSaveMode;
    }
    if (message.isInteractive !== false) {
      obj.isInteractive = message.isInteractive;
    }
    if (message.batteryInfo !== undefined) {
      obj.batteryInfo = BatteryInfo.toJSON(message.batteryInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<DeviceSettings>): DeviceSettings {
    return DeviceSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeviceSettings>): DeviceSettings {
    const message = createBaseDeviceSettings();
    message.locationPowerSaveMode = object.locationPowerSaveMode ?? 0;
    message.isPowerSaveMode = object.isPowerSaveMode ?? false;
    message.isInteractive = object.isInteractive ?? false;
    message.batteryInfo = (object.batteryInfo !== undefined && object.batteryInfo !== null)
      ? BatteryInfo.fromPartial(object.batteryInfo)
      : undefined;
    return message;
  },
};

function createBaseLicensePlate(): LicensePlate {
  return { countryCode: "", lastCharacter: "" };
}

export const LicensePlate: MessageFns<LicensePlate> = {
  encode(message: LicensePlate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.countryCode !== "") {
      writer.uint32(10).string(message.countryCode);
    }
    if (message.lastCharacter !== "") {
      writer.uint32(18).string(message.lastCharacter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LicensePlate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLicensePlate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.countryCode = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.lastCharacter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LicensePlate {
    return {
      countryCode: isSet(object.countryCode) ? globalThis.String(object.countryCode) : "",
      lastCharacter: isSet(object.lastCharacter) ? globalThis.String(object.lastCharacter) : "",
    };
  },

  toJSON(message: LicensePlate): unknown {
    const obj: any = {};
    if (message.countryCode !== "") {
      obj.countryCode = message.countryCode;
    }
    if (message.lastCharacter !== "") {
      obj.lastCharacter = message.lastCharacter;
    }
    return obj;
  },

  create(base?: DeepPartial<LicensePlate>): LicensePlate {
    return LicensePlate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LicensePlate>): LicensePlate {
    const message = createBaseLicensePlate();
    message.countryCode = object.countryCode ?? "";
    message.lastCharacter = object.lastCharacter ?? "";
    return message;
  },
};

function createBaseVisualTrafficReportPolylineRendering(): VisualTrafficReportPolylineRendering {
  return { roadStretch: [] };
}

export const VisualTrafficReportPolylineRendering: MessageFns<VisualTrafficReportPolylineRendering> = {
  encode(message: VisualTrafficReportPolylineRendering, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.roadStretch) {
      VisualTrafficReportPolylineRendering_RoadStretch.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VisualTrafficReportPolylineRendering {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVisualTrafficReportPolylineRendering();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.roadStretch.push(VisualTrafficReportPolylineRendering_RoadStretch.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VisualTrafficReportPolylineRendering {
    return {
      roadStretch: globalThis.Array.isArray(object?.roadStretch)
        ? object.roadStretch.map((e: any) => VisualTrafficReportPolylineRendering_RoadStretch.fromJSON(e))
        : [],
    };
  },

  toJSON(message: VisualTrafficReportPolylineRendering): unknown {
    const obj: any = {};
    if (message.roadStretch?.length) {
      obj.roadStretch = message.roadStretch.map((e) => VisualTrafficReportPolylineRendering_RoadStretch.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<VisualTrafficReportPolylineRendering>): VisualTrafficReportPolylineRendering {
    return VisualTrafficReportPolylineRendering.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VisualTrafficReportPolylineRendering>): VisualTrafficReportPolylineRendering {
    const message = createBaseVisualTrafficReportPolylineRendering();
    message.roadStretch =
      object.roadStretch?.map((e) => VisualTrafficReportPolylineRendering_RoadStretch.fromPartial(e)) || [];
    return message;
  },
};

function createBaseVisualTrafficReportPolylineRendering_RoadStretch(): VisualTrafficReportPolylineRendering_RoadStretch {
  return { style: 0, offsetMeters: 0, lengthMeters: 0 };
}

export const VisualTrafficReportPolylineRendering_RoadStretch: MessageFns<
  VisualTrafficReportPolylineRendering_RoadStretch
> = {
  encode(
    message: VisualTrafficReportPolylineRendering_RoadStretch,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.style !== 0) {
      writer.uint32(8).int32(message.style);
    }
    if (message.offsetMeters !== 0) {
      writer.uint32(16).int32(message.offsetMeters);
    }
    if (message.lengthMeters !== 0) {
      writer.uint32(24).int32(message.lengthMeters);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VisualTrafficReportPolylineRendering_RoadStretch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVisualTrafficReportPolylineRendering_RoadStretch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.style = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.offsetMeters = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.lengthMeters = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VisualTrafficReportPolylineRendering_RoadStretch {
    return {
      style: isSet(object.style) ? visualTrafficReportPolylineRendering_RoadStretch_StyleFromJSON(object.style) : 0,
      offsetMeters: isSet(object.offsetMeters) ? globalThis.Number(object.offsetMeters) : 0,
      lengthMeters: isSet(object.lengthMeters) ? globalThis.Number(object.lengthMeters) : 0,
    };
  },

  toJSON(message: VisualTrafficReportPolylineRendering_RoadStretch): unknown {
    const obj: any = {};
    if (message.style !== 0) {
      obj.style = visualTrafficReportPolylineRendering_RoadStretch_StyleToJSON(message.style);
    }
    if (message.offsetMeters !== 0) {
      obj.offsetMeters = Math.round(message.offsetMeters);
    }
    if (message.lengthMeters !== 0) {
      obj.lengthMeters = Math.round(message.lengthMeters);
    }
    return obj;
  },

  create(
    base?: DeepPartial<VisualTrafficReportPolylineRendering_RoadStretch>,
  ): VisualTrafficReportPolylineRendering_RoadStretch {
    return VisualTrafficReportPolylineRendering_RoadStretch.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<VisualTrafficReportPolylineRendering_RoadStretch>,
  ): VisualTrafficReportPolylineRendering_RoadStretch {
    const message = createBaseVisualTrafficReportPolylineRendering_RoadStretch();
    message.style = object.style ?? 0;
    message.offsetMeters = object.offsetMeters ?? 0;
    message.lengthMeters = object.lengthMeters ?? 0;
    return message;
  },
};

function createBaseTrafficPolylineData(): TrafficPolylineData {
  return { trafficRendering: undefined };
}

export const TrafficPolylineData: MessageFns<TrafficPolylineData> = {
  encode(message: TrafficPolylineData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trafficRendering !== undefined) {
      VisualTrafficReportPolylineRendering.encode(message.trafficRendering, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrafficPolylineData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrafficPolylineData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.trafficRendering = VisualTrafficReportPolylineRendering.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrafficPolylineData {
    return {
      trafficRendering: isSet(object.trafficRendering)
        ? VisualTrafficReportPolylineRendering.fromJSON(object.trafficRendering)
        : undefined,
    };
  },

  toJSON(message: TrafficPolylineData): unknown {
    const obj: any = {};
    if (message.trafficRendering !== undefined) {
      obj.trafficRendering = VisualTrafficReportPolylineRendering.toJSON(message.trafficRendering);
    }
    return obj;
  },

  create(base?: DeepPartial<TrafficPolylineData>): TrafficPolylineData {
    return TrafficPolylineData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TrafficPolylineData>): TrafficPolylineData {
    const message = createBaseTrafficPolylineData();
    message.trafficRendering = (object.trafficRendering !== undefined && object.trafficRendering !== null)
      ? VisualTrafficReportPolylineRendering.fromPartial(object.trafficRendering)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
