// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/maps/fleetengine/v1/trips.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../protobuf/duration.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Int32Value } from "../../../protobuf/wrappers.js";
import { LatLng } from "../../../type/latlng.js";
import {
  TerminalLocation,
  TripType,
  tripTypeFromJSON,
  tripTypeToJSON,
  TripWaypoint,
  VehicleLocation,
} from "./fleetengine.js";
import { ConsumableTrafficPolyline } from "./traffic.js";

export const protobufPackage = "maps.fleetengine.v1";

/** The status of a trip indicating its progression. */
export enum TripStatus {
  /** UNKNOWN_TRIP_STATUS - Default, used for unspecified or unrecognized trip status. */
  UNKNOWN_TRIP_STATUS = 0,
  /** NEW - Newly created trip. */
  NEW = 1,
  /** ENROUTE_TO_PICKUP - The driver is on their way to the pickup point. */
  ENROUTE_TO_PICKUP = 2,
  /** ARRIVED_AT_PICKUP - The driver has arrived at the pickup point. */
  ARRIVED_AT_PICKUP = 3,
  /**
   * ARRIVED_AT_INTERMEDIATE_DESTINATION - The driver has arrived at an intermediate destination and is waiting for
   * the rider.
   */
  ARRIVED_AT_INTERMEDIATE_DESTINATION = 7,
  /**
   * ENROUTE_TO_INTERMEDIATE_DESTINATION - The driver is on their way to an intermediate destination
   * (not the dropoff point).
   */
  ENROUTE_TO_INTERMEDIATE_DESTINATION = 8,
  /**
   * ENROUTE_TO_DROPOFF - The driver has picked up the rider and is on their way to the
   * next destination.
   */
  ENROUTE_TO_DROPOFF = 4,
  /** COMPLETE - The rider has been dropped off and the trip is complete. */
  COMPLETE = 5,
  /**
   * CANCELED - The trip was canceled prior to pickup by the driver, rider, or
   * rideshare provider.
   */
  CANCELED = 6,
  UNRECOGNIZED = -1,
}

export function tripStatusFromJSON(object: any): TripStatus {
  switch (object) {
    case 0:
    case "UNKNOWN_TRIP_STATUS":
      return TripStatus.UNKNOWN_TRIP_STATUS;
    case 1:
    case "NEW":
      return TripStatus.NEW;
    case 2:
    case "ENROUTE_TO_PICKUP":
      return TripStatus.ENROUTE_TO_PICKUP;
    case 3:
    case "ARRIVED_AT_PICKUP":
      return TripStatus.ARRIVED_AT_PICKUP;
    case 7:
    case "ARRIVED_AT_INTERMEDIATE_DESTINATION":
      return TripStatus.ARRIVED_AT_INTERMEDIATE_DESTINATION;
    case 8:
    case "ENROUTE_TO_INTERMEDIATE_DESTINATION":
      return TripStatus.ENROUTE_TO_INTERMEDIATE_DESTINATION;
    case 4:
    case "ENROUTE_TO_DROPOFF":
      return TripStatus.ENROUTE_TO_DROPOFF;
    case 5:
    case "COMPLETE":
      return TripStatus.COMPLETE;
    case 6:
    case "CANCELED":
      return TripStatus.CANCELED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TripStatus.UNRECOGNIZED;
  }
}

export function tripStatusToJSON(object: TripStatus): string {
  switch (object) {
    case TripStatus.UNKNOWN_TRIP_STATUS:
      return "UNKNOWN_TRIP_STATUS";
    case TripStatus.NEW:
      return "NEW";
    case TripStatus.ENROUTE_TO_PICKUP:
      return "ENROUTE_TO_PICKUP";
    case TripStatus.ARRIVED_AT_PICKUP:
      return "ARRIVED_AT_PICKUP";
    case TripStatus.ARRIVED_AT_INTERMEDIATE_DESTINATION:
      return "ARRIVED_AT_INTERMEDIATE_DESTINATION";
    case TripStatus.ENROUTE_TO_INTERMEDIATE_DESTINATION:
      return "ENROUTE_TO_INTERMEDIATE_DESTINATION";
    case TripStatus.ENROUTE_TO_DROPOFF:
      return "ENROUTE_TO_DROPOFF";
    case TripStatus.COMPLETE:
      return "COMPLETE";
    case TripStatus.CANCELED:
      return "CANCELED";
    case TripStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A set of values that indicate upon which platform the request was issued. */
export enum BillingPlatformIdentifier {
  /** BILLING_PLATFORM_IDENTIFIER_UNSPECIFIED - Default. Used for unspecified platforms. */
  BILLING_PLATFORM_IDENTIFIER_UNSPECIFIED = 0,
  /** SERVER - The platform is a client server. */
  SERVER = 1,
  /** WEB - The platform is a web browser. */
  WEB = 2,
  /** ANDROID - The platform is an Android mobile device. */
  ANDROID = 3,
  /** IOS - The platform is an IOS mobile device. */
  IOS = 4,
  /** OTHERS - Other platforms that are not listed in this enumeration. */
  OTHERS = 5,
  UNRECOGNIZED = -1,
}

export function billingPlatformIdentifierFromJSON(object: any): BillingPlatformIdentifier {
  switch (object) {
    case 0:
    case "BILLING_PLATFORM_IDENTIFIER_UNSPECIFIED":
      return BillingPlatformIdentifier.BILLING_PLATFORM_IDENTIFIER_UNSPECIFIED;
    case 1:
    case "SERVER":
      return BillingPlatformIdentifier.SERVER;
    case 2:
    case "WEB":
      return BillingPlatformIdentifier.WEB;
    case 3:
    case "ANDROID":
      return BillingPlatformIdentifier.ANDROID;
    case 4:
    case "IOS":
      return BillingPlatformIdentifier.IOS;
    case 5:
    case "OTHERS":
      return BillingPlatformIdentifier.OTHERS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BillingPlatformIdentifier.UNRECOGNIZED;
  }
}

export function billingPlatformIdentifierToJSON(object: BillingPlatformIdentifier): string {
  switch (object) {
    case BillingPlatformIdentifier.BILLING_PLATFORM_IDENTIFIER_UNSPECIFIED:
      return "BILLING_PLATFORM_IDENTIFIER_UNSPECIFIED";
    case BillingPlatformIdentifier.SERVER:
      return "SERVER";
    case BillingPlatformIdentifier.WEB:
      return "WEB";
    case BillingPlatformIdentifier.ANDROID:
      return "ANDROID";
    case BillingPlatformIdentifier.IOS:
      return "IOS";
    case BillingPlatformIdentifier.OTHERS:
      return "OTHERS";
    case BillingPlatformIdentifier.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Selector for different sets of Trip fields in a `GetTrip` response.  See
 * [AIP-157](https://google.aip.dev/157) for context. Additional views are
 * likely to be added.
 */
export enum TripView {
  /**
   * TRIP_VIEW_UNSPECIFIED - The default value. For backwards-compatibility, the API will default to an
   * SDK view. To ensure stability and support, customers are
   * advised to select a `TripView` other than `SDK`.
   */
  TRIP_VIEW_UNSPECIFIED = 0,
  /**
   * SDK - Includes fields that may not be interpretable or supportable using
   * publicly available libraries.
   */
  SDK = 1,
  /**
   * JOURNEY_SHARING_V1S - Trip fields are populated for the Journey Sharing use case. This view is
   * intended for server-to-server communications.
   */
  JOURNEY_SHARING_V1S = 2,
  UNRECOGNIZED = -1,
}

export function tripViewFromJSON(object: any): TripView {
  switch (object) {
    case 0:
    case "TRIP_VIEW_UNSPECIFIED":
      return TripView.TRIP_VIEW_UNSPECIFIED;
    case 1:
    case "SDK":
      return TripView.SDK;
    case 2:
    case "JOURNEY_SHARING_V1S":
      return TripView.JOURNEY_SHARING_V1S;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TripView.UNRECOGNIZED;
  }
}

export function tripViewToJSON(object: TripView): string {
  switch (object) {
    case TripView.TRIP_VIEW_UNSPECIFIED:
      return "TRIP_VIEW_UNSPECIFIED";
    case TripView.SDK:
      return "SDK";
    case TripView.JOURNEY_SHARING_V1S:
      return "JOURNEY_SHARING_V1S";
    case TripView.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Trip metadata. */
export interface Trip {
  /** Output only. In the format "providers/{provider}/trips/{trip}" */
  name: string;
  /** ID of the vehicle making this trip. */
  vehicleId: string;
  /** Current status of the trip. */
  tripStatus: TripStatus;
  /** The type of the trip. */
  tripType: TripType;
  /** Location where customer indicates they will be picked up. */
  pickupPoint:
    | TerminalLocation
    | undefined;
  /**
   * Input only. The actual location when and where customer was picked up.
   * This field is for provider to provide feedback on actual pickup
   * information.
   */
  actualPickupPoint:
    | StopLocation
    | undefined;
  /**
   * Input only. The actual time and location of the driver arrival at
   * the pickup point.
   * This field is for provider to provide feedback on actual arrival
   * information at the pickup point.
   */
  actualPickupArrivalPoint:
    | StopLocation
    | undefined;
  /**
   * Output only. Either the estimated future time when the rider(s) will be
   * picked up, or the actual time when they were picked up.
   */
  pickupTime:
    | Date
    | undefined;
  /**
   * Intermediate stops in order that the trip requests (in addition
   * to pickup and dropoff). Initially this will not be supported for shared
   * trips.
   */
  intermediateDestinations: TerminalLocation[];
  /**
   * Indicates the last time the `intermediate_destinations` was modified.
   * Your server should cache this value and pass it in `UpdateTripRequest`
   * when update `intermediate_destination_index` to ensure the
   * `intermediate_destinations` is not changed.
   */
  intermediateDestinationsVersion:
    | Date
    | undefined;
  /**
   * When `TripStatus` is `ENROUTE_TO_INTERMEDIATE_DESTINATION`, a number
   * between [0..N-1] indicating which intermediate destination the vehicle will
   * cross next. When `TripStatus` is `ARRIVED_AT_INTERMEDIATE_DESTINATION`, a
   * number between [0..N-1] indicating which intermediate destination the
   * vehicle is at. The provider sets this value. If there are no
   * `intermediate_destinations`, this field is ignored.
   */
  intermediateDestinationIndex: number;
  /**
   * Input only. The actual time and location of the driver's arrival at
   * an intermediate destination.
   * This field is for provider to provide feedback on actual arrival
   * information at intermediate destinations.
   */
  actualIntermediateDestinationArrivalPoints: StopLocation[];
  /**
   * Input only. The actual time and location when and where the customer was
   * picked up from an intermediate destination. This field is for provider to
   * provide feedback on actual pickup information at intermediate destinations.
   */
  actualIntermediateDestinations: StopLocation[];
  /** Location where customer indicates they will be dropped off. */
  dropoffPoint:
    | TerminalLocation
    | undefined;
  /**
   * Input only. The actual time and location when and where customer was
   * dropped off. This field is for provider to provide feedback on actual
   * dropoff information.
   */
  actualDropoffPoint:
    | StopLocation
    | undefined;
  /**
   * Output only. Either the estimated future time when the rider(s) will be
   * dropped off at the final destination, or the actual time when they were
   * dropped off.
   */
  dropoffTime:
    | Date
    | undefined;
  /**
   * Output only. The full path from the current location to the dropoff point,
   * inclusive. This path could include waypoints from other trips.
   */
  remainingWaypoints: TripWaypoint[];
  /**
   * This field supports manual ordering of the waypoints for the trip. It
   * contains all of the remaining waypoints for the assigned vehicle, as well
   * as the pickup and drop-off waypoints for this trip. If the trip hasn't been
   * assigned to a vehicle, then Fleet Engine ignores this field. For privacy
   * reasons, this field is only populated by the server on `UpdateTrip` and
   * `CreateTrip` calls, NOT on `GetTrip` calls.
   */
  vehicleWaypoints: TripWaypoint[];
  /**
   * Output only. Anticipated route for this trip to the first entry in
   * remaining_waypoints. Note that the first waypoint may belong to a different
   * trip.
   */
  route: LatLng[];
  /**
   * Output only. An encoded path to the next waypoint.
   *
   * Note: This field is intended only for use by the Driver SDK and Consumer
   * SDK. Decoding is not yet supported.
   */
  currentRouteSegment: string;
  /**
   * Output only. Indicates the last time the route was modified.
   *
   * Note: This field is intended only for use by the Driver SDK and Consumer
   * SDK.
   */
  currentRouteSegmentVersion:
    | Date
    | undefined;
  /**
   * Output only. Indicates the traffic conditions along the
   * `current_route_segment` when they're available.
   *
   * Note: This field is intended only for use by the Driver SDK and Consumer
   * SDK.
   */
  currentRouteSegmentTraffic:
    | ConsumableTrafficPolyline
    | undefined;
  /**
   * Output only. Indicates the last time the `current_route_segment_traffic`
   * was modified.
   *
   * Note: This field is intended only for use by the Driver SDK and Consumer
   * SDK.
   */
  currentRouteSegmentTrafficVersion:
    | Date
    | undefined;
  /** Output only. The waypoint where `current_route_segment` ends. */
  currentRouteSegmentEndPoint:
    | TripWaypoint
    | undefined;
  /**
   * Output only. The remaining driving distance in the `current_route_segment`
   * field. The value is unspecified if the trip is not assigned to a vehicle,
   * or the trip is completed or cancelled.
   */
  remainingDistanceMeters:
    | number
    | undefined;
  /**
   * Output only. The ETA to the next waypoint (the first entry in the
   * `remaining_waypoints` field). The value is unspecified if the trip is not
   * assigned to a vehicle, or the trip is inactive (completed or cancelled).
   */
  etaToFirstWaypoint:
    | Date
    | undefined;
  /**
   * Output only. The duration from when the Trip data is returned to the time
   * in `Trip.eta_to_first_waypoint`. The value is unspecified if the trip is
   * not assigned to a vehicle, or the trip is inactive (completed or
   * cancelled).
   */
  remainingTimeToFirstWaypoint:
    | Duration
    | undefined;
  /**
   * Output only. Indicates the last time that `remaining_waypoints` was changed
   * (a waypoint was added, removed, or changed).
   */
  remainingWaypointsVersion:
    | Date
    | undefined;
  /**
   * Output only. Indicates the last time the
   * `remaining_waypoints.path_to_waypoint` and
   * `remaining_waypoints.traffic_to_waypoint` were modified. Your client app
   * should cache this value and pass it in `GetTripRequest` to ensure the
   * paths and traffic for `remaining_waypoints` are only returned if updated.
   */
  remainingWaypointsRouteVersion:
    | Date
    | undefined;
  /**
   * Immutable. Indicates the number of passengers on this trip and does not
   * include the driver. A vehicle must have available capacity to be returned
   * in a `SearchVehicles` response.
   */
  numberOfPassengers: number;
  /**
   * Output only. Indicates the last reported location of the vehicle along the
   * route.
   */
  lastLocation:
    | VehicleLocation
    | undefined;
  /**
   * Output only. Indicates whether the vehicle's `last_location` can be snapped
   * to the current_route_segment. False if `last_location` or
   * `current_route_segment` doesn't exist.
   * It is computed by Fleet Engine. Any update from clients will be ignored.
   */
  lastLocationSnappable: boolean;
  /**
   * The subset of Trip fields that are populated and how they should be
   * interpreted.
   */
  view: TripView;
}

/** The actual location where a stop (pickup/dropoff) happened. */
export interface StopLocation {
  /** Required. Denotes the actual location. */
  point:
    | LatLng
    | undefined;
  /** Indicates when the stop happened. */
  timestamp:
    | Date
    | undefined;
  /**
   * Input only. Deprecated.  Use the timestamp field.
   *
   * @deprecated
   */
  stopTime: Date | undefined;
}

function createBaseTrip(): Trip {
  return {
    name: "",
    vehicleId: "",
    tripStatus: 0,
    tripType: 0,
    pickupPoint: undefined,
    actualPickupPoint: undefined,
    actualPickupArrivalPoint: undefined,
    pickupTime: undefined,
    intermediateDestinations: [],
    intermediateDestinationsVersion: undefined,
    intermediateDestinationIndex: 0,
    actualIntermediateDestinationArrivalPoints: [],
    actualIntermediateDestinations: [],
    dropoffPoint: undefined,
    actualDropoffPoint: undefined,
    dropoffTime: undefined,
    remainingWaypoints: [],
    vehicleWaypoints: [],
    route: [],
    currentRouteSegment: "",
    currentRouteSegmentVersion: undefined,
    currentRouteSegmentTraffic: undefined,
    currentRouteSegmentTrafficVersion: undefined,
    currentRouteSegmentEndPoint: undefined,
    remainingDistanceMeters: undefined,
    etaToFirstWaypoint: undefined,
    remainingTimeToFirstWaypoint: undefined,
    remainingWaypointsVersion: undefined,
    remainingWaypointsRouteVersion: undefined,
    numberOfPassengers: 0,
    lastLocation: undefined,
    lastLocationSnappable: false,
    view: 0,
  };
}

export const Trip: MessageFns<Trip> = {
  encode(message: Trip, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.vehicleId !== "") {
      writer.uint32(18).string(message.vehicleId);
    }
    if (message.tripStatus !== 0) {
      writer.uint32(24).int32(message.tripStatus);
    }
    if (message.tripType !== 0) {
      writer.uint32(32).int32(message.tripType);
    }
    if (message.pickupPoint !== undefined) {
      TerminalLocation.encode(message.pickupPoint, writer.uint32(42).fork()).join();
    }
    if (message.actualPickupPoint !== undefined) {
      StopLocation.encode(message.actualPickupPoint, writer.uint32(178).fork()).join();
    }
    if (message.actualPickupArrivalPoint !== undefined) {
      StopLocation.encode(message.actualPickupArrivalPoint, writer.uint32(258).fork()).join();
    }
    if (message.pickupTime !== undefined) {
      Timestamp.encode(toTimestamp(message.pickupTime), writer.uint32(50).fork()).join();
    }
    for (const v of message.intermediateDestinations) {
      TerminalLocation.encode(v!, writer.uint32(114).fork()).join();
    }
    if (message.intermediateDestinationsVersion !== undefined) {
      Timestamp.encode(toTimestamp(message.intermediateDestinationsVersion), writer.uint32(202).fork()).join();
    }
    if (message.intermediateDestinationIndex !== 0) {
      writer.uint32(120).int32(message.intermediateDestinationIndex);
    }
    for (const v of message.actualIntermediateDestinationArrivalPoints) {
      StopLocation.encode(v!, writer.uint32(266).fork()).join();
    }
    for (const v of message.actualIntermediateDestinations) {
      StopLocation.encode(v!, writer.uint32(274).fork()).join();
    }
    if (message.dropoffPoint !== undefined) {
      TerminalLocation.encode(message.dropoffPoint, writer.uint32(58).fork()).join();
    }
    if (message.actualDropoffPoint !== undefined) {
      StopLocation.encode(message.actualDropoffPoint, writer.uint32(186).fork()).join();
    }
    if (message.dropoffTime !== undefined) {
      Timestamp.encode(toTimestamp(message.dropoffTime), writer.uint32(66).fork()).join();
    }
    for (const v of message.remainingWaypoints) {
      TripWaypoint.encode(v!, writer.uint32(130).fork()).join();
    }
    for (const v of message.vehicleWaypoints) {
      TripWaypoint.encode(v!, writer.uint32(162).fork()).join();
    }
    for (const v of message.route) {
      LatLng.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.currentRouteSegment !== "") {
      writer.uint32(170).string(message.currentRouteSegment);
    }
    if (message.currentRouteSegmentVersion !== undefined) {
      Timestamp.encode(toTimestamp(message.currentRouteSegmentVersion), writer.uint32(138).fork()).join();
    }
    if (message.currentRouteSegmentTraffic !== undefined) {
      ConsumableTrafficPolyline.encode(message.currentRouteSegmentTraffic, writer.uint32(226).fork()).join();
    }
    if (message.currentRouteSegmentTrafficVersion !== undefined) {
      Timestamp.encode(toTimestamp(message.currentRouteSegmentTrafficVersion), writer.uint32(242).fork()).join();
    }
    if (message.currentRouteSegmentEndPoint !== undefined) {
      TripWaypoint.encode(message.currentRouteSegmentEndPoint, writer.uint32(194).fork()).join();
    }
    if (message.remainingDistanceMeters !== undefined) {
      Int32Value.encode({ value: message.remainingDistanceMeters! }, writer.uint32(98).fork()).join();
    }
    if (message.etaToFirstWaypoint !== undefined) {
      Timestamp.encode(toTimestamp(message.etaToFirstWaypoint), writer.uint32(106).fork()).join();
    }
    if (message.remainingTimeToFirstWaypoint !== undefined) {
      Duration.encode(message.remainingTimeToFirstWaypoint, writer.uint32(218).fork()).join();
    }
    if (message.remainingWaypointsVersion !== undefined) {
      Timestamp.encode(toTimestamp(message.remainingWaypointsVersion), writer.uint32(154).fork()).join();
    }
    if (message.remainingWaypointsRouteVersion !== undefined) {
      Timestamp.encode(toTimestamp(message.remainingWaypointsRouteVersion), writer.uint32(234).fork()).join();
    }
    if (message.numberOfPassengers !== 0) {
      writer.uint32(80).int32(message.numberOfPassengers);
    }
    if (message.lastLocation !== undefined) {
      VehicleLocation.encode(message.lastLocation, writer.uint32(90).fork()).join();
    }
    if (message.lastLocationSnappable !== false) {
      writer.uint32(208).bool(message.lastLocationSnappable);
    }
    if (message.view !== 0) {
      writer.uint32(248).int32(message.view);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Trip {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrip();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.vehicleId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.tripStatus = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.tripType = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.pickupPoint = TerminalLocation.decode(reader, reader.uint32());
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.actualPickupPoint = StopLocation.decode(reader, reader.uint32());
          continue;
        case 32:
          if (tag !== 258) {
            break;
          }

          message.actualPickupArrivalPoint = StopLocation.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.pickupTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.intermediateDestinations.push(TerminalLocation.decode(reader, reader.uint32()));
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.intermediateDestinationsVersion = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.intermediateDestinationIndex = reader.int32();
          continue;
        case 33:
          if (tag !== 266) {
            break;
          }

          message.actualIntermediateDestinationArrivalPoints.push(StopLocation.decode(reader, reader.uint32()));
          continue;
        case 34:
          if (tag !== 274) {
            break;
          }

          message.actualIntermediateDestinations.push(StopLocation.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.dropoffPoint = TerminalLocation.decode(reader, reader.uint32());
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.actualDropoffPoint = StopLocation.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.dropoffTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.remainingWaypoints.push(TripWaypoint.decode(reader, reader.uint32()));
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.vehicleWaypoints.push(TripWaypoint.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.route.push(LatLng.decode(reader, reader.uint32()));
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.currentRouteSegment = reader.string();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.currentRouteSegmentVersion = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }

          message.currentRouteSegmentTraffic = ConsumableTrafficPolyline.decode(reader, reader.uint32());
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }

          message.currentRouteSegmentTrafficVersion = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.currentRouteSegmentEndPoint = TripWaypoint.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.remainingDistanceMeters = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.etaToFirstWaypoint = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }

          message.remainingTimeToFirstWaypoint = Duration.decode(reader, reader.uint32());
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.remainingWaypointsVersion = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }

          message.remainingWaypointsRouteVersion = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.numberOfPassengers = reader.int32();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.lastLocation = VehicleLocation.decode(reader, reader.uint32());
          continue;
        case 26:
          if (tag !== 208) {
            break;
          }

          message.lastLocationSnappable = reader.bool();
          continue;
        case 31:
          if (tag !== 248) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Trip {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      vehicleId: isSet(object.vehicleId) ? globalThis.String(object.vehicleId) : "",
      tripStatus: isSet(object.tripStatus) ? tripStatusFromJSON(object.tripStatus) : 0,
      tripType: isSet(object.tripType) ? tripTypeFromJSON(object.tripType) : 0,
      pickupPoint: isSet(object.pickupPoint) ? TerminalLocation.fromJSON(object.pickupPoint) : undefined,
      actualPickupPoint: isSet(object.actualPickupPoint) ? StopLocation.fromJSON(object.actualPickupPoint) : undefined,
      actualPickupArrivalPoint: isSet(object.actualPickupArrivalPoint)
        ? StopLocation.fromJSON(object.actualPickupArrivalPoint)
        : undefined,
      pickupTime: isSet(object.pickupTime) ? fromJsonTimestamp(object.pickupTime) : undefined,
      intermediateDestinations: globalThis.Array.isArray(object?.intermediateDestinations)
        ? object.intermediateDestinations.map((e: any) => TerminalLocation.fromJSON(e))
        : [],
      intermediateDestinationsVersion: isSet(object.intermediateDestinationsVersion)
        ? fromJsonTimestamp(object.intermediateDestinationsVersion)
        : undefined,
      intermediateDestinationIndex: isSet(object.intermediateDestinationIndex)
        ? globalThis.Number(object.intermediateDestinationIndex)
        : 0,
      actualIntermediateDestinationArrivalPoints:
        globalThis.Array.isArray(object?.actualIntermediateDestinationArrivalPoints)
          ? object.actualIntermediateDestinationArrivalPoints.map((e: any) => StopLocation.fromJSON(e))
          : [],
      actualIntermediateDestinations: globalThis.Array.isArray(object?.actualIntermediateDestinations)
        ? object.actualIntermediateDestinations.map((e: any) => StopLocation.fromJSON(e))
        : [],
      dropoffPoint: isSet(object.dropoffPoint) ? TerminalLocation.fromJSON(object.dropoffPoint) : undefined,
      actualDropoffPoint: isSet(object.actualDropoffPoint)
        ? StopLocation.fromJSON(object.actualDropoffPoint)
        : undefined,
      dropoffTime: isSet(object.dropoffTime) ? fromJsonTimestamp(object.dropoffTime) : undefined,
      remainingWaypoints: globalThis.Array.isArray(object?.remainingWaypoints)
        ? object.remainingWaypoints.map((e: any) => TripWaypoint.fromJSON(e))
        : [],
      vehicleWaypoints: globalThis.Array.isArray(object?.vehicleWaypoints)
        ? object.vehicleWaypoints.map((e: any) => TripWaypoint.fromJSON(e))
        : [],
      route: globalThis.Array.isArray(object?.route) ? object.route.map((e: any) => LatLng.fromJSON(e)) : [],
      currentRouteSegment: isSet(object.currentRouteSegment) ? globalThis.String(object.currentRouteSegment) : "",
      currentRouteSegmentVersion: isSet(object.currentRouteSegmentVersion)
        ? fromJsonTimestamp(object.currentRouteSegmentVersion)
        : undefined,
      currentRouteSegmentTraffic: isSet(object.currentRouteSegmentTraffic)
        ? ConsumableTrafficPolyline.fromJSON(object.currentRouteSegmentTraffic)
        : undefined,
      currentRouteSegmentTrafficVersion: isSet(object.currentRouteSegmentTrafficVersion)
        ? fromJsonTimestamp(object.currentRouteSegmentTrafficVersion)
        : undefined,
      currentRouteSegmentEndPoint: isSet(object.currentRouteSegmentEndPoint)
        ? TripWaypoint.fromJSON(object.currentRouteSegmentEndPoint)
        : undefined,
      remainingDistanceMeters: isSet(object.remainingDistanceMeters)
        ? Number(object.remainingDistanceMeters)
        : undefined,
      etaToFirstWaypoint: isSet(object.etaToFirstWaypoint) ? fromJsonTimestamp(object.etaToFirstWaypoint) : undefined,
      remainingTimeToFirstWaypoint: isSet(object.remainingTimeToFirstWaypoint)
        ? Duration.fromJSON(object.remainingTimeToFirstWaypoint)
        : undefined,
      remainingWaypointsVersion: isSet(object.remainingWaypointsVersion)
        ? fromJsonTimestamp(object.remainingWaypointsVersion)
        : undefined,
      remainingWaypointsRouteVersion: isSet(object.remainingWaypointsRouteVersion)
        ? fromJsonTimestamp(object.remainingWaypointsRouteVersion)
        : undefined,
      numberOfPassengers: isSet(object.numberOfPassengers) ? globalThis.Number(object.numberOfPassengers) : 0,
      lastLocation: isSet(object.lastLocation) ? VehicleLocation.fromJSON(object.lastLocation) : undefined,
      lastLocationSnappable: isSet(object.lastLocationSnappable)
        ? globalThis.Boolean(object.lastLocationSnappable)
        : false,
      view: isSet(object.view) ? tripViewFromJSON(object.view) : 0,
    };
  },

  toJSON(message: Trip): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.vehicleId !== "") {
      obj.vehicleId = message.vehicleId;
    }
    if (message.tripStatus !== 0) {
      obj.tripStatus = tripStatusToJSON(message.tripStatus);
    }
    if (message.tripType !== 0) {
      obj.tripType = tripTypeToJSON(message.tripType);
    }
    if (message.pickupPoint !== undefined) {
      obj.pickupPoint = TerminalLocation.toJSON(message.pickupPoint);
    }
    if (message.actualPickupPoint !== undefined) {
      obj.actualPickupPoint = StopLocation.toJSON(message.actualPickupPoint);
    }
    if (message.actualPickupArrivalPoint !== undefined) {
      obj.actualPickupArrivalPoint = StopLocation.toJSON(message.actualPickupArrivalPoint);
    }
    if (message.pickupTime !== undefined) {
      obj.pickupTime = message.pickupTime.toISOString();
    }
    if (message.intermediateDestinations?.length) {
      obj.intermediateDestinations = message.intermediateDestinations.map((e) => TerminalLocation.toJSON(e));
    }
    if (message.intermediateDestinationsVersion !== undefined) {
      obj.intermediateDestinationsVersion = message.intermediateDestinationsVersion.toISOString();
    }
    if (message.intermediateDestinationIndex !== 0) {
      obj.intermediateDestinationIndex = Math.round(message.intermediateDestinationIndex);
    }
    if (message.actualIntermediateDestinationArrivalPoints?.length) {
      obj.actualIntermediateDestinationArrivalPoints = message.actualIntermediateDestinationArrivalPoints.map((e) =>
        StopLocation.toJSON(e)
      );
    }
    if (message.actualIntermediateDestinations?.length) {
      obj.actualIntermediateDestinations = message.actualIntermediateDestinations.map((e) => StopLocation.toJSON(e));
    }
    if (message.dropoffPoint !== undefined) {
      obj.dropoffPoint = TerminalLocation.toJSON(message.dropoffPoint);
    }
    if (message.actualDropoffPoint !== undefined) {
      obj.actualDropoffPoint = StopLocation.toJSON(message.actualDropoffPoint);
    }
    if (message.dropoffTime !== undefined) {
      obj.dropoffTime = message.dropoffTime.toISOString();
    }
    if (message.remainingWaypoints?.length) {
      obj.remainingWaypoints = message.remainingWaypoints.map((e) => TripWaypoint.toJSON(e));
    }
    if (message.vehicleWaypoints?.length) {
      obj.vehicleWaypoints = message.vehicleWaypoints.map((e) => TripWaypoint.toJSON(e));
    }
    if (message.route?.length) {
      obj.route = message.route.map((e) => LatLng.toJSON(e));
    }
    if (message.currentRouteSegment !== "") {
      obj.currentRouteSegment = message.currentRouteSegment;
    }
    if (message.currentRouteSegmentVersion !== undefined) {
      obj.currentRouteSegmentVersion = message.currentRouteSegmentVersion.toISOString();
    }
    if (message.currentRouteSegmentTraffic !== undefined) {
      obj.currentRouteSegmentTraffic = ConsumableTrafficPolyline.toJSON(message.currentRouteSegmentTraffic);
    }
    if (message.currentRouteSegmentTrafficVersion !== undefined) {
      obj.currentRouteSegmentTrafficVersion = message.currentRouteSegmentTrafficVersion.toISOString();
    }
    if (message.currentRouteSegmentEndPoint !== undefined) {
      obj.currentRouteSegmentEndPoint = TripWaypoint.toJSON(message.currentRouteSegmentEndPoint);
    }
    if (message.remainingDistanceMeters !== undefined) {
      obj.remainingDistanceMeters = message.remainingDistanceMeters;
    }
    if (message.etaToFirstWaypoint !== undefined) {
      obj.etaToFirstWaypoint = message.etaToFirstWaypoint.toISOString();
    }
    if (message.remainingTimeToFirstWaypoint !== undefined) {
      obj.remainingTimeToFirstWaypoint = Duration.toJSON(message.remainingTimeToFirstWaypoint);
    }
    if (message.remainingWaypointsVersion !== undefined) {
      obj.remainingWaypointsVersion = message.remainingWaypointsVersion.toISOString();
    }
    if (message.remainingWaypointsRouteVersion !== undefined) {
      obj.remainingWaypointsRouteVersion = message.remainingWaypointsRouteVersion.toISOString();
    }
    if (message.numberOfPassengers !== 0) {
      obj.numberOfPassengers = Math.round(message.numberOfPassengers);
    }
    if (message.lastLocation !== undefined) {
      obj.lastLocation = VehicleLocation.toJSON(message.lastLocation);
    }
    if (message.lastLocationSnappable !== false) {
      obj.lastLocationSnappable = message.lastLocationSnappable;
    }
    if (message.view !== 0) {
      obj.view = tripViewToJSON(message.view);
    }
    return obj;
  },

  create(base?: DeepPartial<Trip>): Trip {
    return Trip.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Trip>): Trip {
    const message = createBaseTrip();
    message.name = object.name ?? "";
    message.vehicleId = object.vehicleId ?? "";
    message.tripStatus = object.tripStatus ?? 0;
    message.tripType = object.tripType ?? 0;
    message.pickupPoint = (object.pickupPoint !== undefined && object.pickupPoint !== null)
      ? TerminalLocation.fromPartial(object.pickupPoint)
      : undefined;
    message.actualPickupPoint = (object.actualPickupPoint !== undefined && object.actualPickupPoint !== null)
      ? StopLocation.fromPartial(object.actualPickupPoint)
      : undefined;
    message.actualPickupArrivalPoint =
      (object.actualPickupArrivalPoint !== undefined && object.actualPickupArrivalPoint !== null)
        ? StopLocation.fromPartial(object.actualPickupArrivalPoint)
        : undefined;
    message.pickupTime = object.pickupTime ?? undefined;
    message.intermediateDestinations = object.intermediateDestinations?.map((e) => TerminalLocation.fromPartial(e)) ||
      [];
    message.intermediateDestinationsVersion = object.intermediateDestinationsVersion ?? undefined;
    message.intermediateDestinationIndex = object.intermediateDestinationIndex ?? 0;
    message.actualIntermediateDestinationArrivalPoints =
      object.actualIntermediateDestinationArrivalPoints?.map((e) => StopLocation.fromPartial(e)) || [];
    message.actualIntermediateDestinations =
      object.actualIntermediateDestinations?.map((e) => StopLocation.fromPartial(e)) || [];
    message.dropoffPoint = (object.dropoffPoint !== undefined && object.dropoffPoint !== null)
      ? TerminalLocation.fromPartial(object.dropoffPoint)
      : undefined;
    message.actualDropoffPoint = (object.actualDropoffPoint !== undefined && object.actualDropoffPoint !== null)
      ? StopLocation.fromPartial(object.actualDropoffPoint)
      : undefined;
    message.dropoffTime = object.dropoffTime ?? undefined;
    message.remainingWaypoints = object.remainingWaypoints?.map((e) => TripWaypoint.fromPartial(e)) || [];
    message.vehicleWaypoints = object.vehicleWaypoints?.map((e) => TripWaypoint.fromPartial(e)) || [];
    message.route = object.route?.map((e) => LatLng.fromPartial(e)) || [];
    message.currentRouteSegment = object.currentRouteSegment ?? "";
    message.currentRouteSegmentVersion = object.currentRouteSegmentVersion ?? undefined;
    message.currentRouteSegmentTraffic =
      (object.currentRouteSegmentTraffic !== undefined && object.currentRouteSegmentTraffic !== null)
        ? ConsumableTrafficPolyline.fromPartial(object.currentRouteSegmentTraffic)
        : undefined;
    message.currentRouteSegmentTrafficVersion = object.currentRouteSegmentTrafficVersion ?? undefined;
    message.currentRouteSegmentEndPoint =
      (object.currentRouteSegmentEndPoint !== undefined && object.currentRouteSegmentEndPoint !== null)
        ? TripWaypoint.fromPartial(object.currentRouteSegmentEndPoint)
        : undefined;
    message.remainingDistanceMeters = object.remainingDistanceMeters ?? undefined;
    message.etaToFirstWaypoint = object.etaToFirstWaypoint ?? undefined;
    message.remainingTimeToFirstWaypoint =
      (object.remainingTimeToFirstWaypoint !== undefined && object.remainingTimeToFirstWaypoint !== null)
        ? Duration.fromPartial(object.remainingTimeToFirstWaypoint)
        : undefined;
    message.remainingWaypointsVersion = object.remainingWaypointsVersion ?? undefined;
    message.remainingWaypointsRouteVersion = object.remainingWaypointsRouteVersion ?? undefined;
    message.numberOfPassengers = object.numberOfPassengers ?? 0;
    message.lastLocation = (object.lastLocation !== undefined && object.lastLocation !== null)
      ? VehicleLocation.fromPartial(object.lastLocation)
      : undefined;
    message.lastLocationSnappable = object.lastLocationSnappable ?? false;
    message.view = object.view ?? 0;
    return message;
  },
};

function createBaseStopLocation(): StopLocation {
  return { point: undefined, timestamp: undefined, stopTime: undefined };
}

export const StopLocation: MessageFns<StopLocation> = {
  encode(message: StopLocation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.point !== undefined) {
      LatLng.encode(message.point, writer.uint32(10).fork()).join();
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(18).fork()).join();
    }
    if (message.stopTime !== undefined) {
      Timestamp.encode(toTimestamp(message.stopTime), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StopLocation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStopLocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.point = LatLng.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.stopTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StopLocation {
    return {
      point: isSet(object.point) ? LatLng.fromJSON(object.point) : undefined,
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      stopTime: isSet(object.stopTime) ? fromJsonTimestamp(object.stopTime) : undefined,
    };
  },

  toJSON(message: StopLocation): unknown {
    const obj: any = {};
    if (message.point !== undefined) {
      obj.point = LatLng.toJSON(message.point);
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.stopTime !== undefined) {
      obj.stopTime = message.stopTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<StopLocation>): StopLocation {
    return StopLocation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StopLocation>): StopLocation {
    const message = createBaseStopLocation();
    message.point = (object.point !== undefined && object.point !== null)
      ? LatLng.fromPartial(object.point)
      : undefined;
    message.timestamp = object.timestamp ?? undefined;
    message.stopTime = object.stopTime ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
