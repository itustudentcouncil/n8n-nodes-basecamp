// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/maps/fleetengine/v1/fleetengine.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../protobuf/duration.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { BoolValue, DoubleValue, Int32Value } from "../../../protobuf/wrappers.js";
import { LatLng } from "../../../type/latlng.js";
import { ConsumableTrafficPolyline } from "./traffic.js";

export const protobufPackage = "maps.fleetengine.v1";

/** The type of a trip. */
export enum TripType {
  /** UNKNOWN_TRIP_TYPE - Default, used for unspecified or unrecognized trip types. */
  UNKNOWN_TRIP_TYPE = 0,
  /** SHARED - The trip may share a vehicle with other trips. */
  SHARED = 1,
  /** EXCLUSIVE - The trip is exclusive to a vehicle. */
  EXCLUSIVE = 2,
  UNRECOGNIZED = -1,
}

export function tripTypeFromJSON(object: any): TripType {
  switch (object) {
    case 0:
    case "UNKNOWN_TRIP_TYPE":
      return TripType.UNKNOWN_TRIP_TYPE;
    case 1:
    case "SHARED":
      return TripType.SHARED;
    case 2:
    case "EXCLUSIVE":
      return TripType.EXCLUSIVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TripType.UNRECOGNIZED;
  }
}

export function tripTypeToJSON(object: TripType): string {
  switch (object) {
    case TripType.UNKNOWN_TRIP_TYPE:
      return "UNKNOWN_TRIP_TYPE";
    case TripType.SHARED:
      return "SHARED";
    case TripType.EXCLUSIVE:
      return "EXCLUSIVE";
    case TripType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The type of waypoint. */
export enum WaypointType {
  /** UNKNOWN_WAYPOINT_TYPE - Unknown or unspecified waypoint type. */
  UNKNOWN_WAYPOINT_TYPE = 0,
  /** PICKUP_WAYPOINT_TYPE - Waypoints for picking up riders or items. */
  PICKUP_WAYPOINT_TYPE = 1,
  /** DROP_OFF_WAYPOINT_TYPE - Waypoints for dropping off riders or items. */
  DROP_OFF_WAYPOINT_TYPE = 2,
  /** INTERMEDIATE_DESTINATION_WAYPOINT_TYPE - Waypoints for intermediate destinations in a multi-destination trip. */
  INTERMEDIATE_DESTINATION_WAYPOINT_TYPE = 3,
  UNRECOGNIZED = -1,
}

export function waypointTypeFromJSON(object: any): WaypointType {
  switch (object) {
    case 0:
    case "UNKNOWN_WAYPOINT_TYPE":
      return WaypointType.UNKNOWN_WAYPOINT_TYPE;
    case 1:
    case "PICKUP_WAYPOINT_TYPE":
      return WaypointType.PICKUP_WAYPOINT_TYPE;
    case 2:
    case "DROP_OFF_WAYPOINT_TYPE":
      return WaypointType.DROP_OFF_WAYPOINT_TYPE;
    case 3:
    case "INTERMEDIATE_DESTINATION_WAYPOINT_TYPE":
      return WaypointType.INTERMEDIATE_DESTINATION_WAYPOINT_TYPE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WaypointType.UNRECOGNIZED;
  }
}

export function waypointTypeToJSON(object: WaypointType): string {
  switch (object) {
    case WaypointType.UNKNOWN_WAYPOINT_TYPE:
      return "UNKNOWN_WAYPOINT_TYPE";
    case WaypointType.PICKUP_WAYPOINT_TYPE:
      return "PICKUP_WAYPOINT_TYPE";
    case WaypointType.DROP_OFF_WAYPOINT_TYPE:
      return "DROP_OFF_WAYPOINT_TYPE";
    case WaypointType.INTERMEDIATE_DESTINATION_WAYPOINT_TYPE:
      return "INTERMEDIATE_DESTINATION_WAYPOINT_TYPE";
    case WaypointType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The type of polyline format. */
export enum PolylineFormatType {
  /** UNKNOWN_FORMAT_TYPE - The format is unspecified or unknown. */
  UNKNOWN_FORMAT_TYPE = 0,
  /** LAT_LNG_LIST_TYPE - A list of `google.type.LatLng`. */
  LAT_LNG_LIST_TYPE = 1,
  /**
   * ENCODED_POLYLINE_TYPE - A polyline encoded with a polyline compression algorithm. Decoding is not
   * yet supported.
   */
  ENCODED_POLYLINE_TYPE = 2,
  UNRECOGNIZED = -1,
}

export function polylineFormatTypeFromJSON(object: any): PolylineFormatType {
  switch (object) {
    case 0:
    case "UNKNOWN_FORMAT_TYPE":
      return PolylineFormatType.UNKNOWN_FORMAT_TYPE;
    case 1:
    case "LAT_LNG_LIST_TYPE":
      return PolylineFormatType.LAT_LNG_LIST_TYPE;
    case 2:
    case "ENCODED_POLYLINE_TYPE":
      return PolylineFormatType.ENCODED_POLYLINE_TYPE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PolylineFormatType.UNRECOGNIZED;
  }
}

export function polylineFormatTypeToJSON(object: PolylineFormatType): string {
  switch (object) {
    case PolylineFormatType.UNKNOWN_FORMAT_TYPE:
      return "UNKNOWN_FORMAT_TYPE";
    case PolylineFormatType.LAT_LNG_LIST_TYPE:
      return "LAT_LNG_LIST_TYPE";
    case PolylineFormatType.ENCODED_POLYLINE_TYPE:
      return "ENCODED_POLYLINE_TYPE";
    case PolylineFormatType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The vehicle's navigation status. */
export enum NavigationStatus {
  /** UNKNOWN_NAVIGATION_STATUS - Unspecified navigation status. */
  UNKNOWN_NAVIGATION_STATUS = 0,
  /** NO_GUIDANCE - The Driver app's navigation is in `FREE_NAV` mode. */
  NO_GUIDANCE = 1,
  /**
   * ENROUTE_TO_DESTINATION - Turn-by-turn navigation is available and the Driver app navigation has
   * entered `GUIDED_NAV` mode.
   */
  ENROUTE_TO_DESTINATION = 2,
  /** OFF_ROUTE - The vehicle has gone off the suggested route. */
  OFF_ROUTE = 3,
  /** ARRIVED_AT_DESTINATION - The vehicle is within approximately 50m of the destination. */
  ARRIVED_AT_DESTINATION = 4,
  UNRECOGNIZED = -1,
}

export function navigationStatusFromJSON(object: any): NavigationStatus {
  switch (object) {
    case 0:
    case "UNKNOWN_NAVIGATION_STATUS":
      return NavigationStatus.UNKNOWN_NAVIGATION_STATUS;
    case 1:
    case "NO_GUIDANCE":
      return NavigationStatus.NO_GUIDANCE;
    case 2:
    case "ENROUTE_TO_DESTINATION":
      return NavigationStatus.ENROUTE_TO_DESTINATION;
    case 3:
    case "OFF_ROUTE":
      return NavigationStatus.OFF_ROUTE;
    case 4:
    case "ARRIVED_AT_DESTINATION":
      return NavigationStatus.ARRIVED_AT_DESTINATION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NavigationStatus.UNRECOGNIZED;
  }
}

export function navigationStatusToJSON(object: NavigationStatus): string {
  switch (object) {
    case NavigationStatus.UNKNOWN_NAVIGATION_STATUS:
      return "UNKNOWN_NAVIGATION_STATUS";
    case NavigationStatus.NO_GUIDANCE:
      return "NO_GUIDANCE";
    case NavigationStatus.ENROUTE_TO_DESTINATION:
      return "ENROUTE_TO_DESTINATION";
    case NavigationStatus.OFF_ROUTE:
      return "OFF_ROUTE";
    case NavigationStatus.ARRIVED_AT_DESTINATION:
      return "ARRIVED_AT_DESTINATION";
    case NavigationStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The sensor or methodology used to determine the location. */
export enum LocationSensor {
  /** UNKNOWN_SENSOR - The sensor is unspecified or unknown. */
  UNKNOWN_SENSOR = 0,
  /** GPS - GPS or Assisted GPS. */
  GPS = 1,
  /** NETWORK - Assisted GPS, cell tower ID, or WiFi access point. */
  NETWORK = 2,
  /** PASSIVE - Cell tower ID or WiFi access point. */
  PASSIVE = 3,
  /**
   * ROAD_SNAPPED_LOCATION_PROVIDER - A location determined by the mobile device to be the most likely
   * road position.
   */
  ROAD_SNAPPED_LOCATION_PROVIDER = 4,
  /**
   * CUSTOMER_SUPPLIED_LOCATION - A customer-supplied location from an independent source.  Typically, this
   * value is used for a location provided from sources other than the mobile
   * device running Driver SDK.  If the original source is described by one of
   * the other enum values, use that value. Locations marked
   * CUSTOMER_SUPPLIED_LOCATION are typically provided via a Vehicle's
   * `last_location.supplemental_location_sensor`.
   */
  CUSTOMER_SUPPLIED_LOCATION = 5,
  /**
   * FLEET_ENGINE_LOCATION - A location calculated by Fleet Engine based on the signals available to it.
   * Output only. This value will be rejected if it is received in a request.
   */
  FLEET_ENGINE_LOCATION = 6,
  /** FUSED_LOCATION_PROVIDER - Android's Fused Location Provider. */
  FUSED_LOCATION_PROVIDER = 100,
  /** CORE_LOCATION - The location provider on Apple operating systems. */
  CORE_LOCATION = 200,
  UNRECOGNIZED = -1,
}

export function locationSensorFromJSON(object: any): LocationSensor {
  switch (object) {
    case 0:
    case "UNKNOWN_SENSOR":
      return LocationSensor.UNKNOWN_SENSOR;
    case 1:
    case "GPS":
      return LocationSensor.GPS;
    case 2:
    case "NETWORK":
      return LocationSensor.NETWORK;
    case 3:
    case "PASSIVE":
      return LocationSensor.PASSIVE;
    case 4:
    case "ROAD_SNAPPED_LOCATION_PROVIDER":
      return LocationSensor.ROAD_SNAPPED_LOCATION_PROVIDER;
    case 5:
    case "CUSTOMER_SUPPLIED_LOCATION":
      return LocationSensor.CUSTOMER_SUPPLIED_LOCATION;
    case 6:
    case "FLEET_ENGINE_LOCATION":
      return LocationSensor.FLEET_ENGINE_LOCATION;
    case 100:
    case "FUSED_LOCATION_PROVIDER":
      return LocationSensor.FUSED_LOCATION_PROVIDER;
    case 200:
    case "CORE_LOCATION":
      return LocationSensor.CORE_LOCATION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LocationSensor.UNRECOGNIZED;
  }
}

export function locationSensorToJSON(object: LocationSensor): string {
  switch (object) {
    case LocationSensor.UNKNOWN_SENSOR:
      return "UNKNOWN_SENSOR";
    case LocationSensor.GPS:
      return "GPS";
    case LocationSensor.NETWORK:
      return "NETWORK";
    case LocationSensor.PASSIVE:
      return "PASSIVE";
    case LocationSensor.ROAD_SNAPPED_LOCATION_PROVIDER:
      return "ROAD_SNAPPED_LOCATION_PROVIDER";
    case LocationSensor.CUSTOMER_SUPPLIED_LOCATION:
      return "CUSTOMER_SUPPLIED_LOCATION";
    case LocationSensor.FLEET_ENGINE_LOCATION:
      return "FLEET_ENGINE_LOCATION";
    case LocationSensor.FUSED_LOCATION_PROVIDER:
      return "FUSED_LOCATION_PROVIDER";
    case LocationSensor.CORE_LOCATION:
      return "CORE_LOCATION";
    case LocationSensor.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Deprecated: TerminalPoints are no longer supported in Fleet Engine. Use
 * `TerminalLocation.point` instead.
 *
 * @deprecated
 */
export interface TerminalPointId {
  /**
   * Deprecated.
   *
   * @deprecated
   */
  placeId?:
    | string
    | undefined;
  /**
   * Deprecated.
   *
   * @deprecated
   */
  generatedId?:
    | string
    | undefined;
  /**
   * Deprecated.
   *
   * @deprecated
   */
  value: string;
}

/** Describes the location of a waypoint. */
export interface TerminalLocation {
  /** Required. Denotes the location of a trip waypoint. */
  point:
    | LatLng
    | undefined;
  /**
   * Deprecated: Specify the `point` field instead.
   *
   * @deprecated
   */
  terminalPointId:
    | TerminalPointId
    | undefined;
  /**
   * Deprecated: Specify the `point` field instead.
   *
   * @deprecated
   */
  accessPointId: string;
  /**
   * Deprecated.
   *
   * @deprecated
   */
  tripId: string;
  /**
   * Deprecated: `Vehicle.waypoint` will have this data.
   *
   * @deprecated
   */
  terminalLocationType: WaypointType;
}

/**
 * Describes a stopping point on a vehicle's route or an ending point on a
 * vehicle's trip.
 */
export interface TripWaypoint {
  /** The location of this waypoint. */
  location:
    | TerminalLocation
    | undefined;
  /** The trip associated with this waypoint. */
  tripId: string;
  /** The role this waypoint plays in this trip, such as pickup or dropoff. */
  waypointType: WaypointType;
  /**
   * The path from the previous waypoint to the current waypoint.  Undefined for
   * the first waypoint in a list. This field is only populated when requested.
   */
  pathToWaypoint: LatLng[];
  /**
   * The encoded path from the previous waypoint to the current waypoint.
   *
   * <p>Note: This field is intended only for use by the Driver SDK and Consumer
   * SDK. Decoding is not yet supported.
   */
  encodedPathToWaypoint: string;
  /**
   * The traffic conditions along the path to this waypoint.  Note that traffic
   * is only available for Google Map Platform Rides and Deliveries Solution
   * customers.
   */
  trafficToWaypoint:
    | ConsumableTrafficPolyline
    | undefined;
  /**
   * The path distance from the previous waypoint to the current waypoint.
   * Undefined for the first waypoint in a list.
   */
  distanceMeters:
    | number
    | undefined;
  /**
   * The estimated time of arrival at this waypoint. Undefined for the first
   * waypoint in a list.
   */
  eta:
    | Date
    | undefined;
  /**
   * The travel time from previous waypoint to this point. Undefined for the
   * first waypoint in a list.
   */
  duration: Duration | undefined;
}

/**
 * Describes a vehicle attribute as a key-value pair. The "key:value" string
 * length cannot exceed 256 characters.
 */
export interface VehicleAttribute {
  /** The attribute's key. Keys may not contain the colon character (:). */
  key: string;
  /** The attribute's value. */
  value: string;
  /**
   * String typed attribute value.
   *
   * Note: This is identical to the `value` field which will eventually be
   * deprecated. For create or update methods, either field can be used, but
   * it's strongly recommended to use `string_value`. If both `string_value`
   * and `value` are set, they must be identical or an error will be thrown.
   * Both fields are populated in responses.
   */
  stringValue?:
    | string
    | undefined;
  /** Boolean typed attribute value. */
  boolValue?:
    | boolean
    | undefined;
  /** Double typed attribute value. */
  numberValue?: number | undefined;
}

/** The location, speed, and heading of a vehicle at a point in time. */
export interface VehicleLocation {
  /**
   * The location of the vehicle.
   * When it is sent to Fleet Engine, the vehicle's location is a GPS location.
   * When you receive it in a response, the vehicle's location can be either a
   * GPS location, a supplemental location, or some other estimated location.
   * The source is specified in `location_sensor`.
   */
  location:
    | LatLng
    | undefined;
  /**
   * Deprecated: Use `latlng_accuracy` instead.
   *
   * @deprecated
   */
  horizontalAccuracy:
    | number
    | undefined;
  /** Accuracy of `location` in meters as a radius. */
  latlngAccuracy:
    | number
    | undefined;
  /**
   * Direction the vehicle is moving in degrees.  0 represents North.
   * The valid range is [0,360).
   */
  heading:
    | number
    | undefined;
  /**
   * Deprecated: Use `heading_accuracy` instead.
   *
   * @deprecated
   */
  bearingAccuracy:
    | number
    | undefined;
  /** Accuracy of `heading` in degrees. */
  headingAccuracy:
    | number
    | undefined;
  /** Altitude in meters above WGS84. */
  altitude:
    | number
    | undefined;
  /**
   * Deprecated: Use `altitude_accuracy` instead.
   *
   * @deprecated
   */
  verticalAccuracy:
    | number
    | undefined;
  /** Accuracy of `altitude` in meters. */
  altitudeAccuracy:
    | number
    | undefined;
  /**
   * Speed of the vehicle in kilometers per hour.
   * Deprecated: Use `speed` instead.
   *
   * @deprecated
   */
  speedKmph:
    | number
    | undefined;
  /** Speed of the vehicle in meters/second */
  speed:
    | number
    | undefined;
  /** Accuracy of `speed` in meters/second. */
  speedAccuracy:
    | number
    | undefined;
  /**
   * The time when `location` was reported by the sensor according to the
   * sensor's clock.
   */
  updateTime:
    | Date
    | undefined;
  /** Output only. The time when the server received the location information. */
  serverTime:
    | Date
    | undefined;
  /** Provider of location data (for example, `GPS`). */
  locationSensor: LocationSensor;
  /** Whether `location` is snapped to a road. */
  isRoadSnapped:
    | boolean
    | undefined;
  /**
   * Input only. Indicates whether the GPS sensor is enabled on the mobile
   * device.
   */
  isGpsSensorEnabled:
    | boolean
    | undefined;
  /**
   * Input only. Time (in seconds) since this location was first sent to the
   * server. This will be zero for the first update. If the time is unknown (for
   * example, when the app restarts), this value resets to zero.
   */
  timeSinceUpdate:
    | number
    | undefined;
  /**
   * Input only. Deprecated: Other signals are now used to determine if a
   * location is stale.
   *
   * @deprecated
   */
  numStaleUpdates:
    | number
    | undefined;
  /** Raw vehicle location (unprocessed by road-snapper). */
  rawLocation:
    | LatLng
    | undefined;
  /** Timestamp associated with the raw location. */
  rawLocationTime:
    | Date
    | undefined;
  /** Source of the raw location. Defaults to `GPS`. */
  rawLocationSensor: LocationSensor;
  /** Accuracy of `raw_location` as a radius, in meters. */
  rawLocationAccuracy:
    | number
    | undefined;
  /** Supplemental location provided by the integrating app. */
  supplementalLocation:
    | LatLng
    | undefined;
  /** Timestamp associated with the supplemental location. */
  supplementalLocationTime:
    | Date
    | undefined;
  /**
   * Source of the supplemental location. Defaults to
   * `CUSTOMER_SUPPLIED_LOCATION`.
   */
  supplementalLocationSensor: LocationSensor;
  /** Accuracy of `supplemental_location` as a radius, in meters. */
  supplementalLocationAccuracy:
    | number
    | undefined;
  /**
   * Deprecated: Use `is_road_snapped` instead.
   *
   * @deprecated
   */
  roadSnapped: boolean;
}

function createBaseTerminalPointId(): TerminalPointId {
  return { placeId: undefined, generatedId: undefined, value: "" };
}

export const TerminalPointId: MessageFns<TerminalPointId> = {
  encode(message: TerminalPointId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.placeId !== undefined) {
      writer.uint32(18).string(message.placeId);
    }
    if (message.generatedId !== undefined) {
      writer.uint32(26).string(message.generatedId);
    }
    if (message.value !== "") {
      writer.uint32(34).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TerminalPointId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTerminalPointId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.placeId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.generatedId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TerminalPointId {
    return {
      placeId: isSet(object.placeId) ? globalThis.String(object.placeId) : undefined,
      generatedId: isSet(object.generatedId) ? globalThis.String(object.generatedId) : undefined,
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: TerminalPointId): unknown {
    const obj: any = {};
    if (message.placeId !== undefined) {
      obj.placeId = message.placeId;
    }
    if (message.generatedId !== undefined) {
      obj.generatedId = message.generatedId;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<TerminalPointId>): TerminalPointId {
    return TerminalPointId.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TerminalPointId>): TerminalPointId {
    const message = createBaseTerminalPointId();
    message.placeId = object.placeId ?? undefined;
    message.generatedId = object.generatedId ?? undefined;
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseTerminalLocation(): TerminalLocation {
  return { point: undefined, terminalPointId: undefined, accessPointId: "", tripId: "", terminalLocationType: 0 };
}

export const TerminalLocation: MessageFns<TerminalLocation> = {
  encode(message: TerminalLocation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.point !== undefined) {
      LatLng.encode(message.point, writer.uint32(10).fork()).join();
    }
    if (message.terminalPointId !== undefined) {
      TerminalPointId.encode(message.terminalPointId, writer.uint32(18).fork()).join();
    }
    if (message.accessPointId !== "") {
      writer.uint32(26).string(message.accessPointId);
    }
    if (message.tripId !== "") {
      writer.uint32(34).string(message.tripId);
    }
    if (message.terminalLocationType !== 0) {
      writer.uint32(40).int32(message.terminalLocationType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TerminalLocation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTerminalLocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.point = LatLng.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.terminalPointId = TerminalPointId.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.accessPointId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.tripId = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.terminalLocationType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TerminalLocation {
    return {
      point: isSet(object.point) ? LatLng.fromJSON(object.point) : undefined,
      terminalPointId: isSet(object.terminalPointId) ? TerminalPointId.fromJSON(object.terminalPointId) : undefined,
      accessPointId: isSet(object.accessPointId) ? globalThis.String(object.accessPointId) : "",
      tripId: isSet(object.tripId) ? globalThis.String(object.tripId) : "",
      terminalLocationType: isSet(object.terminalLocationType) ? waypointTypeFromJSON(object.terminalLocationType) : 0,
    };
  },

  toJSON(message: TerminalLocation): unknown {
    const obj: any = {};
    if (message.point !== undefined) {
      obj.point = LatLng.toJSON(message.point);
    }
    if (message.terminalPointId !== undefined) {
      obj.terminalPointId = TerminalPointId.toJSON(message.terminalPointId);
    }
    if (message.accessPointId !== "") {
      obj.accessPointId = message.accessPointId;
    }
    if (message.tripId !== "") {
      obj.tripId = message.tripId;
    }
    if (message.terminalLocationType !== 0) {
      obj.terminalLocationType = waypointTypeToJSON(message.terminalLocationType);
    }
    return obj;
  },

  create(base?: DeepPartial<TerminalLocation>): TerminalLocation {
    return TerminalLocation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TerminalLocation>): TerminalLocation {
    const message = createBaseTerminalLocation();
    message.point = (object.point !== undefined && object.point !== null)
      ? LatLng.fromPartial(object.point)
      : undefined;
    message.terminalPointId = (object.terminalPointId !== undefined && object.terminalPointId !== null)
      ? TerminalPointId.fromPartial(object.terminalPointId)
      : undefined;
    message.accessPointId = object.accessPointId ?? "";
    message.tripId = object.tripId ?? "";
    message.terminalLocationType = object.terminalLocationType ?? 0;
    return message;
  },
};

function createBaseTripWaypoint(): TripWaypoint {
  return {
    location: undefined,
    tripId: "",
    waypointType: 0,
    pathToWaypoint: [],
    encodedPathToWaypoint: "",
    trafficToWaypoint: undefined,
    distanceMeters: undefined,
    eta: undefined,
    duration: undefined,
  };
}

export const TripWaypoint: MessageFns<TripWaypoint> = {
  encode(message: TripWaypoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.location !== undefined) {
      TerminalLocation.encode(message.location, writer.uint32(10).fork()).join();
    }
    if (message.tripId !== "") {
      writer.uint32(18).string(message.tripId);
    }
    if (message.waypointType !== 0) {
      writer.uint32(24).int32(message.waypointType);
    }
    for (const v of message.pathToWaypoint) {
      LatLng.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.encodedPathToWaypoint !== "") {
      writer.uint32(42).string(message.encodedPathToWaypoint);
    }
    if (message.trafficToWaypoint !== undefined) {
      ConsumableTrafficPolyline.encode(message.trafficToWaypoint, writer.uint32(82).fork()).join();
    }
    if (message.distanceMeters !== undefined) {
      Int32Value.encode({ value: message.distanceMeters! }, writer.uint32(50).fork()).join();
    }
    if (message.eta !== undefined) {
      Timestamp.encode(toTimestamp(message.eta), writer.uint32(58).fork()).join();
    }
    if (message.duration !== undefined) {
      Duration.encode(message.duration, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TripWaypoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTripWaypoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.location = TerminalLocation.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tripId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.waypointType = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pathToWaypoint.push(LatLng.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.encodedPathToWaypoint = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.trafficToWaypoint = ConsumableTrafficPolyline.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.distanceMeters = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.eta = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.duration = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TripWaypoint {
    return {
      location: isSet(object.location) ? TerminalLocation.fromJSON(object.location) : undefined,
      tripId: isSet(object.tripId) ? globalThis.String(object.tripId) : "",
      waypointType: isSet(object.waypointType) ? waypointTypeFromJSON(object.waypointType) : 0,
      pathToWaypoint: globalThis.Array.isArray(object?.pathToWaypoint)
        ? object.pathToWaypoint.map((e: any) => LatLng.fromJSON(e))
        : [],
      encodedPathToWaypoint: isSet(object.encodedPathToWaypoint) ? globalThis.String(object.encodedPathToWaypoint) : "",
      trafficToWaypoint: isSet(object.trafficToWaypoint)
        ? ConsumableTrafficPolyline.fromJSON(object.trafficToWaypoint)
        : undefined,
      distanceMeters: isSet(object.distanceMeters) ? Number(object.distanceMeters) : undefined,
      eta: isSet(object.eta) ? fromJsonTimestamp(object.eta) : undefined,
      duration: isSet(object.duration) ? Duration.fromJSON(object.duration) : undefined,
    };
  },

  toJSON(message: TripWaypoint): unknown {
    const obj: any = {};
    if (message.location !== undefined) {
      obj.location = TerminalLocation.toJSON(message.location);
    }
    if (message.tripId !== "") {
      obj.tripId = message.tripId;
    }
    if (message.waypointType !== 0) {
      obj.waypointType = waypointTypeToJSON(message.waypointType);
    }
    if (message.pathToWaypoint?.length) {
      obj.pathToWaypoint = message.pathToWaypoint.map((e) => LatLng.toJSON(e));
    }
    if (message.encodedPathToWaypoint !== "") {
      obj.encodedPathToWaypoint = message.encodedPathToWaypoint;
    }
    if (message.trafficToWaypoint !== undefined) {
      obj.trafficToWaypoint = ConsumableTrafficPolyline.toJSON(message.trafficToWaypoint);
    }
    if (message.distanceMeters !== undefined) {
      obj.distanceMeters = message.distanceMeters;
    }
    if (message.eta !== undefined) {
      obj.eta = message.eta.toISOString();
    }
    if (message.duration !== undefined) {
      obj.duration = Duration.toJSON(message.duration);
    }
    return obj;
  },

  create(base?: DeepPartial<TripWaypoint>): TripWaypoint {
    return TripWaypoint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TripWaypoint>): TripWaypoint {
    const message = createBaseTripWaypoint();
    message.location = (object.location !== undefined && object.location !== null)
      ? TerminalLocation.fromPartial(object.location)
      : undefined;
    message.tripId = object.tripId ?? "";
    message.waypointType = object.waypointType ?? 0;
    message.pathToWaypoint = object.pathToWaypoint?.map((e) => LatLng.fromPartial(e)) || [];
    message.encodedPathToWaypoint = object.encodedPathToWaypoint ?? "";
    message.trafficToWaypoint = (object.trafficToWaypoint !== undefined && object.trafficToWaypoint !== null)
      ? ConsumableTrafficPolyline.fromPartial(object.trafficToWaypoint)
      : undefined;
    message.distanceMeters = object.distanceMeters ?? undefined;
    message.eta = object.eta ?? undefined;
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? Duration.fromPartial(object.duration)
      : undefined;
    return message;
  },
};

function createBaseVehicleAttribute(): VehicleAttribute {
  return { key: "", value: "", stringValue: undefined, boolValue: undefined, numberValue: undefined };
}

export const VehicleAttribute: MessageFns<VehicleAttribute> = {
  encode(message: VehicleAttribute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    if (message.stringValue !== undefined) {
      writer.uint32(26).string(message.stringValue);
    }
    if (message.boolValue !== undefined) {
      writer.uint32(32).bool(message.boolValue);
    }
    if (message.numberValue !== undefined) {
      writer.uint32(41).double(message.numberValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VehicleAttribute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVehicleAttribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.stringValue = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.boolValue = reader.bool();
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.numberValue = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VehicleAttribute {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      stringValue: isSet(object.stringValue) ? globalThis.String(object.stringValue) : undefined,
      boolValue: isSet(object.boolValue) ? globalThis.Boolean(object.boolValue) : undefined,
      numberValue: isSet(object.numberValue) ? globalThis.Number(object.numberValue) : undefined,
    };
  },

  toJSON(message: VehicleAttribute): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.stringValue !== undefined) {
      obj.stringValue = message.stringValue;
    }
    if (message.boolValue !== undefined) {
      obj.boolValue = message.boolValue;
    }
    if (message.numberValue !== undefined) {
      obj.numberValue = message.numberValue;
    }
    return obj;
  },

  create(base?: DeepPartial<VehicleAttribute>): VehicleAttribute {
    return VehicleAttribute.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VehicleAttribute>): VehicleAttribute {
    const message = createBaseVehicleAttribute();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    message.stringValue = object.stringValue ?? undefined;
    message.boolValue = object.boolValue ?? undefined;
    message.numberValue = object.numberValue ?? undefined;
    return message;
  },
};

function createBaseVehicleLocation(): VehicleLocation {
  return {
    location: undefined,
    horizontalAccuracy: undefined,
    latlngAccuracy: undefined,
    heading: undefined,
    bearingAccuracy: undefined,
    headingAccuracy: undefined,
    altitude: undefined,
    verticalAccuracy: undefined,
    altitudeAccuracy: undefined,
    speedKmph: undefined,
    speed: undefined,
    speedAccuracy: undefined,
    updateTime: undefined,
    serverTime: undefined,
    locationSensor: 0,
    isRoadSnapped: undefined,
    isGpsSensorEnabled: undefined,
    timeSinceUpdate: undefined,
    numStaleUpdates: undefined,
    rawLocation: undefined,
    rawLocationTime: undefined,
    rawLocationSensor: 0,
    rawLocationAccuracy: undefined,
    supplementalLocation: undefined,
    supplementalLocationTime: undefined,
    supplementalLocationSensor: 0,
    supplementalLocationAccuracy: undefined,
    roadSnapped: false,
  };
}

export const VehicleLocation: MessageFns<VehicleLocation> = {
  encode(message: VehicleLocation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.location !== undefined) {
      LatLng.encode(message.location, writer.uint32(10).fork()).join();
    }
    if (message.horizontalAccuracy !== undefined) {
      DoubleValue.encode({ value: message.horizontalAccuracy! }, writer.uint32(66).fork()).join();
    }
    if (message.latlngAccuracy !== undefined) {
      DoubleValue.encode({ value: message.latlngAccuracy! }, writer.uint32(178).fork()).join();
    }
    if (message.heading !== undefined) {
      Int32Value.encode({ value: message.heading! }, writer.uint32(18).fork()).join();
    }
    if (message.bearingAccuracy !== undefined) {
      DoubleValue.encode({ value: message.bearingAccuracy! }, writer.uint32(82).fork()).join();
    }
    if (message.headingAccuracy !== undefined) {
      DoubleValue.encode({ value: message.headingAccuracy! }, writer.uint32(186).fork()).join();
    }
    if (message.altitude !== undefined) {
      DoubleValue.encode({ value: message.altitude! }, writer.uint32(42).fork()).join();
    }
    if (message.verticalAccuracy !== undefined) {
      DoubleValue.encode({ value: message.verticalAccuracy! }, writer.uint32(74).fork()).join();
    }
    if (message.altitudeAccuracy !== undefined) {
      DoubleValue.encode({ value: message.altitudeAccuracy! }, writer.uint32(194).fork()).join();
    }
    if (message.speedKmph !== undefined) {
      Int32Value.encode({ value: message.speedKmph! }, writer.uint32(26).fork()).join();
    }
    if (message.speed !== undefined) {
      DoubleValue.encode({ value: message.speed! }, writer.uint32(50).fork()).join();
    }
    if (message.speedAccuracy !== undefined) {
      DoubleValue.encode({ value: message.speedAccuracy! }, writer.uint32(58).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(34).fork()).join();
    }
    if (message.serverTime !== undefined) {
      Timestamp.encode(toTimestamp(message.serverTime), writer.uint32(106).fork()).join();
    }
    if (message.locationSensor !== 0) {
      writer.uint32(88).int32(message.locationSensor);
    }
    if (message.isRoadSnapped !== undefined) {
      BoolValue.encode({ value: message.isRoadSnapped! }, writer.uint32(218).fork()).join();
    }
    if (message.isGpsSensorEnabled !== undefined) {
      BoolValue.encode({ value: message.isGpsSensorEnabled! }, writer.uint32(98).fork()).join();
    }
    if (message.timeSinceUpdate !== undefined) {
      Int32Value.encode({ value: message.timeSinceUpdate! }, writer.uint32(114).fork()).join();
    }
    if (message.numStaleUpdates !== undefined) {
      Int32Value.encode({ value: message.numStaleUpdates! }, writer.uint32(122).fork()).join();
    }
    if (message.rawLocation !== undefined) {
      LatLng.encode(message.rawLocation, writer.uint32(130).fork()).join();
    }
    if (message.rawLocationTime !== undefined) {
      Timestamp.encode(toTimestamp(message.rawLocationTime), writer.uint32(138).fork()).join();
    }
    if (message.rawLocationSensor !== 0) {
      writer.uint32(224).int32(message.rawLocationSensor);
    }
    if (message.rawLocationAccuracy !== undefined) {
      DoubleValue.encode({ value: message.rawLocationAccuracy! }, writer.uint32(202).fork()).join();
    }
    if (message.supplementalLocation !== undefined) {
      LatLng.encode(message.supplementalLocation, writer.uint32(146).fork()).join();
    }
    if (message.supplementalLocationTime !== undefined) {
      Timestamp.encode(toTimestamp(message.supplementalLocationTime), writer.uint32(154).fork()).join();
    }
    if (message.supplementalLocationSensor !== 0) {
      writer.uint32(160).int32(message.supplementalLocationSensor);
    }
    if (message.supplementalLocationAccuracy !== undefined) {
      DoubleValue.encode({ value: message.supplementalLocationAccuracy! }, writer.uint32(170).fork()).join();
    }
    if (message.roadSnapped !== false) {
      writer.uint32(208).bool(message.roadSnapped);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VehicleLocation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVehicleLocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.location = LatLng.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.horizontalAccuracy = DoubleValue.decode(reader, reader.uint32()).value;
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.latlngAccuracy = DoubleValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.heading = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.bearingAccuracy = DoubleValue.decode(reader, reader.uint32()).value;
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.headingAccuracy = DoubleValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.altitude = DoubleValue.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.verticalAccuracy = DoubleValue.decode(reader, reader.uint32()).value;
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.altitudeAccuracy = DoubleValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.speedKmph = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.speed = DoubleValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.speedAccuracy = DoubleValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.serverTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.locationSensor = reader.int32() as any;
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }

          message.isRoadSnapped = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.isGpsSensorEnabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.timeSinceUpdate = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.numStaleUpdates = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.rawLocation = LatLng.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.rawLocationTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 28:
          if (tag !== 224) {
            break;
          }

          message.rawLocationSensor = reader.int32() as any;
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.rawLocationAccuracy = DoubleValue.decode(reader, reader.uint32()).value;
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.supplementalLocation = LatLng.decode(reader, reader.uint32());
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.supplementalLocationTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.supplementalLocationSensor = reader.int32() as any;
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.supplementalLocationAccuracy = DoubleValue.decode(reader, reader.uint32()).value;
          continue;
        case 26:
          if (tag !== 208) {
            break;
          }

          message.roadSnapped = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VehicleLocation {
    return {
      location: isSet(object.location) ? LatLng.fromJSON(object.location) : undefined,
      horizontalAccuracy: isSet(object.horizontalAccuracy) ? Number(object.horizontalAccuracy) : undefined,
      latlngAccuracy: isSet(object.latlngAccuracy) ? Number(object.latlngAccuracy) : undefined,
      heading: isSet(object.heading) ? Number(object.heading) : undefined,
      bearingAccuracy: isSet(object.bearingAccuracy) ? Number(object.bearingAccuracy) : undefined,
      headingAccuracy: isSet(object.headingAccuracy) ? Number(object.headingAccuracy) : undefined,
      altitude: isSet(object.altitude) ? Number(object.altitude) : undefined,
      verticalAccuracy: isSet(object.verticalAccuracy) ? Number(object.verticalAccuracy) : undefined,
      altitudeAccuracy: isSet(object.altitudeAccuracy) ? Number(object.altitudeAccuracy) : undefined,
      speedKmph: isSet(object.speedKmph) ? Number(object.speedKmph) : undefined,
      speed: isSet(object.speed) ? Number(object.speed) : undefined,
      speedAccuracy: isSet(object.speedAccuracy) ? Number(object.speedAccuracy) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      serverTime: isSet(object.serverTime) ? fromJsonTimestamp(object.serverTime) : undefined,
      locationSensor: isSet(object.locationSensor) ? locationSensorFromJSON(object.locationSensor) : 0,
      isRoadSnapped: isSet(object.isRoadSnapped) ? Boolean(object.isRoadSnapped) : undefined,
      isGpsSensorEnabled: isSet(object.isGpsSensorEnabled) ? Boolean(object.isGpsSensorEnabled) : undefined,
      timeSinceUpdate: isSet(object.timeSinceUpdate) ? Number(object.timeSinceUpdate) : undefined,
      numStaleUpdates: isSet(object.numStaleUpdates) ? Number(object.numStaleUpdates) : undefined,
      rawLocation: isSet(object.rawLocation) ? LatLng.fromJSON(object.rawLocation) : undefined,
      rawLocationTime: isSet(object.rawLocationTime) ? fromJsonTimestamp(object.rawLocationTime) : undefined,
      rawLocationSensor: isSet(object.rawLocationSensor) ? locationSensorFromJSON(object.rawLocationSensor) : 0,
      rawLocationAccuracy: isSet(object.rawLocationAccuracy) ? Number(object.rawLocationAccuracy) : undefined,
      supplementalLocation: isSet(object.supplementalLocation)
        ? LatLng.fromJSON(object.supplementalLocation)
        : undefined,
      supplementalLocationTime: isSet(object.supplementalLocationTime)
        ? fromJsonTimestamp(object.supplementalLocationTime)
        : undefined,
      supplementalLocationSensor: isSet(object.supplementalLocationSensor)
        ? locationSensorFromJSON(object.supplementalLocationSensor)
        : 0,
      supplementalLocationAccuracy: isSet(object.supplementalLocationAccuracy)
        ? Number(object.supplementalLocationAccuracy)
        : undefined,
      roadSnapped: isSet(object.roadSnapped) ? globalThis.Boolean(object.roadSnapped) : false,
    };
  },

  toJSON(message: VehicleLocation): unknown {
    const obj: any = {};
    if (message.location !== undefined) {
      obj.location = LatLng.toJSON(message.location);
    }
    if (message.horizontalAccuracy !== undefined) {
      obj.horizontalAccuracy = message.horizontalAccuracy;
    }
    if (message.latlngAccuracy !== undefined) {
      obj.latlngAccuracy = message.latlngAccuracy;
    }
    if (message.heading !== undefined) {
      obj.heading = message.heading;
    }
    if (message.bearingAccuracy !== undefined) {
      obj.bearingAccuracy = message.bearingAccuracy;
    }
    if (message.headingAccuracy !== undefined) {
      obj.headingAccuracy = message.headingAccuracy;
    }
    if (message.altitude !== undefined) {
      obj.altitude = message.altitude;
    }
    if (message.verticalAccuracy !== undefined) {
      obj.verticalAccuracy = message.verticalAccuracy;
    }
    if (message.altitudeAccuracy !== undefined) {
      obj.altitudeAccuracy = message.altitudeAccuracy;
    }
    if (message.speedKmph !== undefined) {
      obj.speedKmph = message.speedKmph;
    }
    if (message.speed !== undefined) {
      obj.speed = message.speed;
    }
    if (message.speedAccuracy !== undefined) {
      obj.speedAccuracy = message.speedAccuracy;
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.serverTime !== undefined) {
      obj.serverTime = message.serverTime.toISOString();
    }
    if (message.locationSensor !== 0) {
      obj.locationSensor = locationSensorToJSON(message.locationSensor);
    }
    if (message.isRoadSnapped !== undefined) {
      obj.isRoadSnapped = message.isRoadSnapped;
    }
    if (message.isGpsSensorEnabled !== undefined) {
      obj.isGpsSensorEnabled = message.isGpsSensorEnabled;
    }
    if (message.timeSinceUpdate !== undefined) {
      obj.timeSinceUpdate = message.timeSinceUpdate;
    }
    if (message.numStaleUpdates !== undefined) {
      obj.numStaleUpdates = message.numStaleUpdates;
    }
    if (message.rawLocation !== undefined) {
      obj.rawLocation = LatLng.toJSON(message.rawLocation);
    }
    if (message.rawLocationTime !== undefined) {
      obj.rawLocationTime = message.rawLocationTime.toISOString();
    }
    if (message.rawLocationSensor !== 0) {
      obj.rawLocationSensor = locationSensorToJSON(message.rawLocationSensor);
    }
    if (message.rawLocationAccuracy !== undefined) {
      obj.rawLocationAccuracy = message.rawLocationAccuracy;
    }
    if (message.supplementalLocation !== undefined) {
      obj.supplementalLocation = LatLng.toJSON(message.supplementalLocation);
    }
    if (message.supplementalLocationTime !== undefined) {
      obj.supplementalLocationTime = message.supplementalLocationTime.toISOString();
    }
    if (message.supplementalLocationSensor !== 0) {
      obj.supplementalLocationSensor = locationSensorToJSON(message.supplementalLocationSensor);
    }
    if (message.supplementalLocationAccuracy !== undefined) {
      obj.supplementalLocationAccuracy = message.supplementalLocationAccuracy;
    }
    if (message.roadSnapped !== false) {
      obj.roadSnapped = message.roadSnapped;
    }
    return obj;
  },

  create(base?: DeepPartial<VehicleLocation>): VehicleLocation {
    return VehicleLocation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VehicleLocation>): VehicleLocation {
    const message = createBaseVehicleLocation();
    message.location = (object.location !== undefined && object.location !== null)
      ? LatLng.fromPartial(object.location)
      : undefined;
    message.horizontalAccuracy = object.horizontalAccuracy ?? undefined;
    message.latlngAccuracy = object.latlngAccuracy ?? undefined;
    message.heading = object.heading ?? undefined;
    message.bearingAccuracy = object.bearingAccuracy ?? undefined;
    message.headingAccuracy = object.headingAccuracy ?? undefined;
    message.altitude = object.altitude ?? undefined;
    message.verticalAccuracy = object.verticalAccuracy ?? undefined;
    message.altitudeAccuracy = object.altitudeAccuracy ?? undefined;
    message.speedKmph = object.speedKmph ?? undefined;
    message.speed = object.speed ?? undefined;
    message.speedAccuracy = object.speedAccuracy ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.serverTime = object.serverTime ?? undefined;
    message.locationSensor = object.locationSensor ?? 0;
    message.isRoadSnapped = object.isRoadSnapped ?? undefined;
    message.isGpsSensorEnabled = object.isGpsSensorEnabled ?? undefined;
    message.timeSinceUpdate = object.timeSinceUpdate ?? undefined;
    message.numStaleUpdates = object.numStaleUpdates ?? undefined;
    message.rawLocation = (object.rawLocation !== undefined && object.rawLocation !== null)
      ? LatLng.fromPartial(object.rawLocation)
      : undefined;
    message.rawLocationTime = object.rawLocationTime ?? undefined;
    message.rawLocationSensor = object.rawLocationSensor ?? 0;
    message.rawLocationAccuracy = object.rawLocationAccuracy ?? undefined;
    message.supplementalLocation = (object.supplementalLocation !== undefined && object.supplementalLocation !== null)
      ? LatLng.fromPartial(object.supplementalLocation)
      : undefined;
    message.supplementalLocationTime = object.supplementalLocationTime ?? undefined;
    message.supplementalLocationSensor = object.supplementalLocationSensor ?? 0;
    message.supplementalLocationAccuracy = object.supplementalLocationAccuracy ?? undefined;
    message.roadSnapped = object.roadSnapped ?? false;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
