// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/maps/fleetengine/delivery/v1/common.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../../protobuf/timestamp.js";
import { BoolValue, DoubleValue, Int32Value } from "../../../../protobuf/wrappers.js";
import { LatLng } from "../../../../type/latlng.js";

export const protobufPackage = "maps.fleetengine.delivery.v1";

/** The sensor or methodology used to determine the location. */
export enum DeliveryVehicleLocationSensor {
  /** UNKNOWN_SENSOR - The sensor is unspecified or unknown. */
  UNKNOWN_SENSOR = 0,
  /** GPS - GPS or Assisted GPS. */
  GPS = 1,
  /** NETWORK - Assisted GPS, cell tower ID, or WiFi access point. */
  NETWORK = 2,
  /** PASSIVE - Cell tower ID or WiFi access point. */
  PASSIVE = 3,
  /**
   * ROAD_SNAPPED_LOCATION_PROVIDER - A location determined by the mobile device to be the most likely
   * road position.
   */
  ROAD_SNAPPED_LOCATION_PROVIDER = 4,
  /**
   * CUSTOMER_SUPPLIED_LOCATION - A customer-supplied location from an independent source.  Typically, this
   * value is used for a location provided from sources other than the mobile
   * device running Driver SDK.  If the original source is described by one of
   * the other enum values, use that value. Locations marked
   * CUSTOMER_SUPPLIED_LOCATION are typically provided via a DeliveryVehicle's
   * `last_location.supplemental_location_sensor`.
   */
  CUSTOMER_SUPPLIED_LOCATION = 5,
  /**
   * FLEET_ENGINE_LOCATION - A location calculated by Fleet Engine based on the signals available to it.
   * Output only. This value will be rejected if it is received in a request.
   */
  FLEET_ENGINE_LOCATION = 6,
  /** FUSED_LOCATION_PROVIDER - Android's Fused Location Provider. */
  FUSED_LOCATION_PROVIDER = 100,
  /** CORE_LOCATION - The location provider on Apple operating systems. */
  CORE_LOCATION = 200,
  UNRECOGNIZED = -1,
}

export function deliveryVehicleLocationSensorFromJSON(object: any): DeliveryVehicleLocationSensor {
  switch (object) {
    case 0:
    case "UNKNOWN_SENSOR":
      return DeliveryVehicleLocationSensor.UNKNOWN_SENSOR;
    case 1:
    case "GPS":
      return DeliveryVehicleLocationSensor.GPS;
    case 2:
    case "NETWORK":
      return DeliveryVehicleLocationSensor.NETWORK;
    case 3:
    case "PASSIVE":
      return DeliveryVehicleLocationSensor.PASSIVE;
    case 4:
    case "ROAD_SNAPPED_LOCATION_PROVIDER":
      return DeliveryVehicleLocationSensor.ROAD_SNAPPED_LOCATION_PROVIDER;
    case 5:
    case "CUSTOMER_SUPPLIED_LOCATION":
      return DeliveryVehicleLocationSensor.CUSTOMER_SUPPLIED_LOCATION;
    case 6:
    case "FLEET_ENGINE_LOCATION":
      return DeliveryVehicleLocationSensor.FLEET_ENGINE_LOCATION;
    case 100:
    case "FUSED_LOCATION_PROVIDER":
      return DeliveryVehicleLocationSensor.FUSED_LOCATION_PROVIDER;
    case 200:
    case "CORE_LOCATION":
      return DeliveryVehicleLocationSensor.CORE_LOCATION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DeliveryVehicleLocationSensor.UNRECOGNIZED;
  }
}

export function deliveryVehicleLocationSensorToJSON(object: DeliveryVehicleLocationSensor): string {
  switch (object) {
    case DeliveryVehicleLocationSensor.UNKNOWN_SENSOR:
      return "UNKNOWN_SENSOR";
    case DeliveryVehicleLocationSensor.GPS:
      return "GPS";
    case DeliveryVehicleLocationSensor.NETWORK:
      return "NETWORK";
    case DeliveryVehicleLocationSensor.PASSIVE:
      return "PASSIVE";
    case DeliveryVehicleLocationSensor.ROAD_SNAPPED_LOCATION_PROVIDER:
      return "ROAD_SNAPPED_LOCATION_PROVIDER";
    case DeliveryVehicleLocationSensor.CUSTOMER_SUPPLIED_LOCATION:
      return "CUSTOMER_SUPPLIED_LOCATION";
    case DeliveryVehicleLocationSensor.FLEET_ENGINE_LOCATION:
      return "FLEET_ENGINE_LOCATION";
    case DeliveryVehicleLocationSensor.FUSED_LOCATION_PROVIDER:
      return "FUSED_LOCATION_PROVIDER";
    case DeliveryVehicleLocationSensor.CORE_LOCATION:
      return "CORE_LOCATION";
    case DeliveryVehicleLocationSensor.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The vehicle's navigation status. */
export enum DeliveryVehicleNavigationStatus {
  /** UNKNOWN_NAVIGATION_STATUS - Unspecified navigation status. */
  UNKNOWN_NAVIGATION_STATUS = 0,
  /** NO_GUIDANCE - The Driver app's navigation is in `FREE_NAV` mode. */
  NO_GUIDANCE = 1,
  /**
   * ENROUTE_TO_DESTINATION - Turn-by-turn navigation is available and the Driver app navigation has
   * entered `GUIDED_NAV` mode.
   */
  ENROUTE_TO_DESTINATION = 2,
  /** OFF_ROUTE - The vehicle has gone off the suggested route. */
  OFF_ROUTE = 3,
  /** ARRIVED_AT_DESTINATION - The vehicle is within approximately 50m of the destination. */
  ARRIVED_AT_DESTINATION = 4,
  UNRECOGNIZED = -1,
}

export function deliveryVehicleNavigationStatusFromJSON(object: any): DeliveryVehicleNavigationStatus {
  switch (object) {
    case 0:
    case "UNKNOWN_NAVIGATION_STATUS":
      return DeliveryVehicleNavigationStatus.UNKNOWN_NAVIGATION_STATUS;
    case 1:
    case "NO_GUIDANCE":
      return DeliveryVehicleNavigationStatus.NO_GUIDANCE;
    case 2:
    case "ENROUTE_TO_DESTINATION":
      return DeliveryVehicleNavigationStatus.ENROUTE_TO_DESTINATION;
    case 3:
    case "OFF_ROUTE":
      return DeliveryVehicleNavigationStatus.OFF_ROUTE;
    case 4:
    case "ARRIVED_AT_DESTINATION":
      return DeliveryVehicleNavigationStatus.ARRIVED_AT_DESTINATION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DeliveryVehicleNavigationStatus.UNRECOGNIZED;
  }
}

export function deliveryVehicleNavigationStatusToJSON(object: DeliveryVehicleNavigationStatus): string {
  switch (object) {
    case DeliveryVehicleNavigationStatus.UNKNOWN_NAVIGATION_STATUS:
      return "UNKNOWN_NAVIGATION_STATUS";
    case DeliveryVehicleNavigationStatus.NO_GUIDANCE:
      return "NO_GUIDANCE";
    case DeliveryVehicleNavigationStatus.ENROUTE_TO_DESTINATION:
      return "ENROUTE_TO_DESTINATION";
    case DeliveryVehicleNavigationStatus.OFF_ROUTE:
      return "OFF_ROUTE";
    case DeliveryVehicleNavigationStatus.ARRIVED_AT_DESTINATION:
      return "ARRIVED_AT_DESTINATION";
    case DeliveryVehicleNavigationStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Describes a vehicle attribute as a key-value pair. The "key:value" string
 * length cannot exceed 256 characters.
 */
export interface DeliveryVehicleAttribute {
  /** The attribute's key. */
  key: string;
  /** The attribute's value. */
  value: string;
  /**
   * String typed attribute value.
   *
   * Note: This is identical to the `value` field which will eventually be
   * deprecated. For create or update methods, either field can be used, but
   * it's strongly recommended to use `string_value`. If both `string_value`
   * and `value` are set, they must be identical or an error will be thrown.
   * Both fields are populated in responses.
   */
  stringValue?:
    | string
    | undefined;
  /** Boolean typed attribute value. */
  boolValue?:
    | boolean
    | undefined;
  /** Double typed attribute value. */
  numberValue?: number | undefined;
}

/** The location, speed, and heading of a vehicle at a point in time. */
export interface DeliveryVehicleLocation {
  /**
   * The location of the vehicle.
   * When it is sent to Fleet Engine, the vehicle's location is a GPS location.
   * When you receive it in a response, the vehicle's location can be either a
   * GPS location, a supplemental location, or some other estimated location.
   * The source is specified in `location_sensor`.
   */
  location:
    | LatLng
    | undefined;
  /**
   * Deprecated: Use `latlng_accuracy` instead.
   *
   * @deprecated
   */
  horizontalAccuracy:
    | number
    | undefined;
  /** Accuracy of `location` in meters as a radius. */
  latlngAccuracy:
    | number
    | undefined;
  /**
   * Direction the vehicle is moving in degrees.  0 represents North.
   * The valid range is [0,360).
   */
  heading:
    | number
    | undefined;
  /**
   * Deprecated: Use `heading_accuracy` instead.
   *
   * @deprecated
   */
  bearingAccuracy:
    | number
    | undefined;
  /** Accuracy of `heading` in degrees. */
  headingAccuracy:
    | number
    | undefined;
  /** Altitude in meters above WGS84. */
  altitude:
    | number
    | undefined;
  /**
   * Deprecated: Use `altitude_accuracy` instead.
   *
   * @deprecated
   */
  verticalAccuracy:
    | number
    | undefined;
  /** Accuracy of `altitude` in meters. */
  altitudeAccuracy:
    | number
    | undefined;
  /**
   * Speed of the vehicle in kilometers per hour.
   * Deprecated: Use `speed` instead.
   *
   * @deprecated
   */
  speedKmph:
    | number
    | undefined;
  /** Speed of the vehicle in meters/second */
  speed:
    | number
    | undefined;
  /** Accuracy of `speed` in meters/second. */
  speedAccuracy:
    | number
    | undefined;
  /**
   * The time when `location` was reported by the sensor according to the
   * sensor's clock.
   */
  updateTime:
    | Date
    | undefined;
  /** Output only. The time when the server received the location information. */
  serverTime:
    | Date
    | undefined;
  /** Provider of location data (for example, `GPS`). */
  locationSensor: DeliveryVehicleLocationSensor;
  /** Whether `location` is snapped to a road. */
  isRoadSnapped:
    | boolean
    | undefined;
  /**
   * Input only. Indicates whether the GPS sensor is enabled on the mobile
   * device.
   */
  isGpsSensorEnabled:
    | boolean
    | undefined;
  /**
   * Input only. Time (in seconds) since this location was first sent to the
   * server. This will be zero for the first update. If the time is unknown (for
   * example, when the app restarts), this value resets to zero.
   */
  timeSinceUpdate:
    | number
    | undefined;
  /**
   * Input only. Deprecated: Other signals are now used to determine if a
   * location is stale.
   *
   * @deprecated
   */
  numStaleUpdates:
    | number
    | undefined;
  /** Raw vehicle location (unprocessed by road-snapper). */
  rawLocation:
    | LatLng
    | undefined;
  /** Timestamp associated with the raw location. */
  rawLocationTime:
    | Date
    | undefined;
  /** Source of the raw location. Defaults to `GPS`. */
  rawLocationSensor: DeliveryVehicleLocationSensor;
  /** Accuracy of `raw_location` as a radius, in meters. */
  rawLocationAccuracy:
    | number
    | undefined;
  /** Supplemental location provided by the integrating app. */
  supplementalLocation:
    | LatLng
    | undefined;
  /** Timestamp associated with the supplemental location. */
  supplementalLocationTime:
    | Date
    | undefined;
  /**
   * Source of the supplemental location. Defaults to
   * `CUSTOMER_SUPPLIED_LOCATION`.
   */
  supplementalLocationSensor: DeliveryVehicleLocationSensor;
  /** Accuracy of `supplemental_location` as a radius, in meters. */
  supplementalLocationAccuracy:
    | number
    | undefined;
  /**
   * Deprecated: Use `is_road_snapped` instead.
   *
   * @deprecated
   */
  roadSnapped: boolean;
}

/** A time range. */
export interface TimeWindow {
  /** Required. The start time of the time window (inclusive). */
  startTime:
    | Date
    | undefined;
  /** Required. The end time of the time window (inclusive). */
  endTime: Date | undefined;
}

/**
 * Describes a task attribute as a key-value pair. The "key:value" string length
 * cannot exceed 256 characters.
 */
export interface TaskAttribute {
  /** The attribute's key. Keys may not contain the colon character (:). */
  key: string;
  /** String typed attribute value. */
  stringValue?:
    | string
    | undefined;
  /** Boolean typed attribute value. */
  boolValue?:
    | boolean
    | undefined;
  /** Double typed attribute value. */
  numberValue?: number | undefined;
}

function createBaseDeliveryVehicleAttribute(): DeliveryVehicleAttribute {
  return { key: "", value: "", stringValue: undefined, boolValue: undefined, numberValue: undefined };
}

export const DeliveryVehicleAttribute: MessageFns<DeliveryVehicleAttribute> = {
  encode(message: DeliveryVehicleAttribute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    if (message.stringValue !== undefined) {
      writer.uint32(26).string(message.stringValue);
    }
    if (message.boolValue !== undefined) {
      writer.uint32(32).bool(message.boolValue);
    }
    if (message.numberValue !== undefined) {
      writer.uint32(41).double(message.numberValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeliveryVehicleAttribute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeliveryVehicleAttribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.stringValue = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.boolValue = reader.bool();
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.numberValue = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeliveryVehicleAttribute {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      stringValue: isSet(object.stringValue) ? globalThis.String(object.stringValue) : undefined,
      boolValue: isSet(object.boolValue) ? globalThis.Boolean(object.boolValue) : undefined,
      numberValue: isSet(object.numberValue) ? globalThis.Number(object.numberValue) : undefined,
    };
  },

  toJSON(message: DeliveryVehicleAttribute): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.stringValue !== undefined) {
      obj.stringValue = message.stringValue;
    }
    if (message.boolValue !== undefined) {
      obj.boolValue = message.boolValue;
    }
    if (message.numberValue !== undefined) {
      obj.numberValue = message.numberValue;
    }
    return obj;
  },

  create(base?: DeepPartial<DeliveryVehicleAttribute>): DeliveryVehicleAttribute {
    return DeliveryVehicleAttribute.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeliveryVehicleAttribute>): DeliveryVehicleAttribute {
    const message = createBaseDeliveryVehicleAttribute();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    message.stringValue = object.stringValue ?? undefined;
    message.boolValue = object.boolValue ?? undefined;
    message.numberValue = object.numberValue ?? undefined;
    return message;
  },
};

function createBaseDeliveryVehicleLocation(): DeliveryVehicleLocation {
  return {
    location: undefined,
    horizontalAccuracy: undefined,
    latlngAccuracy: undefined,
    heading: undefined,
    bearingAccuracy: undefined,
    headingAccuracy: undefined,
    altitude: undefined,
    verticalAccuracy: undefined,
    altitudeAccuracy: undefined,
    speedKmph: undefined,
    speed: undefined,
    speedAccuracy: undefined,
    updateTime: undefined,
    serverTime: undefined,
    locationSensor: 0,
    isRoadSnapped: undefined,
    isGpsSensorEnabled: undefined,
    timeSinceUpdate: undefined,
    numStaleUpdates: undefined,
    rawLocation: undefined,
    rawLocationTime: undefined,
    rawLocationSensor: 0,
    rawLocationAccuracy: undefined,
    supplementalLocation: undefined,
    supplementalLocationTime: undefined,
    supplementalLocationSensor: 0,
    supplementalLocationAccuracy: undefined,
    roadSnapped: false,
  };
}

export const DeliveryVehicleLocation: MessageFns<DeliveryVehicleLocation> = {
  encode(message: DeliveryVehicleLocation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.location !== undefined) {
      LatLng.encode(message.location, writer.uint32(10).fork()).join();
    }
    if (message.horizontalAccuracy !== undefined) {
      DoubleValue.encode({ value: message.horizontalAccuracy! }, writer.uint32(66).fork()).join();
    }
    if (message.latlngAccuracy !== undefined) {
      DoubleValue.encode({ value: message.latlngAccuracy! }, writer.uint32(178).fork()).join();
    }
    if (message.heading !== undefined) {
      Int32Value.encode({ value: message.heading! }, writer.uint32(18).fork()).join();
    }
    if (message.bearingAccuracy !== undefined) {
      DoubleValue.encode({ value: message.bearingAccuracy! }, writer.uint32(82).fork()).join();
    }
    if (message.headingAccuracy !== undefined) {
      DoubleValue.encode({ value: message.headingAccuracy! }, writer.uint32(186).fork()).join();
    }
    if (message.altitude !== undefined) {
      DoubleValue.encode({ value: message.altitude! }, writer.uint32(42).fork()).join();
    }
    if (message.verticalAccuracy !== undefined) {
      DoubleValue.encode({ value: message.verticalAccuracy! }, writer.uint32(74).fork()).join();
    }
    if (message.altitudeAccuracy !== undefined) {
      DoubleValue.encode({ value: message.altitudeAccuracy! }, writer.uint32(194).fork()).join();
    }
    if (message.speedKmph !== undefined) {
      Int32Value.encode({ value: message.speedKmph! }, writer.uint32(26).fork()).join();
    }
    if (message.speed !== undefined) {
      DoubleValue.encode({ value: message.speed! }, writer.uint32(50).fork()).join();
    }
    if (message.speedAccuracy !== undefined) {
      DoubleValue.encode({ value: message.speedAccuracy! }, writer.uint32(58).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(34).fork()).join();
    }
    if (message.serverTime !== undefined) {
      Timestamp.encode(toTimestamp(message.serverTime), writer.uint32(106).fork()).join();
    }
    if (message.locationSensor !== 0) {
      writer.uint32(88).int32(message.locationSensor);
    }
    if (message.isRoadSnapped !== undefined) {
      BoolValue.encode({ value: message.isRoadSnapped! }, writer.uint32(218).fork()).join();
    }
    if (message.isGpsSensorEnabled !== undefined) {
      BoolValue.encode({ value: message.isGpsSensorEnabled! }, writer.uint32(98).fork()).join();
    }
    if (message.timeSinceUpdate !== undefined) {
      Int32Value.encode({ value: message.timeSinceUpdate! }, writer.uint32(114).fork()).join();
    }
    if (message.numStaleUpdates !== undefined) {
      Int32Value.encode({ value: message.numStaleUpdates! }, writer.uint32(122).fork()).join();
    }
    if (message.rawLocation !== undefined) {
      LatLng.encode(message.rawLocation, writer.uint32(130).fork()).join();
    }
    if (message.rawLocationTime !== undefined) {
      Timestamp.encode(toTimestamp(message.rawLocationTime), writer.uint32(138).fork()).join();
    }
    if (message.rawLocationSensor !== 0) {
      writer.uint32(224).int32(message.rawLocationSensor);
    }
    if (message.rawLocationAccuracy !== undefined) {
      DoubleValue.encode({ value: message.rawLocationAccuracy! }, writer.uint32(202).fork()).join();
    }
    if (message.supplementalLocation !== undefined) {
      LatLng.encode(message.supplementalLocation, writer.uint32(146).fork()).join();
    }
    if (message.supplementalLocationTime !== undefined) {
      Timestamp.encode(toTimestamp(message.supplementalLocationTime), writer.uint32(154).fork()).join();
    }
    if (message.supplementalLocationSensor !== 0) {
      writer.uint32(160).int32(message.supplementalLocationSensor);
    }
    if (message.supplementalLocationAccuracy !== undefined) {
      DoubleValue.encode({ value: message.supplementalLocationAccuracy! }, writer.uint32(170).fork()).join();
    }
    if (message.roadSnapped !== false) {
      writer.uint32(208).bool(message.roadSnapped);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeliveryVehicleLocation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeliveryVehicleLocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.location = LatLng.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.horizontalAccuracy = DoubleValue.decode(reader, reader.uint32()).value;
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.latlngAccuracy = DoubleValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.heading = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.bearingAccuracy = DoubleValue.decode(reader, reader.uint32()).value;
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.headingAccuracy = DoubleValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.altitude = DoubleValue.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.verticalAccuracy = DoubleValue.decode(reader, reader.uint32()).value;
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.altitudeAccuracy = DoubleValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.speedKmph = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.speed = DoubleValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.speedAccuracy = DoubleValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.serverTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.locationSensor = reader.int32() as any;
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }

          message.isRoadSnapped = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.isGpsSensorEnabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.timeSinceUpdate = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.numStaleUpdates = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.rawLocation = LatLng.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.rawLocationTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 28:
          if (tag !== 224) {
            break;
          }

          message.rawLocationSensor = reader.int32() as any;
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.rawLocationAccuracy = DoubleValue.decode(reader, reader.uint32()).value;
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.supplementalLocation = LatLng.decode(reader, reader.uint32());
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.supplementalLocationTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.supplementalLocationSensor = reader.int32() as any;
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.supplementalLocationAccuracy = DoubleValue.decode(reader, reader.uint32()).value;
          continue;
        case 26:
          if (tag !== 208) {
            break;
          }

          message.roadSnapped = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeliveryVehicleLocation {
    return {
      location: isSet(object.location) ? LatLng.fromJSON(object.location) : undefined,
      horizontalAccuracy: isSet(object.horizontalAccuracy) ? Number(object.horizontalAccuracy) : undefined,
      latlngAccuracy: isSet(object.latlngAccuracy) ? Number(object.latlngAccuracy) : undefined,
      heading: isSet(object.heading) ? Number(object.heading) : undefined,
      bearingAccuracy: isSet(object.bearingAccuracy) ? Number(object.bearingAccuracy) : undefined,
      headingAccuracy: isSet(object.headingAccuracy) ? Number(object.headingAccuracy) : undefined,
      altitude: isSet(object.altitude) ? Number(object.altitude) : undefined,
      verticalAccuracy: isSet(object.verticalAccuracy) ? Number(object.verticalAccuracy) : undefined,
      altitudeAccuracy: isSet(object.altitudeAccuracy) ? Number(object.altitudeAccuracy) : undefined,
      speedKmph: isSet(object.speedKmph) ? Number(object.speedKmph) : undefined,
      speed: isSet(object.speed) ? Number(object.speed) : undefined,
      speedAccuracy: isSet(object.speedAccuracy) ? Number(object.speedAccuracy) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      serverTime: isSet(object.serverTime) ? fromJsonTimestamp(object.serverTime) : undefined,
      locationSensor: isSet(object.locationSensor) ? deliveryVehicleLocationSensorFromJSON(object.locationSensor) : 0,
      isRoadSnapped: isSet(object.isRoadSnapped) ? Boolean(object.isRoadSnapped) : undefined,
      isGpsSensorEnabled: isSet(object.isGpsSensorEnabled) ? Boolean(object.isGpsSensorEnabled) : undefined,
      timeSinceUpdate: isSet(object.timeSinceUpdate) ? Number(object.timeSinceUpdate) : undefined,
      numStaleUpdates: isSet(object.numStaleUpdates) ? Number(object.numStaleUpdates) : undefined,
      rawLocation: isSet(object.rawLocation) ? LatLng.fromJSON(object.rawLocation) : undefined,
      rawLocationTime: isSet(object.rawLocationTime) ? fromJsonTimestamp(object.rawLocationTime) : undefined,
      rawLocationSensor: isSet(object.rawLocationSensor)
        ? deliveryVehicleLocationSensorFromJSON(object.rawLocationSensor)
        : 0,
      rawLocationAccuracy: isSet(object.rawLocationAccuracy) ? Number(object.rawLocationAccuracy) : undefined,
      supplementalLocation: isSet(object.supplementalLocation)
        ? LatLng.fromJSON(object.supplementalLocation)
        : undefined,
      supplementalLocationTime: isSet(object.supplementalLocationTime)
        ? fromJsonTimestamp(object.supplementalLocationTime)
        : undefined,
      supplementalLocationSensor: isSet(object.supplementalLocationSensor)
        ? deliveryVehicleLocationSensorFromJSON(object.supplementalLocationSensor)
        : 0,
      supplementalLocationAccuracy: isSet(object.supplementalLocationAccuracy)
        ? Number(object.supplementalLocationAccuracy)
        : undefined,
      roadSnapped: isSet(object.roadSnapped) ? globalThis.Boolean(object.roadSnapped) : false,
    };
  },

  toJSON(message: DeliveryVehicleLocation): unknown {
    const obj: any = {};
    if (message.location !== undefined) {
      obj.location = LatLng.toJSON(message.location);
    }
    if (message.horizontalAccuracy !== undefined) {
      obj.horizontalAccuracy = message.horizontalAccuracy;
    }
    if (message.latlngAccuracy !== undefined) {
      obj.latlngAccuracy = message.latlngAccuracy;
    }
    if (message.heading !== undefined) {
      obj.heading = message.heading;
    }
    if (message.bearingAccuracy !== undefined) {
      obj.bearingAccuracy = message.bearingAccuracy;
    }
    if (message.headingAccuracy !== undefined) {
      obj.headingAccuracy = message.headingAccuracy;
    }
    if (message.altitude !== undefined) {
      obj.altitude = message.altitude;
    }
    if (message.verticalAccuracy !== undefined) {
      obj.verticalAccuracy = message.verticalAccuracy;
    }
    if (message.altitudeAccuracy !== undefined) {
      obj.altitudeAccuracy = message.altitudeAccuracy;
    }
    if (message.speedKmph !== undefined) {
      obj.speedKmph = message.speedKmph;
    }
    if (message.speed !== undefined) {
      obj.speed = message.speed;
    }
    if (message.speedAccuracy !== undefined) {
      obj.speedAccuracy = message.speedAccuracy;
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.serverTime !== undefined) {
      obj.serverTime = message.serverTime.toISOString();
    }
    if (message.locationSensor !== 0) {
      obj.locationSensor = deliveryVehicleLocationSensorToJSON(message.locationSensor);
    }
    if (message.isRoadSnapped !== undefined) {
      obj.isRoadSnapped = message.isRoadSnapped;
    }
    if (message.isGpsSensorEnabled !== undefined) {
      obj.isGpsSensorEnabled = message.isGpsSensorEnabled;
    }
    if (message.timeSinceUpdate !== undefined) {
      obj.timeSinceUpdate = message.timeSinceUpdate;
    }
    if (message.numStaleUpdates !== undefined) {
      obj.numStaleUpdates = message.numStaleUpdates;
    }
    if (message.rawLocation !== undefined) {
      obj.rawLocation = LatLng.toJSON(message.rawLocation);
    }
    if (message.rawLocationTime !== undefined) {
      obj.rawLocationTime = message.rawLocationTime.toISOString();
    }
    if (message.rawLocationSensor !== 0) {
      obj.rawLocationSensor = deliveryVehicleLocationSensorToJSON(message.rawLocationSensor);
    }
    if (message.rawLocationAccuracy !== undefined) {
      obj.rawLocationAccuracy = message.rawLocationAccuracy;
    }
    if (message.supplementalLocation !== undefined) {
      obj.supplementalLocation = LatLng.toJSON(message.supplementalLocation);
    }
    if (message.supplementalLocationTime !== undefined) {
      obj.supplementalLocationTime = message.supplementalLocationTime.toISOString();
    }
    if (message.supplementalLocationSensor !== 0) {
      obj.supplementalLocationSensor = deliveryVehicleLocationSensorToJSON(message.supplementalLocationSensor);
    }
    if (message.supplementalLocationAccuracy !== undefined) {
      obj.supplementalLocationAccuracy = message.supplementalLocationAccuracy;
    }
    if (message.roadSnapped !== false) {
      obj.roadSnapped = message.roadSnapped;
    }
    return obj;
  },

  create(base?: DeepPartial<DeliveryVehicleLocation>): DeliveryVehicleLocation {
    return DeliveryVehicleLocation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeliveryVehicleLocation>): DeliveryVehicleLocation {
    const message = createBaseDeliveryVehicleLocation();
    message.location = (object.location !== undefined && object.location !== null)
      ? LatLng.fromPartial(object.location)
      : undefined;
    message.horizontalAccuracy = object.horizontalAccuracy ?? undefined;
    message.latlngAccuracy = object.latlngAccuracy ?? undefined;
    message.heading = object.heading ?? undefined;
    message.bearingAccuracy = object.bearingAccuracy ?? undefined;
    message.headingAccuracy = object.headingAccuracy ?? undefined;
    message.altitude = object.altitude ?? undefined;
    message.verticalAccuracy = object.verticalAccuracy ?? undefined;
    message.altitudeAccuracy = object.altitudeAccuracy ?? undefined;
    message.speedKmph = object.speedKmph ?? undefined;
    message.speed = object.speed ?? undefined;
    message.speedAccuracy = object.speedAccuracy ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.serverTime = object.serverTime ?? undefined;
    message.locationSensor = object.locationSensor ?? 0;
    message.isRoadSnapped = object.isRoadSnapped ?? undefined;
    message.isGpsSensorEnabled = object.isGpsSensorEnabled ?? undefined;
    message.timeSinceUpdate = object.timeSinceUpdate ?? undefined;
    message.numStaleUpdates = object.numStaleUpdates ?? undefined;
    message.rawLocation = (object.rawLocation !== undefined && object.rawLocation !== null)
      ? LatLng.fromPartial(object.rawLocation)
      : undefined;
    message.rawLocationTime = object.rawLocationTime ?? undefined;
    message.rawLocationSensor = object.rawLocationSensor ?? 0;
    message.rawLocationAccuracy = object.rawLocationAccuracy ?? undefined;
    message.supplementalLocation = (object.supplementalLocation !== undefined && object.supplementalLocation !== null)
      ? LatLng.fromPartial(object.supplementalLocation)
      : undefined;
    message.supplementalLocationTime = object.supplementalLocationTime ?? undefined;
    message.supplementalLocationSensor = object.supplementalLocationSensor ?? 0;
    message.supplementalLocationAccuracy = object.supplementalLocationAccuracy ?? undefined;
    message.roadSnapped = object.roadSnapped ?? false;
    return message;
  },
};

function createBaseTimeWindow(): TimeWindow {
  return { startTime: undefined, endTime: undefined };
}

export const TimeWindow: MessageFns<TimeWindow> = {
  encode(message: TimeWindow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeWindow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeWindow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimeWindow {
    return {
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: TimeWindow): unknown {
    const obj: any = {};
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<TimeWindow>): TimeWindow {
    return TimeWindow.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TimeWindow>): TimeWindow {
    const message = createBaseTimeWindow();
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBaseTaskAttribute(): TaskAttribute {
  return { key: "", stringValue: undefined, boolValue: undefined, numberValue: undefined };
}

export const TaskAttribute: MessageFns<TaskAttribute> = {
  encode(message: TaskAttribute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.stringValue !== undefined) {
      writer.uint32(18).string(message.stringValue);
    }
    if (message.boolValue !== undefined) {
      writer.uint32(24).bool(message.boolValue);
    }
    if (message.numberValue !== undefined) {
      writer.uint32(33).double(message.numberValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskAttribute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskAttribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stringValue = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.boolValue = reader.bool();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.numberValue = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskAttribute {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      stringValue: isSet(object.stringValue) ? globalThis.String(object.stringValue) : undefined,
      boolValue: isSet(object.boolValue) ? globalThis.Boolean(object.boolValue) : undefined,
      numberValue: isSet(object.numberValue) ? globalThis.Number(object.numberValue) : undefined,
    };
  },

  toJSON(message: TaskAttribute): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.stringValue !== undefined) {
      obj.stringValue = message.stringValue;
    }
    if (message.boolValue !== undefined) {
      obj.boolValue = message.boolValue;
    }
    if (message.numberValue !== undefined) {
      obj.numberValue = message.numberValue;
    }
    return obj;
  },

  create(base?: DeepPartial<TaskAttribute>): TaskAttribute {
    return TaskAttribute.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskAttribute>): TaskAttribute {
    const message = createBaseTaskAttribute();
    message.key = object.key ?? "";
    message.stringValue = object.stringValue ?? undefined;
    message.boolValue = object.boolValue ?? undefined;
    message.numberValue = object.numberValue ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
