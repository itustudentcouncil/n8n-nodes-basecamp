// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/maps/fleetengine/delivery/v1/tasks.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../../protobuf/duration.js";
import { Timestamp } from "../../../../protobuf/timestamp.js";
import { DeliveryVehicleLocation, TaskAttribute, TimeWindow } from "./common.js";
import { LocationInfo, VehicleJourneySegment } from "./delivery_vehicles.js";

export const protobufPackage = "maps.fleetengine.delivery.v1";

/**
 * A Task in the Delivery API represents a single action to track. In general,
 * there is a distinction between shipment-related Tasks and break Tasks. A
 * shipment can have multiple Tasks associated with it. For example, there could
 * be one Task for the pickup, and one for the drop-off or transfer. Also,
 * different Tasks for a given shipment can be handled by different vehicles.
 * For example, one vehicle could handle the pickup, driving the shipment to the
 * hub, while another vehicle drives the same shipment from the hub to the
 * drop-off location.
 *
 * Note: gRPC and REST APIs use different field naming conventions. For example,
 * the `Task.journey_sharing_info` field in the gRPC API and the
 * `Task.journeySharingInfo` field in the REST API refer to the same
 * field.
 */
export interface Task {
  /** Must be in the format `providers/{provider}/tasks/{task}`. */
  name: string;
  /**
   * Required. Immutable. Defines the type of the Task. For example, a break or
   * shipment.
   */
  type: Task_Type;
  /** Required. The current execution state of the Task. */
  state: Task_State;
  /** The outcome of the Task. */
  taskOutcome: Task_TaskOutcome;
  /**
   * The timestamp that indicates when the `Task`'s outcome was set by the
   * provider.
   */
  taskOutcomeTime:
    | Date
    | undefined;
  /**
   * The location where the `Task`'s outcome was set. This value is updated as
   * part of `UpdateTask`. If this value isn't explicitly updated by the
   * provider, then Fleet Engine populates it by default with the last known
   * vehicle location (the *raw* location).
   */
  taskOutcomeLocation:
    | LocationInfo
    | undefined;
  /** Indicates where the value of the `task_outcome_location` came from. */
  taskOutcomeLocationSource: Task_TaskOutcomeLocationSource;
  /**
   * Immutable. This field facilitates the storing of an ID so you can avoid
   * using a complicated mapping. You cannot set `tracking_id` for Tasks of type
   * `UNAVAILABLE` and `SCHEDULED_STOP`. These IDs are subject to the
   * following restrictions:
   *
   * * Must be a valid Unicode string.
   * * Limited to a maximum length of 64 characters.
   * * Normalized according to [Unicode Normalization Form C]
   * (http://www.unicode.org/reports/tr15/).
   * * May not contain any of the following ASCII characters: '/', ':', '?',
   * ',', or '#'.
   */
  trackingId: string;
  /**
   * Output only. The ID of the vehicle that is executing this Task. Delivery
   * Vehicle IDs are subject to the following restrictions:
   *
   * * Must be a valid Unicode string.
   * * Limited to a maximum length of 64 characters.
   * * Normalized according to [Unicode Normalization Form C]
   * (http://www.unicode.org/reports/tr15/).
   * * May not contain any of the following ASCII characters: '/', ':', '?',
   * ',', or '#'.
   */
  deliveryVehicleId: string;
  /**
   * Immutable. The location where the Task will be completed.
   * Optional for `UNAVAILABLE` Tasks, but required for all other Tasks.
   */
  plannedLocation:
    | LocationInfo
    | undefined;
  /** Required. Immutable. The time needed to execute a Task at this location. */
  taskDuration:
    | Duration
    | undefined;
  /** The time window during which the task should be completed. */
  targetTimeWindow:
    | TimeWindow
    | undefined;
  /**
   * Output only. Journey sharing-specific fields. Not populated when state is
   * `CLOSED`.
   */
  journeySharingInfo:
    | Task_JourneySharingInfo
    | undefined;
  /**
   * The configuration for task tracking that specifies which data elements are
   * visible to the end users under what circumstances.
   */
  taskTrackingViewConfig:
    | TaskTrackingViewConfig
    | undefined;
  /** A list of custom Task attributes. Each attribute must have a unique key. */
  attributes: TaskAttribute[];
}

/** The type of Task. */
export enum Task_Type {
  /** TYPE_UNSPECIFIED - Default, the Task type is unknown. */
  TYPE_UNSPECIFIED = 0,
  /**
   * PICKUP - A pickup Task is the action taken for picking up a shipment from a
   * customer. Depot or feeder vehicle pickups should use the `SCHEDULED_STOP`
   * type.
   */
  PICKUP = 1,
  /**
   * DELIVERY - A delivery Task is the action taken for delivering a shipment to an end
   * customer. Depot or feeder vehicle dropoffs should use the
   * `SCHEDULED_STOP` type.
   */
  DELIVERY = 2,
  /**
   * SCHEDULED_STOP - A scheduled stop Task is used for planning purposes. For example, it
   * could represent picking up or dropping off shipments from feeder vehicles
   * or depots. It shouldn't be used for any shipments that are picked up or
   * dropped off from an end customer.
   */
  SCHEDULED_STOP = 3,
  /**
   * UNAVAILABLE - A Task that means the Vehicle is not available for service. For example,
   * this can happen when the driver takes a break, or when the vehicle
   * is being refueled.
   */
  UNAVAILABLE = 4,
  UNRECOGNIZED = -1,
}

export function task_TypeFromJSON(object: any): Task_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return Task_Type.TYPE_UNSPECIFIED;
    case 1:
    case "PICKUP":
      return Task_Type.PICKUP;
    case 2:
    case "DELIVERY":
      return Task_Type.DELIVERY;
    case 3:
    case "SCHEDULED_STOP":
      return Task_Type.SCHEDULED_STOP;
    case 4:
    case "UNAVAILABLE":
      return Task_Type.UNAVAILABLE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Task_Type.UNRECOGNIZED;
  }
}

export function task_TypeToJSON(object: Task_Type): string {
  switch (object) {
    case Task_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case Task_Type.PICKUP:
      return "PICKUP";
    case Task_Type.DELIVERY:
      return "DELIVERY";
    case Task_Type.SCHEDULED_STOP:
      return "SCHEDULED_STOP";
    case Task_Type.UNAVAILABLE:
      return "UNAVAILABLE";
    case Task_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The state of a Task. This indicates the Tasks's progress. */
export enum Task_State {
  /** STATE_UNSPECIFIED - Default. Used for an unspecified or unrecognized Task state. */
  STATE_UNSPECIFIED = 0,
  /**
   * OPEN - Either the Task has not yet been assigned to a delivery vehicle, or the
   * delivery vehicle has not yet passed the `Task`'s assigned vehicle stop.
   */
  OPEN = 1,
  /** CLOSED - When the vehicle passes the vehicle stop for this Task. */
  CLOSED = 2,
  UNRECOGNIZED = -1,
}

export function task_StateFromJSON(object: any): Task_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Task_State.STATE_UNSPECIFIED;
    case 1:
    case "OPEN":
      return Task_State.OPEN;
    case 2:
    case "CLOSED":
      return Task_State.CLOSED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Task_State.UNRECOGNIZED;
  }
}

export function task_StateToJSON(object: Task_State): string {
  switch (object) {
    case Task_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Task_State.OPEN:
      return "OPEN";
    case Task_State.CLOSED:
      return "CLOSED";
    case Task_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The outcome of attempting to execute a Task. When `TaskState` is closed,
 * `TaskOutcome` indicates whether it was completed successfully.
 */
export enum Task_TaskOutcome {
  /** TASK_OUTCOME_UNSPECIFIED - The Task outcome before its value is set. */
  TASK_OUTCOME_UNSPECIFIED = 0,
  /** SUCCEEDED - The Task completed successfully. */
  SUCCEEDED = 1,
  /** FAILED - Either the Task couldn't be completed, or it was cancelled. */
  FAILED = 2,
  UNRECOGNIZED = -1,
}

export function task_TaskOutcomeFromJSON(object: any): Task_TaskOutcome {
  switch (object) {
    case 0:
    case "TASK_OUTCOME_UNSPECIFIED":
      return Task_TaskOutcome.TASK_OUTCOME_UNSPECIFIED;
    case 1:
    case "SUCCEEDED":
      return Task_TaskOutcome.SUCCEEDED;
    case 2:
    case "FAILED":
      return Task_TaskOutcome.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Task_TaskOutcome.UNRECOGNIZED;
  }
}

export function task_TaskOutcomeToJSON(object: Task_TaskOutcome): string {
  switch (object) {
    case Task_TaskOutcome.TASK_OUTCOME_UNSPECIFIED:
      return "TASK_OUTCOME_UNSPECIFIED";
    case Task_TaskOutcome.SUCCEEDED:
      return "SUCCEEDED";
    case Task_TaskOutcome.FAILED:
      return "FAILED";
    case Task_TaskOutcome.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The identity of the source that populated the `task_outcome_location`. */
export enum Task_TaskOutcomeLocationSource {
  /** TASK_OUTCOME_LOCATION_SOURCE_UNSPECIFIED - The task outcome before it is set. */
  TASK_OUTCOME_LOCATION_SOURCE_UNSPECIFIED = 0,
  /** PROVIDER - The provider-specified the `task_outcome_location`. */
  PROVIDER = 2,
  /**
   * LAST_VEHICLE_LOCATION - The provider didn't specify the `task_outcome_location`, so Fleet Engine
   * used the last known vehicle location.
   */
  LAST_VEHICLE_LOCATION = 3,
  UNRECOGNIZED = -1,
}

export function task_TaskOutcomeLocationSourceFromJSON(object: any): Task_TaskOutcomeLocationSource {
  switch (object) {
    case 0:
    case "TASK_OUTCOME_LOCATION_SOURCE_UNSPECIFIED":
      return Task_TaskOutcomeLocationSource.TASK_OUTCOME_LOCATION_SOURCE_UNSPECIFIED;
    case 2:
    case "PROVIDER":
      return Task_TaskOutcomeLocationSource.PROVIDER;
    case 3:
    case "LAST_VEHICLE_LOCATION":
      return Task_TaskOutcomeLocationSource.LAST_VEHICLE_LOCATION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Task_TaskOutcomeLocationSource.UNRECOGNIZED;
  }
}

export function task_TaskOutcomeLocationSourceToJSON(object: Task_TaskOutcomeLocationSource): string {
  switch (object) {
    case Task_TaskOutcomeLocationSource.TASK_OUTCOME_LOCATION_SOURCE_UNSPECIFIED:
      return "TASK_OUTCOME_LOCATION_SOURCE_UNSPECIFIED";
    case Task_TaskOutcomeLocationSource.PROVIDER:
      return "PROVIDER";
    case Task_TaskOutcomeLocationSource.LAST_VEHICLE_LOCATION:
      return "LAST_VEHICLE_LOCATION";
    case Task_TaskOutcomeLocationSource.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Journey sharing specific fields. */
export interface Task_JourneySharingInfo {
  /**
   * Tracking information for the stops that the assigned vehicle will make
   * before it completes this Task. Note that this list can contain stops
   * from other tasks.
   *
   * The first segment,
   * `Task.journey_sharing_info.remaining_vehicle_journey_segments[0]` (gRPC)
   * or `Task.journeySharingInfo.remainingVehicleJourneySegments[0]` (REST),
   * contains route information from the driver's last known location to the
   * upcoming `VehicleStop`. Current route information usually comes from the
   * driver app, except for some cases noted in the documentation for
   * [DeliveryVehicle.current_route_segment][maps.fleetengine.delivery.v1.DeliveryVehicle.current_route_segment].
   * The other segments in
   * `Task.journey_sharing_info.remaining_vehicle_journey_segments` (gRPC) or
   * `Task.journeySharingInfo.remainingVehicleJourneySegments` (REST) are
   * populated by Fleet Engine. They provide route information between the
   * remaining `VehicleStops`.
   */
  remainingVehicleJourneySegments: VehicleJourneySegment[];
  /** Indicates the vehicle's last reported location of the assigned vehicle. */
  lastLocation:
    | DeliveryVehicleLocation
    | undefined;
  /**
   * Indicates whether the vehicle's lastLocation can be snapped to
   * the `current_route_segment`. This value is False if either
   * `last_location` or `current_route_segment` don't exist. This value is
   * computed by Fleet Engine. Updates from clients are ignored.
   */
  lastLocationSnappable: boolean;
}

/**
 * The configuration message that defines when a data element of a Task should
 * be visible to the end users.
 */
export interface TaskTrackingViewConfig {
  /**
   * The field that specifies when route polyline points can be visible. If this
   * field is not specified, the project level default visibility configuration
   * for this data will be used.
   */
  routePolylinePointsVisibility:
    | TaskTrackingViewConfig_VisibilityOption
    | undefined;
  /**
   * The field that specifies when estimated arrival time can be visible. If
   * this field is not specified, the project level default visibility
   * configuration for this data will be used.
   */
  estimatedArrivalTimeVisibility:
    | TaskTrackingViewConfig_VisibilityOption
    | undefined;
  /**
   * The field that specifies when estimated task completion time can be
   * visible. If this field is not specified, the project level default
   * visibility configuration for this data will be used.
   */
  estimatedTaskCompletionTimeVisibility:
    | TaskTrackingViewConfig_VisibilityOption
    | undefined;
  /**
   * The field that specifies when remaining driving distance can be visible. If
   * this field is not specified, the project level default visibility
   * configuration for this data will be used.
   */
  remainingDrivingDistanceVisibility:
    | TaskTrackingViewConfig_VisibilityOption
    | undefined;
  /**
   * The field that specifies when remaining stop count can be visible. If this
   * field is not specified, the project level default visibility configuration
   * for this data will be used.
   */
  remainingStopCountVisibility:
    | TaskTrackingViewConfig_VisibilityOption
    | undefined;
  /**
   * The field that specifies when vehicle location can be visible. If this
   * field is not specified, the project level default visibility configuration
   * for this data will be used.
   */
  vehicleLocationVisibility: TaskTrackingViewConfig_VisibilityOption | undefined;
}

/**
 * The option message that defines when a data element should be visible to
 * the end users.
 */
export interface TaskTrackingViewConfig_VisibilityOption {
  /**
   * This data element is visible to the end users if the remaining stop
   * count <= remaining_stop_count_threshold.
   */
  remainingStopCountThreshold?:
    | number
    | undefined;
  /**
   * This data element is visible to the end users if the ETA to the stop
   * <= duration_until_estimated_arrival_time_threshold.
   */
  durationUntilEstimatedArrivalTimeThreshold?:
    | Duration
    | undefined;
  /**
   * This data element is visible to the end users if the remaining
   * driving distance in meters <=
   * remaining_driving_distance_meters_threshold.
   */
  remainingDrivingDistanceMetersThreshold?:
    | number
    | undefined;
  /**
   * If set to true, this data element is always visible to the end users
   * with no thresholds. This field cannot be set to false.
   */
  always?:
    | boolean
    | undefined;
  /**
   * If set to true, this data element is always hidden from the end users
   * with no thresholds. This field cannot be set to false.
   */
  never?: boolean | undefined;
}

function createBaseTask(): Task {
  return {
    name: "",
    type: 0,
    state: 0,
    taskOutcome: 0,
    taskOutcomeTime: undefined,
    taskOutcomeLocation: undefined,
    taskOutcomeLocationSource: 0,
    trackingId: "",
    deliveryVehicleId: "",
    plannedLocation: undefined,
    taskDuration: undefined,
    targetTimeWindow: undefined,
    journeySharingInfo: undefined,
    taskTrackingViewConfig: undefined,
    attributes: [],
  };
}

export const Task: MessageFns<Task> = {
  encode(message: Task, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.state !== 0) {
      writer.uint32(24).int32(message.state);
    }
    if (message.taskOutcome !== 0) {
      writer.uint32(72).int32(message.taskOutcome);
    }
    if (message.taskOutcomeTime !== undefined) {
      Timestamp.encode(toTimestamp(message.taskOutcomeTime), writer.uint32(82).fork()).join();
    }
    if (message.taskOutcomeLocation !== undefined) {
      LocationInfo.encode(message.taskOutcomeLocation, writer.uint32(90).fork()).join();
    }
    if (message.taskOutcomeLocationSource !== 0) {
      writer.uint32(96).int32(message.taskOutcomeLocationSource);
    }
    if (message.trackingId !== "") {
      writer.uint32(34).string(message.trackingId);
    }
    if (message.deliveryVehicleId !== "") {
      writer.uint32(42).string(message.deliveryVehicleId);
    }
    if (message.plannedLocation !== undefined) {
      LocationInfo.encode(message.plannedLocation, writer.uint32(50).fork()).join();
    }
    if (message.taskDuration !== undefined) {
      Duration.encode(message.taskDuration, writer.uint32(58).fork()).join();
    }
    if (message.targetTimeWindow !== undefined) {
      TimeWindow.encode(message.targetTimeWindow, writer.uint32(114).fork()).join();
    }
    if (message.journeySharingInfo !== undefined) {
      Task_JourneySharingInfo.encode(message.journeySharingInfo, writer.uint32(66).fork()).join();
    }
    if (message.taskTrackingViewConfig !== undefined) {
      TaskTrackingViewConfig.encode(message.taskTrackingViewConfig, writer.uint32(106).fork()).join();
    }
    for (const v of message.attributes) {
      TaskAttribute.encode(v!, writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Task {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTask();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.taskOutcome = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.taskOutcomeTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.taskOutcomeLocation = LocationInfo.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.taskOutcomeLocationSource = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.trackingId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.deliveryVehicleId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.plannedLocation = LocationInfo.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.taskDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.targetTimeWindow = TimeWindow.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.journeySharingInfo = Task_JourneySharingInfo.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.taskTrackingViewConfig = TaskTrackingViewConfig.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.attributes.push(TaskAttribute.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Task {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? task_TypeFromJSON(object.type) : 0,
      state: isSet(object.state) ? task_StateFromJSON(object.state) : 0,
      taskOutcome: isSet(object.taskOutcome) ? task_TaskOutcomeFromJSON(object.taskOutcome) : 0,
      taskOutcomeTime: isSet(object.taskOutcomeTime) ? fromJsonTimestamp(object.taskOutcomeTime) : undefined,
      taskOutcomeLocation: isSet(object.taskOutcomeLocation)
        ? LocationInfo.fromJSON(object.taskOutcomeLocation)
        : undefined,
      taskOutcomeLocationSource: isSet(object.taskOutcomeLocationSource)
        ? task_TaskOutcomeLocationSourceFromJSON(object.taskOutcomeLocationSource)
        : 0,
      trackingId: isSet(object.trackingId) ? globalThis.String(object.trackingId) : "",
      deliveryVehicleId: isSet(object.deliveryVehicleId) ? globalThis.String(object.deliveryVehicleId) : "",
      plannedLocation: isSet(object.plannedLocation) ? LocationInfo.fromJSON(object.plannedLocation) : undefined,
      taskDuration: isSet(object.taskDuration) ? Duration.fromJSON(object.taskDuration) : undefined,
      targetTimeWindow: isSet(object.targetTimeWindow) ? TimeWindow.fromJSON(object.targetTimeWindow) : undefined,
      journeySharingInfo: isSet(object.journeySharingInfo)
        ? Task_JourneySharingInfo.fromJSON(object.journeySharingInfo)
        : undefined,
      taskTrackingViewConfig: isSet(object.taskTrackingViewConfig)
        ? TaskTrackingViewConfig.fromJSON(object.taskTrackingViewConfig)
        : undefined,
      attributes: globalThis.Array.isArray(object?.attributes)
        ? object.attributes.map((e: any) => TaskAttribute.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Task): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== 0) {
      obj.type = task_TypeToJSON(message.type);
    }
    if (message.state !== 0) {
      obj.state = task_StateToJSON(message.state);
    }
    if (message.taskOutcome !== 0) {
      obj.taskOutcome = task_TaskOutcomeToJSON(message.taskOutcome);
    }
    if (message.taskOutcomeTime !== undefined) {
      obj.taskOutcomeTime = message.taskOutcomeTime.toISOString();
    }
    if (message.taskOutcomeLocation !== undefined) {
      obj.taskOutcomeLocation = LocationInfo.toJSON(message.taskOutcomeLocation);
    }
    if (message.taskOutcomeLocationSource !== 0) {
      obj.taskOutcomeLocationSource = task_TaskOutcomeLocationSourceToJSON(message.taskOutcomeLocationSource);
    }
    if (message.trackingId !== "") {
      obj.trackingId = message.trackingId;
    }
    if (message.deliveryVehicleId !== "") {
      obj.deliveryVehicleId = message.deliveryVehicleId;
    }
    if (message.plannedLocation !== undefined) {
      obj.plannedLocation = LocationInfo.toJSON(message.plannedLocation);
    }
    if (message.taskDuration !== undefined) {
      obj.taskDuration = Duration.toJSON(message.taskDuration);
    }
    if (message.targetTimeWindow !== undefined) {
      obj.targetTimeWindow = TimeWindow.toJSON(message.targetTimeWindow);
    }
    if (message.journeySharingInfo !== undefined) {
      obj.journeySharingInfo = Task_JourneySharingInfo.toJSON(message.journeySharingInfo);
    }
    if (message.taskTrackingViewConfig !== undefined) {
      obj.taskTrackingViewConfig = TaskTrackingViewConfig.toJSON(message.taskTrackingViewConfig);
    }
    if (message.attributes?.length) {
      obj.attributes = message.attributes.map((e) => TaskAttribute.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Task>): Task {
    return Task.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Task>): Task {
    const message = createBaseTask();
    message.name = object.name ?? "";
    message.type = object.type ?? 0;
    message.state = object.state ?? 0;
    message.taskOutcome = object.taskOutcome ?? 0;
    message.taskOutcomeTime = object.taskOutcomeTime ?? undefined;
    message.taskOutcomeLocation = (object.taskOutcomeLocation !== undefined && object.taskOutcomeLocation !== null)
      ? LocationInfo.fromPartial(object.taskOutcomeLocation)
      : undefined;
    message.taskOutcomeLocationSource = object.taskOutcomeLocationSource ?? 0;
    message.trackingId = object.trackingId ?? "";
    message.deliveryVehicleId = object.deliveryVehicleId ?? "";
    message.plannedLocation = (object.plannedLocation !== undefined && object.plannedLocation !== null)
      ? LocationInfo.fromPartial(object.plannedLocation)
      : undefined;
    message.taskDuration = (object.taskDuration !== undefined && object.taskDuration !== null)
      ? Duration.fromPartial(object.taskDuration)
      : undefined;
    message.targetTimeWindow = (object.targetTimeWindow !== undefined && object.targetTimeWindow !== null)
      ? TimeWindow.fromPartial(object.targetTimeWindow)
      : undefined;
    message.journeySharingInfo = (object.journeySharingInfo !== undefined && object.journeySharingInfo !== null)
      ? Task_JourneySharingInfo.fromPartial(object.journeySharingInfo)
      : undefined;
    message.taskTrackingViewConfig =
      (object.taskTrackingViewConfig !== undefined && object.taskTrackingViewConfig !== null)
        ? TaskTrackingViewConfig.fromPartial(object.taskTrackingViewConfig)
        : undefined;
    message.attributes = object.attributes?.map((e) => TaskAttribute.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTask_JourneySharingInfo(): Task_JourneySharingInfo {
  return { remainingVehicleJourneySegments: [], lastLocation: undefined, lastLocationSnappable: false };
}

export const Task_JourneySharingInfo: MessageFns<Task_JourneySharingInfo> = {
  encode(message: Task_JourneySharingInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.remainingVehicleJourneySegments) {
      VehicleJourneySegment.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.lastLocation !== undefined) {
      DeliveryVehicleLocation.encode(message.lastLocation, writer.uint32(18).fork()).join();
    }
    if (message.lastLocationSnappable !== false) {
      writer.uint32(24).bool(message.lastLocationSnappable);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Task_JourneySharingInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTask_JourneySharingInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.remainingVehicleJourneySegments.push(VehicleJourneySegment.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.lastLocation = DeliveryVehicleLocation.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.lastLocationSnappable = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Task_JourneySharingInfo {
    return {
      remainingVehicleJourneySegments: globalThis.Array.isArray(object?.remainingVehicleJourneySegments)
        ? object.remainingVehicleJourneySegments.map((e: any) => VehicleJourneySegment.fromJSON(e))
        : [],
      lastLocation: isSet(object.lastLocation) ? DeliveryVehicleLocation.fromJSON(object.lastLocation) : undefined,
      lastLocationSnappable: isSet(object.lastLocationSnappable)
        ? globalThis.Boolean(object.lastLocationSnappable)
        : false,
    };
  },

  toJSON(message: Task_JourneySharingInfo): unknown {
    const obj: any = {};
    if (message.remainingVehicleJourneySegments?.length) {
      obj.remainingVehicleJourneySegments = message.remainingVehicleJourneySegments.map((e) =>
        VehicleJourneySegment.toJSON(e)
      );
    }
    if (message.lastLocation !== undefined) {
      obj.lastLocation = DeliveryVehicleLocation.toJSON(message.lastLocation);
    }
    if (message.lastLocationSnappable !== false) {
      obj.lastLocationSnappable = message.lastLocationSnappable;
    }
    return obj;
  },

  create(base?: DeepPartial<Task_JourneySharingInfo>): Task_JourneySharingInfo {
    return Task_JourneySharingInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Task_JourneySharingInfo>): Task_JourneySharingInfo {
    const message = createBaseTask_JourneySharingInfo();
    message.remainingVehicleJourneySegments =
      object.remainingVehicleJourneySegments?.map((e) => VehicleJourneySegment.fromPartial(e)) || [];
    message.lastLocation = (object.lastLocation !== undefined && object.lastLocation !== null)
      ? DeliveryVehicleLocation.fromPartial(object.lastLocation)
      : undefined;
    message.lastLocationSnappable = object.lastLocationSnappable ?? false;
    return message;
  },
};

function createBaseTaskTrackingViewConfig(): TaskTrackingViewConfig {
  return {
    routePolylinePointsVisibility: undefined,
    estimatedArrivalTimeVisibility: undefined,
    estimatedTaskCompletionTimeVisibility: undefined,
    remainingDrivingDistanceVisibility: undefined,
    remainingStopCountVisibility: undefined,
    vehicleLocationVisibility: undefined,
  };
}

export const TaskTrackingViewConfig: MessageFns<TaskTrackingViewConfig> = {
  encode(message: TaskTrackingViewConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.routePolylinePointsVisibility !== undefined) {
      TaskTrackingViewConfig_VisibilityOption.encode(message.routePolylinePointsVisibility, writer.uint32(10).fork())
        .join();
    }
    if (message.estimatedArrivalTimeVisibility !== undefined) {
      TaskTrackingViewConfig_VisibilityOption.encode(message.estimatedArrivalTimeVisibility, writer.uint32(18).fork())
        .join();
    }
    if (message.estimatedTaskCompletionTimeVisibility !== undefined) {
      TaskTrackingViewConfig_VisibilityOption.encode(
        message.estimatedTaskCompletionTimeVisibility,
        writer.uint32(26).fork(),
      ).join();
    }
    if (message.remainingDrivingDistanceVisibility !== undefined) {
      TaskTrackingViewConfig_VisibilityOption.encode(
        message.remainingDrivingDistanceVisibility,
        writer.uint32(34).fork(),
      ).join();
    }
    if (message.remainingStopCountVisibility !== undefined) {
      TaskTrackingViewConfig_VisibilityOption.encode(message.remainingStopCountVisibility, writer.uint32(42).fork())
        .join();
    }
    if (message.vehicleLocationVisibility !== undefined) {
      TaskTrackingViewConfig_VisibilityOption.encode(message.vehicleLocationVisibility, writer.uint32(50).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskTrackingViewConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskTrackingViewConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.routePolylinePointsVisibility = TaskTrackingViewConfig_VisibilityOption.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.estimatedArrivalTimeVisibility = TaskTrackingViewConfig_VisibilityOption.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.estimatedTaskCompletionTimeVisibility = TaskTrackingViewConfig_VisibilityOption.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.remainingDrivingDistanceVisibility = TaskTrackingViewConfig_VisibilityOption.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.remainingStopCountVisibility = TaskTrackingViewConfig_VisibilityOption.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.vehicleLocationVisibility = TaskTrackingViewConfig_VisibilityOption.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskTrackingViewConfig {
    return {
      routePolylinePointsVisibility: isSet(object.routePolylinePointsVisibility)
        ? TaskTrackingViewConfig_VisibilityOption.fromJSON(object.routePolylinePointsVisibility)
        : undefined,
      estimatedArrivalTimeVisibility: isSet(object.estimatedArrivalTimeVisibility)
        ? TaskTrackingViewConfig_VisibilityOption.fromJSON(object.estimatedArrivalTimeVisibility)
        : undefined,
      estimatedTaskCompletionTimeVisibility: isSet(object.estimatedTaskCompletionTimeVisibility)
        ? TaskTrackingViewConfig_VisibilityOption.fromJSON(object.estimatedTaskCompletionTimeVisibility)
        : undefined,
      remainingDrivingDistanceVisibility: isSet(object.remainingDrivingDistanceVisibility)
        ? TaskTrackingViewConfig_VisibilityOption.fromJSON(object.remainingDrivingDistanceVisibility)
        : undefined,
      remainingStopCountVisibility: isSet(object.remainingStopCountVisibility)
        ? TaskTrackingViewConfig_VisibilityOption.fromJSON(object.remainingStopCountVisibility)
        : undefined,
      vehicleLocationVisibility: isSet(object.vehicleLocationVisibility)
        ? TaskTrackingViewConfig_VisibilityOption.fromJSON(object.vehicleLocationVisibility)
        : undefined,
    };
  },

  toJSON(message: TaskTrackingViewConfig): unknown {
    const obj: any = {};
    if (message.routePolylinePointsVisibility !== undefined) {
      obj.routePolylinePointsVisibility = TaskTrackingViewConfig_VisibilityOption.toJSON(
        message.routePolylinePointsVisibility,
      );
    }
    if (message.estimatedArrivalTimeVisibility !== undefined) {
      obj.estimatedArrivalTimeVisibility = TaskTrackingViewConfig_VisibilityOption.toJSON(
        message.estimatedArrivalTimeVisibility,
      );
    }
    if (message.estimatedTaskCompletionTimeVisibility !== undefined) {
      obj.estimatedTaskCompletionTimeVisibility = TaskTrackingViewConfig_VisibilityOption.toJSON(
        message.estimatedTaskCompletionTimeVisibility,
      );
    }
    if (message.remainingDrivingDistanceVisibility !== undefined) {
      obj.remainingDrivingDistanceVisibility = TaskTrackingViewConfig_VisibilityOption.toJSON(
        message.remainingDrivingDistanceVisibility,
      );
    }
    if (message.remainingStopCountVisibility !== undefined) {
      obj.remainingStopCountVisibility = TaskTrackingViewConfig_VisibilityOption.toJSON(
        message.remainingStopCountVisibility,
      );
    }
    if (message.vehicleLocationVisibility !== undefined) {
      obj.vehicleLocationVisibility = TaskTrackingViewConfig_VisibilityOption.toJSON(message.vehicleLocationVisibility);
    }
    return obj;
  },

  create(base?: DeepPartial<TaskTrackingViewConfig>): TaskTrackingViewConfig {
    return TaskTrackingViewConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskTrackingViewConfig>): TaskTrackingViewConfig {
    const message = createBaseTaskTrackingViewConfig();
    message.routePolylinePointsVisibility =
      (object.routePolylinePointsVisibility !== undefined && object.routePolylinePointsVisibility !== null)
        ? TaskTrackingViewConfig_VisibilityOption.fromPartial(object.routePolylinePointsVisibility)
        : undefined;
    message.estimatedArrivalTimeVisibility =
      (object.estimatedArrivalTimeVisibility !== undefined && object.estimatedArrivalTimeVisibility !== null)
        ? TaskTrackingViewConfig_VisibilityOption.fromPartial(object.estimatedArrivalTimeVisibility)
        : undefined;
    message.estimatedTaskCompletionTimeVisibility =
      (object.estimatedTaskCompletionTimeVisibility !== undefined &&
          object.estimatedTaskCompletionTimeVisibility !== null)
        ? TaskTrackingViewConfig_VisibilityOption.fromPartial(object.estimatedTaskCompletionTimeVisibility)
        : undefined;
    message.remainingDrivingDistanceVisibility =
      (object.remainingDrivingDistanceVisibility !== undefined && object.remainingDrivingDistanceVisibility !== null)
        ? TaskTrackingViewConfig_VisibilityOption.fromPartial(object.remainingDrivingDistanceVisibility)
        : undefined;
    message.remainingStopCountVisibility =
      (object.remainingStopCountVisibility !== undefined && object.remainingStopCountVisibility !== null)
        ? TaskTrackingViewConfig_VisibilityOption.fromPartial(object.remainingStopCountVisibility)
        : undefined;
    message.vehicleLocationVisibility =
      (object.vehicleLocationVisibility !== undefined && object.vehicleLocationVisibility !== null)
        ? TaskTrackingViewConfig_VisibilityOption.fromPartial(object.vehicleLocationVisibility)
        : undefined;
    return message;
  },
};

function createBaseTaskTrackingViewConfig_VisibilityOption(): TaskTrackingViewConfig_VisibilityOption {
  return {
    remainingStopCountThreshold: undefined,
    durationUntilEstimatedArrivalTimeThreshold: undefined,
    remainingDrivingDistanceMetersThreshold: undefined,
    always: undefined,
    never: undefined,
  };
}

export const TaskTrackingViewConfig_VisibilityOption: MessageFns<TaskTrackingViewConfig_VisibilityOption> = {
  encode(message: TaskTrackingViewConfig_VisibilityOption, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.remainingStopCountThreshold !== undefined) {
      writer.uint32(8).int32(message.remainingStopCountThreshold);
    }
    if (message.durationUntilEstimatedArrivalTimeThreshold !== undefined) {
      Duration.encode(message.durationUntilEstimatedArrivalTimeThreshold, writer.uint32(18).fork()).join();
    }
    if (message.remainingDrivingDistanceMetersThreshold !== undefined) {
      writer.uint32(24).int32(message.remainingDrivingDistanceMetersThreshold);
    }
    if (message.always !== undefined) {
      writer.uint32(32).bool(message.always);
    }
    if (message.never !== undefined) {
      writer.uint32(40).bool(message.never);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskTrackingViewConfig_VisibilityOption {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskTrackingViewConfig_VisibilityOption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.remainingStopCountThreshold = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.durationUntilEstimatedArrivalTimeThreshold = Duration.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.remainingDrivingDistanceMetersThreshold = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.always = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.never = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskTrackingViewConfig_VisibilityOption {
    return {
      remainingStopCountThreshold: isSet(object.remainingStopCountThreshold)
        ? globalThis.Number(object.remainingStopCountThreshold)
        : undefined,
      durationUntilEstimatedArrivalTimeThreshold: isSet(object.durationUntilEstimatedArrivalTimeThreshold)
        ? Duration.fromJSON(object.durationUntilEstimatedArrivalTimeThreshold)
        : undefined,
      remainingDrivingDistanceMetersThreshold: isSet(object.remainingDrivingDistanceMetersThreshold)
        ? globalThis.Number(object.remainingDrivingDistanceMetersThreshold)
        : undefined,
      always: isSet(object.always) ? globalThis.Boolean(object.always) : undefined,
      never: isSet(object.never) ? globalThis.Boolean(object.never) : undefined,
    };
  },

  toJSON(message: TaskTrackingViewConfig_VisibilityOption): unknown {
    const obj: any = {};
    if (message.remainingStopCountThreshold !== undefined) {
      obj.remainingStopCountThreshold = Math.round(message.remainingStopCountThreshold);
    }
    if (message.durationUntilEstimatedArrivalTimeThreshold !== undefined) {
      obj.durationUntilEstimatedArrivalTimeThreshold = Duration.toJSON(
        message.durationUntilEstimatedArrivalTimeThreshold,
      );
    }
    if (message.remainingDrivingDistanceMetersThreshold !== undefined) {
      obj.remainingDrivingDistanceMetersThreshold = Math.round(message.remainingDrivingDistanceMetersThreshold);
    }
    if (message.always !== undefined) {
      obj.always = message.always;
    }
    if (message.never !== undefined) {
      obj.never = message.never;
    }
    return obj;
  },

  create(base?: DeepPartial<TaskTrackingViewConfig_VisibilityOption>): TaskTrackingViewConfig_VisibilityOption {
    return TaskTrackingViewConfig_VisibilityOption.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskTrackingViewConfig_VisibilityOption>): TaskTrackingViewConfig_VisibilityOption {
    const message = createBaseTaskTrackingViewConfig_VisibilityOption();
    message.remainingStopCountThreshold = object.remainingStopCountThreshold ?? undefined;
    message.durationUntilEstimatedArrivalTimeThreshold =
      (object.durationUntilEstimatedArrivalTimeThreshold !== undefined &&
          object.durationUntilEstimatedArrivalTimeThreshold !== null)
        ? Duration.fromPartial(object.durationUntilEstimatedArrivalTimeThreshold)
        : undefined;
    message.remainingDrivingDistanceMetersThreshold = object.remainingDrivingDistanceMetersThreshold ?? undefined;
    message.always = object.always ?? undefined;
    message.never = object.never ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
