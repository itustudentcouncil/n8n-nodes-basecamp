// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/maps/solar/v1/solar_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { HttpBody } from "../../../api/httpbody.js";
import { DateMessage } from "../../../type/date.js";
import { LatLng } from "../../../type/latlng.js";
import { Money } from "../../../type/money.js";

export const protobufPackage = "google.maps.solar.v1";

/** What subset of the solar information to return. */
export enum DataLayerView {
  /** DATA_LAYER_VIEW_UNSPECIFIED - Equivalent to FULL. */
  DATA_LAYER_VIEW_UNSPECIFIED = 0,
  /** DSM_LAYER - Get the DSM only. */
  DSM_LAYER = 1,
  /** IMAGERY_LAYERS - Get the DSM, RGB, and mask. */
  IMAGERY_LAYERS = 2,
  /** IMAGERY_AND_ANNUAL_FLUX_LAYERS - Get the DSM, RGB, mask, and annual flux. */
  IMAGERY_AND_ANNUAL_FLUX_LAYERS = 3,
  /** IMAGERY_AND_ALL_FLUX_LAYERS - Get the DSM, RGB, mask, annual flux, and monthly flux. */
  IMAGERY_AND_ALL_FLUX_LAYERS = 4,
  /** FULL_LAYERS - Get all data. */
  FULL_LAYERS = 5,
  UNRECOGNIZED = -1,
}

export function dataLayerViewFromJSON(object: any): DataLayerView {
  switch (object) {
    case 0:
    case "DATA_LAYER_VIEW_UNSPECIFIED":
      return DataLayerView.DATA_LAYER_VIEW_UNSPECIFIED;
    case 1:
    case "DSM_LAYER":
      return DataLayerView.DSM_LAYER;
    case 2:
    case "IMAGERY_LAYERS":
      return DataLayerView.IMAGERY_LAYERS;
    case 3:
    case "IMAGERY_AND_ANNUAL_FLUX_LAYERS":
      return DataLayerView.IMAGERY_AND_ANNUAL_FLUX_LAYERS;
    case 4:
    case "IMAGERY_AND_ALL_FLUX_LAYERS":
      return DataLayerView.IMAGERY_AND_ALL_FLUX_LAYERS;
    case 5:
    case "FULL_LAYERS":
      return DataLayerView.FULL_LAYERS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DataLayerView.UNRECOGNIZED;
  }
}

export function dataLayerViewToJSON(object: DataLayerView): string {
  switch (object) {
    case DataLayerView.DATA_LAYER_VIEW_UNSPECIFIED:
      return "DATA_LAYER_VIEW_UNSPECIFIED";
    case DataLayerView.DSM_LAYER:
      return "DSM_LAYER";
    case DataLayerView.IMAGERY_LAYERS:
      return "IMAGERY_LAYERS";
    case DataLayerView.IMAGERY_AND_ANNUAL_FLUX_LAYERS:
      return "IMAGERY_AND_ANNUAL_FLUX_LAYERS";
    case DataLayerView.IMAGERY_AND_ALL_FLUX_LAYERS:
      return "IMAGERY_AND_ALL_FLUX_LAYERS";
    case DataLayerView.FULL_LAYERS:
      return "FULL_LAYERS";
    case DataLayerView.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The quality of the imagery used to compute some API result.
 *
 * Note: Regardless of imagery quality level, DSM outputs always have a
 * resolution of 0.1 m/pixel, monthly flux outputs always have a resolution of
 * 0.5 m/pixel, and hourly shade outputs always have a resolution of 1 m/pixel.
 */
export enum ImageryQuality {
  /** IMAGERY_QUALITY_UNSPECIFIED - No quality is known. */
  IMAGERY_QUALITY_UNSPECIFIED = 0,
  /** HIGH - The underlying imagery and DSM data were processed at 0.1 m/pixel. */
  HIGH = 1,
  /** MEDIUM - The underlying imagery and DSM data were processed at 0.25 m/pixel. */
  MEDIUM = 2,
  /** LOW - The underlying imagery and DSM data were processed at 0.5 m/pixel. */
  LOW = 3,
  UNRECOGNIZED = -1,
}

export function imageryQualityFromJSON(object: any): ImageryQuality {
  switch (object) {
    case 0:
    case "IMAGERY_QUALITY_UNSPECIFIED":
      return ImageryQuality.IMAGERY_QUALITY_UNSPECIFIED;
    case 1:
    case "HIGH":
      return ImageryQuality.HIGH;
    case 2:
    case "MEDIUM":
      return ImageryQuality.MEDIUM;
    case 3:
    case "LOW":
      return ImageryQuality.LOW;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ImageryQuality.UNRECOGNIZED;
  }
}

export function imageryQualityToJSON(object: ImageryQuality): string {
  switch (object) {
    case ImageryQuality.IMAGERY_QUALITY_UNSPECIFIED:
      return "IMAGERY_QUALITY_UNSPECIFIED";
    case ImageryQuality.HIGH:
      return "HIGH";
    case ImageryQuality.MEDIUM:
      return "MEDIUM";
    case ImageryQuality.LOW:
      return "LOW";
    case ImageryQuality.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The orientation of a solar panel. This must be interpreted relative to the
 * azimuth of the roof segment that the panel is placed on.
 */
export enum SolarPanelOrientation {
  /** SOLAR_PANEL_ORIENTATION_UNSPECIFIED - No panel orientation is known. */
  SOLAR_PANEL_ORIENTATION_UNSPECIFIED = 0,
  /**
   * LANDSCAPE - A `LANDSCAPE` panel has its long edge perpendicular to the
   * azimuth direction of the roof segment that it is placed on.
   */
  LANDSCAPE = 1,
  /**
   * PORTRAIT - A `PORTRAIT` panel has its long edge parallel to the azimuth
   * direction of the roof segment that it is placed on.
   */
  PORTRAIT = 2,
  UNRECOGNIZED = -1,
}

export function solarPanelOrientationFromJSON(object: any): SolarPanelOrientation {
  switch (object) {
    case 0:
    case "SOLAR_PANEL_ORIENTATION_UNSPECIFIED":
      return SolarPanelOrientation.SOLAR_PANEL_ORIENTATION_UNSPECIFIED;
    case 1:
    case "LANDSCAPE":
      return SolarPanelOrientation.LANDSCAPE;
    case 2:
    case "PORTRAIT":
      return SolarPanelOrientation.PORTRAIT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SolarPanelOrientation.UNRECOGNIZED;
  }
}

export function solarPanelOrientationToJSON(object: SolarPanelOrientation): string {
  switch (object) {
    case SolarPanelOrientation.SOLAR_PANEL_ORIENTATION_UNSPECIFIED:
      return "SOLAR_PANEL_ORIENTATION_UNSPECIFIED";
    case SolarPanelOrientation.LANDSCAPE:
      return "LANDSCAPE";
    case SolarPanelOrientation.PORTRAIT:
      return "PORTRAIT";
    case SolarPanelOrientation.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Request message for `Solar.FindClosestBuildingInsights`. */
export interface FindClosestBuildingInsightsRequest {
  /**
   * Required. The longitude and latitude from which the API looks for the
   * nearest known building.
   */
  location:
    | LatLng
    | undefined;
  /**
   * Optional. The minimum quality level allowed in the results. No result with
   * lower quality than this will be returned. Not specifying this is
   * equivalent to restricting to HIGH quality only.
   */
  requiredQuality: ImageryQuality;
  /**
   * Optional. Whether to require exact quality of the imagery.
   * If set to false, the `required_quality` field is interpreted as the minimum
   * required quality, such that HIGH quality imagery may be returned when
   * `required_quality` is set to MEDIUM.  If set to true, `required_quality`
   * is interpreted as the exact required quality and only `MEDIUM` quality
   * imagery is returned if `required_quality` is set to `MEDIUM`.
   */
  exactQualityRequired: boolean;
}

/** A bounding box in lat/lng coordinates. */
export interface LatLngBox {
  /** The southwest corner of the box. */
  sw:
    | LatLng
    | undefined;
  /** The northeast corner of the box. */
  ne: LatLng | undefined;
}

/**
 * Response message for `Solar.FindClosestBuildingInsights`.
 * Information about the location, dimensions, and solar potential of a
 * building.
 */
export interface BuildingInsights {
  /** The resource name for the building, of the format `building/<place ID>`. */
  name: string;
  /** A point near the center of the building. */
  center:
    | LatLng
    | undefined;
  /** The bounding box of the building. */
  boundingBox:
    | LatLngBox
    | undefined;
  /** Date that the underlying imagery was acquired. This is approximate. */
  imageryDate:
    | DateMessage
    | undefined;
  /** When processing was completed on this imagery. */
  imageryProcessedDate:
    | DateMessage
    | undefined;
  /** Postal code (e.g., US zip code) this building is contained by. */
  postalCode: string;
  /**
   * Administrative area 1 (e.g., in the US, the state) that contains this
   * building. For example, in the US, the abbreviation might be "MA" or "CA."
   */
  administrativeArea: string;
  /** Statistical area (e.g., US census tract) this building is in. */
  statisticalArea: string;
  /** Region code for the country (or region) this building is in. */
  regionCode: string;
  /** Solar potential of the building. */
  solarPotential:
    | SolarPotential
    | undefined;
  /** The quality of the imagery used to compute the data for this building. */
  imageryQuality: ImageryQuality;
}

/**
 * Information about the solar potential of a building. A number of
 * fields in this are defined in terms of "panels". The fields
 * [panel_capacity_watts]
 * [google.maps.solar.v1.SolarPotential.panel_capacity_watts],
 * [panel_height_meters]
 * [google.maps.solar.v1.SolarPotential.panel_height_meters],
 * and [panel_width_meters]
 * [google.maps.solar.v1.SolarPotential.panel_width_meters]
 * describe the parameters of the model of panel used in these
 * calculations.
 */
export interface SolarPotential {
  /**
   * Size of the maximum array - that is, the maximum number of panels that
   * can fit on the roof.
   */
  maxArrayPanelsCount: number;
  /** Capacity, in watts, of the panel used in the calculations. */
  panelCapacityWatts: number;
  /**
   * Height, in meters in portrait orientation, of the panel used in
   * the calculations.
   */
  panelHeightMeters: number;
  /**
   * Width, in meters in portrait orientation, of the panel used in
   * the calculations.
   */
  panelWidthMeters: number;
  /**
   * The expected lifetime, in years, of the solar panels. This is
   * used in the financial calculations.
   */
  panelLifetimeYears: number;
  /** Size, in square meters, of the maximum array. */
  maxArrayAreaMeters2: number;
  /**
   * Maximum number of sunshine hours received per year, by any point
   * on the roof. Sunshine hours are a measure of the total amount of
   * insolation (energy) received per year. 1 sunshine hour = 1 kWh per kW
   * (where kW refers to kW of capacity under Standard Testing Conditions).
   */
  maxSunshineHoursPerYear: number;
  /**
   * Equivalent amount of CO2 produced per MWh of grid electricity. This
   * is a measure of the carbon intensity of grid electricity displaced
   * by solar electricity.
   */
  carbonOffsetFactorKgPerMwh: number;
  /**
   * Total size and sunlight quantiles for the part of the roof that
   * was assigned to some roof segment. Despite the name, this may not
   * include the entire building. See [building_stats]
   * [google.maps.solar.v1.SolarPotential.building_stats].
   */
  wholeRoofStats:
    | SizeAndSunshineStats
    | undefined;
  /**
   * Size and sunlight quantiles for the entire building, including
   * parts of the roof that were not assigned to some roof segment.
   * Because the orientations of these parts are not well
   * characterised, the roof area estimate is unreliable, but the
   * ground area estimate is reliable. It may be that a more reliable
   * whole building roof area can be obtained by scaling the roof area
   * from [whole_roof_stats]
   * [google.maps.solar.v1.SolarPotential.whole_roof_stats] by
   * the ratio of the ground areas of `building_stats` and
   * `whole_roof_stats`.
   */
  buildingStats:
    | SizeAndSunshineStats
    | undefined;
  /** Size and sunlight quantiles for each roof segment. */
  roofSegmentStats: RoofSegmentSizeAndSunshineStats[];
  /**
   * Each [SolarPanel] [google.maps.solar.v1.SolarPanel]
   * describes a single solar panel. They are listed in the order that
   * the panel layout algorithm placed this. This is usually, though
   * not always, in decreasing order of annual energy production.
   */
  solarPanels: SolarPanel[];
  /**
   * Each [SolarPanelConfig]
   * [google.maps.solar.v1.SolarPanelConfig] describes a
   * different arrangement of solar panels on the roof. They are in
   * order of increasing number of panels. The `SolarPanelConfig` with
   * [panels_count]
   * [google.maps.solar.v1.SolarPanelConfig.panels_count]=N is
   * based on the first N panels in the `solar_panels` list. This field is only
   * populated if at least 4 panels can fit on a roof.
   */
  solarPanelConfigs: SolarPanelConfig[];
  /**
   * A [FinancialAnalysis]
   * [google.maps.solar.v1.FinancialAnalysis] gives the savings
   * from going solar assuming a given monthly bill and a given
   * electricity provider. They are in order of increasing order of
   * monthly bill amount. This field will be empty for buildings in
   * areas for which the Solar API does not have enough information to
   * perform financial computations.
   */
  financialAnalyses: FinancialAnalysis[];
}

/** Information about the size and sunniness quantiles of a roof segment. */
export interface RoofSegmentSizeAndSunshineStats {
  /**
   * Angle of the roof segment relative to the theoretical ground plane.
   * 0 = parallel to the ground, 90 = perpendicular to the ground.
   */
  pitchDegrees?:
    | number
    | undefined;
  /**
   * Compass direction the roof segment is pointing in. 0 = North, 90 =
   * East, 180 = South. For a "flat" roof segment (`pitch_degrees` very
   * near 0), azimuth is not well defined, so for consistency, we define it
   * arbitrarily to be 0 (North).
   */
  azimuthDegrees?:
    | number
    | undefined;
  /** Total size and sunlight quantiles for the roof segment. */
  stats:
    | SizeAndSunshineStats
    | undefined;
  /** A point near the center of the roof segment. */
  center:
    | LatLng
    | undefined;
  /** The bounding box of the roof segment. */
  boundingBox:
    | LatLngBox
    | undefined;
  /**
   * The height of the roof segment plane, in meters above sea level,
   * at the point designated by `center`. Together with the pitch,
   * azimuth, and center location, this fully defines the roof segment
   * plane.
   */
  planeHeightAtCenterMeters?: number | undefined;
}

/** Size and sunniness quantiles of a roof, or part of a roof. */
export interface SizeAndSunshineStats {
  /**
   * The area of the roof or roof segment, in m^2. This is the roof area
   * (accounting for tilt), not the ground footprint area.
   */
  areaMeters2: number;
  /**
   * Quantiles of the pointwise sunniness across the area. If there
   * are N values here, this represents the (N-1)-iles. For example,
   * if there are 5 values, then they would be the quartiles (min,
   * 25%, 50%, 75%, max). Values are in annual kWh/kW like
   * [max_sunshine_hours_per_year]
   * [google.maps.solar.v1.SolarPotential.max_sunshine_hours_per_year].
   */
  sunshineQuantiles: number[];
  /** The ground footprint area covered by the roof or roof segment, in m^2. */
  groundAreaMeters2: number;
}

/**
 * SolarPanel describes the position, orientation, and production of a
 * single solar panel. See the [panel_height_meters]
 * [google.maps.solar.v1.SolarPotential.panel_height_meters],
 * [panel_width_meters]
 * [google.maps.solar.v1.SolarPotential.panel_width_meters],
 * and [panel_capacity_watts]
 * [google.maps.solar.v1.SolarPotential.panel_capacity_watts]
 * fields in [SolarPotential]
 * [google.maps.solar.v1.SolarPotential] for information on the
 * parameters of the panel.
 */
export interface SolarPanel {
  /** The centre of the panel. */
  center:
    | LatLng
    | undefined;
  /** The orientation of the panel. */
  orientation: SolarPanelOrientation;
  /**
   * How much sunlight energy this layout captures over the course of a
   * year, in DC kWh.
   */
  yearlyEnergyDcKwh: number;
  /**
   * Index in [roof_segment_stats]
   * [google.maps.solar.v1.SolarPotential.roof_segment_stats]
   * of the `RoofSegmentSizeAndSunshineStats` which corresponds to the
   * roof segment that this panel is placed on.
   */
  segmentIndex?: number | undefined;
}

/**
 * SolarPanelConfig describes a particular placement of solar panels
 * on the roof.
 */
export interface SolarPanelConfig {
  /**
   * Total number of panels. Note that this is redundant to (the sum
   * of) the corresponding fields in [roof_segment_summaries]
   * [google.maps.solar.v1.SolarPanelConfig.roof_segment_summaries].
   */
  panelsCount: number;
  /**
   * How much sunlight energy this layout captures over the course of a
   * year, in DC kWh, assuming the panels described above.
   */
  yearlyEnergyDcKwh: number;
  /**
   * Information about the production of each roof segment that is carrying
   * at least one panel in this layout. `roof_segment_summaries[i]` describes
   * the i-th roof segment, including its size, expected production and
   * orientation.
   */
  roofSegmentSummaries: RoofSegmentSummary[];
}

/**
 * Information about a roof segment on the building, with some number of
 * panels placed on it.
 */
export interface RoofSegmentSummary {
  /**
   * Angle of the roof segment relative to the theoretical ground plane.
   * 0 = parallel to the ground, 90 = perpendicular to the ground.
   */
  pitchDegrees?:
    | number
    | undefined;
  /**
   * Compass direction the roof segment is pointing in. 0 = North, 90 =
   * East, 180 = South. For a "flat" roof segment (`pitch_degrees` very
   * near 0), azimuth is not well defined, so for consistency, we define it
   * arbitrarily to be 0 (North).
   */
  azimuthDegrees?:
    | number
    | undefined;
  /** The total number of panels on this segment. */
  panelsCount: number;
  /**
   * How much sunlight energy this part of the layout captures over the
   * course of a year, in DC kWh, assuming the panels described above.
   */
  yearlyEnergyDcKwh: number;
  /**
   * Index in [roof_segment_stats]
   * [google.maps.solar.v1.SolarPotential.roof_segment_stats]
   * of the corresponding `RoofSegmentSizeAndSunshineStats`.
   */
  segmentIndex?: number | undefined;
}

/**
 * Analysis of the cost and benefits of the optimum solar layout for a
 * particular electric bill size.
 */
export interface FinancialAnalysis {
  /** The monthly electric bill this analysis assumes. */
  monthlyBill:
    | Money
    | undefined;
  /**
   * Whether this is the bill size selected to be the default bill for the
   * area this building is in. Exactly one `FinancialAnalysis` in
   * `BuildingSolarPotential` should have `default_bill` set.
   */
  defaultBill: boolean;
  /**
   * How much electricity the house uses in an average month, based on the
   * bill size and the local electricity rates.
   */
  averageKwhPerMonth: number;
  /**
   * Index in [solar_panel_configs]
   * [google.maps.solar.v1.SolarPotential.solar_panel_configs]
   * of the optimum solar layout for this bill size. This can be -1
   * indicating that there is no layout. In this case, the remaining
   * submessages will be omitted.
   */
  panelConfigIndex?:
    | number
    | undefined;
  /**
   * Financial information that applies regardless of the financing method
   * used.
   */
  financialDetails:
    | FinancialDetails
    | undefined;
  /** Cost and benefit of leasing the solar panels. */
  leasingSavings:
    | LeasingSavings
    | undefined;
  /** Cost and benefit of buying the solar panels with cash. */
  cashPurchaseSavings:
    | CashPurchaseSavings
    | undefined;
  /** Cost and benefit of buying the solar panels by financing the purchase. */
  financedPurchaseSavings: FinancedPurchaseSavings | undefined;
}

/**
 * Details of a financial analysis. Some of these details are already
 * stored at higher levels (e.g., out of pocket cost). Total money
 * amounts are over a lifetime period defined by the
 * [panel_lifetime_years]
 * [google.maps.solar.v1.SolarPotential.panel_lifetime_years]
 * field in [SolarPotential]
 * [google.maps.solar.v1.SolarPotential]. Note: The out of
 * pocket cost of purchasing the panels is given in the
 * [out_of_pocket_cost]
 * [google.maps.solar.v1.CashPurchaseSavings.out_of_pocket_cost]
 * field in [CashPurchaseSavings]
 * [google.maps.solar.v1.CashPurchaseSavings].
 */
export interface FinancialDetails {
  /**
   * How many AC kWh we think the solar panels will generate in their first
   * year.
   */
  initialAcKwhPerYear: number;
  /**
   * Utility bill for electricity not produced by solar, for the
   * lifetime of the panels.
   */
  remainingLifetimeUtilityBill:
    | Money
    | undefined;
  /**
   * Amount of money available from federal incentives; this applies if the
   * user buys (with or without a loan) the panels.
   */
  federalIncentive:
    | Money
    | undefined;
  /**
   * Amount of money available from state incentives; this applies if the
   * user buys (with or without a loan) the panels.
   */
  stateIncentive:
    | Money
    | undefined;
  /**
   * Amount of money available from utility incentives; this applies if the
   * user buys (with or without a loan) the panels.
   */
  utilityIncentive:
    | Money
    | undefined;
  /**
   * Amount of money the user will receive from Solar Renewable Energy
   * Credits over the panel lifetime; this applies if the user buys
   * (with or without a loan) the panels.
   */
  lifetimeSrecTotal:
    | Money
    | undefined;
  /**
   * Total cost of electricity the user would have paid over the
   * lifetime period if they didn't install solar.
   */
  costOfElectricityWithoutSolar:
    | Money
    | undefined;
  /** Whether net metering is allowed. */
  netMeteringAllowed: boolean;
  /**
   * Percentage (0-100) of the user's power supplied by solar.
   * Valid for the first year but approximately correct for future years.
   */
  solarPercentage?:
    | number
    | undefined;
  /**
   * The percentage (0-100) of solar electricity production we assumed was
   * exported to the grid, based on the first quarter of production. This
   * affects the calculations if net metering is not allowed.
   */
  percentageExportedToGrid?: number | undefined;
}

/** Financial information that's shared between different financing methods. */
export interface SavingsOverTime {
  /** Savings in the first year after panel installation. */
  savingsYear1:
    | Money
    | undefined;
  /** Savings in the first twenty years after panel installation. */
  savingsYear20:
    | Money
    | undefined;
  /**
   * Using the assumed discount rate, what is the present value of the
   * cumulative 20-year savings?
   */
  presentValueOfSavingsYear20:
    | Money
    | undefined;
  /** Savings in the entire panel lifetime. */
  savingsLifetime:
    | Money
    | undefined;
  /**
   * Using the assumed discount rate, what is the present value of the
   * cumulative lifetime savings?
   */
  presentValueOfSavingsLifetime:
    | Money
    | undefined;
  /**
   * Indicates whether this scenario is financially viable.  Will be false for
   * scenarios with poor financial viability (e.g., money-losing).
   */
  financiallyViable: boolean;
}

/**
 * Cost and benefit of leasing a particular configuration of solar panels
 * with a particular electricity usage.
 */
export interface LeasingSavings {
  /**
   * Whether leases are allowed in this juristiction (leases are not
   * allowed in some states). If this field is false, then the values in
   * this message should probably be ignored.
   */
  leasesAllowed: boolean;
  /**
   * Whether leases are supported in this juristiction by the financial
   * calculation engine. If this field is false, then the values in this
   * message should probably be ignored. This is independent of
   * `leases_allowed`: in some areas leases are allowed, but under conditions
   * that aren't handled by the financial models.
   */
  leasesSupported: boolean;
  /** Estimated annual leasing cost. */
  annualLeasingCost:
    | Money
    | undefined;
  /** How much is saved (or not) over the lifetime period. */
  savings: SavingsOverTime | undefined;
}

/**
 * Cost and benefit of an outright purchase of a particular configuration
 * of solar panels with a particular electricity usage.
 */
export interface CashPurchaseSavings {
  /**
   * Initial cost before tax incentives: the amount that must be paid
   * out-of-pocket. Contrast with `upfront_cost`, which is after tax incentives.
   */
  outOfPocketCost:
    | Money
    | undefined;
  /**
   * Initial cost after tax incentives: it's the amount that must be paid
   * during first year. Contrast with `out_of_pocket_cost`, which is before tax
   * incentives.
   */
  upfrontCost:
    | Money
    | undefined;
  /** The value of all tax rebates. */
  rebateValue:
    | Money
    | undefined;
  /**
   * Number of years until payback occurs. A negative value means payback
   * never occurs within the lifetime period.
   */
  paybackYears?:
    | number
    | undefined;
  /** How much is saved (or not) over the lifetime period. */
  savings: SavingsOverTime | undefined;
}

/**
 * Cost and benefit of using a loan to buy a particular configuration
 * of solar panels with a particular electricity usage.
 */
export interface FinancedPurchaseSavings {
  /** Annual loan payments. */
  annualLoanPayment:
    | Money
    | undefined;
  /**
   * The value of all tax rebates (including Federal Investment Tax Credit
   * (ITC)).
   */
  rebateValue:
    | Money
    | undefined;
  /** The interest rate on loans assumed in this set of calculations. */
  loanInterestRate: number;
  /** How much is saved (or not) over the lifetime period. */
  savings: SavingsOverTime | undefined;
}

/** Request message for `Solar.GetDataLayers`. */
export interface GetDataLayersRequest {
  /**
   * Required. The longitude and latitude for the center of the region to get
   * data for.
   */
  location:
    | LatLng
    | undefined;
  /**
   * Required. The radius, in meters, defining the region surrounding that
   * centre point for which data should be returned. The limitations
   * on this value are:
   *
   * * Any value up to 100m can always be specified.
   * * Values over 100m can be specified, as long as
   *   `radius_meters` <= `pixel_size_meters * 1000`.
   * * However, for values over 175m, the `DataLayerView` in the
   *   request must not include monthly flux or hourly shade.
   */
  radiusMeters: number;
  /** Optional. The desired subset of the data to return. */
  view: DataLayerView;
  /**
   * Optional. The minimum quality level allowed in the results. No result with
   * lower quality than this will be returned. Not specifying this is
   * equivalent to restricting to HIGH quality only.
   */
  requiredQuality: ImageryQuality;
  /**
   * Optional. The minimum scale, in meters per pixel, of the data to return.
   * Values of 0.1 (the default, if this field is not set explicitly),
   * 0.25, 0.5, and 1.0 are supported. Imagery components whose normal
   * resolution is less than `pixel_size_meters` will be returned at
   * the resolution specified by `pixel_size_meters`; imagery
   * components whose normal resolution is equal to or greater than
   * `pixel_size_meters` will be returned at that normal resolution.
   */
  pixelSizeMeters: number;
  /**
   * Optional. Whether to require exact quality of the imagery.
   * If set to false, the `required_quality` field is interpreted as the minimum
   * required quality, such that HIGH quality imagery may be returned when
   * `required_quality` is set to MEDIUM.  If set to true, `required_quality`
   * is interpreted as the exact required quality and only `MEDIUM` quality
   * imagery is returned if `required_quality` is set to `MEDIUM`.
   */
  exactQualityRequired: boolean;
}

/**
 * Information about the solar potential of a region. The actual data
 * are contained in a number of GeoTIFF files covering the requested
 * region, for which this message contains URLs: Each string in the
 * `DataLayers` message contains a URL from which the
 * corresponding GeoTIFF can be fetched. These URLs are valid for a
 * few hours after they've been generated. Most of the GeoTIFF files
 * are at a resolution of 0.1m/pixel, but the monthly flux file is at
 * 0.5m/pixel, and the hourly shade files are at 1m/pixel. If a
 * `pixel_size_meters` value was specified in the
 * `GetDataLayersRequest`, then the minimum resolution in the GeoTIFF
 * files will be that value.
 */
export interface DataLayers {
  /**
   * When the source imagery (from which all the other data are derived) in this
   * region was taken. It is necessarily somewhat approximate, as the images may
   * have been taken over more than one day.
   */
  imageryDate:
    | DateMessage
    | undefined;
  /** When processing was completed on this imagery. */
  imageryProcessedDate:
    | DateMessage
    | undefined;
  /**
   * The URL for an image of the DSM (Digital Surface Model) of the region.
   * Values are in meters above EGM96 geoid (i.e., sea level). Invalid locations
   * (where we don't have data) are stored as -9999.
   */
  dsmUrl: string;
  /** The URL for an image of RGB data (aerial photo) of the region. */
  rgbUrl: string;
  /**
   * The URL for the building mask image: one bit per pixel saying whether that
   * pixel is considered to be part of a rooftop or not.
   */
  maskUrl: string;
  /**
   * The URL for the annual flux map (annual sunlight on roofs) of the region.
   * Values are kWh/kW/year. This is *unmasked flux*: flux is computed for every
   * location, not just building rooftops. Invalid locations are stored as
   * -9999: locations outside our coverage area will be invalid, and a few
   * locations inside the coverage area, where we were unable to calculate flux,
   * will also be invalid.
   */
  annualFluxUrl: string;
  /**
   * The URL for the monthly flux map (sunlight on roofs, broken down by month)
   * of the region. Values are kWh/kW/year. The GeoTIFF pointed to by this URL
   * will contain twelve bands, corresponding to January...December, in order.
   */
  monthlyFluxUrl: string;
  /**
   * Twelve URLs for hourly shade, corresponding to January...December, in
   * order. Each GeoTIFF will contain 24 bands, corresponding to the 24 hours of
   * the day. Each pixel is a 32 bit integer, corresponding to the (up to) 31
   * days of that month; a 1 bit means that the corresponding location is able
   * to see the sun at that day, of that hour, of that month. Invalid locations
   * are stored as -9999 (since this is negative, it has bit 31 set, and no
   * valid value could have bit 31 set as that would correspond to the 32nd day
   * of the month).
   *
   * An example may be useful. If you want to know whether a point (at
   * pixel location (x, y)) saw sun at 4pm on the 22nd of June you
   * would:
   *
   * 1. fetch the sixth URL in this list (corresponding to June).
   * 1. look up the 17th channel (corresponding to 4pm).
   * 1. read the 32-bit value at (x, y).
   * 1. read bit 21 of the value (corresponding to the 22nd of the month).
   * 1. if that bit is a 1, then that spot saw the sun at 4pm 22 June.
   *
   * More formally:
   * Given `month` (1-12), `day` (1...month max; February has 28 days)
   * and `hour` (0-23), the shade/sun for that month/day/hour at a
   * position `(x, y)` is the bit
   * ```
   * (hourly_shade[month - 1])(x, y)[hour] & (1 << (day - 1))
   * ```
   * where `(x, y)` is spatial indexing, `[month - 1]` refers to
   * fetching the `month - 1`st URL (indexing from zero), `[hour]` is
   * indexing into the channels, and a final non-zero result means
   * "sunny". There are no leap days, and DST doesn't exist (all days
   * are 24 hours long; noon is always "standard time" noon).
   */
  hourlyShadeUrls: string[];
  /** The quality of the result's imagery. */
  imageryQuality: ImageryQuality;
}

/** Request message for `Solar.GetGeoTiff`. */
export interface GetGeoTiffRequest {
  /** Required. The ID of the asset being requested. */
  id: string;
}

function createBaseFindClosestBuildingInsightsRequest(): FindClosestBuildingInsightsRequest {
  return { location: undefined, requiredQuality: 0, exactQualityRequired: false };
}

export const FindClosestBuildingInsightsRequest: MessageFns<FindClosestBuildingInsightsRequest> = {
  encode(message: FindClosestBuildingInsightsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.location !== undefined) {
      LatLng.encode(message.location, writer.uint32(10).fork()).join();
    }
    if (message.requiredQuality !== 0) {
      writer.uint32(24).int32(message.requiredQuality);
    }
    if (message.exactQualityRequired !== false) {
      writer.uint32(32).bool(message.exactQualityRequired);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FindClosestBuildingInsightsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFindClosestBuildingInsightsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.location = LatLng.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.requiredQuality = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.exactQualityRequired = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FindClosestBuildingInsightsRequest {
    return {
      location: isSet(object.location) ? LatLng.fromJSON(object.location) : undefined,
      requiredQuality: isSet(object.requiredQuality) ? imageryQualityFromJSON(object.requiredQuality) : 0,
      exactQualityRequired: isSet(object.exactQualityRequired)
        ? globalThis.Boolean(object.exactQualityRequired)
        : false,
    };
  },

  toJSON(message: FindClosestBuildingInsightsRequest): unknown {
    const obj: any = {};
    if (message.location !== undefined) {
      obj.location = LatLng.toJSON(message.location);
    }
    if (message.requiredQuality !== 0) {
      obj.requiredQuality = imageryQualityToJSON(message.requiredQuality);
    }
    if (message.exactQualityRequired !== false) {
      obj.exactQualityRequired = message.exactQualityRequired;
    }
    return obj;
  },

  create(base?: DeepPartial<FindClosestBuildingInsightsRequest>): FindClosestBuildingInsightsRequest {
    return FindClosestBuildingInsightsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FindClosestBuildingInsightsRequest>): FindClosestBuildingInsightsRequest {
    const message = createBaseFindClosestBuildingInsightsRequest();
    message.location = (object.location !== undefined && object.location !== null)
      ? LatLng.fromPartial(object.location)
      : undefined;
    message.requiredQuality = object.requiredQuality ?? 0;
    message.exactQualityRequired = object.exactQualityRequired ?? false;
    return message;
  },
};

function createBaseLatLngBox(): LatLngBox {
  return { sw: undefined, ne: undefined };
}

export const LatLngBox: MessageFns<LatLngBox> = {
  encode(message: LatLngBox, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sw !== undefined) {
      LatLng.encode(message.sw, writer.uint32(10).fork()).join();
    }
    if (message.ne !== undefined) {
      LatLng.encode(message.ne, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LatLngBox {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLatLngBox();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sw = LatLng.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ne = LatLng.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LatLngBox {
    return {
      sw: isSet(object.sw) ? LatLng.fromJSON(object.sw) : undefined,
      ne: isSet(object.ne) ? LatLng.fromJSON(object.ne) : undefined,
    };
  },

  toJSON(message: LatLngBox): unknown {
    const obj: any = {};
    if (message.sw !== undefined) {
      obj.sw = LatLng.toJSON(message.sw);
    }
    if (message.ne !== undefined) {
      obj.ne = LatLng.toJSON(message.ne);
    }
    return obj;
  },

  create(base?: DeepPartial<LatLngBox>): LatLngBox {
    return LatLngBox.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LatLngBox>): LatLngBox {
    const message = createBaseLatLngBox();
    message.sw = (object.sw !== undefined && object.sw !== null) ? LatLng.fromPartial(object.sw) : undefined;
    message.ne = (object.ne !== undefined && object.ne !== null) ? LatLng.fromPartial(object.ne) : undefined;
    return message;
  },
};

function createBaseBuildingInsights(): BuildingInsights {
  return {
    name: "",
    center: undefined,
    boundingBox: undefined,
    imageryDate: undefined,
    imageryProcessedDate: undefined,
    postalCode: "",
    administrativeArea: "",
    statisticalArea: "",
    regionCode: "",
    solarPotential: undefined,
    imageryQuality: 0,
  };
}

export const BuildingInsights: MessageFns<BuildingInsights> = {
  encode(message: BuildingInsights, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.center !== undefined) {
      LatLng.encode(message.center, writer.uint32(18).fork()).join();
    }
    if (message.boundingBox !== undefined) {
      LatLngBox.encode(message.boundingBox, writer.uint32(74).fork()).join();
    }
    if (message.imageryDate !== undefined) {
      DateMessage.encode(message.imageryDate, writer.uint32(26).fork()).join();
    }
    if (message.imageryProcessedDate !== undefined) {
      DateMessage.encode(message.imageryProcessedDate, writer.uint32(90).fork()).join();
    }
    if (message.postalCode !== "") {
      writer.uint32(34).string(message.postalCode);
    }
    if (message.administrativeArea !== "") {
      writer.uint32(42).string(message.administrativeArea);
    }
    if (message.statisticalArea !== "") {
      writer.uint32(50).string(message.statisticalArea);
    }
    if (message.regionCode !== "") {
      writer.uint32(58).string(message.regionCode);
    }
    if (message.solarPotential !== undefined) {
      SolarPotential.encode(message.solarPotential, writer.uint32(66).fork()).join();
    }
    if (message.imageryQuality !== 0) {
      writer.uint32(80).int32(message.imageryQuality);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildingInsights {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildingInsights();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.center = LatLng.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.boundingBox = LatLngBox.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.imageryDate = DateMessage.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.imageryProcessedDate = DateMessage.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.postalCode = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.administrativeArea = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.statisticalArea = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.regionCode = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.solarPotential = SolarPotential.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.imageryQuality = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildingInsights {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      center: isSet(object.center) ? LatLng.fromJSON(object.center) : undefined,
      boundingBox: isSet(object.boundingBox) ? LatLngBox.fromJSON(object.boundingBox) : undefined,
      imageryDate: isSet(object.imageryDate) ? DateMessage.fromJSON(object.imageryDate) : undefined,
      imageryProcessedDate: isSet(object.imageryProcessedDate)
        ? DateMessage.fromJSON(object.imageryProcessedDate)
        : undefined,
      postalCode: isSet(object.postalCode) ? globalThis.String(object.postalCode) : "",
      administrativeArea: isSet(object.administrativeArea) ? globalThis.String(object.administrativeArea) : "",
      statisticalArea: isSet(object.statisticalArea) ? globalThis.String(object.statisticalArea) : "",
      regionCode: isSet(object.regionCode) ? globalThis.String(object.regionCode) : "",
      solarPotential: isSet(object.solarPotential) ? SolarPotential.fromJSON(object.solarPotential) : undefined,
      imageryQuality: isSet(object.imageryQuality) ? imageryQualityFromJSON(object.imageryQuality) : 0,
    };
  },

  toJSON(message: BuildingInsights): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.center !== undefined) {
      obj.center = LatLng.toJSON(message.center);
    }
    if (message.boundingBox !== undefined) {
      obj.boundingBox = LatLngBox.toJSON(message.boundingBox);
    }
    if (message.imageryDate !== undefined) {
      obj.imageryDate = DateMessage.toJSON(message.imageryDate);
    }
    if (message.imageryProcessedDate !== undefined) {
      obj.imageryProcessedDate = DateMessage.toJSON(message.imageryProcessedDate);
    }
    if (message.postalCode !== "") {
      obj.postalCode = message.postalCode;
    }
    if (message.administrativeArea !== "") {
      obj.administrativeArea = message.administrativeArea;
    }
    if (message.statisticalArea !== "") {
      obj.statisticalArea = message.statisticalArea;
    }
    if (message.regionCode !== "") {
      obj.regionCode = message.regionCode;
    }
    if (message.solarPotential !== undefined) {
      obj.solarPotential = SolarPotential.toJSON(message.solarPotential);
    }
    if (message.imageryQuality !== 0) {
      obj.imageryQuality = imageryQualityToJSON(message.imageryQuality);
    }
    return obj;
  },

  create(base?: DeepPartial<BuildingInsights>): BuildingInsights {
    return BuildingInsights.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BuildingInsights>): BuildingInsights {
    const message = createBaseBuildingInsights();
    message.name = object.name ?? "";
    message.center = (object.center !== undefined && object.center !== null)
      ? LatLng.fromPartial(object.center)
      : undefined;
    message.boundingBox = (object.boundingBox !== undefined && object.boundingBox !== null)
      ? LatLngBox.fromPartial(object.boundingBox)
      : undefined;
    message.imageryDate = (object.imageryDate !== undefined && object.imageryDate !== null)
      ? DateMessage.fromPartial(object.imageryDate)
      : undefined;
    message.imageryProcessedDate = (object.imageryProcessedDate !== undefined && object.imageryProcessedDate !== null)
      ? DateMessage.fromPartial(object.imageryProcessedDate)
      : undefined;
    message.postalCode = object.postalCode ?? "";
    message.administrativeArea = object.administrativeArea ?? "";
    message.statisticalArea = object.statisticalArea ?? "";
    message.regionCode = object.regionCode ?? "";
    message.solarPotential = (object.solarPotential !== undefined && object.solarPotential !== null)
      ? SolarPotential.fromPartial(object.solarPotential)
      : undefined;
    message.imageryQuality = object.imageryQuality ?? 0;
    return message;
  },
};

function createBaseSolarPotential(): SolarPotential {
  return {
    maxArrayPanelsCount: 0,
    panelCapacityWatts: 0,
    panelHeightMeters: 0,
    panelWidthMeters: 0,
    panelLifetimeYears: 0,
    maxArrayAreaMeters2: 0,
    maxSunshineHoursPerYear: 0,
    carbonOffsetFactorKgPerMwh: 0,
    wholeRoofStats: undefined,
    buildingStats: undefined,
    roofSegmentStats: [],
    solarPanels: [],
    solarPanelConfigs: [],
    financialAnalyses: [],
  };
}

export const SolarPotential: MessageFns<SolarPotential> = {
  encode(message: SolarPotential, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.maxArrayPanelsCount !== 0) {
      writer.uint32(8).int32(message.maxArrayPanelsCount);
    }
    if (message.panelCapacityWatts !== 0) {
      writer.uint32(77).float(message.panelCapacityWatts);
    }
    if (message.panelHeightMeters !== 0) {
      writer.uint32(85).float(message.panelHeightMeters);
    }
    if (message.panelWidthMeters !== 0) {
      writer.uint32(93).float(message.panelWidthMeters);
    }
    if (message.panelLifetimeYears !== 0) {
      writer.uint32(96).int32(message.panelLifetimeYears);
    }
    if (message.maxArrayAreaMeters2 !== 0) {
      writer.uint32(21).float(message.maxArrayAreaMeters2);
    }
    if (message.maxSunshineHoursPerYear !== 0) {
      writer.uint32(29).float(message.maxSunshineHoursPerYear);
    }
    if (message.carbonOffsetFactorKgPerMwh !== 0) {
      writer.uint32(37).float(message.carbonOffsetFactorKgPerMwh);
    }
    if (message.wholeRoofStats !== undefined) {
      SizeAndSunshineStats.encode(message.wholeRoofStats, writer.uint32(42).fork()).join();
    }
    if (message.buildingStats !== undefined) {
      SizeAndSunshineStats.encode(message.buildingStats, writer.uint32(106).fork()).join();
    }
    for (const v of message.roofSegmentStats) {
      RoofSegmentSizeAndSunshineStats.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.solarPanels) {
      SolarPanel.encode(v!, writer.uint32(114).fork()).join();
    }
    for (const v of message.solarPanelConfigs) {
      SolarPanelConfig.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.financialAnalyses) {
      FinancialAnalysis.encode(v!, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SolarPotential {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSolarPotential();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.maxArrayPanelsCount = reader.int32();
          continue;
        case 9:
          if (tag !== 77) {
            break;
          }

          message.panelCapacityWatts = reader.float();
          continue;
        case 10:
          if (tag !== 85) {
            break;
          }

          message.panelHeightMeters = reader.float();
          continue;
        case 11:
          if (tag !== 93) {
            break;
          }

          message.panelWidthMeters = reader.float();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.panelLifetimeYears = reader.int32();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.maxArrayAreaMeters2 = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.maxSunshineHoursPerYear = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.carbonOffsetFactorKgPerMwh = reader.float();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.wholeRoofStats = SizeAndSunshineStats.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.buildingStats = SizeAndSunshineStats.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.roofSegmentStats.push(RoofSegmentSizeAndSunshineStats.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.solarPanels.push(SolarPanel.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.solarPanelConfigs.push(SolarPanelConfig.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.financialAnalyses.push(FinancialAnalysis.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SolarPotential {
    return {
      maxArrayPanelsCount: isSet(object.maxArrayPanelsCount) ? globalThis.Number(object.maxArrayPanelsCount) : 0,
      panelCapacityWatts: isSet(object.panelCapacityWatts) ? globalThis.Number(object.panelCapacityWatts) : 0,
      panelHeightMeters: isSet(object.panelHeightMeters) ? globalThis.Number(object.panelHeightMeters) : 0,
      panelWidthMeters: isSet(object.panelWidthMeters) ? globalThis.Number(object.panelWidthMeters) : 0,
      panelLifetimeYears: isSet(object.panelLifetimeYears) ? globalThis.Number(object.panelLifetimeYears) : 0,
      maxArrayAreaMeters2: isSet(object.maxArrayAreaMeters2) ? globalThis.Number(object.maxArrayAreaMeters2) : 0,
      maxSunshineHoursPerYear: isSet(object.maxSunshineHoursPerYear)
        ? globalThis.Number(object.maxSunshineHoursPerYear)
        : 0,
      carbonOffsetFactorKgPerMwh: isSet(object.carbonOffsetFactorKgPerMwh)
        ? globalThis.Number(object.carbonOffsetFactorKgPerMwh)
        : 0,
      wholeRoofStats: isSet(object.wholeRoofStats) ? SizeAndSunshineStats.fromJSON(object.wholeRoofStats) : undefined,
      buildingStats: isSet(object.buildingStats) ? SizeAndSunshineStats.fromJSON(object.buildingStats) : undefined,
      roofSegmentStats: globalThis.Array.isArray(object?.roofSegmentStats)
        ? object.roofSegmentStats.map((e: any) => RoofSegmentSizeAndSunshineStats.fromJSON(e))
        : [],
      solarPanels: globalThis.Array.isArray(object?.solarPanels)
        ? object.solarPanels.map((e: any) => SolarPanel.fromJSON(e))
        : [],
      solarPanelConfigs: globalThis.Array.isArray(object?.solarPanelConfigs)
        ? object.solarPanelConfigs.map((e: any) => SolarPanelConfig.fromJSON(e))
        : [],
      financialAnalyses: globalThis.Array.isArray(object?.financialAnalyses)
        ? object.financialAnalyses.map((e: any) => FinancialAnalysis.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SolarPotential): unknown {
    const obj: any = {};
    if (message.maxArrayPanelsCount !== 0) {
      obj.maxArrayPanelsCount = Math.round(message.maxArrayPanelsCount);
    }
    if (message.panelCapacityWatts !== 0) {
      obj.panelCapacityWatts = message.panelCapacityWatts;
    }
    if (message.panelHeightMeters !== 0) {
      obj.panelHeightMeters = message.panelHeightMeters;
    }
    if (message.panelWidthMeters !== 0) {
      obj.panelWidthMeters = message.panelWidthMeters;
    }
    if (message.panelLifetimeYears !== 0) {
      obj.panelLifetimeYears = Math.round(message.panelLifetimeYears);
    }
    if (message.maxArrayAreaMeters2 !== 0) {
      obj.maxArrayAreaMeters2 = message.maxArrayAreaMeters2;
    }
    if (message.maxSunshineHoursPerYear !== 0) {
      obj.maxSunshineHoursPerYear = message.maxSunshineHoursPerYear;
    }
    if (message.carbonOffsetFactorKgPerMwh !== 0) {
      obj.carbonOffsetFactorKgPerMwh = message.carbonOffsetFactorKgPerMwh;
    }
    if (message.wholeRoofStats !== undefined) {
      obj.wholeRoofStats = SizeAndSunshineStats.toJSON(message.wholeRoofStats);
    }
    if (message.buildingStats !== undefined) {
      obj.buildingStats = SizeAndSunshineStats.toJSON(message.buildingStats);
    }
    if (message.roofSegmentStats?.length) {
      obj.roofSegmentStats = message.roofSegmentStats.map((e) => RoofSegmentSizeAndSunshineStats.toJSON(e));
    }
    if (message.solarPanels?.length) {
      obj.solarPanels = message.solarPanels.map((e) => SolarPanel.toJSON(e));
    }
    if (message.solarPanelConfigs?.length) {
      obj.solarPanelConfigs = message.solarPanelConfigs.map((e) => SolarPanelConfig.toJSON(e));
    }
    if (message.financialAnalyses?.length) {
      obj.financialAnalyses = message.financialAnalyses.map((e) => FinancialAnalysis.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SolarPotential>): SolarPotential {
    return SolarPotential.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SolarPotential>): SolarPotential {
    const message = createBaseSolarPotential();
    message.maxArrayPanelsCount = object.maxArrayPanelsCount ?? 0;
    message.panelCapacityWatts = object.panelCapacityWatts ?? 0;
    message.panelHeightMeters = object.panelHeightMeters ?? 0;
    message.panelWidthMeters = object.panelWidthMeters ?? 0;
    message.panelLifetimeYears = object.panelLifetimeYears ?? 0;
    message.maxArrayAreaMeters2 = object.maxArrayAreaMeters2 ?? 0;
    message.maxSunshineHoursPerYear = object.maxSunshineHoursPerYear ?? 0;
    message.carbonOffsetFactorKgPerMwh = object.carbonOffsetFactorKgPerMwh ?? 0;
    message.wholeRoofStats = (object.wholeRoofStats !== undefined && object.wholeRoofStats !== null)
      ? SizeAndSunshineStats.fromPartial(object.wholeRoofStats)
      : undefined;
    message.buildingStats = (object.buildingStats !== undefined && object.buildingStats !== null)
      ? SizeAndSunshineStats.fromPartial(object.buildingStats)
      : undefined;
    message.roofSegmentStats = object.roofSegmentStats?.map((e) => RoofSegmentSizeAndSunshineStats.fromPartial(e)) ||
      [];
    message.solarPanels = object.solarPanels?.map((e) => SolarPanel.fromPartial(e)) || [];
    message.solarPanelConfigs = object.solarPanelConfigs?.map((e) => SolarPanelConfig.fromPartial(e)) || [];
    message.financialAnalyses = object.financialAnalyses?.map((e) => FinancialAnalysis.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRoofSegmentSizeAndSunshineStats(): RoofSegmentSizeAndSunshineStats {
  return {
    pitchDegrees: undefined,
    azimuthDegrees: undefined,
    stats: undefined,
    center: undefined,
    boundingBox: undefined,
    planeHeightAtCenterMeters: undefined,
  };
}

export const RoofSegmentSizeAndSunshineStats: MessageFns<RoofSegmentSizeAndSunshineStats> = {
  encode(message: RoofSegmentSizeAndSunshineStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pitchDegrees !== undefined) {
      writer.uint32(13).float(message.pitchDegrees);
    }
    if (message.azimuthDegrees !== undefined) {
      writer.uint32(21).float(message.azimuthDegrees);
    }
    if (message.stats !== undefined) {
      SizeAndSunshineStats.encode(message.stats, writer.uint32(26).fork()).join();
    }
    if (message.center !== undefined) {
      LatLng.encode(message.center, writer.uint32(34).fork()).join();
    }
    if (message.boundingBox !== undefined) {
      LatLngBox.encode(message.boundingBox, writer.uint32(42).fork()).join();
    }
    if (message.planeHeightAtCenterMeters !== undefined) {
      writer.uint32(53).float(message.planeHeightAtCenterMeters);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoofSegmentSizeAndSunshineStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoofSegmentSizeAndSunshineStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.pitchDegrees = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.azimuthDegrees = reader.float();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.stats = SizeAndSunshineStats.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.center = LatLng.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.boundingBox = LatLngBox.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 53) {
            break;
          }

          message.planeHeightAtCenterMeters = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoofSegmentSizeAndSunshineStats {
    return {
      pitchDegrees: isSet(object.pitchDegrees) ? globalThis.Number(object.pitchDegrees) : undefined,
      azimuthDegrees: isSet(object.azimuthDegrees) ? globalThis.Number(object.azimuthDegrees) : undefined,
      stats: isSet(object.stats) ? SizeAndSunshineStats.fromJSON(object.stats) : undefined,
      center: isSet(object.center) ? LatLng.fromJSON(object.center) : undefined,
      boundingBox: isSet(object.boundingBox) ? LatLngBox.fromJSON(object.boundingBox) : undefined,
      planeHeightAtCenterMeters: isSet(object.planeHeightAtCenterMeters)
        ? globalThis.Number(object.planeHeightAtCenterMeters)
        : undefined,
    };
  },

  toJSON(message: RoofSegmentSizeAndSunshineStats): unknown {
    const obj: any = {};
    if (message.pitchDegrees !== undefined) {
      obj.pitchDegrees = message.pitchDegrees;
    }
    if (message.azimuthDegrees !== undefined) {
      obj.azimuthDegrees = message.azimuthDegrees;
    }
    if (message.stats !== undefined) {
      obj.stats = SizeAndSunshineStats.toJSON(message.stats);
    }
    if (message.center !== undefined) {
      obj.center = LatLng.toJSON(message.center);
    }
    if (message.boundingBox !== undefined) {
      obj.boundingBox = LatLngBox.toJSON(message.boundingBox);
    }
    if (message.planeHeightAtCenterMeters !== undefined) {
      obj.planeHeightAtCenterMeters = message.planeHeightAtCenterMeters;
    }
    return obj;
  },

  create(base?: DeepPartial<RoofSegmentSizeAndSunshineStats>): RoofSegmentSizeAndSunshineStats {
    return RoofSegmentSizeAndSunshineStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RoofSegmentSizeAndSunshineStats>): RoofSegmentSizeAndSunshineStats {
    const message = createBaseRoofSegmentSizeAndSunshineStats();
    message.pitchDegrees = object.pitchDegrees ?? undefined;
    message.azimuthDegrees = object.azimuthDegrees ?? undefined;
    message.stats = (object.stats !== undefined && object.stats !== null)
      ? SizeAndSunshineStats.fromPartial(object.stats)
      : undefined;
    message.center = (object.center !== undefined && object.center !== null)
      ? LatLng.fromPartial(object.center)
      : undefined;
    message.boundingBox = (object.boundingBox !== undefined && object.boundingBox !== null)
      ? LatLngBox.fromPartial(object.boundingBox)
      : undefined;
    message.planeHeightAtCenterMeters = object.planeHeightAtCenterMeters ?? undefined;
    return message;
  },
};

function createBaseSizeAndSunshineStats(): SizeAndSunshineStats {
  return { areaMeters2: 0, sunshineQuantiles: [], groundAreaMeters2: 0 };
}

export const SizeAndSunshineStats: MessageFns<SizeAndSunshineStats> = {
  encode(message: SizeAndSunshineStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.areaMeters2 !== 0) {
      writer.uint32(13).float(message.areaMeters2);
    }
    writer.uint32(18).fork();
    for (const v of message.sunshineQuantiles) {
      writer.float(v);
    }
    writer.join();
    if (message.groundAreaMeters2 !== 0) {
      writer.uint32(29).float(message.groundAreaMeters2);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SizeAndSunshineStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSizeAndSunshineStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.areaMeters2 = reader.float();
          continue;
        case 2:
          if (tag === 21) {
            message.sunshineQuantiles.push(reader.float());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.sunshineQuantiles.push(reader.float());
            }

            continue;
          }

          break;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.groundAreaMeters2 = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SizeAndSunshineStats {
    return {
      areaMeters2: isSet(object.areaMeters2) ? globalThis.Number(object.areaMeters2) : 0,
      sunshineQuantiles: globalThis.Array.isArray(object?.sunshineQuantiles)
        ? object.sunshineQuantiles.map((e: any) => globalThis.Number(e))
        : [],
      groundAreaMeters2: isSet(object.groundAreaMeters2) ? globalThis.Number(object.groundAreaMeters2) : 0,
    };
  },

  toJSON(message: SizeAndSunshineStats): unknown {
    const obj: any = {};
    if (message.areaMeters2 !== 0) {
      obj.areaMeters2 = message.areaMeters2;
    }
    if (message.sunshineQuantiles?.length) {
      obj.sunshineQuantiles = message.sunshineQuantiles;
    }
    if (message.groundAreaMeters2 !== 0) {
      obj.groundAreaMeters2 = message.groundAreaMeters2;
    }
    return obj;
  },

  create(base?: DeepPartial<SizeAndSunshineStats>): SizeAndSunshineStats {
    return SizeAndSunshineStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SizeAndSunshineStats>): SizeAndSunshineStats {
    const message = createBaseSizeAndSunshineStats();
    message.areaMeters2 = object.areaMeters2 ?? 0;
    message.sunshineQuantiles = object.sunshineQuantiles?.map((e) => e) || [];
    message.groundAreaMeters2 = object.groundAreaMeters2 ?? 0;
    return message;
  },
};

function createBaseSolarPanel(): SolarPanel {
  return { center: undefined, orientation: 0, yearlyEnergyDcKwh: 0, segmentIndex: undefined };
}

export const SolarPanel: MessageFns<SolarPanel> = {
  encode(message: SolarPanel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.center !== undefined) {
      LatLng.encode(message.center, writer.uint32(10).fork()).join();
    }
    if (message.orientation !== 0) {
      writer.uint32(16).int32(message.orientation);
    }
    if (message.yearlyEnergyDcKwh !== 0) {
      writer.uint32(29).float(message.yearlyEnergyDcKwh);
    }
    if (message.segmentIndex !== undefined) {
      writer.uint32(32).int32(message.segmentIndex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SolarPanel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSolarPanel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.center = LatLng.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.orientation = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.yearlyEnergyDcKwh = reader.float();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.segmentIndex = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SolarPanel {
    return {
      center: isSet(object.center) ? LatLng.fromJSON(object.center) : undefined,
      orientation: isSet(object.orientation) ? solarPanelOrientationFromJSON(object.orientation) : 0,
      yearlyEnergyDcKwh: isSet(object.yearlyEnergyDcKwh) ? globalThis.Number(object.yearlyEnergyDcKwh) : 0,
      segmentIndex: isSet(object.segmentIndex) ? globalThis.Number(object.segmentIndex) : undefined,
    };
  },

  toJSON(message: SolarPanel): unknown {
    const obj: any = {};
    if (message.center !== undefined) {
      obj.center = LatLng.toJSON(message.center);
    }
    if (message.orientation !== 0) {
      obj.orientation = solarPanelOrientationToJSON(message.orientation);
    }
    if (message.yearlyEnergyDcKwh !== 0) {
      obj.yearlyEnergyDcKwh = message.yearlyEnergyDcKwh;
    }
    if (message.segmentIndex !== undefined) {
      obj.segmentIndex = Math.round(message.segmentIndex);
    }
    return obj;
  },

  create(base?: DeepPartial<SolarPanel>): SolarPanel {
    return SolarPanel.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SolarPanel>): SolarPanel {
    const message = createBaseSolarPanel();
    message.center = (object.center !== undefined && object.center !== null)
      ? LatLng.fromPartial(object.center)
      : undefined;
    message.orientation = object.orientation ?? 0;
    message.yearlyEnergyDcKwh = object.yearlyEnergyDcKwh ?? 0;
    message.segmentIndex = object.segmentIndex ?? undefined;
    return message;
  },
};

function createBaseSolarPanelConfig(): SolarPanelConfig {
  return { panelsCount: 0, yearlyEnergyDcKwh: 0, roofSegmentSummaries: [] };
}

export const SolarPanelConfig: MessageFns<SolarPanelConfig> = {
  encode(message: SolarPanelConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.panelsCount !== 0) {
      writer.uint32(8).int32(message.panelsCount);
    }
    if (message.yearlyEnergyDcKwh !== 0) {
      writer.uint32(21).float(message.yearlyEnergyDcKwh);
    }
    for (const v of message.roofSegmentSummaries) {
      RoofSegmentSummary.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SolarPanelConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSolarPanelConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.panelsCount = reader.int32();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.yearlyEnergyDcKwh = reader.float();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.roofSegmentSummaries.push(RoofSegmentSummary.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SolarPanelConfig {
    return {
      panelsCount: isSet(object.panelsCount) ? globalThis.Number(object.panelsCount) : 0,
      yearlyEnergyDcKwh: isSet(object.yearlyEnergyDcKwh) ? globalThis.Number(object.yearlyEnergyDcKwh) : 0,
      roofSegmentSummaries: globalThis.Array.isArray(object?.roofSegmentSummaries)
        ? object.roofSegmentSummaries.map((e: any) => RoofSegmentSummary.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SolarPanelConfig): unknown {
    const obj: any = {};
    if (message.panelsCount !== 0) {
      obj.panelsCount = Math.round(message.panelsCount);
    }
    if (message.yearlyEnergyDcKwh !== 0) {
      obj.yearlyEnergyDcKwh = message.yearlyEnergyDcKwh;
    }
    if (message.roofSegmentSummaries?.length) {
      obj.roofSegmentSummaries = message.roofSegmentSummaries.map((e) => RoofSegmentSummary.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SolarPanelConfig>): SolarPanelConfig {
    return SolarPanelConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SolarPanelConfig>): SolarPanelConfig {
    const message = createBaseSolarPanelConfig();
    message.panelsCount = object.panelsCount ?? 0;
    message.yearlyEnergyDcKwh = object.yearlyEnergyDcKwh ?? 0;
    message.roofSegmentSummaries = object.roofSegmentSummaries?.map((e) => RoofSegmentSummary.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRoofSegmentSummary(): RoofSegmentSummary {
  return {
    pitchDegrees: undefined,
    azimuthDegrees: undefined,
    panelsCount: 0,
    yearlyEnergyDcKwh: 0,
    segmentIndex: undefined,
  };
}

export const RoofSegmentSummary: MessageFns<RoofSegmentSummary> = {
  encode(message: RoofSegmentSummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pitchDegrees !== undefined) {
      writer.uint32(21).float(message.pitchDegrees);
    }
    if (message.azimuthDegrees !== undefined) {
      writer.uint32(29).float(message.azimuthDegrees);
    }
    if (message.panelsCount !== 0) {
      writer.uint32(56).int32(message.panelsCount);
    }
    if (message.yearlyEnergyDcKwh !== 0) {
      writer.uint32(69).float(message.yearlyEnergyDcKwh);
    }
    if (message.segmentIndex !== undefined) {
      writer.uint32(72).int32(message.segmentIndex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoofSegmentSummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoofSegmentSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 21) {
            break;
          }

          message.pitchDegrees = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.azimuthDegrees = reader.float();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.panelsCount = reader.int32();
          continue;
        case 8:
          if (tag !== 69) {
            break;
          }

          message.yearlyEnergyDcKwh = reader.float();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.segmentIndex = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoofSegmentSummary {
    return {
      pitchDegrees: isSet(object.pitchDegrees) ? globalThis.Number(object.pitchDegrees) : undefined,
      azimuthDegrees: isSet(object.azimuthDegrees) ? globalThis.Number(object.azimuthDegrees) : undefined,
      panelsCount: isSet(object.panelsCount) ? globalThis.Number(object.panelsCount) : 0,
      yearlyEnergyDcKwh: isSet(object.yearlyEnergyDcKwh) ? globalThis.Number(object.yearlyEnergyDcKwh) : 0,
      segmentIndex: isSet(object.segmentIndex) ? globalThis.Number(object.segmentIndex) : undefined,
    };
  },

  toJSON(message: RoofSegmentSummary): unknown {
    const obj: any = {};
    if (message.pitchDegrees !== undefined) {
      obj.pitchDegrees = message.pitchDegrees;
    }
    if (message.azimuthDegrees !== undefined) {
      obj.azimuthDegrees = message.azimuthDegrees;
    }
    if (message.panelsCount !== 0) {
      obj.panelsCount = Math.round(message.panelsCount);
    }
    if (message.yearlyEnergyDcKwh !== 0) {
      obj.yearlyEnergyDcKwh = message.yearlyEnergyDcKwh;
    }
    if (message.segmentIndex !== undefined) {
      obj.segmentIndex = Math.round(message.segmentIndex);
    }
    return obj;
  },

  create(base?: DeepPartial<RoofSegmentSummary>): RoofSegmentSummary {
    return RoofSegmentSummary.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RoofSegmentSummary>): RoofSegmentSummary {
    const message = createBaseRoofSegmentSummary();
    message.pitchDegrees = object.pitchDegrees ?? undefined;
    message.azimuthDegrees = object.azimuthDegrees ?? undefined;
    message.panelsCount = object.panelsCount ?? 0;
    message.yearlyEnergyDcKwh = object.yearlyEnergyDcKwh ?? 0;
    message.segmentIndex = object.segmentIndex ?? undefined;
    return message;
  },
};

function createBaseFinancialAnalysis(): FinancialAnalysis {
  return {
    monthlyBill: undefined,
    defaultBill: false,
    averageKwhPerMonth: 0,
    panelConfigIndex: undefined,
    financialDetails: undefined,
    leasingSavings: undefined,
    cashPurchaseSavings: undefined,
    financedPurchaseSavings: undefined,
  };
}

export const FinancialAnalysis: MessageFns<FinancialAnalysis> = {
  encode(message: FinancialAnalysis, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.monthlyBill !== undefined) {
      Money.encode(message.monthlyBill, writer.uint32(26).fork()).join();
    }
    if (message.defaultBill !== false) {
      writer.uint32(32).bool(message.defaultBill);
    }
    if (message.averageKwhPerMonth !== 0) {
      writer.uint32(45).float(message.averageKwhPerMonth);
    }
    if (message.panelConfigIndex !== undefined) {
      writer.uint32(48).int32(message.panelConfigIndex);
    }
    if (message.financialDetails !== undefined) {
      FinancialDetails.encode(message.financialDetails, writer.uint32(58).fork()).join();
    }
    if (message.leasingSavings !== undefined) {
      LeasingSavings.encode(message.leasingSavings, writer.uint32(66).fork()).join();
    }
    if (message.cashPurchaseSavings !== undefined) {
      CashPurchaseSavings.encode(message.cashPurchaseSavings, writer.uint32(74).fork()).join();
    }
    if (message.financedPurchaseSavings !== undefined) {
      FinancedPurchaseSavings.encode(message.financedPurchaseSavings, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinancialAnalysis {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinancialAnalysis();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.monthlyBill = Money.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.defaultBill = reader.bool();
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.averageKwhPerMonth = reader.float();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.panelConfigIndex = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.financialDetails = FinancialDetails.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.leasingSavings = LeasingSavings.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.cashPurchaseSavings = CashPurchaseSavings.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.financedPurchaseSavings = FinancedPurchaseSavings.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinancialAnalysis {
    return {
      monthlyBill: isSet(object.monthlyBill) ? Money.fromJSON(object.monthlyBill) : undefined,
      defaultBill: isSet(object.defaultBill) ? globalThis.Boolean(object.defaultBill) : false,
      averageKwhPerMonth: isSet(object.averageKwhPerMonth) ? globalThis.Number(object.averageKwhPerMonth) : 0,
      panelConfigIndex: isSet(object.panelConfigIndex) ? globalThis.Number(object.panelConfigIndex) : undefined,
      financialDetails: isSet(object.financialDetails) ? FinancialDetails.fromJSON(object.financialDetails) : undefined,
      leasingSavings: isSet(object.leasingSavings) ? LeasingSavings.fromJSON(object.leasingSavings) : undefined,
      cashPurchaseSavings: isSet(object.cashPurchaseSavings)
        ? CashPurchaseSavings.fromJSON(object.cashPurchaseSavings)
        : undefined,
      financedPurchaseSavings: isSet(object.financedPurchaseSavings)
        ? FinancedPurchaseSavings.fromJSON(object.financedPurchaseSavings)
        : undefined,
    };
  },

  toJSON(message: FinancialAnalysis): unknown {
    const obj: any = {};
    if (message.monthlyBill !== undefined) {
      obj.monthlyBill = Money.toJSON(message.monthlyBill);
    }
    if (message.defaultBill !== false) {
      obj.defaultBill = message.defaultBill;
    }
    if (message.averageKwhPerMonth !== 0) {
      obj.averageKwhPerMonth = message.averageKwhPerMonth;
    }
    if (message.panelConfigIndex !== undefined) {
      obj.panelConfigIndex = Math.round(message.panelConfigIndex);
    }
    if (message.financialDetails !== undefined) {
      obj.financialDetails = FinancialDetails.toJSON(message.financialDetails);
    }
    if (message.leasingSavings !== undefined) {
      obj.leasingSavings = LeasingSavings.toJSON(message.leasingSavings);
    }
    if (message.cashPurchaseSavings !== undefined) {
      obj.cashPurchaseSavings = CashPurchaseSavings.toJSON(message.cashPurchaseSavings);
    }
    if (message.financedPurchaseSavings !== undefined) {
      obj.financedPurchaseSavings = FinancedPurchaseSavings.toJSON(message.financedPurchaseSavings);
    }
    return obj;
  },

  create(base?: DeepPartial<FinancialAnalysis>): FinancialAnalysis {
    return FinancialAnalysis.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FinancialAnalysis>): FinancialAnalysis {
    const message = createBaseFinancialAnalysis();
    message.monthlyBill = (object.monthlyBill !== undefined && object.monthlyBill !== null)
      ? Money.fromPartial(object.monthlyBill)
      : undefined;
    message.defaultBill = object.defaultBill ?? false;
    message.averageKwhPerMonth = object.averageKwhPerMonth ?? 0;
    message.panelConfigIndex = object.panelConfigIndex ?? undefined;
    message.financialDetails = (object.financialDetails !== undefined && object.financialDetails !== null)
      ? FinancialDetails.fromPartial(object.financialDetails)
      : undefined;
    message.leasingSavings = (object.leasingSavings !== undefined && object.leasingSavings !== null)
      ? LeasingSavings.fromPartial(object.leasingSavings)
      : undefined;
    message.cashPurchaseSavings = (object.cashPurchaseSavings !== undefined && object.cashPurchaseSavings !== null)
      ? CashPurchaseSavings.fromPartial(object.cashPurchaseSavings)
      : undefined;
    message.financedPurchaseSavings =
      (object.financedPurchaseSavings !== undefined && object.financedPurchaseSavings !== null)
        ? FinancedPurchaseSavings.fromPartial(object.financedPurchaseSavings)
        : undefined;
    return message;
  },
};

function createBaseFinancialDetails(): FinancialDetails {
  return {
    initialAcKwhPerYear: 0,
    remainingLifetimeUtilityBill: undefined,
    federalIncentive: undefined,
    stateIncentive: undefined,
    utilityIncentive: undefined,
    lifetimeSrecTotal: undefined,
    costOfElectricityWithoutSolar: undefined,
    netMeteringAllowed: false,
    solarPercentage: undefined,
    percentageExportedToGrid: undefined,
  };
}

export const FinancialDetails: MessageFns<FinancialDetails> = {
  encode(message: FinancialDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.initialAcKwhPerYear !== 0) {
      writer.uint32(13).float(message.initialAcKwhPerYear);
    }
    if (message.remainingLifetimeUtilityBill !== undefined) {
      Money.encode(message.remainingLifetimeUtilityBill, writer.uint32(18).fork()).join();
    }
    if (message.federalIncentive !== undefined) {
      Money.encode(message.federalIncentive, writer.uint32(26).fork()).join();
    }
    if (message.stateIncentive !== undefined) {
      Money.encode(message.stateIncentive, writer.uint32(34).fork()).join();
    }
    if (message.utilityIncentive !== undefined) {
      Money.encode(message.utilityIncentive, writer.uint32(42).fork()).join();
    }
    if (message.lifetimeSrecTotal !== undefined) {
      Money.encode(message.lifetimeSrecTotal, writer.uint32(50).fork()).join();
    }
    if (message.costOfElectricityWithoutSolar !== undefined) {
      Money.encode(message.costOfElectricityWithoutSolar, writer.uint32(58).fork()).join();
    }
    if (message.netMeteringAllowed !== false) {
      writer.uint32(64).bool(message.netMeteringAllowed);
    }
    if (message.solarPercentage !== undefined) {
      writer.uint32(77).float(message.solarPercentage);
    }
    if (message.percentageExportedToGrid !== undefined) {
      writer.uint32(85).float(message.percentageExportedToGrid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinancialDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinancialDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.initialAcKwhPerYear = reader.float();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.remainingLifetimeUtilityBill = Money.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.federalIncentive = Money.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.stateIncentive = Money.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.utilityIncentive = Money.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.lifetimeSrecTotal = Money.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.costOfElectricityWithoutSolar = Money.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.netMeteringAllowed = reader.bool();
          continue;
        case 9:
          if (tag !== 77) {
            break;
          }

          message.solarPercentage = reader.float();
          continue;
        case 10:
          if (tag !== 85) {
            break;
          }

          message.percentageExportedToGrid = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinancialDetails {
    return {
      initialAcKwhPerYear: isSet(object.initialAcKwhPerYear) ? globalThis.Number(object.initialAcKwhPerYear) : 0,
      remainingLifetimeUtilityBill: isSet(object.remainingLifetimeUtilityBill)
        ? Money.fromJSON(object.remainingLifetimeUtilityBill)
        : undefined,
      federalIncentive: isSet(object.federalIncentive) ? Money.fromJSON(object.federalIncentive) : undefined,
      stateIncentive: isSet(object.stateIncentive) ? Money.fromJSON(object.stateIncentive) : undefined,
      utilityIncentive: isSet(object.utilityIncentive) ? Money.fromJSON(object.utilityIncentive) : undefined,
      lifetimeSrecTotal: isSet(object.lifetimeSrecTotal) ? Money.fromJSON(object.lifetimeSrecTotal) : undefined,
      costOfElectricityWithoutSolar: isSet(object.costOfElectricityWithoutSolar)
        ? Money.fromJSON(object.costOfElectricityWithoutSolar)
        : undefined,
      netMeteringAllowed: isSet(object.netMeteringAllowed) ? globalThis.Boolean(object.netMeteringAllowed) : false,
      solarPercentage: isSet(object.solarPercentage) ? globalThis.Number(object.solarPercentage) : undefined,
      percentageExportedToGrid: isSet(object.percentageExportedToGrid)
        ? globalThis.Number(object.percentageExportedToGrid)
        : undefined,
    };
  },

  toJSON(message: FinancialDetails): unknown {
    const obj: any = {};
    if (message.initialAcKwhPerYear !== 0) {
      obj.initialAcKwhPerYear = message.initialAcKwhPerYear;
    }
    if (message.remainingLifetimeUtilityBill !== undefined) {
      obj.remainingLifetimeUtilityBill = Money.toJSON(message.remainingLifetimeUtilityBill);
    }
    if (message.federalIncentive !== undefined) {
      obj.federalIncentive = Money.toJSON(message.federalIncentive);
    }
    if (message.stateIncentive !== undefined) {
      obj.stateIncentive = Money.toJSON(message.stateIncentive);
    }
    if (message.utilityIncentive !== undefined) {
      obj.utilityIncentive = Money.toJSON(message.utilityIncentive);
    }
    if (message.lifetimeSrecTotal !== undefined) {
      obj.lifetimeSrecTotal = Money.toJSON(message.lifetimeSrecTotal);
    }
    if (message.costOfElectricityWithoutSolar !== undefined) {
      obj.costOfElectricityWithoutSolar = Money.toJSON(message.costOfElectricityWithoutSolar);
    }
    if (message.netMeteringAllowed !== false) {
      obj.netMeteringAllowed = message.netMeteringAllowed;
    }
    if (message.solarPercentage !== undefined) {
      obj.solarPercentage = message.solarPercentage;
    }
    if (message.percentageExportedToGrid !== undefined) {
      obj.percentageExportedToGrid = message.percentageExportedToGrid;
    }
    return obj;
  },

  create(base?: DeepPartial<FinancialDetails>): FinancialDetails {
    return FinancialDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FinancialDetails>): FinancialDetails {
    const message = createBaseFinancialDetails();
    message.initialAcKwhPerYear = object.initialAcKwhPerYear ?? 0;
    message.remainingLifetimeUtilityBill =
      (object.remainingLifetimeUtilityBill !== undefined && object.remainingLifetimeUtilityBill !== null)
        ? Money.fromPartial(object.remainingLifetimeUtilityBill)
        : undefined;
    message.federalIncentive = (object.federalIncentive !== undefined && object.federalIncentive !== null)
      ? Money.fromPartial(object.federalIncentive)
      : undefined;
    message.stateIncentive = (object.stateIncentive !== undefined && object.stateIncentive !== null)
      ? Money.fromPartial(object.stateIncentive)
      : undefined;
    message.utilityIncentive = (object.utilityIncentive !== undefined && object.utilityIncentive !== null)
      ? Money.fromPartial(object.utilityIncentive)
      : undefined;
    message.lifetimeSrecTotal = (object.lifetimeSrecTotal !== undefined && object.lifetimeSrecTotal !== null)
      ? Money.fromPartial(object.lifetimeSrecTotal)
      : undefined;
    message.costOfElectricityWithoutSolar =
      (object.costOfElectricityWithoutSolar !== undefined && object.costOfElectricityWithoutSolar !== null)
        ? Money.fromPartial(object.costOfElectricityWithoutSolar)
        : undefined;
    message.netMeteringAllowed = object.netMeteringAllowed ?? false;
    message.solarPercentage = object.solarPercentage ?? undefined;
    message.percentageExportedToGrid = object.percentageExportedToGrid ?? undefined;
    return message;
  },
};

function createBaseSavingsOverTime(): SavingsOverTime {
  return {
    savingsYear1: undefined,
    savingsYear20: undefined,
    presentValueOfSavingsYear20: undefined,
    savingsLifetime: undefined,
    presentValueOfSavingsLifetime: undefined,
    financiallyViable: false,
  };
}

export const SavingsOverTime: MessageFns<SavingsOverTime> = {
  encode(message: SavingsOverTime, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.savingsYear1 !== undefined) {
      Money.encode(message.savingsYear1, writer.uint32(10).fork()).join();
    }
    if (message.savingsYear20 !== undefined) {
      Money.encode(message.savingsYear20, writer.uint32(18).fork()).join();
    }
    if (message.presentValueOfSavingsYear20 !== undefined) {
      Money.encode(message.presentValueOfSavingsYear20, writer.uint32(26).fork()).join();
    }
    if (message.savingsLifetime !== undefined) {
      Money.encode(message.savingsLifetime, writer.uint32(42).fork()).join();
    }
    if (message.presentValueOfSavingsLifetime !== undefined) {
      Money.encode(message.presentValueOfSavingsLifetime, writer.uint32(50).fork()).join();
    }
    if (message.financiallyViable !== false) {
      writer.uint32(32).bool(message.financiallyViable);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SavingsOverTime {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSavingsOverTime();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.savingsYear1 = Money.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.savingsYear20 = Money.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.presentValueOfSavingsYear20 = Money.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.savingsLifetime = Money.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.presentValueOfSavingsLifetime = Money.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.financiallyViable = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SavingsOverTime {
    return {
      savingsYear1: isSet(object.savingsYear1) ? Money.fromJSON(object.savingsYear1) : undefined,
      savingsYear20: isSet(object.savingsYear20) ? Money.fromJSON(object.savingsYear20) : undefined,
      presentValueOfSavingsYear20: isSet(object.presentValueOfSavingsYear20)
        ? Money.fromJSON(object.presentValueOfSavingsYear20)
        : undefined,
      savingsLifetime: isSet(object.savingsLifetime) ? Money.fromJSON(object.savingsLifetime) : undefined,
      presentValueOfSavingsLifetime: isSet(object.presentValueOfSavingsLifetime)
        ? Money.fromJSON(object.presentValueOfSavingsLifetime)
        : undefined,
      financiallyViable: isSet(object.financiallyViable) ? globalThis.Boolean(object.financiallyViable) : false,
    };
  },

  toJSON(message: SavingsOverTime): unknown {
    const obj: any = {};
    if (message.savingsYear1 !== undefined) {
      obj.savingsYear1 = Money.toJSON(message.savingsYear1);
    }
    if (message.savingsYear20 !== undefined) {
      obj.savingsYear20 = Money.toJSON(message.savingsYear20);
    }
    if (message.presentValueOfSavingsYear20 !== undefined) {
      obj.presentValueOfSavingsYear20 = Money.toJSON(message.presentValueOfSavingsYear20);
    }
    if (message.savingsLifetime !== undefined) {
      obj.savingsLifetime = Money.toJSON(message.savingsLifetime);
    }
    if (message.presentValueOfSavingsLifetime !== undefined) {
      obj.presentValueOfSavingsLifetime = Money.toJSON(message.presentValueOfSavingsLifetime);
    }
    if (message.financiallyViable !== false) {
      obj.financiallyViable = message.financiallyViable;
    }
    return obj;
  },

  create(base?: DeepPartial<SavingsOverTime>): SavingsOverTime {
    return SavingsOverTime.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SavingsOverTime>): SavingsOverTime {
    const message = createBaseSavingsOverTime();
    message.savingsYear1 = (object.savingsYear1 !== undefined && object.savingsYear1 !== null)
      ? Money.fromPartial(object.savingsYear1)
      : undefined;
    message.savingsYear20 = (object.savingsYear20 !== undefined && object.savingsYear20 !== null)
      ? Money.fromPartial(object.savingsYear20)
      : undefined;
    message.presentValueOfSavingsYear20 =
      (object.presentValueOfSavingsYear20 !== undefined && object.presentValueOfSavingsYear20 !== null)
        ? Money.fromPartial(object.presentValueOfSavingsYear20)
        : undefined;
    message.savingsLifetime = (object.savingsLifetime !== undefined && object.savingsLifetime !== null)
      ? Money.fromPartial(object.savingsLifetime)
      : undefined;
    message.presentValueOfSavingsLifetime =
      (object.presentValueOfSavingsLifetime !== undefined && object.presentValueOfSavingsLifetime !== null)
        ? Money.fromPartial(object.presentValueOfSavingsLifetime)
        : undefined;
    message.financiallyViable = object.financiallyViable ?? false;
    return message;
  },
};

function createBaseLeasingSavings(): LeasingSavings {
  return { leasesAllowed: false, leasesSupported: false, annualLeasingCost: undefined, savings: undefined };
}

export const LeasingSavings: MessageFns<LeasingSavings> = {
  encode(message: LeasingSavings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.leasesAllowed !== false) {
      writer.uint32(8).bool(message.leasesAllowed);
    }
    if (message.leasesSupported !== false) {
      writer.uint32(16).bool(message.leasesSupported);
    }
    if (message.annualLeasingCost !== undefined) {
      Money.encode(message.annualLeasingCost, writer.uint32(26).fork()).join();
    }
    if (message.savings !== undefined) {
      SavingsOverTime.encode(message.savings, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LeasingSavings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLeasingSavings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.leasesAllowed = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.leasesSupported = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.annualLeasingCost = Money.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.savings = SavingsOverTime.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LeasingSavings {
    return {
      leasesAllowed: isSet(object.leasesAllowed) ? globalThis.Boolean(object.leasesAllowed) : false,
      leasesSupported: isSet(object.leasesSupported) ? globalThis.Boolean(object.leasesSupported) : false,
      annualLeasingCost: isSet(object.annualLeasingCost) ? Money.fromJSON(object.annualLeasingCost) : undefined,
      savings: isSet(object.savings) ? SavingsOverTime.fromJSON(object.savings) : undefined,
    };
  },

  toJSON(message: LeasingSavings): unknown {
    const obj: any = {};
    if (message.leasesAllowed !== false) {
      obj.leasesAllowed = message.leasesAllowed;
    }
    if (message.leasesSupported !== false) {
      obj.leasesSupported = message.leasesSupported;
    }
    if (message.annualLeasingCost !== undefined) {
      obj.annualLeasingCost = Money.toJSON(message.annualLeasingCost);
    }
    if (message.savings !== undefined) {
      obj.savings = SavingsOverTime.toJSON(message.savings);
    }
    return obj;
  },

  create(base?: DeepPartial<LeasingSavings>): LeasingSavings {
    return LeasingSavings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LeasingSavings>): LeasingSavings {
    const message = createBaseLeasingSavings();
    message.leasesAllowed = object.leasesAllowed ?? false;
    message.leasesSupported = object.leasesSupported ?? false;
    message.annualLeasingCost = (object.annualLeasingCost !== undefined && object.annualLeasingCost !== null)
      ? Money.fromPartial(object.annualLeasingCost)
      : undefined;
    message.savings = (object.savings !== undefined && object.savings !== null)
      ? SavingsOverTime.fromPartial(object.savings)
      : undefined;
    return message;
  },
};

function createBaseCashPurchaseSavings(): CashPurchaseSavings {
  return {
    outOfPocketCost: undefined,
    upfrontCost: undefined,
    rebateValue: undefined,
    paybackYears: undefined,
    savings: undefined,
  };
}

export const CashPurchaseSavings: MessageFns<CashPurchaseSavings> = {
  encode(message: CashPurchaseSavings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.outOfPocketCost !== undefined) {
      Money.encode(message.outOfPocketCost, writer.uint32(10).fork()).join();
    }
    if (message.upfrontCost !== undefined) {
      Money.encode(message.upfrontCost, writer.uint32(18).fork()).join();
    }
    if (message.rebateValue !== undefined) {
      Money.encode(message.rebateValue, writer.uint32(26).fork()).join();
    }
    if (message.paybackYears !== undefined) {
      writer.uint32(37).float(message.paybackYears);
    }
    if (message.savings !== undefined) {
      SavingsOverTime.encode(message.savings, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CashPurchaseSavings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCashPurchaseSavings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.outOfPocketCost = Money.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.upfrontCost = Money.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.rebateValue = Money.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.paybackYears = reader.float();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.savings = SavingsOverTime.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CashPurchaseSavings {
    return {
      outOfPocketCost: isSet(object.outOfPocketCost) ? Money.fromJSON(object.outOfPocketCost) : undefined,
      upfrontCost: isSet(object.upfrontCost) ? Money.fromJSON(object.upfrontCost) : undefined,
      rebateValue: isSet(object.rebateValue) ? Money.fromJSON(object.rebateValue) : undefined,
      paybackYears: isSet(object.paybackYears) ? globalThis.Number(object.paybackYears) : undefined,
      savings: isSet(object.savings) ? SavingsOverTime.fromJSON(object.savings) : undefined,
    };
  },

  toJSON(message: CashPurchaseSavings): unknown {
    const obj: any = {};
    if (message.outOfPocketCost !== undefined) {
      obj.outOfPocketCost = Money.toJSON(message.outOfPocketCost);
    }
    if (message.upfrontCost !== undefined) {
      obj.upfrontCost = Money.toJSON(message.upfrontCost);
    }
    if (message.rebateValue !== undefined) {
      obj.rebateValue = Money.toJSON(message.rebateValue);
    }
    if (message.paybackYears !== undefined) {
      obj.paybackYears = message.paybackYears;
    }
    if (message.savings !== undefined) {
      obj.savings = SavingsOverTime.toJSON(message.savings);
    }
    return obj;
  },

  create(base?: DeepPartial<CashPurchaseSavings>): CashPurchaseSavings {
    return CashPurchaseSavings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CashPurchaseSavings>): CashPurchaseSavings {
    const message = createBaseCashPurchaseSavings();
    message.outOfPocketCost = (object.outOfPocketCost !== undefined && object.outOfPocketCost !== null)
      ? Money.fromPartial(object.outOfPocketCost)
      : undefined;
    message.upfrontCost = (object.upfrontCost !== undefined && object.upfrontCost !== null)
      ? Money.fromPartial(object.upfrontCost)
      : undefined;
    message.rebateValue = (object.rebateValue !== undefined && object.rebateValue !== null)
      ? Money.fromPartial(object.rebateValue)
      : undefined;
    message.paybackYears = object.paybackYears ?? undefined;
    message.savings = (object.savings !== undefined && object.savings !== null)
      ? SavingsOverTime.fromPartial(object.savings)
      : undefined;
    return message;
  },
};

function createBaseFinancedPurchaseSavings(): FinancedPurchaseSavings {
  return { annualLoanPayment: undefined, rebateValue: undefined, loanInterestRate: 0, savings: undefined };
}

export const FinancedPurchaseSavings: MessageFns<FinancedPurchaseSavings> = {
  encode(message: FinancedPurchaseSavings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.annualLoanPayment !== undefined) {
      Money.encode(message.annualLoanPayment, writer.uint32(10).fork()).join();
    }
    if (message.rebateValue !== undefined) {
      Money.encode(message.rebateValue, writer.uint32(18).fork()).join();
    }
    if (message.loanInterestRate !== 0) {
      writer.uint32(29).float(message.loanInterestRate);
    }
    if (message.savings !== undefined) {
      SavingsOverTime.encode(message.savings, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinancedPurchaseSavings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinancedPurchaseSavings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.annualLoanPayment = Money.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.rebateValue = Money.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.loanInterestRate = reader.float();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.savings = SavingsOverTime.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinancedPurchaseSavings {
    return {
      annualLoanPayment: isSet(object.annualLoanPayment) ? Money.fromJSON(object.annualLoanPayment) : undefined,
      rebateValue: isSet(object.rebateValue) ? Money.fromJSON(object.rebateValue) : undefined,
      loanInterestRate: isSet(object.loanInterestRate) ? globalThis.Number(object.loanInterestRate) : 0,
      savings: isSet(object.savings) ? SavingsOverTime.fromJSON(object.savings) : undefined,
    };
  },

  toJSON(message: FinancedPurchaseSavings): unknown {
    const obj: any = {};
    if (message.annualLoanPayment !== undefined) {
      obj.annualLoanPayment = Money.toJSON(message.annualLoanPayment);
    }
    if (message.rebateValue !== undefined) {
      obj.rebateValue = Money.toJSON(message.rebateValue);
    }
    if (message.loanInterestRate !== 0) {
      obj.loanInterestRate = message.loanInterestRate;
    }
    if (message.savings !== undefined) {
      obj.savings = SavingsOverTime.toJSON(message.savings);
    }
    return obj;
  },

  create(base?: DeepPartial<FinancedPurchaseSavings>): FinancedPurchaseSavings {
    return FinancedPurchaseSavings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FinancedPurchaseSavings>): FinancedPurchaseSavings {
    const message = createBaseFinancedPurchaseSavings();
    message.annualLoanPayment = (object.annualLoanPayment !== undefined && object.annualLoanPayment !== null)
      ? Money.fromPartial(object.annualLoanPayment)
      : undefined;
    message.rebateValue = (object.rebateValue !== undefined && object.rebateValue !== null)
      ? Money.fromPartial(object.rebateValue)
      : undefined;
    message.loanInterestRate = object.loanInterestRate ?? 0;
    message.savings = (object.savings !== undefined && object.savings !== null)
      ? SavingsOverTime.fromPartial(object.savings)
      : undefined;
    return message;
  },
};

function createBaseGetDataLayersRequest(): GetDataLayersRequest {
  return {
    location: undefined,
    radiusMeters: 0,
    view: 0,
    requiredQuality: 0,
    pixelSizeMeters: 0,
    exactQualityRequired: false,
  };
}

export const GetDataLayersRequest: MessageFns<GetDataLayersRequest> = {
  encode(message: GetDataLayersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.location !== undefined) {
      LatLng.encode(message.location, writer.uint32(10).fork()).join();
    }
    if (message.radiusMeters !== 0) {
      writer.uint32(21).float(message.radiusMeters);
    }
    if (message.view !== 0) {
      writer.uint32(24).int32(message.view);
    }
    if (message.requiredQuality !== 0) {
      writer.uint32(40).int32(message.requiredQuality);
    }
    if (message.pixelSizeMeters !== 0) {
      writer.uint32(53).float(message.pixelSizeMeters);
    }
    if (message.exactQualityRequired !== false) {
      writer.uint32(56).bool(message.exactQualityRequired);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDataLayersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDataLayersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.location = LatLng.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.radiusMeters = reader.float();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.requiredQuality = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 53) {
            break;
          }

          message.pixelSizeMeters = reader.float();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.exactQualityRequired = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDataLayersRequest {
    return {
      location: isSet(object.location) ? LatLng.fromJSON(object.location) : undefined,
      radiusMeters: isSet(object.radiusMeters) ? globalThis.Number(object.radiusMeters) : 0,
      view: isSet(object.view) ? dataLayerViewFromJSON(object.view) : 0,
      requiredQuality: isSet(object.requiredQuality) ? imageryQualityFromJSON(object.requiredQuality) : 0,
      pixelSizeMeters: isSet(object.pixelSizeMeters) ? globalThis.Number(object.pixelSizeMeters) : 0,
      exactQualityRequired: isSet(object.exactQualityRequired)
        ? globalThis.Boolean(object.exactQualityRequired)
        : false,
    };
  },

  toJSON(message: GetDataLayersRequest): unknown {
    const obj: any = {};
    if (message.location !== undefined) {
      obj.location = LatLng.toJSON(message.location);
    }
    if (message.radiusMeters !== 0) {
      obj.radiusMeters = message.radiusMeters;
    }
    if (message.view !== 0) {
      obj.view = dataLayerViewToJSON(message.view);
    }
    if (message.requiredQuality !== 0) {
      obj.requiredQuality = imageryQualityToJSON(message.requiredQuality);
    }
    if (message.pixelSizeMeters !== 0) {
      obj.pixelSizeMeters = message.pixelSizeMeters;
    }
    if (message.exactQualityRequired !== false) {
      obj.exactQualityRequired = message.exactQualityRequired;
    }
    return obj;
  },

  create(base?: DeepPartial<GetDataLayersRequest>): GetDataLayersRequest {
    return GetDataLayersRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDataLayersRequest>): GetDataLayersRequest {
    const message = createBaseGetDataLayersRequest();
    message.location = (object.location !== undefined && object.location !== null)
      ? LatLng.fromPartial(object.location)
      : undefined;
    message.radiusMeters = object.radiusMeters ?? 0;
    message.view = object.view ?? 0;
    message.requiredQuality = object.requiredQuality ?? 0;
    message.pixelSizeMeters = object.pixelSizeMeters ?? 0;
    message.exactQualityRequired = object.exactQualityRequired ?? false;
    return message;
  },
};

function createBaseDataLayers(): DataLayers {
  return {
    imageryDate: undefined,
    imageryProcessedDate: undefined,
    dsmUrl: "",
    rgbUrl: "",
    maskUrl: "",
    annualFluxUrl: "",
    monthlyFluxUrl: "",
    hourlyShadeUrls: [],
    imageryQuality: 0,
  };
}

export const DataLayers: MessageFns<DataLayers> = {
  encode(message: DataLayers, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.imageryDate !== undefined) {
      DateMessage.encode(message.imageryDate, writer.uint32(10).fork()).join();
    }
    if (message.imageryProcessedDate !== undefined) {
      DateMessage.encode(message.imageryProcessedDate, writer.uint32(18).fork()).join();
    }
    if (message.dsmUrl !== "") {
      writer.uint32(26).string(message.dsmUrl);
    }
    if (message.rgbUrl !== "") {
      writer.uint32(34).string(message.rgbUrl);
    }
    if (message.maskUrl !== "") {
      writer.uint32(42).string(message.maskUrl);
    }
    if (message.annualFluxUrl !== "") {
      writer.uint32(50).string(message.annualFluxUrl);
    }
    if (message.monthlyFluxUrl !== "") {
      writer.uint32(58).string(message.monthlyFluxUrl);
    }
    for (const v of message.hourlyShadeUrls) {
      writer.uint32(66).string(v!);
    }
    if (message.imageryQuality !== 0) {
      writer.uint32(72).int32(message.imageryQuality);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataLayers {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataLayers();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.imageryDate = DateMessage.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.imageryProcessedDate = DateMessage.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.dsmUrl = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.rgbUrl = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.maskUrl = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.annualFluxUrl = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.monthlyFluxUrl = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.hourlyShadeUrls.push(reader.string());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.imageryQuality = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataLayers {
    return {
      imageryDate: isSet(object.imageryDate) ? DateMessage.fromJSON(object.imageryDate) : undefined,
      imageryProcessedDate: isSet(object.imageryProcessedDate)
        ? DateMessage.fromJSON(object.imageryProcessedDate)
        : undefined,
      dsmUrl: isSet(object.dsmUrl) ? globalThis.String(object.dsmUrl) : "",
      rgbUrl: isSet(object.rgbUrl) ? globalThis.String(object.rgbUrl) : "",
      maskUrl: isSet(object.maskUrl) ? globalThis.String(object.maskUrl) : "",
      annualFluxUrl: isSet(object.annualFluxUrl) ? globalThis.String(object.annualFluxUrl) : "",
      monthlyFluxUrl: isSet(object.monthlyFluxUrl) ? globalThis.String(object.monthlyFluxUrl) : "",
      hourlyShadeUrls: globalThis.Array.isArray(object?.hourlyShadeUrls)
        ? object.hourlyShadeUrls.map((e: any) => globalThis.String(e))
        : [],
      imageryQuality: isSet(object.imageryQuality) ? imageryQualityFromJSON(object.imageryQuality) : 0,
    };
  },

  toJSON(message: DataLayers): unknown {
    const obj: any = {};
    if (message.imageryDate !== undefined) {
      obj.imageryDate = DateMessage.toJSON(message.imageryDate);
    }
    if (message.imageryProcessedDate !== undefined) {
      obj.imageryProcessedDate = DateMessage.toJSON(message.imageryProcessedDate);
    }
    if (message.dsmUrl !== "") {
      obj.dsmUrl = message.dsmUrl;
    }
    if (message.rgbUrl !== "") {
      obj.rgbUrl = message.rgbUrl;
    }
    if (message.maskUrl !== "") {
      obj.maskUrl = message.maskUrl;
    }
    if (message.annualFluxUrl !== "") {
      obj.annualFluxUrl = message.annualFluxUrl;
    }
    if (message.monthlyFluxUrl !== "") {
      obj.monthlyFluxUrl = message.monthlyFluxUrl;
    }
    if (message.hourlyShadeUrls?.length) {
      obj.hourlyShadeUrls = message.hourlyShadeUrls;
    }
    if (message.imageryQuality !== 0) {
      obj.imageryQuality = imageryQualityToJSON(message.imageryQuality);
    }
    return obj;
  },

  create(base?: DeepPartial<DataLayers>): DataLayers {
    return DataLayers.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataLayers>): DataLayers {
    const message = createBaseDataLayers();
    message.imageryDate = (object.imageryDate !== undefined && object.imageryDate !== null)
      ? DateMessage.fromPartial(object.imageryDate)
      : undefined;
    message.imageryProcessedDate = (object.imageryProcessedDate !== undefined && object.imageryProcessedDate !== null)
      ? DateMessage.fromPartial(object.imageryProcessedDate)
      : undefined;
    message.dsmUrl = object.dsmUrl ?? "";
    message.rgbUrl = object.rgbUrl ?? "";
    message.maskUrl = object.maskUrl ?? "";
    message.annualFluxUrl = object.annualFluxUrl ?? "";
    message.monthlyFluxUrl = object.monthlyFluxUrl ?? "";
    message.hourlyShadeUrls = object.hourlyShadeUrls?.map((e) => e) || [];
    message.imageryQuality = object.imageryQuality ?? 0;
    return message;
  },
};

function createBaseGetGeoTiffRequest(): GetGeoTiffRequest {
  return { id: "" };
}

export const GetGeoTiffRequest: MessageFns<GetGeoTiffRequest> = {
  encode(message: GetGeoTiffRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGeoTiffRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGeoTiffRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGeoTiffRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: GetGeoTiffRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create(base?: DeepPartial<GetGeoTiffRequest>): GetGeoTiffRequest {
    return GetGeoTiffRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetGeoTiffRequest>): GetGeoTiffRequest {
    const message = createBaseGetGeoTiffRequest();
    message.id = object.id ?? "";
    return message;
  },
};

/** Service definition for the Solar API. */
export type SolarDefinition = typeof SolarDefinition;
export const SolarDefinition = {
  name: "Solar",
  fullName: "google.maps.solar.v1.Solar",
  methods: {
    /**
     * Locates the closest building to a query point. Returns an error with
     * code `NOT_FOUND` if there are no buildings within approximately 50m of the
     * query point.
     */
    findClosestBuildingInsights: {
      name: "FindClosestBuildingInsights",
      requestType: FindClosestBuildingInsightsRequest,
      requestStream: false,
      responseType: BuildingInsights,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              34,
              18,
              32,
              47,
              118,
              49,
              47,
              98,
              117,
              105,
              108,
              100,
              105,
              110,
              103,
              73,
              110,
              115,
              105,
              103,
              104,
              116,
              115,
              58,
              102,
              105,
              110,
              100,
              67,
              108,
              111,
              115,
              101,
              115,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * Gets solar information for a region surrounding a location.
     * Returns an error with code `NOT_FOUND` if the location is outside
     * the coverage area.
     */
    getDataLayers: {
      name: "GetDataLayers",
      requestType: GetDataLayersRequest,
      requestStream: false,
      responseType: DataLayers,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([20, 18, 18, 47, 118, 49, 47, 100, 97, 116, 97, 76, 97, 121, 101, 114, 115, 58, 103, 101, 116]),
          ],
        },
      },
    },
    /** Returns an image by its ID. */
    getGeoTiff: {
      name: "GetGeoTiff",
      requestType: GetGeoTiffRequest,
      requestStream: false,
      responseType: HttpBody,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [Buffer.from([17, 18, 15, 47, 118, 49, 47, 103, 101, 111, 84, 105, 102, 102, 58, 103, 101, 116])],
        },
      },
    },
  },
} as const;

export interface SolarServiceImplementation<CallContextExt = {}> {
  /**
   * Locates the closest building to a query point. Returns an error with
   * code `NOT_FOUND` if there are no buildings within approximately 50m of the
   * query point.
   */
  findClosestBuildingInsights(
    request: FindClosestBuildingInsightsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<BuildingInsights>>;
  /**
   * Gets solar information for a region surrounding a location.
   * Returns an error with code `NOT_FOUND` if the location is outside
   * the coverage area.
   */
  getDataLayers(request: GetDataLayersRequest, context: CallContext & CallContextExt): Promise<DeepPartial<DataLayers>>;
  /** Returns an image by its ID. */
  getGeoTiff(request: GetGeoTiffRequest, context: CallContext & CallContextExt): Promise<DeepPartial<HttpBody>>;
}

export interface SolarClient<CallOptionsExt = {}> {
  /**
   * Locates the closest building to a query point. Returns an error with
   * code `NOT_FOUND` if there are no buildings within approximately 50m of the
   * query point.
   */
  findClosestBuildingInsights(
    request: DeepPartial<FindClosestBuildingInsightsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<BuildingInsights>;
  /**
   * Gets solar information for a region surrounding a location.
   * Returns an error with code `NOT_FOUND` if the location is outside
   * the coverage area.
   */
  getDataLayers(
    request: DeepPartial<GetDataLayersRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<DataLayers>;
  /** Returns an image by its ID. */
  getGeoTiff(request: DeepPartial<GetGeoTiffRequest>, options?: CallOptions & CallOptionsExt): Promise<HttpBody>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
