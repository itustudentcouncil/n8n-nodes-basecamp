// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/maps/routes/v1/route.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Viewport } from "../../../geo/type/viewport.js";
import { Duration } from "../../../protobuf/duration.js";
import { Money } from "../../../type/money.js";
import { Polyline } from "./polyline.js";
import { Location } from "./waypoint.js";

export const protobufPackage = "google.maps.routes.v1";

/**
 * A set of values that specify the navigation action to take for the current
 * step (for example, turn left, merge, or straight).
 */
export enum Maneuver {
  /** MANEUVER_UNSPECIFIED - Not used. */
  MANEUVER_UNSPECIFIED = 0,
  /** TURN_SLIGHT_LEFT - Turn slightly to the left. */
  TURN_SLIGHT_LEFT = 1,
  /** TURN_SHARP_LEFT - Turn sharply to the left. */
  TURN_SHARP_LEFT = 2,
  /** UTURN_LEFT - Make a left u-turn. */
  UTURN_LEFT = 3,
  /** TURN_LEFT - Turn left. */
  TURN_LEFT = 4,
  /** TURN_SLIGHT_RIGHT - Turn slightly to the right. */
  TURN_SLIGHT_RIGHT = 5,
  /** TURN_SHARP_RIGHT - Turn sharply to the right. */
  TURN_SHARP_RIGHT = 6,
  /** UTURN_RIGHT - Make a right u-turn. */
  UTURN_RIGHT = 7,
  /** TURN_RIGHT - Turn right. */
  TURN_RIGHT = 8,
  /** STRAIGHT - Go straight. */
  STRAIGHT = 9,
  /** RAMP_LEFT - Take the left ramp. */
  RAMP_LEFT = 10,
  /** RAMP_RIGHT - Take the right ramp. */
  RAMP_RIGHT = 11,
  /** MERGE - Merge into traffic. */
  MERGE = 12,
  /** FORK_LEFT - Take the left fork. */
  FORK_LEFT = 13,
  /** FORK_RIGHT - Take the right fork. */
  FORK_RIGHT = 14,
  /** FERRY - Take the ferry. */
  FERRY = 15,
  /** FERRY_TRAIN - Take the train leading onto the ferry. */
  FERRY_TRAIN = 16,
  /** ROUNDABOUT_LEFT - Turn left at the roundabout. */
  ROUNDABOUT_LEFT = 17,
  /** ROUNDABOUT_RIGHT - Turn right at the roundabout. */
  ROUNDABOUT_RIGHT = 18,
  /** DEPART - Initial maneuver. */
  DEPART = 19,
  /** NAME_CHANGE - Used to indicate a street name change. */
  NAME_CHANGE = 20,
  UNRECOGNIZED = -1,
}

export function maneuverFromJSON(object: any): Maneuver {
  switch (object) {
    case 0:
    case "MANEUVER_UNSPECIFIED":
      return Maneuver.MANEUVER_UNSPECIFIED;
    case 1:
    case "TURN_SLIGHT_LEFT":
      return Maneuver.TURN_SLIGHT_LEFT;
    case 2:
    case "TURN_SHARP_LEFT":
      return Maneuver.TURN_SHARP_LEFT;
    case 3:
    case "UTURN_LEFT":
      return Maneuver.UTURN_LEFT;
    case 4:
    case "TURN_LEFT":
      return Maneuver.TURN_LEFT;
    case 5:
    case "TURN_SLIGHT_RIGHT":
      return Maneuver.TURN_SLIGHT_RIGHT;
    case 6:
    case "TURN_SHARP_RIGHT":
      return Maneuver.TURN_SHARP_RIGHT;
    case 7:
    case "UTURN_RIGHT":
      return Maneuver.UTURN_RIGHT;
    case 8:
    case "TURN_RIGHT":
      return Maneuver.TURN_RIGHT;
    case 9:
    case "STRAIGHT":
      return Maneuver.STRAIGHT;
    case 10:
    case "RAMP_LEFT":
      return Maneuver.RAMP_LEFT;
    case 11:
    case "RAMP_RIGHT":
      return Maneuver.RAMP_RIGHT;
    case 12:
    case "MERGE":
      return Maneuver.MERGE;
    case 13:
    case "FORK_LEFT":
      return Maneuver.FORK_LEFT;
    case 14:
    case "FORK_RIGHT":
      return Maneuver.FORK_RIGHT;
    case 15:
    case "FERRY":
      return Maneuver.FERRY;
    case 16:
    case "FERRY_TRAIN":
      return Maneuver.FERRY_TRAIN;
    case 17:
    case "ROUNDABOUT_LEFT":
      return Maneuver.ROUNDABOUT_LEFT;
    case 18:
    case "ROUNDABOUT_RIGHT":
      return Maneuver.ROUNDABOUT_RIGHT;
    case 19:
    case "DEPART":
      return Maneuver.DEPART;
    case 20:
    case "NAME_CHANGE":
      return Maneuver.NAME_CHANGE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Maneuver.UNRECOGNIZED;
  }
}

export function maneuverToJSON(object: Maneuver): string {
  switch (object) {
    case Maneuver.MANEUVER_UNSPECIFIED:
      return "MANEUVER_UNSPECIFIED";
    case Maneuver.TURN_SLIGHT_LEFT:
      return "TURN_SLIGHT_LEFT";
    case Maneuver.TURN_SHARP_LEFT:
      return "TURN_SHARP_LEFT";
    case Maneuver.UTURN_LEFT:
      return "UTURN_LEFT";
    case Maneuver.TURN_LEFT:
      return "TURN_LEFT";
    case Maneuver.TURN_SLIGHT_RIGHT:
      return "TURN_SLIGHT_RIGHT";
    case Maneuver.TURN_SHARP_RIGHT:
      return "TURN_SHARP_RIGHT";
    case Maneuver.UTURN_RIGHT:
      return "UTURN_RIGHT";
    case Maneuver.TURN_RIGHT:
      return "TURN_RIGHT";
    case Maneuver.STRAIGHT:
      return "STRAIGHT";
    case Maneuver.RAMP_LEFT:
      return "RAMP_LEFT";
    case Maneuver.RAMP_RIGHT:
      return "RAMP_RIGHT";
    case Maneuver.MERGE:
      return "MERGE";
    case Maneuver.FORK_LEFT:
      return "FORK_LEFT";
    case Maneuver.FORK_RIGHT:
      return "FORK_RIGHT";
    case Maneuver.FERRY:
      return "FERRY";
    case Maneuver.FERRY_TRAIN:
      return "FERRY_TRAIN";
    case Maneuver.ROUNDABOUT_LEFT:
      return "ROUNDABOUT_LEFT";
    case Maneuver.ROUNDABOUT_RIGHT:
      return "ROUNDABOUT_RIGHT";
    case Maneuver.DEPART:
      return "DEPART";
    case Maneuver.NAME_CHANGE:
      return "NAME_CHANGE";
    case Maneuver.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Encapsulates a route, which consists of a series of connected road segments
 * that join beginning, ending, and intermediate waypoints.
 */
export interface Route {
  /**
   * A collection of legs (path segments between waypoints) that make-up the
   * route. Each leg corresponds to the trip between two non-`via` Waypoints.
   * For example, a route with no intermediate waypoints has only one leg. A
   * route that includes one non-`via` intermediate waypoint has two legs. A
   * route that includes one `via` intermediate waypoint has one leg. The order
   * of the legs matches the order of Waypoints from `origin` to `intermediates`
   * to `destination`.
   */
  legs: RouteLeg[];
  /** The travel distance of the route, in meters. */
  distanceMeters: number;
  /**
   * The length of time needed to navigate the route. If you set the
   * `routing_preference` to `TRAFFIC_UNAWARE`, then this value is the same as
   * `static_duration`. If you set the `routing_preference` to either
   * `TRAFFIC_AWARE` or `TRAFFIC_AWARE_OPTIMAL`, then this value is calculated
   * taking traffic conditions into account.
   */
  duration:
    | Duration
    | undefined;
  /**
   * The duration of traveling through the route without taking traffic
   * conditions into consideration.
   */
  staticDuration:
    | Duration
    | undefined;
  /**
   * The overall route polyline. This polyline is the combined polyline of all
   * `legs`.
   */
  polyline:
    | Polyline
    | undefined;
  /** A description of the route. */
  description: string;
  /** An array of warnings to show when displaying the route. */
  warnings: string[];
  /** The viewport bounding box of the polyline. */
  viewport:
    | Viewport
    | undefined;
  /** Additional information about the route. */
  travelAdvisory:
    | RouteTravelAdvisory
    | undefined;
  /**
   * If `ComputeRoutesRequest.optimize_waypoint_order` is set to true, this
   * field contains the optimized ordering of intermediates waypoints.
   * otherwise, this field is empty.
   * For example, suppose the input is Origin: LA; Intermediates: Dallas,
   * Bangor, Phoenix;  Destination: New York; and the optimized intermediate
   * waypoint order is:  Phoenix, Dallas, Bangor. Then this field contains the
   * values [2, 0, 1]. The index starts with 0 for the first intermediate
   * waypoint.
   */
  optimizedIntermediateWaypointIndex: number[];
}

/**
 * Encapsulates the additional information that the user should be informed
 * about, such as possible traffic zone restriction etc.
 */
export interface RouteTravelAdvisory {
  /**
   * The traffic restriction that applies to the route. A vehicle that is
   * subject to the restriction is not allowed to travel on the route. As of
   * October 2019, only Jakarta, Indonesia takes into consideration.
   */
  trafficRestriction:
    | TrafficRestriction
    | undefined;
  /**
   * Encapsulates information about tolls on the Route.
   * This field is only populated if we expect there are tolls on the Route.
   * If this field is set but the `estimated_price` subfield is not populated,
   * we expect that road contains tolls but we do not know an estimated price.
   * If this field is not set, then we expect there is no toll on the Route.
   */
  tollInfo:
    | TollInfo
    | undefined;
  /**
   * Speed reading intervals detailing traffic density. Applicable in case of
   * `TRAFFIC_AWARE` and `TRAFFIC_AWARE_OPTIMAL` routing preferences.
   * The intervals cover the entire polyline of the route without overlap.
   * The start point of a specified interval is the same as the end point of the
   * preceding interval.
   *
   * Example:
   *
   *     polyline: A ---- B ---- C ---- D ---- E ---- F ---- G
   *     speed_reading_intervals: [A,C), [C,D), [D,G).
   */
  speedReadingIntervals: SpeedReadingInterval[];
  /**
   * Deprecated: This field will stop being populated soon.
   * Information related to the custom layer data that the customer specified
   * (e.g. time spent in a customer specified area).
   *
   * @deprecated
   */
  customLayerInfo: CustomLayerInfo | undefined;
}

/**
 * Encapsulates the additional information that the user should be informed
 * about, such as possible traffic zone restriction etc. on a route leg.
 */
export interface RouteLegTravelAdvisory {
  /**
   * Encapsulates information about tolls on the specific `RouteLeg`.
   * This field is only populated if we expect there are tolls on the
   * `RouteLeg`. If this field is set but the `estimated_price` subfield is not
   * populated, we expect that road contains tolls but we do not know an
   * estimated price. If this field does not exist, then there is no toll on the
   * `RouteLeg`.
   */
  tollInfo:
    | TollInfo
    | undefined;
  /**
   * Speed reading intervals detailing traffic density. Applicable in case of
   * `TRAFFIC_AWARE` and `TRAFFIC_AWARE_OPTIMAL` routing preferences.
   * The intervals cover the entire polyline of the `RouteLeg` without overlap.
   * The start point of a specified interval is the same as the end point of the
   * preceding interval.
   *
   * Example:
   *
   *     polyline: A ---- B ---- C ---- D ---- E ---- F ---- G
   *     speed_reading_intervals: [A,C), [C,D), [D,G).
   */
  speedReadingIntervals: SpeedReadingInterval[];
  /**
   * Deprecated: This field will stop being populated soon.
   * Information related to the custom layer data that the customer specified
   * (e.g. time spent in a customer specified area).
   *
   * @deprecated
   */
  customLayerInfo: CustomLayerInfo | undefined;
}

/**
 * Encapsulates the additional information that the user should be informed
 * about, such as possible traffic zone restriction on a leg step.
 */
export interface RouteLegStepTravelAdvisory {
  /** NOTE: This field is not currently populated. */
  speedReadingIntervals: SpeedReadingInterval[];
}

/**
 * Encapsulates the traffic restriction applied to the route. As of October
 * 2019, only Jakarta, Indonesia takes into consideration.
 */
export interface TrafficRestriction {
  /**
   * The restriction based on the vehicle's license plate last character. If
   * this field does not exist, then no restriction on route.
   */
  licensePlateLastCharacterRestriction: LicensePlateLastCharacterRestriction | undefined;
}

/** Encapsulates the license plate last character restriction. */
export interface LicensePlateLastCharacterRestriction {
  /**
   * The allowed last character of a license plate of a vehicle. Only vehicles
   * whose license plate's last characters match these are allowed to travel on
   * the route. If empty, no vehicle is allowed.
   */
  allowedLastCharacters: string[];
}

/** Encapsulates a segment between non-`via` waypoints. */
export interface RouteLeg {
  /** The travel distance of the route leg, in meters. */
  distanceMeters: number;
  /**
   * The length of time needed to navigate the leg. If the `route_preference`
   * is set to `TRAFFIC_UNAWARE`, then this value is the same as
   * `static_duration`. If the `route_preference` is either `TRAFFIC_AWARE` or
   * `TRAFFIC_AWARE_OPTIMAL`, then this value is calculated taking traffic
   * conditions into account.
   */
  duration:
    | Duration
    | undefined;
  /**
   * The duration of traveling through the leg, calculated without taking
   * traffic conditions into consideration.
   */
  staticDuration:
    | Duration
    | undefined;
  /**
   * The overall polyline for this leg. This includes that each `step`'s
   * polyline.
   */
  polyline:
    | Polyline
    | undefined;
  /**
   * The start location of this leg. This might be different from the provided
   * `origin`. For example, when the provided `origin` is not near a road, this
   * is a point on the road.
   */
  startLocation:
    | Location
    | undefined;
  /**
   * The end location of this leg. This might be different from the provided
   * `destination`. For example, when the provided `destination` is not near a
   * road, this is a point on the road.
   */
  endLocation:
    | Location
    | undefined;
  /**
   * An array of steps denoting segments within this leg. Each step represents
   * one navigation instruction.
   */
  steps: RouteLegStep[];
  /**
   * Encapsulates the additional information that the user should be informed
   * about, such as possible traffic zone restriction etc. on a route leg.
   */
  travelAdvisory: RouteLegTravelAdvisory | undefined;
}

/** Encapsulates toll information on a `Route` or on a `RouteLeg`. */
export interface TollInfo {
  /**
   * The monetary amount of tolls for the corresponding `Route` or `RouteLeg`.
   * This list contains a money amount for each currency that is expected
   * to be charged by the toll stations. Typically this list contains only one
   * item for routes with tolls in one currency. For international trips, this
   * list may contain multiple items to reflect tolls in different currencies.
   */
  estimatedPrice: Money[];
}

/**
 * Encapsulates a segment of a `RouteLeg`. A step corresponds to a single
 * navigation instruction. Route legs are made up of steps.
 */
export interface RouteLegStep {
  /**
   * The travel distance of this step, in meters. In some circumstances, this
   * field might not have a value.
   */
  distanceMeters: number;
  /**
   * The duration of travel through this step without taking traffic conditions
   * into consideration. In some circumstances, this field might not have a
   * value.
   */
  staticDuration:
    | Duration
    | undefined;
  /** The polyline associated with this step. */
  polyline:
    | Polyline
    | undefined;
  /** The start location of this step. */
  startLocation:
    | Location
    | undefined;
  /** The end location of this step. */
  endLocation:
    | Location
    | undefined;
  /** Navigation instructions. */
  navigationInstruction:
    | NavigationInstruction
    | undefined;
  /**
   * Encapsulates the additional information that the user should be informed
   * about, such as possible traffic zone restriction on a leg step.
   */
  travelAdvisory: RouteLegStepTravelAdvisory | undefined;
}

export interface NavigationInstruction {
  /**
   * Encapsulates the navigation instructions for the current step (for example,
   * turn left, merge, or straight). This field determines which icon to
   * display.
   */
  maneuver: Maneuver;
  /** Instructions for navigating this step. */
  instructions: string;
}

/**
 * Traffic density indicator on a contiguous segment of a polyline or path.
 * Given a path with points P_0, P_1, ... , P_N (zero-based index), the
 * `SpeedReadingInterval` defines an interval and describes its traffic using
 * the following categories.
 */
export interface SpeedReadingInterval {
  /**
   * The starting index of this interval in the polyline.
   * In JSON, when the index is 0, the field appears to be unpopulated.
   */
  startPolylinePointIndex: number;
  /**
   * The ending index of this interval in the polyline.
   * In JSON, when the index is 0, the field appears to be unpopulated.
   */
  endPolylinePointIndex: number;
  /** Traffic speed in this interval. */
  speed: SpeedReadingInterval_Speed;
}

/** The classification of polyline speed based on traffic data. */
export enum SpeedReadingInterval_Speed {
  /** SPEED_UNSPECIFIED - Default value. This value is unused. */
  SPEED_UNSPECIFIED = 0,
  /** NORMAL - Normal speed, no slowdown is detected. */
  NORMAL = 1,
  /** SLOW - Slowdown detected, but no traffic jam formed. */
  SLOW = 2,
  /** TRAFFIC_JAM - Traffic jam detected. */
  TRAFFIC_JAM = 3,
  UNRECOGNIZED = -1,
}

export function speedReadingInterval_SpeedFromJSON(object: any): SpeedReadingInterval_Speed {
  switch (object) {
    case 0:
    case "SPEED_UNSPECIFIED":
      return SpeedReadingInterval_Speed.SPEED_UNSPECIFIED;
    case 1:
    case "NORMAL":
      return SpeedReadingInterval_Speed.NORMAL;
    case 2:
    case "SLOW":
      return SpeedReadingInterval_Speed.SLOW;
    case 3:
    case "TRAFFIC_JAM":
      return SpeedReadingInterval_Speed.TRAFFIC_JAM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SpeedReadingInterval_Speed.UNRECOGNIZED;
  }
}

export function speedReadingInterval_SpeedToJSON(object: SpeedReadingInterval_Speed): string {
  switch (object) {
    case SpeedReadingInterval_Speed.SPEED_UNSPECIFIED:
      return "SPEED_UNSPECIFIED";
    case SpeedReadingInterval_Speed.NORMAL:
      return "NORMAL";
    case SpeedReadingInterval_Speed.SLOW:
      return "SLOW";
    case SpeedReadingInterval_Speed.TRAFFIC_JAM:
      return "TRAFFIC_JAM";
    case SpeedReadingInterval_Speed.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Deprecated: This field will stop being populated soon.
 * Encapsulates statistics about the time spent and distance travelled in a
 * custom area.
 *
 * @deprecated
 */
export interface CustomLayerInfo {
  /**
   * Encapsulates information about areas in the custom layer on the Route.
   * This field is only populated if a route travels through areas in the
   * custom layer.
   */
  areaInfo: CustomLayerInfo_AreaInfo[];
  /**
   * Total unique distance traveled across all activated areas in the provided
   * dataset (in meters). For example, if a route travels through the
   * intersection of area A and area B, the distance in the intersection region
   * is only added once to the `total_distance_in_areas_meters`.
   */
  totalDistanceInAreasMeters: number;
  /**
   * Total time spent across all activated areas in the provided dataset.
   * For example, if a route travels through the intersection of area A and
   * area B, the time spent in the intersection region is only added once to the
   * `total_duration_in_areas`.
   */
  totalDurationInAreas: Duration | undefined;
}

/** Encapsulates areas related information on a `Route` or on a `RouteLeg`. */
export interface CustomLayerInfo_AreaInfo {
  /**
   * ID of an area inside a customer provided dataset. An area represents a
   * collection of polygons on the map that are of concern to the customer.
   * For example, the customer may be interested in knowing whether a
   * returned route is traveling through multiple busy city blocks during
   * a predefined period of time. An area ID is unique within a single
   * dataset uploaded by a customer. That is, a (`customer_id`, `dataset_id`,
   * `area_id`) triplet should uniquely identify a set of polygons on the map
   * that "activates" following a common schedule.
   */
  areaId: string;
  /** Total distance traveled in the area (in meters). */
  distanceInAreaMeters: number;
  /** Total time spent in the area. */
  durationInArea: Duration | undefined;
}

function createBaseRoute(): Route {
  return {
    legs: [],
    distanceMeters: 0,
    duration: undefined,
    staticDuration: undefined,
    polyline: undefined,
    description: "",
    warnings: [],
    viewport: undefined,
    travelAdvisory: undefined,
    optimizedIntermediateWaypointIndex: [],
  };
}

export const Route: MessageFns<Route> = {
  encode(message: Route, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.legs) {
      RouteLeg.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.distanceMeters !== 0) {
      writer.uint32(16).int32(message.distanceMeters);
    }
    if (message.duration !== undefined) {
      Duration.encode(message.duration, writer.uint32(26).fork()).join();
    }
    if (message.staticDuration !== undefined) {
      Duration.encode(message.staticDuration, writer.uint32(34).fork()).join();
    }
    if (message.polyline !== undefined) {
      Polyline.encode(message.polyline, writer.uint32(42).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(50).string(message.description);
    }
    for (const v of message.warnings) {
      writer.uint32(58).string(v!);
    }
    if (message.viewport !== undefined) {
      Viewport.encode(message.viewport, writer.uint32(66).fork()).join();
    }
    if (message.travelAdvisory !== undefined) {
      RouteTravelAdvisory.encode(message.travelAdvisory, writer.uint32(74).fork()).join();
    }
    writer.uint32(82).fork();
    for (const v of message.optimizedIntermediateWaypointIndex) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Route {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.legs.push(RouteLeg.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.distanceMeters = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.duration = Duration.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.staticDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.polyline = Polyline.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.warnings.push(reader.string());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.viewport = Viewport.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.travelAdvisory = RouteTravelAdvisory.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag === 80) {
            message.optimizedIntermediateWaypointIndex.push(reader.int32());

            continue;
          }

          if (tag === 82) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.optimizedIntermediateWaypointIndex.push(reader.int32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Route {
    return {
      legs: globalThis.Array.isArray(object?.legs) ? object.legs.map((e: any) => RouteLeg.fromJSON(e)) : [],
      distanceMeters: isSet(object.distanceMeters) ? globalThis.Number(object.distanceMeters) : 0,
      duration: isSet(object.duration) ? Duration.fromJSON(object.duration) : undefined,
      staticDuration: isSet(object.staticDuration) ? Duration.fromJSON(object.staticDuration) : undefined,
      polyline: isSet(object.polyline) ? Polyline.fromJSON(object.polyline) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      warnings: globalThis.Array.isArray(object?.warnings) ? object.warnings.map((e: any) => globalThis.String(e)) : [],
      viewport: isSet(object.viewport) ? Viewport.fromJSON(object.viewport) : undefined,
      travelAdvisory: isSet(object.travelAdvisory) ? RouteTravelAdvisory.fromJSON(object.travelAdvisory) : undefined,
      optimizedIntermediateWaypointIndex: globalThis.Array.isArray(object?.optimizedIntermediateWaypointIndex)
        ? object.optimizedIntermediateWaypointIndex.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: Route): unknown {
    const obj: any = {};
    if (message.legs?.length) {
      obj.legs = message.legs.map((e) => RouteLeg.toJSON(e));
    }
    if (message.distanceMeters !== 0) {
      obj.distanceMeters = Math.round(message.distanceMeters);
    }
    if (message.duration !== undefined) {
      obj.duration = Duration.toJSON(message.duration);
    }
    if (message.staticDuration !== undefined) {
      obj.staticDuration = Duration.toJSON(message.staticDuration);
    }
    if (message.polyline !== undefined) {
      obj.polyline = Polyline.toJSON(message.polyline);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.warnings?.length) {
      obj.warnings = message.warnings;
    }
    if (message.viewport !== undefined) {
      obj.viewport = Viewport.toJSON(message.viewport);
    }
    if (message.travelAdvisory !== undefined) {
      obj.travelAdvisory = RouteTravelAdvisory.toJSON(message.travelAdvisory);
    }
    if (message.optimizedIntermediateWaypointIndex?.length) {
      obj.optimizedIntermediateWaypointIndex = message.optimizedIntermediateWaypointIndex.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Route>): Route {
    return Route.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Route>): Route {
    const message = createBaseRoute();
    message.legs = object.legs?.map((e) => RouteLeg.fromPartial(e)) || [];
    message.distanceMeters = object.distanceMeters ?? 0;
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? Duration.fromPartial(object.duration)
      : undefined;
    message.staticDuration = (object.staticDuration !== undefined && object.staticDuration !== null)
      ? Duration.fromPartial(object.staticDuration)
      : undefined;
    message.polyline = (object.polyline !== undefined && object.polyline !== null)
      ? Polyline.fromPartial(object.polyline)
      : undefined;
    message.description = object.description ?? "";
    message.warnings = object.warnings?.map((e) => e) || [];
    message.viewport = (object.viewport !== undefined && object.viewport !== null)
      ? Viewport.fromPartial(object.viewport)
      : undefined;
    message.travelAdvisory = (object.travelAdvisory !== undefined && object.travelAdvisory !== null)
      ? RouteTravelAdvisory.fromPartial(object.travelAdvisory)
      : undefined;
    message.optimizedIntermediateWaypointIndex = object.optimizedIntermediateWaypointIndex?.map((e) => e) || [];
    return message;
  },
};

function createBaseRouteTravelAdvisory(): RouteTravelAdvisory {
  return { trafficRestriction: undefined, tollInfo: undefined, speedReadingIntervals: [], customLayerInfo: undefined };
}

export const RouteTravelAdvisory: MessageFns<RouteTravelAdvisory> = {
  encode(message: RouteTravelAdvisory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trafficRestriction !== undefined) {
      TrafficRestriction.encode(message.trafficRestriction, writer.uint32(10).fork()).join();
    }
    if (message.tollInfo !== undefined) {
      TollInfo.encode(message.tollInfo, writer.uint32(18).fork()).join();
    }
    for (const v of message.speedReadingIntervals) {
      SpeedReadingInterval.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.customLayerInfo !== undefined) {
      CustomLayerInfo.encode(message.customLayerInfo, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteTravelAdvisory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteTravelAdvisory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.trafficRestriction = TrafficRestriction.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tollInfo = TollInfo.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.speedReadingIntervals.push(SpeedReadingInterval.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.customLayerInfo = CustomLayerInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteTravelAdvisory {
    return {
      trafficRestriction: isSet(object.trafficRestriction)
        ? TrafficRestriction.fromJSON(object.trafficRestriction)
        : undefined,
      tollInfo: isSet(object.tollInfo) ? TollInfo.fromJSON(object.tollInfo) : undefined,
      speedReadingIntervals: globalThis.Array.isArray(object?.speedReadingIntervals)
        ? object.speedReadingIntervals.map((e: any) => SpeedReadingInterval.fromJSON(e))
        : [],
      customLayerInfo: isSet(object.customLayerInfo) ? CustomLayerInfo.fromJSON(object.customLayerInfo) : undefined,
    };
  },

  toJSON(message: RouteTravelAdvisory): unknown {
    const obj: any = {};
    if (message.trafficRestriction !== undefined) {
      obj.trafficRestriction = TrafficRestriction.toJSON(message.trafficRestriction);
    }
    if (message.tollInfo !== undefined) {
      obj.tollInfo = TollInfo.toJSON(message.tollInfo);
    }
    if (message.speedReadingIntervals?.length) {
      obj.speedReadingIntervals = message.speedReadingIntervals.map((e) => SpeedReadingInterval.toJSON(e));
    }
    if (message.customLayerInfo !== undefined) {
      obj.customLayerInfo = CustomLayerInfo.toJSON(message.customLayerInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<RouteTravelAdvisory>): RouteTravelAdvisory {
    return RouteTravelAdvisory.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RouteTravelAdvisory>): RouteTravelAdvisory {
    const message = createBaseRouteTravelAdvisory();
    message.trafficRestriction = (object.trafficRestriction !== undefined && object.trafficRestriction !== null)
      ? TrafficRestriction.fromPartial(object.trafficRestriction)
      : undefined;
    message.tollInfo = (object.tollInfo !== undefined && object.tollInfo !== null)
      ? TollInfo.fromPartial(object.tollInfo)
      : undefined;
    message.speedReadingIntervals = object.speedReadingIntervals?.map((e) => SpeedReadingInterval.fromPartial(e)) || [];
    message.customLayerInfo = (object.customLayerInfo !== undefined && object.customLayerInfo !== null)
      ? CustomLayerInfo.fromPartial(object.customLayerInfo)
      : undefined;
    return message;
  },
};

function createBaseRouteLegTravelAdvisory(): RouteLegTravelAdvisory {
  return { tollInfo: undefined, speedReadingIntervals: [], customLayerInfo: undefined };
}

export const RouteLegTravelAdvisory: MessageFns<RouteLegTravelAdvisory> = {
  encode(message: RouteLegTravelAdvisory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tollInfo !== undefined) {
      TollInfo.encode(message.tollInfo, writer.uint32(10).fork()).join();
    }
    for (const v of message.speedReadingIntervals) {
      SpeedReadingInterval.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.customLayerInfo !== undefined) {
      CustomLayerInfo.encode(message.customLayerInfo, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteLegTravelAdvisory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteLegTravelAdvisory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tollInfo = TollInfo.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.speedReadingIntervals.push(SpeedReadingInterval.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.customLayerInfo = CustomLayerInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteLegTravelAdvisory {
    return {
      tollInfo: isSet(object.tollInfo) ? TollInfo.fromJSON(object.tollInfo) : undefined,
      speedReadingIntervals: globalThis.Array.isArray(object?.speedReadingIntervals)
        ? object.speedReadingIntervals.map((e: any) => SpeedReadingInterval.fromJSON(e))
        : [],
      customLayerInfo: isSet(object.customLayerInfo) ? CustomLayerInfo.fromJSON(object.customLayerInfo) : undefined,
    };
  },

  toJSON(message: RouteLegTravelAdvisory): unknown {
    const obj: any = {};
    if (message.tollInfo !== undefined) {
      obj.tollInfo = TollInfo.toJSON(message.tollInfo);
    }
    if (message.speedReadingIntervals?.length) {
      obj.speedReadingIntervals = message.speedReadingIntervals.map((e) => SpeedReadingInterval.toJSON(e));
    }
    if (message.customLayerInfo !== undefined) {
      obj.customLayerInfo = CustomLayerInfo.toJSON(message.customLayerInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<RouteLegTravelAdvisory>): RouteLegTravelAdvisory {
    return RouteLegTravelAdvisory.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RouteLegTravelAdvisory>): RouteLegTravelAdvisory {
    const message = createBaseRouteLegTravelAdvisory();
    message.tollInfo = (object.tollInfo !== undefined && object.tollInfo !== null)
      ? TollInfo.fromPartial(object.tollInfo)
      : undefined;
    message.speedReadingIntervals = object.speedReadingIntervals?.map((e) => SpeedReadingInterval.fromPartial(e)) || [];
    message.customLayerInfo = (object.customLayerInfo !== undefined && object.customLayerInfo !== null)
      ? CustomLayerInfo.fromPartial(object.customLayerInfo)
      : undefined;
    return message;
  },
};

function createBaseRouteLegStepTravelAdvisory(): RouteLegStepTravelAdvisory {
  return { speedReadingIntervals: [] };
}

export const RouteLegStepTravelAdvisory: MessageFns<RouteLegStepTravelAdvisory> = {
  encode(message: RouteLegStepTravelAdvisory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.speedReadingIntervals) {
      SpeedReadingInterval.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteLegStepTravelAdvisory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteLegStepTravelAdvisory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.speedReadingIntervals.push(SpeedReadingInterval.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteLegStepTravelAdvisory {
    return {
      speedReadingIntervals: globalThis.Array.isArray(object?.speedReadingIntervals)
        ? object.speedReadingIntervals.map((e: any) => SpeedReadingInterval.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RouteLegStepTravelAdvisory): unknown {
    const obj: any = {};
    if (message.speedReadingIntervals?.length) {
      obj.speedReadingIntervals = message.speedReadingIntervals.map((e) => SpeedReadingInterval.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RouteLegStepTravelAdvisory>): RouteLegStepTravelAdvisory {
    return RouteLegStepTravelAdvisory.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RouteLegStepTravelAdvisory>): RouteLegStepTravelAdvisory {
    const message = createBaseRouteLegStepTravelAdvisory();
    message.speedReadingIntervals = object.speedReadingIntervals?.map((e) => SpeedReadingInterval.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTrafficRestriction(): TrafficRestriction {
  return { licensePlateLastCharacterRestriction: undefined };
}

export const TrafficRestriction: MessageFns<TrafficRestriction> = {
  encode(message: TrafficRestriction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.licensePlateLastCharacterRestriction !== undefined) {
      LicensePlateLastCharacterRestriction.encode(
        message.licensePlateLastCharacterRestriction,
        writer.uint32(10).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrafficRestriction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrafficRestriction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.licensePlateLastCharacterRestriction = LicensePlateLastCharacterRestriction.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrafficRestriction {
    return {
      licensePlateLastCharacterRestriction: isSet(object.licensePlateLastCharacterRestriction)
        ? LicensePlateLastCharacterRestriction.fromJSON(object.licensePlateLastCharacterRestriction)
        : undefined,
    };
  },

  toJSON(message: TrafficRestriction): unknown {
    const obj: any = {};
    if (message.licensePlateLastCharacterRestriction !== undefined) {
      obj.licensePlateLastCharacterRestriction = LicensePlateLastCharacterRestriction.toJSON(
        message.licensePlateLastCharacterRestriction,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<TrafficRestriction>): TrafficRestriction {
    return TrafficRestriction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TrafficRestriction>): TrafficRestriction {
    const message = createBaseTrafficRestriction();
    message.licensePlateLastCharacterRestriction =
      (object.licensePlateLastCharacterRestriction !== undefined &&
          object.licensePlateLastCharacterRestriction !== null)
        ? LicensePlateLastCharacterRestriction.fromPartial(object.licensePlateLastCharacterRestriction)
        : undefined;
    return message;
  },
};

function createBaseLicensePlateLastCharacterRestriction(): LicensePlateLastCharacterRestriction {
  return { allowedLastCharacters: [] };
}

export const LicensePlateLastCharacterRestriction: MessageFns<LicensePlateLastCharacterRestriction> = {
  encode(message: LicensePlateLastCharacterRestriction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.allowedLastCharacters) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LicensePlateLastCharacterRestriction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLicensePlateLastCharacterRestriction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.allowedLastCharacters.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LicensePlateLastCharacterRestriction {
    return {
      allowedLastCharacters: globalThis.Array.isArray(object?.allowedLastCharacters)
        ? object.allowedLastCharacters.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: LicensePlateLastCharacterRestriction): unknown {
    const obj: any = {};
    if (message.allowedLastCharacters?.length) {
      obj.allowedLastCharacters = message.allowedLastCharacters;
    }
    return obj;
  },

  create(base?: DeepPartial<LicensePlateLastCharacterRestriction>): LicensePlateLastCharacterRestriction {
    return LicensePlateLastCharacterRestriction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LicensePlateLastCharacterRestriction>): LicensePlateLastCharacterRestriction {
    const message = createBaseLicensePlateLastCharacterRestriction();
    message.allowedLastCharacters = object.allowedLastCharacters?.map((e) => e) || [];
    return message;
  },
};

function createBaseRouteLeg(): RouteLeg {
  return {
    distanceMeters: 0,
    duration: undefined,
    staticDuration: undefined,
    polyline: undefined,
    startLocation: undefined,
    endLocation: undefined,
    steps: [],
    travelAdvisory: undefined,
  };
}

export const RouteLeg: MessageFns<RouteLeg> = {
  encode(message: RouteLeg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.distanceMeters !== 0) {
      writer.uint32(8).int32(message.distanceMeters);
    }
    if (message.duration !== undefined) {
      Duration.encode(message.duration, writer.uint32(18).fork()).join();
    }
    if (message.staticDuration !== undefined) {
      Duration.encode(message.staticDuration, writer.uint32(26).fork()).join();
    }
    if (message.polyline !== undefined) {
      Polyline.encode(message.polyline, writer.uint32(34).fork()).join();
    }
    if (message.startLocation !== undefined) {
      Location.encode(message.startLocation, writer.uint32(42).fork()).join();
    }
    if (message.endLocation !== undefined) {
      Location.encode(message.endLocation, writer.uint32(50).fork()).join();
    }
    for (const v of message.steps) {
      RouteLegStep.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.travelAdvisory !== undefined) {
      RouteLegTravelAdvisory.encode(message.travelAdvisory, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteLeg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteLeg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.distanceMeters = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.duration = Duration.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.staticDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.polyline = Polyline.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.startLocation = Location.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.endLocation = Location.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.steps.push(RouteLegStep.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.travelAdvisory = RouteLegTravelAdvisory.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteLeg {
    return {
      distanceMeters: isSet(object.distanceMeters) ? globalThis.Number(object.distanceMeters) : 0,
      duration: isSet(object.duration) ? Duration.fromJSON(object.duration) : undefined,
      staticDuration: isSet(object.staticDuration) ? Duration.fromJSON(object.staticDuration) : undefined,
      polyline: isSet(object.polyline) ? Polyline.fromJSON(object.polyline) : undefined,
      startLocation: isSet(object.startLocation) ? Location.fromJSON(object.startLocation) : undefined,
      endLocation: isSet(object.endLocation) ? Location.fromJSON(object.endLocation) : undefined,
      steps: globalThis.Array.isArray(object?.steps) ? object.steps.map((e: any) => RouteLegStep.fromJSON(e)) : [],
      travelAdvisory: isSet(object.travelAdvisory) ? RouteLegTravelAdvisory.fromJSON(object.travelAdvisory) : undefined,
    };
  },

  toJSON(message: RouteLeg): unknown {
    const obj: any = {};
    if (message.distanceMeters !== 0) {
      obj.distanceMeters = Math.round(message.distanceMeters);
    }
    if (message.duration !== undefined) {
      obj.duration = Duration.toJSON(message.duration);
    }
    if (message.staticDuration !== undefined) {
      obj.staticDuration = Duration.toJSON(message.staticDuration);
    }
    if (message.polyline !== undefined) {
      obj.polyline = Polyline.toJSON(message.polyline);
    }
    if (message.startLocation !== undefined) {
      obj.startLocation = Location.toJSON(message.startLocation);
    }
    if (message.endLocation !== undefined) {
      obj.endLocation = Location.toJSON(message.endLocation);
    }
    if (message.steps?.length) {
      obj.steps = message.steps.map((e) => RouteLegStep.toJSON(e));
    }
    if (message.travelAdvisory !== undefined) {
      obj.travelAdvisory = RouteLegTravelAdvisory.toJSON(message.travelAdvisory);
    }
    return obj;
  },

  create(base?: DeepPartial<RouteLeg>): RouteLeg {
    return RouteLeg.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RouteLeg>): RouteLeg {
    const message = createBaseRouteLeg();
    message.distanceMeters = object.distanceMeters ?? 0;
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? Duration.fromPartial(object.duration)
      : undefined;
    message.staticDuration = (object.staticDuration !== undefined && object.staticDuration !== null)
      ? Duration.fromPartial(object.staticDuration)
      : undefined;
    message.polyline = (object.polyline !== undefined && object.polyline !== null)
      ? Polyline.fromPartial(object.polyline)
      : undefined;
    message.startLocation = (object.startLocation !== undefined && object.startLocation !== null)
      ? Location.fromPartial(object.startLocation)
      : undefined;
    message.endLocation = (object.endLocation !== undefined && object.endLocation !== null)
      ? Location.fromPartial(object.endLocation)
      : undefined;
    message.steps = object.steps?.map((e) => RouteLegStep.fromPartial(e)) || [];
    message.travelAdvisory = (object.travelAdvisory !== undefined && object.travelAdvisory !== null)
      ? RouteLegTravelAdvisory.fromPartial(object.travelAdvisory)
      : undefined;
    return message;
  },
};

function createBaseTollInfo(): TollInfo {
  return { estimatedPrice: [] };
}

export const TollInfo: MessageFns<TollInfo> = {
  encode(message: TollInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.estimatedPrice) {
      Money.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TollInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTollInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.estimatedPrice.push(Money.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TollInfo {
    return {
      estimatedPrice: globalThis.Array.isArray(object?.estimatedPrice)
        ? object.estimatedPrice.map((e: any) => Money.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TollInfo): unknown {
    const obj: any = {};
    if (message.estimatedPrice?.length) {
      obj.estimatedPrice = message.estimatedPrice.map((e) => Money.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TollInfo>): TollInfo {
    return TollInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TollInfo>): TollInfo {
    const message = createBaseTollInfo();
    message.estimatedPrice = object.estimatedPrice?.map((e) => Money.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRouteLegStep(): RouteLegStep {
  return {
    distanceMeters: 0,
    staticDuration: undefined,
    polyline: undefined,
    startLocation: undefined,
    endLocation: undefined,
    navigationInstruction: undefined,
    travelAdvisory: undefined,
  };
}

export const RouteLegStep: MessageFns<RouteLegStep> = {
  encode(message: RouteLegStep, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.distanceMeters !== 0) {
      writer.uint32(8).int32(message.distanceMeters);
    }
    if (message.staticDuration !== undefined) {
      Duration.encode(message.staticDuration, writer.uint32(18).fork()).join();
    }
    if (message.polyline !== undefined) {
      Polyline.encode(message.polyline, writer.uint32(26).fork()).join();
    }
    if (message.startLocation !== undefined) {
      Location.encode(message.startLocation, writer.uint32(34).fork()).join();
    }
    if (message.endLocation !== undefined) {
      Location.encode(message.endLocation, writer.uint32(42).fork()).join();
    }
    if (message.navigationInstruction !== undefined) {
      NavigationInstruction.encode(message.navigationInstruction, writer.uint32(50).fork()).join();
    }
    if (message.travelAdvisory !== undefined) {
      RouteLegStepTravelAdvisory.encode(message.travelAdvisory, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteLegStep {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteLegStep();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.distanceMeters = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.staticDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.polyline = Polyline.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.startLocation = Location.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.endLocation = Location.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.navigationInstruction = NavigationInstruction.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.travelAdvisory = RouteLegStepTravelAdvisory.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteLegStep {
    return {
      distanceMeters: isSet(object.distanceMeters) ? globalThis.Number(object.distanceMeters) : 0,
      staticDuration: isSet(object.staticDuration) ? Duration.fromJSON(object.staticDuration) : undefined,
      polyline: isSet(object.polyline) ? Polyline.fromJSON(object.polyline) : undefined,
      startLocation: isSet(object.startLocation) ? Location.fromJSON(object.startLocation) : undefined,
      endLocation: isSet(object.endLocation) ? Location.fromJSON(object.endLocation) : undefined,
      navigationInstruction: isSet(object.navigationInstruction)
        ? NavigationInstruction.fromJSON(object.navigationInstruction)
        : undefined,
      travelAdvisory: isSet(object.travelAdvisory)
        ? RouteLegStepTravelAdvisory.fromJSON(object.travelAdvisory)
        : undefined,
    };
  },

  toJSON(message: RouteLegStep): unknown {
    const obj: any = {};
    if (message.distanceMeters !== 0) {
      obj.distanceMeters = Math.round(message.distanceMeters);
    }
    if (message.staticDuration !== undefined) {
      obj.staticDuration = Duration.toJSON(message.staticDuration);
    }
    if (message.polyline !== undefined) {
      obj.polyline = Polyline.toJSON(message.polyline);
    }
    if (message.startLocation !== undefined) {
      obj.startLocation = Location.toJSON(message.startLocation);
    }
    if (message.endLocation !== undefined) {
      obj.endLocation = Location.toJSON(message.endLocation);
    }
    if (message.navigationInstruction !== undefined) {
      obj.navigationInstruction = NavigationInstruction.toJSON(message.navigationInstruction);
    }
    if (message.travelAdvisory !== undefined) {
      obj.travelAdvisory = RouteLegStepTravelAdvisory.toJSON(message.travelAdvisory);
    }
    return obj;
  },

  create(base?: DeepPartial<RouteLegStep>): RouteLegStep {
    return RouteLegStep.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RouteLegStep>): RouteLegStep {
    const message = createBaseRouteLegStep();
    message.distanceMeters = object.distanceMeters ?? 0;
    message.staticDuration = (object.staticDuration !== undefined && object.staticDuration !== null)
      ? Duration.fromPartial(object.staticDuration)
      : undefined;
    message.polyline = (object.polyline !== undefined && object.polyline !== null)
      ? Polyline.fromPartial(object.polyline)
      : undefined;
    message.startLocation = (object.startLocation !== undefined && object.startLocation !== null)
      ? Location.fromPartial(object.startLocation)
      : undefined;
    message.endLocation = (object.endLocation !== undefined && object.endLocation !== null)
      ? Location.fromPartial(object.endLocation)
      : undefined;
    message.navigationInstruction =
      (object.navigationInstruction !== undefined && object.navigationInstruction !== null)
        ? NavigationInstruction.fromPartial(object.navigationInstruction)
        : undefined;
    message.travelAdvisory = (object.travelAdvisory !== undefined && object.travelAdvisory !== null)
      ? RouteLegStepTravelAdvisory.fromPartial(object.travelAdvisory)
      : undefined;
    return message;
  },
};

function createBaseNavigationInstruction(): NavigationInstruction {
  return { maneuver: 0, instructions: "" };
}

export const NavigationInstruction: MessageFns<NavigationInstruction> = {
  encode(message: NavigationInstruction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.maneuver !== 0) {
      writer.uint32(8).int32(message.maneuver);
    }
    if (message.instructions !== "") {
      writer.uint32(18).string(message.instructions);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NavigationInstruction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNavigationInstruction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.maneuver = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instructions = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NavigationInstruction {
    return {
      maneuver: isSet(object.maneuver) ? maneuverFromJSON(object.maneuver) : 0,
      instructions: isSet(object.instructions) ? globalThis.String(object.instructions) : "",
    };
  },

  toJSON(message: NavigationInstruction): unknown {
    const obj: any = {};
    if (message.maneuver !== 0) {
      obj.maneuver = maneuverToJSON(message.maneuver);
    }
    if (message.instructions !== "") {
      obj.instructions = message.instructions;
    }
    return obj;
  },

  create(base?: DeepPartial<NavigationInstruction>): NavigationInstruction {
    return NavigationInstruction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NavigationInstruction>): NavigationInstruction {
    const message = createBaseNavigationInstruction();
    message.maneuver = object.maneuver ?? 0;
    message.instructions = object.instructions ?? "";
    return message;
  },
};

function createBaseSpeedReadingInterval(): SpeedReadingInterval {
  return { startPolylinePointIndex: 0, endPolylinePointIndex: 0, speed: 0 };
}

export const SpeedReadingInterval: MessageFns<SpeedReadingInterval> = {
  encode(message: SpeedReadingInterval, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startPolylinePointIndex !== 0) {
      writer.uint32(8).int32(message.startPolylinePointIndex);
    }
    if (message.endPolylinePointIndex !== 0) {
      writer.uint32(16).int32(message.endPolylinePointIndex);
    }
    if (message.speed !== 0) {
      writer.uint32(24).int32(message.speed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpeedReadingInterval {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpeedReadingInterval();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.startPolylinePointIndex = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.endPolylinePointIndex = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.speed = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpeedReadingInterval {
    return {
      startPolylinePointIndex: isSet(object.startPolylinePointIndex)
        ? globalThis.Number(object.startPolylinePointIndex)
        : 0,
      endPolylinePointIndex: isSet(object.endPolylinePointIndex) ? globalThis.Number(object.endPolylinePointIndex) : 0,
      speed: isSet(object.speed) ? speedReadingInterval_SpeedFromJSON(object.speed) : 0,
    };
  },

  toJSON(message: SpeedReadingInterval): unknown {
    const obj: any = {};
    if (message.startPolylinePointIndex !== 0) {
      obj.startPolylinePointIndex = Math.round(message.startPolylinePointIndex);
    }
    if (message.endPolylinePointIndex !== 0) {
      obj.endPolylinePointIndex = Math.round(message.endPolylinePointIndex);
    }
    if (message.speed !== 0) {
      obj.speed = speedReadingInterval_SpeedToJSON(message.speed);
    }
    return obj;
  },

  create(base?: DeepPartial<SpeedReadingInterval>): SpeedReadingInterval {
    return SpeedReadingInterval.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SpeedReadingInterval>): SpeedReadingInterval {
    const message = createBaseSpeedReadingInterval();
    message.startPolylinePointIndex = object.startPolylinePointIndex ?? 0;
    message.endPolylinePointIndex = object.endPolylinePointIndex ?? 0;
    message.speed = object.speed ?? 0;
    return message;
  },
};

function createBaseCustomLayerInfo(): CustomLayerInfo {
  return { areaInfo: [], totalDistanceInAreasMeters: 0, totalDurationInAreas: undefined };
}

export const CustomLayerInfo: MessageFns<CustomLayerInfo> = {
  encode(message: CustomLayerInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.areaInfo) {
      CustomLayerInfo_AreaInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalDistanceInAreasMeters !== 0) {
      writer.uint32(21).float(message.totalDistanceInAreasMeters);
    }
    if (message.totalDurationInAreas !== undefined) {
      Duration.encode(message.totalDurationInAreas, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomLayerInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomLayerInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.areaInfo.push(CustomLayerInfo_AreaInfo.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.totalDistanceInAreasMeters = reader.float();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.totalDurationInAreas = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomLayerInfo {
    return {
      areaInfo: globalThis.Array.isArray(object?.areaInfo)
        ? object.areaInfo.map((e: any) => CustomLayerInfo_AreaInfo.fromJSON(e))
        : [],
      totalDistanceInAreasMeters: isSet(object.totalDistanceInAreasMeters)
        ? globalThis.Number(object.totalDistanceInAreasMeters)
        : 0,
      totalDurationInAreas: isSet(object.totalDurationInAreas)
        ? Duration.fromJSON(object.totalDurationInAreas)
        : undefined,
    };
  },

  toJSON(message: CustomLayerInfo): unknown {
    const obj: any = {};
    if (message.areaInfo?.length) {
      obj.areaInfo = message.areaInfo.map((e) => CustomLayerInfo_AreaInfo.toJSON(e));
    }
    if (message.totalDistanceInAreasMeters !== 0) {
      obj.totalDistanceInAreasMeters = message.totalDistanceInAreasMeters;
    }
    if (message.totalDurationInAreas !== undefined) {
      obj.totalDurationInAreas = Duration.toJSON(message.totalDurationInAreas);
    }
    return obj;
  },

  create(base?: DeepPartial<CustomLayerInfo>): CustomLayerInfo {
    return CustomLayerInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CustomLayerInfo>): CustomLayerInfo {
    const message = createBaseCustomLayerInfo();
    message.areaInfo = object.areaInfo?.map((e) => CustomLayerInfo_AreaInfo.fromPartial(e)) || [];
    message.totalDistanceInAreasMeters = object.totalDistanceInAreasMeters ?? 0;
    message.totalDurationInAreas = (object.totalDurationInAreas !== undefined && object.totalDurationInAreas !== null)
      ? Duration.fromPartial(object.totalDurationInAreas)
      : undefined;
    return message;
  },
};

function createBaseCustomLayerInfo_AreaInfo(): CustomLayerInfo_AreaInfo {
  return { areaId: "", distanceInAreaMeters: 0, durationInArea: undefined };
}

export const CustomLayerInfo_AreaInfo: MessageFns<CustomLayerInfo_AreaInfo> = {
  encode(message: CustomLayerInfo_AreaInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.areaId !== "") {
      writer.uint32(10).string(message.areaId);
    }
    if (message.distanceInAreaMeters !== 0) {
      writer.uint32(21).float(message.distanceInAreaMeters);
    }
    if (message.durationInArea !== undefined) {
      Duration.encode(message.durationInArea, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomLayerInfo_AreaInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomLayerInfo_AreaInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.areaId = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.distanceInAreaMeters = reader.float();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.durationInArea = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomLayerInfo_AreaInfo {
    return {
      areaId: isSet(object.areaId) ? globalThis.String(object.areaId) : "",
      distanceInAreaMeters: isSet(object.distanceInAreaMeters) ? globalThis.Number(object.distanceInAreaMeters) : 0,
      durationInArea: isSet(object.durationInArea) ? Duration.fromJSON(object.durationInArea) : undefined,
    };
  },

  toJSON(message: CustomLayerInfo_AreaInfo): unknown {
    const obj: any = {};
    if (message.areaId !== "") {
      obj.areaId = message.areaId;
    }
    if (message.distanceInAreaMeters !== 0) {
      obj.distanceInAreaMeters = message.distanceInAreaMeters;
    }
    if (message.durationInArea !== undefined) {
      obj.durationInArea = Duration.toJSON(message.durationInArea);
    }
    return obj;
  },

  create(base?: DeepPartial<CustomLayerInfo_AreaInfo>): CustomLayerInfo_AreaInfo {
    return CustomLayerInfo_AreaInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CustomLayerInfo_AreaInfo>): CustomLayerInfo_AreaInfo {
    const message = createBaseCustomLayerInfo_AreaInfo();
    message.areaId = object.areaId ?? "";
    message.distanceInAreaMeters = object.distanceInAreaMeters ?? 0;
    message.durationInArea = (object.durationInArea !== undefined && object.durationInArea !== null)
      ? Duration.fromPartial(object.durationInArea)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
