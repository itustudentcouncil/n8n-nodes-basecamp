// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/maps/places/v1/place.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Viewport } from "../../../geo/type/viewport.js";
import { DateMessage } from "../../../type/date.js";
import { LatLng } from "../../../type/latlng.js";
import { LocalizedText } from "../../../type/localized_text.js";
import { ContentBlock } from "./content_block.js";
import { EVChargeOptions } from "./ev_charging.js";
import { FuelOptions } from "./fuel_options.js";
import { Photo } from "./photo.js";
import { References } from "./reference.js";
import { Review } from "./review.js";

export const protobufPackage = "google.maps.places.v1";

/** Price level of the place. */
export enum PriceLevel {
  /** PRICE_LEVEL_UNSPECIFIED - Place price level is unspecified or unknown. */
  PRICE_LEVEL_UNSPECIFIED = 0,
  /** PRICE_LEVEL_FREE - Place provides free services. */
  PRICE_LEVEL_FREE = 1,
  /** PRICE_LEVEL_INEXPENSIVE - Place provides inexpensive services. */
  PRICE_LEVEL_INEXPENSIVE = 2,
  /** PRICE_LEVEL_MODERATE - Place provides moderately priced services. */
  PRICE_LEVEL_MODERATE = 3,
  /** PRICE_LEVEL_EXPENSIVE - Place provides expensive services. */
  PRICE_LEVEL_EXPENSIVE = 4,
  /** PRICE_LEVEL_VERY_EXPENSIVE - Place provides very expensive services. */
  PRICE_LEVEL_VERY_EXPENSIVE = 5,
  UNRECOGNIZED = -1,
}

export function priceLevelFromJSON(object: any): PriceLevel {
  switch (object) {
    case 0:
    case "PRICE_LEVEL_UNSPECIFIED":
      return PriceLevel.PRICE_LEVEL_UNSPECIFIED;
    case 1:
    case "PRICE_LEVEL_FREE":
      return PriceLevel.PRICE_LEVEL_FREE;
    case 2:
    case "PRICE_LEVEL_INEXPENSIVE":
      return PriceLevel.PRICE_LEVEL_INEXPENSIVE;
    case 3:
    case "PRICE_LEVEL_MODERATE":
      return PriceLevel.PRICE_LEVEL_MODERATE;
    case 4:
    case "PRICE_LEVEL_EXPENSIVE":
      return PriceLevel.PRICE_LEVEL_EXPENSIVE;
    case 5:
    case "PRICE_LEVEL_VERY_EXPENSIVE":
      return PriceLevel.PRICE_LEVEL_VERY_EXPENSIVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PriceLevel.UNRECOGNIZED;
  }
}

export function priceLevelToJSON(object: PriceLevel): string {
  switch (object) {
    case PriceLevel.PRICE_LEVEL_UNSPECIFIED:
      return "PRICE_LEVEL_UNSPECIFIED";
    case PriceLevel.PRICE_LEVEL_FREE:
      return "PRICE_LEVEL_FREE";
    case PriceLevel.PRICE_LEVEL_INEXPENSIVE:
      return "PRICE_LEVEL_INEXPENSIVE";
    case PriceLevel.PRICE_LEVEL_MODERATE:
      return "PRICE_LEVEL_MODERATE";
    case PriceLevel.PRICE_LEVEL_EXPENSIVE:
      return "PRICE_LEVEL_EXPENSIVE";
    case PriceLevel.PRICE_LEVEL_VERY_EXPENSIVE:
      return "PRICE_LEVEL_VERY_EXPENSIVE";
    case PriceLevel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** All the information representing a Place. */
export interface Place {
  /**
   * This Place's resource name, in `places/{place_id}` format.  Can be used to
   * look up the Place.
   */
  name: string;
  /** The unique identifier of a place. */
  id: string;
  /**
   * The localized name of the place, suitable as a short human-readable
   * description. For example, "Google Sydney", "Starbucks", "Pyrmont", etc.
   */
  displayName:
    | LocalizedText
    | undefined;
  /**
   * A set of type tags for this result. For example, "political" and
   * "locality". For the complete list of possible values, see Table A and Table
   * B at
   * https://developers.google.com/maps/documentation/places/web-service/place-types
   */
  types: string[];
  /**
   * The primary type of the given result. This type must one of the Places API
   * supported types. For example, "restaurant", "cafe", "airport", etc.  A
   * place can only have a single primary type.  For the complete list of
   * possible values, see Table A and Table B at
   * https://developers.google.com/maps/documentation/places/web-service/place-types
   */
  primaryType: string;
  /**
   * The display name of the primary type, localized to the request language if
   * applicable. For the complete list of possible values, see Table A and Table
   * B at
   * https://developers.google.com/maps/documentation/places/web-service/place-types
   */
  primaryTypeDisplayName:
    | LocalizedText
    | undefined;
  /** A human-readable phone number for the place, in national format. */
  nationalPhoneNumber: string;
  /** A human-readable phone number for the place, in international format. */
  internationalPhoneNumber: string;
  /** A full, human-readable address for this place. */
  formattedAddress: string;
  /** A short, human-readable address for this place. */
  shortFormattedAddress: string;
  /**
   * Repeated components for each locality level.
   * Note the following facts about the address_components[] array:
   * - The array of address components may contain more components than the
   * formatted_address.
   * - The array does not necessarily include all the political entities that
   * contain an address, apart from those included in the formatted_address. To
   * retrieve all the political entities that contain a specific address, you
   * should use reverse geocoding, passing the latitude/longitude of the address
   * as a parameter to the request.
   * - The format of the response is not guaranteed to remain the same between
   * requests. In particular, the number of address_components varies based on
   * the address requested and can change over time for the same address. A
   * component can change position in the array. The type of the component can
   * change. A particular component may be missing in a later response.
   */
  addressComponents: Place_AddressComponent[];
  /** Plus code of the place location lat/long. */
  plusCode:
    | Place_PlusCode
    | undefined;
  /** The position of this place. */
  location:
    | LatLng
    | undefined;
  /** A viewport suitable for displaying the place on an average-sized map. */
  viewport:
    | Viewport
    | undefined;
  /** A rating between 1.0 and 5.0, based on user reviews of this place. */
  rating: number;
  /** A URL providing more information about this place. */
  googleMapsUri: string;
  /**
   * The authoritative website for this place, e.g. a business' homepage.
   * Note that for places that are part of a chain (e.g. an IKEA store), this
   * will usually be the website for the individual store, not the overall
   * chain.
   */
  websiteUri: string;
  /**
   * List of reviews about this place, sorted by relevance. A maximum of 5
   * reviews can be returned.
   */
  reviews: Review[];
  /** The regular hours of operation. */
  regularOpeningHours:
    | Place_OpeningHours
    | undefined;
  /**
   * Number of minutes this place's timezone is currently offset from UTC.
   * This is expressed in minutes to support timezones that are offset by
   * fractions of an hour, e.g. X hours and 15 minutes.
   */
  utcOffsetMinutes?:
    | number
    | undefined;
  /**
   * Information (including references) about photos of this place. A maximum of
   * 10 photos can be returned.
   */
  photos: Photo[];
  /** The place's address in adr microformat: http://microformats.org/wiki/adr. */
  adrFormatAddress: string;
  /** The business status for the place. */
  businessStatus: Place_BusinessStatus;
  /** Price level of the place. */
  priceLevel: PriceLevel;
  /** A set of data provider that must be shown with this result. */
  attributions: Place_Attribution[];
  /** The total number of reviews (with or without text) for this place. */
  userRatingCount?:
    | number
    | undefined;
  /**
   * A truncated URL to an icon mask. User can access different icon type by
   * appending type suffix to the end (eg, ".svg" or ".png").
   */
  iconMaskBaseUri: string;
  /** Background color for icon_mask in hex format, e.g. #909CE1. */
  iconBackgroundColor: string;
  /** Specifies if the business supports takeout. */
  takeout?:
    | boolean
    | undefined;
  /** Specifies if the business supports delivery. */
  delivery?:
    | boolean
    | undefined;
  /** Specifies if the business supports indoor or outdoor seating options. */
  dineIn?:
    | boolean
    | undefined;
  /** Specifies if the business supports curbside pickup. */
  curbsidePickup?:
    | boolean
    | undefined;
  /** Specifies if the place supports reservations. */
  reservable?:
    | boolean
    | undefined;
  /** Specifies if the place serves breakfast. */
  servesBreakfast?:
    | boolean
    | undefined;
  /** Specifies if the place serves lunch. */
  servesLunch?:
    | boolean
    | undefined;
  /** Specifies if the place serves dinner. */
  servesDinner?:
    | boolean
    | undefined;
  /** Specifies if the place serves beer. */
  servesBeer?:
    | boolean
    | undefined;
  /** Specifies if the place serves wine. */
  servesWine?:
    | boolean
    | undefined;
  /** Specifies if the place serves brunch. */
  servesBrunch?:
    | boolean
    | undefined;
  /** Specifies if the place serves vegetarian food. */
  servesVegetarianFood?:
    | boolean
    | undefined;
  /**
   * The hours of operation for the next seven days (including today). The time
   * period starts at midnight on the date of the request and ends at 11:59 pm
   * six days later. This field includes the special_days subfield of all hours,
   * set for dates that have exceptional hours.
   */
  currentOpeningHours:
    | Place_OpeningHours
    | undefined;
  /**
   * Contains an array of entries for the next seven days including information
   * about secondary hours of a business. Secondary hours are different from a
   * business's main hours. For example, a restaurant can specify drive through
   * hours or delivery hours as its secondary hours. This field populates the
   * type subfield, which draws from a predefined list of opening hours types
   * (such as DRIVE_THROUGH, PICKUP, or TAKEOUT) based on the types of the
   * place. This field includes the special_days subfield of all hours, set for
   * dates that have exceptional hours.
   */
  currentSecondaryOpeningHours: Place_OpeningHours[];
  /**
   * Contains an array of entries for information about regular secondary hours
   * of a business. Secondary hours are different from a business's main hours.
   * For example, a restaurant can specify drive through hours or delivery hours
   * as its secondary hours. This field populates the type subfield, which draws
   * from a predefined list of opening hours types (such as DRIVE_THROUGH,
   * PICKUP, or TAKEOUT) based on the types of the place.
   */
  regularSecondaryOpeningHours: Place_OpeningHours[];
  /**
   * Contains a summary of the place. A summary is comprised of a textual
   * overview, and also includes the language code for these if applicable.
   * Summary text must be presented as-is and can not be modified or altered.
   */
  editorialSummary:
    | LocalizedText
    | undefined;
  /** Place provides outdoor seating. */
  outdoorSeating?:
    | boolean
    | undefined;
  /** Place provides live music. */
  liveMusic?:
    | boolean
    | undefined;
  /** Place has a children's menu. */
  menuForChildren?:
    | boolean
    | undefined;
  /** Place serves cocktails. */
  servesCocktails?:
    | boolean
    | undefined;
  /** Place serves dessert. */
  servesDessert?:
    | boolean
    | undefined;
  /** Place serves coffee. */
  servesCoffee?:
    | boolean
    | undefined;
  /** Place is good for children. */
  goodForChildren?:
    | boolean
    | undefined;
  /** Place allows dogs. */
  allowsDogs?:
    | boolean
    | undefined;
  /** Place has restroom. */
  restroom?:
    | boolean
    | undefined;
  /** Place accommodates groups. */
  goodForGroups?:
    | boolean
    | undefined;
  /** Place is suitable for watching sports. */
  goodForWatchingSports?:
    | boolean
    | undefined;
  /**
   * Payment options the place accepts. If a payment option data is not
   * available, the payment option field will be unset.
   */
  paymentOptions:
    | Place_PaymentOptions
    | undefined;
  /** Options of parking provided by the place. */
  parkingOptions:
    | Place_ParkingOptions
    | undefined;
  /** A list of sub destinations related to the place. */
  subDestinations: Place_SubDestination[];
  /** Information about the accessibility options a place offers. */
  accessibilityOptions?:
    | Place_AccessibilityOptions
    | undefined;
  /**
   * The most recent information about fuel options in a gas station. This
   * information is updated regularly.
   */
  fuelOptions:
    | FuelOptions
    | undefined;
  /** Information of ev charging options. */
  evChargeOptions:
    | EVChargeOptions
    | undefined;
  /**
   * Experimental: See
   * https://developers.google.com/maps/documentation/places/web-service/experimental/places-generative
   * for more details.
   *
   * AI-generated summary of the place.
   */
  generativeSummary:
    | Place_GenerativeSummary
    | undefined;
  /**
   * Experimental: See
   * https://developers.google.com/maps/documentation/places/web-service/experimental/places-generative
   * for more details.
   *
   * AI-generated summary of the area that the place is in.
   */
  areaSummary: Place_AreaSummary | undefined;
}

/** Business status for the place. */
export enum Place_BusinessStatus {
  /** BUSINESS_STATUS_UNSPECIFIED - Default value. This value is unused. */
  BUSINESS_STATUS_UNSPECIFIED = 0,
  /** OPERATIONAL - The establishment is operational, not necessarily open now. */
  OPERATIONAL = 1,
  /** CLOSED_TEMPORARILY - The establishment is temporarily closed. */
  CLOSED_TEMPORARILY = 2,
  /** CLOSED_PERMANENTLY - The establishment is permanently closed. */
  CLOSED_PERMANENTLY = 3,
  UNRECOGNIZED = -1,
}

export function place_BusinessStatusFromJSON(object: any): Place_BusinessStatus {
  switch (object) {
    case 0:
    case "BUSINESS_STATUS_UNSPECIFIED":
      return Place_BusinessStatus.BUSINESS_STATUS_UNSPECIFIED;
    case 1:
    case "OPERATIONAL":
      return Place_BusinessStatus.OPERATIONAL;
    case 2:
    case "CLOSED_TEMPORARILY":
      return Place_BusinessStatus.CLOSED_TEMPORARILY;
    case 3:
    case "CLOSED_PERMANENTLY":
      return Place_BusinessStatus.CLOSED_PERMANENTLY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Place_BusinessStatus.UNRECOGNIZED;
  }
}

export function place_BusinessStatusToJSON(object: Place_BusinessStatus): string {
  switch (object) {
    case Place_BusinessStatus.BUSINESS_STATUS_UNSPECIFIED:
      return "BUSINESS_STATUS_UNSPECIFIED";
    case Place_BusinessStatus.OPERATIONAL:
      return "OPERATIONAL";
    case Place_BusinessStatus.CLOSED_TEMPORARILY:
      return "CLOSED_TEMPORARILY";
    case Place_BusinessStatus.CLOSED_PERMANENTLY:
      return "CLOSED_PERMANENTLY";
    case Place_BusinessStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The structured components that form the formatted address, if this
 * information is available.
 */
export interface Place_AddressComponent {
  /**
   * The full text description or name of the address component. For example,
   * an address component for the country Australia may have a long_name of
   * "Australia".
   */
  longText: string;
  /**
   * An abbreviated textual name for the address component, if available. For
   * example, an address component for the country of Australia may have a
   * short_name of "AU".
   */
  shortText: string;
  /** An array indicating the type(s) of the address component. */
  types: string[];
  /** The language used to format this components, in CLDR notation. */
  languageCode: string;
}

/**
 * Plus code (http://plus.codes) is a location reference with two formats:
 * global code defining a 14mx14m (1/8000th of a degree) or smaller rectangle,
 * and compound code, replacing the prefix with a reference location.
 */
export interface Place_PlusCode {
  /**
   * Place's global (full) code, such as "9FWM33GV+HQ", representing an
   * 1/8000 by 1/8000 degree area (~14 by 14 meters).
   */
  globalCode: string;
  /**
   * Place's compound code, such as "33GV+HQ, Ramberg, Norway", containing
   * the suffix of the global code and replacing the prefix with a formatted
   * name of a reference entity.
   */
  compoundCode: string;
}

/** Information about business hour of the place. */
export interface Place_OpeningHours {
  /**
   * Whether the opening hours period is currently active. For regular opening
   * hours and current opening hours, this field means whether the place is
   * open. For secondary opening hours and current secondary opening hours,
   * this field means whether the secondary hours of this place is active.
   */
  openNow?:
    | boolean
    | undefined;
  /**
   * The periods that this place is open during the week. The periods are in
   * chronological order, starting with Sunday in the place-local timezone. An
   * empty (but not absent) value indicates a place that is never open, e.g.
   * because it is closed temporarily for renovations.
   */
  periods: Place_OpeningHours_Period[];
  /**
   * Localized strings describing the opening hours of this place, one string
   * for each day of the week.  Will be empty if the hours are unknown or
   * could not be converted to localized text. Example: "Sun: 18:00â€“06:00"
   */
  weekdayDescriptions: string[];
  /** A type string used to identify the type of secondary hours. */
  secondaryHoursType: Place_OpeningHours_SecondaryHoursType;
  /**
   * Structured information for special days that fall within the period that
   * the returned opening hours cover. Special days are days that could impact
   * the business hours of a place, e.g. Christmas day. Set for
   * current_opening_hours and current_secondary_opening_hours if there are
   * exceptional hours.
   */
  specialDays: Place_OpeningHours_SpecialDay[];
}

/** A type used to identify the type of secondary hours. */
export enum Place_OpeningHours_SecondaryHoursType {
  /** SECONDARY_HOURS_TYPE_UNSPECIFIED - Default value when secondary hour type is not specified. */
  SECONDARY_HOURS_TYPE_UNSPECIFIED = 0,
  /** DRIVE_THROUGH - The drive-through hour for banks, restaurants, or pharmacies. */
  DRIVE_THROUGH = 1,
  /** HAPPY_HOUR - The happy hour. */
  HAPPY_HOUR = 2,
  /** DELIVERY - The delivery hour. */
  DELIVERY = 3,
  /** TAKEOUT - The takeout hour. */
  TAKEOUT = 4,
  /** KITCHEN - The kitchen hour. */
  KITCHEN = 5,
  /** BREAKFAST - The breakfast hour. */
  BREAKFAST = 6,
  /** LUNCH - The lunch hour. */
  LUNCH = 7,
  /** DINNER - The dinner hour. */
  DINNER = 8,
  /** BRUNCH - The brunch hour. */
  BRUNCH = 9,
  /** PICKUP - The pickup hour. */
  PICKUP = 10,
  /** ACCESS - The access hours for storage places. */
  ACCESS = 11,
  /** SENIOR_HOURS - The special hours for seniors. */
  SENIOR_HOURS = 12,
  /** ONLINE_SERVICE_HOURS - The online service hours. */
  ONLINE_SERVICE_HOURS = 13,
  UNRECOGNIZED = -1,
}

export function place_OpeningHours_SecondaryHoursTypeFromJSON(object: any): Place_OpeningHours_SecondaryHoursType {
  switch (object) {
    case 0:
    case "SECONDARY_HOURS_TYPE_UNSPECIFIED":
      return Place_OpeningHours_SecondaryHoursType.SECONDARY_HOURS_TYPE_UNSPECIFIED;
    case 1:
    case "DRIVE_THROUGH":
      return Place_OpeningHours_SecondaryHoursType.DRIVE_THROUGH;
    case 2:
    case "HAPPY_HOUR":
      return Place_OpeningHours_SecondaryHoursType.HAPPY_HOUR;
    case 3:
    case "DELIVERY":
      return Place_OpeningHours_SecondaryHoursType.DELIVERY;
    case 4:
    case "TAKEOUT":
      return Place_OpeningHours_SecondaryHoursType.TAKEOUT;
    case 5:
    case "KITCHEN":
      return Place_OpeningHours_SecondaryHoursType.KITCHEN;
    case 6:
    case "BREAKFAST":
      return Place_OpeningHours_SecondaryHoursType.BREAKFAST;
    case 7:
    case "LUNCH":
      return Place_OpeningHours_SecondaryHoursType.LUNCH;
    case 8:
    case "DINNER":
      return Place_OpeningHours_SecondaryHoursType.DINNER;
    case 9:
    case "BRUNCH":
      return Place_OpeningHours_SecondaryHoursType.BRUNCH;
    case 10:
    case "PICKUP":
      return Place_OpeningHours_SecondaryHoursType.PICKUP;
    case 11:
    case "ACCESS":
      return Place_OpeningHours_SecondaryHoursType.ACCESS;
    case 12:
    case "SENIOR_HOURS":
      return Place_OpeningHours_SecondaryHoursType.SENIOR_HOURS;
    case 13:
    case "ONLINE_SERVICE_HOURS":
      return Place_OpeningHours_SecondaryHoursType.ONLINE_SERVICE_HOURS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Place_OpeningHours_SecondaryHoursType.UNRECOGNIZED;
  }
}

export function place_OpeningHours_SecondaryHoursTypeToJSON(object: Place_OpeningHours_SecondaryHoursType): string {
  switch (object) {
    case Place_OpeningHours_SecondaryHoursType.SECONDARY_HOURS_TYPE_UNSPECIFIED:
      return "SECONDARY_HOURS_TYPE_UNSPECIFIED";
    case Place_OpeningHours_SecondaryHoursType.DRIVE_THROUGH:
      return "DRIVE_THROUGH";
    case Place_OpeningHours_SecondaryHoursType.HAPPY_HOUR:
      return "HAPPY_HOUR";
    case Place_OpeningHours_SecondaryHoursType.DELIVERY:
      return "DELIVERY";
    case Place_OpeningHours_SecondaryHoursType.TAKEOUT:
      return "TAKEOUT";
    case Place_OpeningHours_SecondaryHoursType.KITCHEN:
      return "KITCHEN";
    case Place_OpeningHours_SecondaryHoursType.BREAKFAST:
      return "BREAKFAST";
    case Place_OpeningHours_SecondaryHoursType.LUNCH:
      return "LUNCH";
    case Place_OpeningHours_SecondaryHoursType.DINNER:
      return "DINNER";
    case Place_OpeningHours_SecondaryHoursType.BRUNCH:
      return "BRUNCH";
    case Place_OpeningHours_SecondaryHoursType.PICKUP:
      return "PICKUP";
    case Place_OpeningHours_SecondaryHoursType.ACCESS:
      return "ACCESS";
    case Place_OpeningHours_SecondaryHoursType.SENIOR_HOURS:
      return "SENIOR_HOURS";
    case Place_OpeningHours_SecondaryHoursType.ONLINE_SERVICE_HOURS:
      return "ONLINE_SERVICE_HOURS";
    case Place_OpeningHours_SecondaryHoursType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A period the place remains in open_now status. */
export interface Place_OpeningHours_Period {
  /** The time that the place starts to be open. */
  open:
    | Place_OpeningHours_Period_Point
    | undefined;
  /** The time that the place starts to be closed. */
  close: Place_OpeningHours_Period_Point | undefined;
}

/** Status changing points. */
export interface Place_OpeningHours_Period_Point {
  /**
   * A day of the week, as an integer in the range 0-6.  0 is Sunday, 1 is
   * Monday, etc.
   */
  day?:
    | number
    | undefined;
  /** The hour in 2 digits. Ranges from 00 to 23. */
  hour?:
    | number
    | undefined;
  /** The minute in 2 digits. Ranges from 00 to 59. */
  minute?:
    | number
    | undefined;
  /** Date in the local timezone for the place. */
  date:
    | DateMessage
    | undefined;
  /**
   * Whether or not this endpoint was truncated. Truncation occurs when
   * the real hours are outside the times we are willing to return hours
   * between, so we truncate the hours back to these boundaries. This
   * ensures that at most 24 * 7 hours from midnight of the day of the
   * request are returned.
   */
  truncated: boolean;
}

/**
 * Structured information for special days that fall within the period that
 * the returned opening hours cover. Special days are days that could impact
 * the business hours of a place, e.g. Christmas day.
 */
export interface Place_OpeningHours_SpecialDay {
  /** The date of this special day. */
  date: DateMessage | undefined;
}

/** Information about data providers of this place. */
export interface Place_Attribution {
  /** Name of the Place's data provider. */
  provider: string;
  /** URI to the Place's data provider. */
  providerUri: string;
}

/** Payment options the place accepts. */
export interface Place_PaymentOptions {
  /** Place accepts credit cards as payment. */
  acceptsCreditCards?:
    | boolean
    | undefined;
  /** Place accepts debit cards as payment. */
  acceptsDebitCards?:
    | boolean
    | undefined;
  /**
   * Place accepts cash only as payment. Places with this attribute may still
   * accept other payment methods.
   */
  acceptsCashOnly?:
    | boolean
    | undefined;
  /** Place accepts NFC payments. */
  acceptsNfc?: boolean | undefined;
}

/**
 * Information about parking options for the place. A parking lot could
 * support more than one option at the same time.
 */
export interface Place_ParkingOptions {
  /** Place offers free parking lots. */
  freeParkingLot?:
    | boolean
    | undefined;
  /** Place offers paid parking lots. */
  paidParkingLot?:
    | boolean
    | undefined;
  /** Place offers free street parking. */
  freeStreetParking?:
    | boolean
    | undefined;
  /** Place offers paid street parking. */
  paidStreetParking?:
    | boolean
    | undefined;
  /** Place offers valet parking. */
  valetParking?:
    | boolean
    | undefined;
  /** Place offers free garage parking. */
  freeGarageParking?:
    | boolean
    | undefined;
  /** Place offers paid garage parking. */
  paidGarageParking?: boolean | undefined;
}

/**
 * Place resource name and id of sub destinations that relate to the place.
 * For example, different terminals are different destinations of an airport.
 */
export interface Place_SubDestination {
  /** The resource name of the sub destination. */
  name: string;
  /** The place id of the sub destination. */
  id: string;
}

/** Information about the accessibility options a place offers. */
export interface Place_AccessibilityOptions {
  /** Place offers wheelchair accessible parking. */
  wheelchairAccessibleParking?:
    | boolean
    | undefined;
  /** Places has wheelchair accessible entrance. */
  wheelchairAccessibleEntrance?:
    | boolean
    | undefined;
  /** Place has wheelchair accessible restroom. */
  wheelchairAccessibleRestroom?:
    | boolean
    | undefined;
  /** Place has wheelchair accessible seating. */
  wheelchairAccessibleSeating?: boolean | undefined;
}

/**
 * Experimental: See
 * https://developers.google.com/maps/documentation/places/web-service/experimental/places-generative
 * for more details.
 *
 * AI-generated summary of the place.
 */
export interface Place_GenerativeSummary {
  /** The overview of the place. */
  overview:
    | LocalizedText
    | undefined;
  /** The detailed description of the place. */
  description:
    | LocalizedText
    | undefined;
  /** References that are used to generate the summary description. */
  references: References | undefined;
}

/**
 * Experimental: See
 * https://developers.google.com/maps/documentation/places/web-service/experimental/places-generative
 * for more details.
 *
 * AI-generated summary of the area that the place is in.
 */
export interface Place_AreaSummary {
  /**
   * Content blocks that compose the area summary. Each block has a separate
   * topic about the area.
   */
  contentBlocks: ContentBlock[];
}

function createBasePlace(): Place {
  return {
    name: "",
    id: "",
    displayName: undefined,
    types: [],
    primaryType: "",
    primaryTypeDisplayName: undefined,
    nationalPhoneNumber: "",
    internationalPhoneNumber: "",
    formattedAddress: "",
    shortFormattedAddress: "",
    addressComponents: [],
    plusCode: undefined,
    location: undefined,
    viewport: undefined,
    rating: 0,
    googleMapsUri: "",
    websiteUri: "",
    reviews: [],
    regularOpeningHours: undefined,
    utcOffsetMinutes: undefined,
    photos: [],
    adrFormatAddress: "",
    businessStatus: 0,
    priceLevel: 0,
    attributions: [],
    userRatingCount: undefined,
    iconMaskBaseUri: "",
    iconBackgroundColor: "",
    takeout: undefined,
    delivery: undefined,
    dineIn: undefined,
    curbsidePickup: undefined,
    reservable: undefined,
    servesBreakfast: undefined,
    servesLunch: undefined,
    servesDinner: undefined,
    servesBeer: undefined,
    servesWine: undefined,
    servesBrunch: undefined,
    servesVegetarianFood: undefined,
    currentOpeningHours: undefined,
    currentSecondaryOpeningHours: [],
    regularSecondaryOpeningHours: [],
    editorialSummary: undefined,
    outdoorSeating: undefined,
    liveMusic: undefined,
    menuForChildren: undefined,
    servesCocktails: undefined,
    servesDessert: undefined,
    servesCoffee: undefined,
    goodForChildren: undefined,
    allowsDogs: undefined,
    restroom: undefined,
    goodForGroups: undefined,
    goodForWatchingSports: undefined,
    paymentOptions: undefined,
    parkingOptions: undefined,
    subDestinations: [],
    accessibilityOptions: undefined,
    fuelOptions: undefined,
    evChargeOptions: undefined,
    generativeSummary: undefined,
    areaSummary: undefined,
  };
}

export const Place: MessageFns<Place> = {
  encode(message: Place, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.displayName !== undefined) {
      LocalizedText.encode(message.displayName, writer.uint32(250).fork()).join();
    }
    for (const v of message.types) {
      writer.uint32(42).string(v!);
    }
    if (message.primaryType !== "") {
      writer.uint32(402).string(message.primaryType);
    }
    if (message.primaryTypeDisplayName !== undefined) {
      LocalizedText.encode(message.primaryTypeDisplayName, writer.uint32(258).fork()).join();
    }
    if (message.nationalPhoneNumber !== "") {
      writer.uint32(58).string(message.nationalPhoneNumber);
    }
    if (message.internationalPhoneNumber !== "") {
      writer.uint32(66).string(message.internationalPhoneNumber);
    }
    if (message.formattedAddress !== "") {
      writer.uint32(74).string(message.formattedAddress);
    }
    if (message.shortFormattedAddress !== "") {
      writer.uint32(410).string(message.shortFormattedAddress);
    }
    for (const v of message.addressComponents) {
      Place_AddressComponent.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.plusCode !== undefined) {
      Place_PlusCode.encode(message.plusCode, writer.uint32(90).fork()).join();
    }
    if (message.location !== undefined) {
      LatLng.encode(message.location, writer.uint32(98).fork()).join();
    }
    if (message.viewport !== undefined) {
      Viewport.encode(message.viewport, writer.uint32(106).fork()).join();
    }
    if (message.rating !== 0) {
      writer.uint32(113).double(message.rating);
    }
    if (message.googleMapsUri !== "") {
      writer.uint32(122).string(message.googleMapsUri);
    }
    if (message.websiteUri !== "") {
      writer.uint32(130).string(message.websiteUri);
    }
    for (const v of message.reviews) {
      Review.encode(v!, writer.uint32(426).fork()).join();
    }
    if (message.regularOpeningHours !== undefined) {
      Place_OpeningHours.encode(message.regularOpeningHours, writer.uint32(170).fork()).join();
    }
    if (message.utcOffsetMinutes !== undefined) {
      writer.uint32(176).int32(message.utcOffsetMinutes);
    }
    for (const v of message.photos) {
      Photo.encode(v!, writer.uint32(434).fork()).join();
    }
    if (message.adrFormatAddress !== "") {
      writer.uint32(194).string(message.adrFormatAddress);
    }
    if (message.businessStatus !== 0) {
      writer.uint32(200).int32(message.businessStatus);
    }
    if (message.priceLevel !== 0) {
      writer.uint32(208).int32(message.priceLevel);
    }
    for (const v of message.attributions) {
      Place_Attribution.encode(v!, writer.uint32(218).fork()).join();
    }
    if (message.userRatingCount !== undefined) {
      writer.uint32(224).int32(message.userRatingCount);
    }
    if (message.iconMaskBaseUri !== "") {
      writer.uint32(234).string(message.iconMaskBaseUri);
    }
    if (message.iconBackgroundColor !== "") {
      writer.uint32(242).string(message.iconBackgroundColor);
    }
    if (message.takeout !== undefined) {
      writer.uint32(264).bool(message.takeout);
    }
    if (message.delivery !== undefined) {
      writer.uint32(272).bool(message.delivery);
    }
    if (message.dineIn !== undefined) {
      writer.uint32(280).bool(message.dineIn);
    }
    if (message.curbsidePickup !== undefined) {
      writer.uint32(288).bool(message.curbsidePickup);
    }
    if (message.reservable !== undefined) {
      writer.uint32(304).bool(message.reservable);
    }
    if (message.servesBreakfast !== undefined) {
      writer.uint32(312).bool(message.servesBreakfast);
    }
    if (message.servesLunch !== undefined) {
      writer.uint32(320).bool(message.servesLunch);
    }
    if (message.servesDinner !== undefined) {
      writer.uint32(328).bool(message.servesDinner);
    }
    if (message.servesBeer !== undefined) {
      writer.uint32(336).bool(message.servesBeer);
    }
    if (message.servesWine !== undefined) {
      writer.uint32(344).bool(message.servesWine);
    }
    if (message.servesBrunch !== undefined) {
      writer.uint32(352).bool(message.servesBrunch);
    }
    if (message.servesVegetarianFood !== undefined) {
      writer.uint32(360).bool(message.servesVegetarianFood);
    }
    if (message.currentOpeningHours !== undefined) {
      Place_OpeningHours.encode(message.currentOpeningHours, writer.uint32(370).fork()).join();
    }
    for (const v of message.currentSecondaryOpeningHours) {
      Place_OpeningHours.encode(v!, writer.uint32(378).fork()).join();
    }
    for (const v of message.regularSecondaryOpeningHours) {
      Place_OpeningHours.encode(v!, writer.uint32(394).fork()).join();
    }
    if (message.editorialSummary !== undefined) {
      LocalizedText.encode(message.editorialSummary, writer.uint32(418).fork()).join();
    }
    if (message.outdoorSeating !== undefined) {
      writer.uint32(440).bool(message.outdoorSeating);
    }
    if (message.liveMusic !== undefined) {
      writer.uint32(448).bool(message.liveMusic);
    }
    if (message.menuForChildren !== undefined) {
      writer.uint32(456).bool(message.menuForChildren);
    }
    if (message.servesCocktails !== undefined) {
      writer.uint32(464).bool(message.servesCocktails);
    }
    if (message.servesDessert !== undefined) {
      writer.uint32(472).bool(message.servesDessert);
    }
    if (message.servesCoffee !== undefined) {
      writer.uint32(480).bool(message.servesCoffee);
    }
    if (message.goodForChildren !== undefined) {
      writer.uint32(496).bool(message.goodForChildren);
    }
    if (message.allowsDogs !== undefined) {
      writer.uint32(504).bool(message.allowsDogs);
    }
    if (message.restroom !== undefined) {
      writer.uint32(512).bool(message.restroom);
    }
    if (message.goodForGroups !== undefined) {
      writer.uint32(520).bool(message.goodForGroups);
    }
    if (message.goodForWatchingSports !== undefined) {
      writer.uint32(528).bool(message.goodForWatchingSports);
    }
    if (message.paymentOptions !== undefined) {
      Place_PaymentOptions.encode(message.paymentOptions, writer.uint32(538).fork()).join();
    }
    if (message.parkingOptions !== undefined) {
      Place_ParkingOptions.encode(message.parkingOptions, writer.uint32(562).fork()).join();
    }
    for (const v of message.subDestinations) {
      Place_SubDestination.encode(v!, writer.uint32(570).fork()).join();
    }
    if (message.accessibilityOptions !== undefined) {
      Place_AccessibilityOptions.encode(message.accessibilityOptions, writer.uint32(578).fork()).join();
    }
    if (message.fuelOptions !== undefined) {
      FuelOptions.encode(message.fuelOptions, writer.uint32(626).fork()).join();
    }
    if (message.evChargeOptions !== undefined) {
      EVChargeOptions.encode(message.evChargeOptions, writer.uint32(634).fork()).join();
    }
    if (message.generativeSummary !== undefined) {
      Place_GenerativeSummary.encode(message.generativeSummary, writer.uint32(642).fork()).join();
    }
    if (message.areaSummary !== undefined) {
      Place_AreaSummary.encode(message.areaSummary, writer.uint32(650).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Place {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlace();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        case 31:
          if (tag !== 250) {
            break;
          }

          message.displayName = LocalizedText.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.types.push(reader.string());
          continue;
        case 50:
          if (tag !== 402) {
            break;
          }

          message.primaryType = reader.string();
          continue;
        case 32:
          if (tag !== 258) {
            break;
          }

          message.primaryTypeDisplayName = LocalizedText.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.nationalPhoneNumber = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.internationalPhoneNumber = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.formattedAddress = reader.string();
          continue;
        case 51:
          if (tag !== 410) {
            break;
          }

          message.shortFormattedAddress = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.addressComponents.push(Place_AddressComponent.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.plusCode = Place_PlusCode.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.location = LatLng.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.viewport = Viewport.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 113) {
            break;
          }

          message.rating = reader.double();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.googleMapsUri = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.websiteUri = reader.string();
          continue;
        case 53:
          if (tag !== 426) {
            break;
          }

          message.reviews.push(Review.decode(reader, reader.uint32()));
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.regularOpeningHours = Place_OpeningHours.decode(reader, reader.uint32());
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.utcOffsetMinutes = reader.int32();
          continue;
        case 54:
          if (tag !== 434) {
            break;
          }

          message.photos.push(Photo.decode(reader, reader.uint32()));
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.adrFormatAddress = reader.string();
          continue;
        case 25:
          if (tag !== 200) {
            break;
          }

          message.businessStatus = reader.int32() as any;
          continue;
        case 26:
          if (tag !== 208) {
            break;
          }

          message.priceLevel = reader.int32() as any;
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }

          message.attributions.push(Place_Attribution.decode(reader, reader.uint32()));
          continue;
        case 28:
          if (tag !== 224) {
            break;
          }

          message.userRatingCount = reader.int32();
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }

          message.iconMaskBaseUri = reader.string();
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }

          message.iconBackgroundColor = reader.string();
          continue;
        case 33:
          if (tag !== 264) {
            break;
          }

          message.takeout = reader.bool();
          continue;
        case 34:
          if (tag !== 272) {
            break;
          }

          message.delivery = reader.bool();
          continue;
        case 35:
          if (tag !== 280) {
            break;
          }

          message.dineIn = reader.bool();
          continue;
        case 36:
          if (tag !== 288) {
            break;
          }

          message.curbsidePickup = reader.bool();
          continue;
        case 38:
          if (tag !== 304) {
            break;
          }

          message.reservable = reader.bool();
          continue;
        case 39:
          if (tag !== 312) {
            break;
          }

          message.servesBreakfast = reader.bool();
          continue;
        case 40:
          if (tag !== 320) {
            break;
          }

          message.servesLunch = reader.bool();
          continue;
        case 41:
          if (tag !== 328) {
            break;
          }

          message.servesDinner = reader.bool();
          continue;
        case 42:
          if (tag !== 336) {
            break;
          }

          message.servesBeer = reader.bool();
          continue;
        case 43:
          if (tag !== 344) {
            break;
          }

          message.servesWine = reader.bool();
          continue;
        case 44:
          if (tag !== 352) {
            break;
          }

          message.servesBrunch = reader.bool();
          continue;
        case 45:
          if (tag !== 360) {
            break;
          }

          message.servesVegetarianFood = reader.bool();
          continue;
        case 46:
          if (tag !== 370) {
            break;
          }

          message.currentOpeningHours = Place_OpeningHours.decode(reader, reader.uint32());
          continue;
        case 47:
          if (tag !== 378) {
            break;
          }

          message.currentSecondaryOpeningHours.push(Place_OpeningHours.decode(reader, reader.uint32()));
          continue;
        case 49:
          if (tag !== 394) {
            break;
          }

          message.regularSecondaryOpeningHours.push(Place_OpeningHours.decode(reader, reader.uint32()));
          continue;
        case 52:
          if (tag !== 418) {
            break;
          }

          message.editorialSummary = LocalizedText.decode(reader, reader.uint32());
          continue;
        case 55:
          if (tag !== 440) {
            break;
          }

          message.outdoorSeating = reader.bool();
          continue;
        case 56:
          if (tag !== 448) {
            break;
          }

          message.liveMusic = reader.bool();
          continue;
        case 57:
          if (tag !== 456) {
            break;
          }

          message.menuForChildren = reader.bool();
          continue;
        case 58:
          if (tag !== 464) {
            break;
          }

          message.servesCocktails = reader.bool();
          continue;
        case 59:
          if (tag !== 472) {
            break;
          }

          message.servesDessert = reader.bool();
          continue;
        case 60:
          if (tag !== 480) {
            break;
          }

          message.servesCoffee = reader.bool();
          continue;
        case 62:
          if (tag !== 496) {
            break;
          }

          message.goodForChildren = reader.bool();
          continue;
        case 63:
          if (tag !== 504) {
            break;
          }

          message.allowsDogs = reader.bool();
          continue;
        case 64:
          if (tag !== 512) {
            break;
          }

          message.restroom = reader.bool();
          continue;
        case 65:
          if (tag !== 520) {
            break;
          }

          message.goodForGroups = reader.bool();
          continue;
        case 66:
          if (tag !== 528) {
            break;
          }

          message.goodForWatchingSports = reader.bool();
          continue;
        case 67:
          if (tag !== 538) {
            break;
          }

          message.paymentOptions = Place_PaymentOptions.decode(reader, reader.uint32());
          continue;
        case 70:
          if (tag !== 562) {
            break;
          }

          message.parkingOptions = Place_ParkingOptions.decode(reader, reader.uint32());
          continue;
        case 71:
          if (tag !== 570) {
            break;
          }

          message.subDestinations.push(Place_SubDestination.decode(reader, reader.uint32()));
          continue;
        case 72:
          if (tag !== 578) {
            break;
          }

          message.accessibilityOptions = Place_AccessibilityOptions.decode(reader, reader.uint32());
          continue;
        case 78:
          if (tag !== 626) {
            break;
          }

          message.fuelOptions = FuelOptions.decode(reader, reader.uint32());
          continue;
        case 79:
          if (tag !== 634) {
            break;
          }

          message.evChargeOptions = EVChargeOptions.decode(reader, reader.uint32());
          continue;
        case 80:
          if (tag !== 642) {
            break;
          }

          message.generativeSummary = Place_GenerativeSummary.decode(reader, reader.uint32());
          continue;
        case 81:
          if (tag !== 650) {
            break;
          }

          message.areaSummary = Place_AreaSummary.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Place {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      displayName: isSet(object.displayName) ? LocalizedText.fromJSON(object.displayName) : undefined,
      types: globalThis.Array.isArray(object?.types) ? object.types.map((e: any) => globalThis.String(e)) : [],
      primaryType: isSet(object.primaryType) ? globalThis.String(object.primaryType) : "",
      primaryTypeDisplayName: isSet(object.primaryTypeDisplayName)
        ? LocalizedText.fromJSON(object.primaryTypeDisplayName)
        : undefined,
      nationalPhoneNumber: isSet(object.nationalPhoneNumber) ? globalThis.String(object.nationalPhoneNumber) : "",
      internationalPhoneNumber: isSet(object.internationalPhoneNumber)
        ? globalThis.String(object.internationalPhoneNumber)
        : "",
      formattedAddress: isSet(object.formattedAddress) ? globalThis.String(object.formattedAddress) : "",
      shortFormattedAddress: isSet(object.shortFormattedAddress) ? globalThis.String(object.shortFormattedAddress) : "",
      addressComponents: globalThis.Array.isArray(object?.addressComponents)
        ? object.addressComponents.map((e: any) => Place_AddressComponent.fromJSON(e))
        : [],
      plusCode: isSet(object.plusCode) ? Place_PlusCode.fromJSON(object.plusCode) : undefined,
      location: isSet(object.location) ? LatLng.fromJSON(object.location) : undefined,
      viewport: isSet(object.viewport) ? Viewport.fromJSON(object.viewport) : undefined,
      rating: isSet(object.rating) ? globalThis.Number(object.rating) : 0,
      googleMapsUri: isSet(object.googleMapsUri) ? globalThis.String(object.googleMapsUri) : "",
      websiteUri: isSet(object.websiteUri) ? globalThis.String(object.websiteUri) : "",
      reviews: globalThis.Array.isArray(object?.reviews) ? object.reviews.map((e: any) => Review.fromJSON(e)) : [],
      regularOpeningHours: isSet(object.regularOpeningHours)
        ? Place_OpeningHours.fromJSON(object.regularOpeningHours)
        : undefined,
      utcOffsetMinutes: isSet(object.utcOffsetMinutes) ? globalThis.Number(object.utcOffsetMinutes) : undefined,
      photos: globalThis.Array.isArray(object?.photos) ? object.photos.map((e: any) => Photo.fromJSON(e)) : [],
      adrFormatAddress: isSet(object.adrFormatAddress) ? globalThis.String(object.adrFormatAddress) : "",
      businessStatus: isSet(object.businessStatus) ? place_BusinessStatusFromJSON(object.businessStatus) : 0,
      priceLevel: isSet(object.priceLevel) ? priceLevelFromJSON(object.priceLevel) : 0,
      attributions: globalThis.Array.isArray(object?.attributions)
        ? object.attributions.map((e: any) => Place_Attribution.fromJSON(e))
        : [],
      userRatingCount: isSet(object.userRatingCount) ? globalThis.Number(object.userRatingCount) : undefined,
      iconMaskBaseUri: isSet(object.iconMaskBaseUri) ? globalThis.String(object.iconMaskBaseUri) : "",
      iconBackgroundColor: isSet(object.iconBackgroundColor) ? globalThis.String(object.iconBackgroundColor) : "",
      takeout: isSet(object.takeout) ? globalThis.Boolean(object.takeout) : undefined,
      delivery: isSet(object.delivery) ? globalThis.Boolean(object.delivery) : undefined,
      dineIn: isSet(object.dineIn) ? globalThis.Boolean(object.dineIn) : undefined,
      curbsidePickup: isSet(object.curbsidePickup) ? globalThis.Boolean(object.curbsidePickup) : undefined,
      reservable: isSet(object.reservable) ? globalThis.Boolean(object.reservable) : undefined,
      servesBreakfast: isSet(object.servesBreakfast) ? globalThis.Boolean(object.servesBreakfast) : undefined,
      servesLunch: isSet(object.servesLunch) ? globalThis.Boolean(object.servesLunch) : undefined,
      servesDinner: isSet(object.servesDinner) ? globalThis.Boolean(object.servesDinner) : undefined,
      servesBeer: isSet(object.servesBeer) ? globalThis.Boolean(object.servesBeer) : undefined,
      servesWine: isSet(object.servesWine) ? globalThis.Boolean(object.servesWine) : undefined,
      servesBrunch: isSet(object.servesBrunch) ? globalThis.Boolean(object.servesBrunch) : undefined,
      servesVegetarianFood: isSet(object.servesVegetarianFood)
        ? globalThis.Boolean(object.servesVegetarianFood)
        : undefined,
      currentOpeningHours: isSet(object.currentOpeningHours)
        ? Place_OpeningHours.fromJSON(object.currentOpeningHours)
        : undefined,
      currentSecondaryOpeningHours: globalThis.Array.isArray(object?.currentSecondaryOpeningHours)
        ? object.currentSecondaryOpeningHours.map((e: any) => Place_OpeningHours.fromJSON(e))
        : [],
      regularSecondaryOpeningHours: globalThis.Array.isArray(object?.regularSecondaryOpeningHours)
        ? object.regularSecondaryOpeningHours.map((e: any) => Place_OpeningHours.fromJSON(e))
        : [],
      editorialSummary: isSet(object.editorialSummary) ? LocalizedText.fromJSON(object.editorialSummary) : undefined,
      outdoorSeating: isSet(object.outdoorSeating) ? globalThis.Boolean(object.outdoorSeating) : undefined,
      liveMusic: isSet(object.liveMusic) ? globalThis.Boolean(object.liveMusic) : undefined,
      menuForChildren: isSet(object.menuForChildren) ? globalThis.Boolean(object.menuForChildren) : undefined,
      servesCocktails: isSet(object.servesCocktails) ? globalThis.Boolean(object.servesCocktails) : undefined,
      servesDessert: isSet(object.servesDessert) ? globalThis.Boolean(object.servesDessert) : undefined,
      servesCoffee: isSet(object.servesCoffee) ? globalThis.Boolean(object.servesCoffee) : undefined,
      goodForChildren: isSet(object.goodForChildren) ? globalThis.Boolean(object.goodForChildren) : undefined,
      allowsDogs: isSet(object.allowsDogs) ? globalThis.Boolean(object.allowsDogs) : undefined,
      restroom: isSet(object.restroom) ? globalThis.Boolean(object.restroom) : undefined,
      goodForGroups: isSet(object.goodForGroups) ? globalThis.Boolean(object.goodForGroups) : undefined,
      goodForWatchingSports: isSet(object.goodForWatchingSports)
        ? globalThis.Boolean(object.goodForWatchingSports)
        : undefined,
      paymentOptions: isSet(object.paymentOptions) ? Place_PaymentOptions.fromJSON(object.paymentOptions) : undefined,
      parkingOptions: isSet(object.parkingOptions) ? Place_ParkingOptions.fromJSON(object.parkingOptions) : undefined,
      subDestinations: globalThis.Array.isArray(object?.subDestinations)
        ? object.subDestinations.map((e: any) => Place_SubDestination.fromJSON(e))
        : [],
      accessibilityOptions: isSet(object.accessibilityOptions)
        ? Place_AccessibilityOptions.fromJSON(object.accessibilityOptions)
        : undefined,
      fuelOptions: isSet(object.fuelOptions) ? FuelOptions.fromJSON(object.fuelOptions) : undefined,
      evChargeOptions: isSet(object.evChargeOptions) ? EVChargeOptions.fromJSON(object.evChargeOptions) : undefined,
      generativeSummary: isSet(object.generativeSummary)
        ? Place_GenerativeSummary.fromJSON(object.generativeSummary)
        : undefined,
      areaSummary: isSet(object.areaSummary) ? Place_AreaSummary.fromJSON(object.areaSummary) : undefined,
    };
  },

  toJSON(message: Place): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.displayName !== undefined) {
      obj.displayName = LocalizedText.toJSON(message.displayName);
    }
    if (message.types?.length) {
      obj.types = message.types;
    }
    if (message.primaryType !== "") {
      obj.primaryType = message.primaryType;
    }
    if (message.primaryTypeDisplayName !== undefined) {
      obj.primaryTypeDisplayName = LocalizedText.toJSON(message.primaryTypeDisplayName);
    }
    if (message.nationalPhoneNumber !== "") {
      obj.nationalPhoneNumber = message.nationalPhoneNumber;
    }
    if (message.internationalPhoneNumber !== "") {
      obj.internationalPhoneNumber = message.internationalPhoneNumber;
    }
    if (message.formattedAddress !== "") {
      obj.formattedAddress = message.formattedAddress;
    }
    if (message.shortFormattedAddress !== "") {
      obj.shortFormattedAddress = message.shortFormattedAddress;
    }
    if (message.addressComponents?.length) {
      obj.addressComponents = message.addressComponents.map((e) => Place_AddressComponent.toJSON(e));
    }
    if (message.plusCode !== undefined) {
      obj.plusCode = Place_PlusCode.toJSON(message.plusCode);
    }
    if (message.location !== undefined) {
      obj.location = LatLng.toJSON(message.location);
    }
    if (message.viewport !== undefined) {
      obj.viewport = Viewport.toJSON(message.viewport);
    }
    if (message.rating !== 0) {
      obj.rating = message.rating;
    }
    if (message.googleMapsUri !== "") {
      obj.googleMapsUri = message.googleMapsUri;
    }
    if (message.websiteUri !== "") {
      obj.websiteUri = message.websiteUri;
    }
    if (message.reviews?.length) {
      obj.reviews = message.reviews.map((e) => Review.toJSON(e));
    }
    if (message.regularOpeningHours !== undefined) {
      obj.regularOpeningHours = Place_OpeningHours.toJSON(message.regularOpeningHours);
    }
    if (message.utcOffsetMinutes !== undefined) {
      obj.utcOffsetMinutes = Math.round(message.utcOffsetMinutes);
    }
    if (message.photos?.length) {
      obj.photos = message.photos.map((e) => Photo.toJSON(e));
    }
    if (message.adrFormatAddress !== "") {
      obj.adrFormatAddress = message.adrFormatAddress;
    }
    if (message.businessStatus !== 0) {
      obj.businessStatus = place_BusinessStatusToJSON(message.businessStatus);
    }
    if (message.priceLevel !== 0) {
      obj.priceLevel = priceLevelToJSON(message.priceLevel);
    }
    if (message.attributions?.length) {
      obj.attributions = message.attributions.map((e) => Place_Attribution.toJSON(e));
    }
    if (message.userRatingCount !== undefined) {
      obj.userRatingCount = Math.round(message.userRatingCount);
    }
    if (message.iconMaskBaseUri !== "") {
      obj.iconMaskBaseUri = message.iconMaskBaseUri;
    }
    if (message.iconBackgroundColor !== "") {
      obj.iconBackgroundColor = message.iconBackgroundColor;
    }
    if (message.takeout !== undefined) {
      obj.takeout = message.takeout;
    }
    if (message.delivery !== undefined) {
      obj.delivery = message.delivery;
    }
    if (message.dineIn !== undefined) {
      obj.dineIn = message.dineIn;
    }
    if (message.curbsidePickup !== undefined) {
      obj.curbsidePickup = message.curbsidePickup;
    }
    if (message.reservable !== undefined) {
      obj.reservable = message.reservable;
    }
    if (message.servesBreakfast !== undefined) {
      obj.servesBreakfast = message.servesBreakfast;
    }
    if (message.servesLunch !== undefined) {
      obj.servesLunch = message.servesLunch;
    }
    if (message.servesDinner !== undefined) {
      obj.servesDinner = message.servesDinner;
    }
    if (message.servesBeer !== undefined) {
      obj.servesBeer = message.servesBeer;
    }
    if (message.servesWine !== undefined) {
      obj.servesWine = message.servesWine;
    }
    if (message.servesBrunch !== undefined) {
      obj.servesBrunch = message.servesBrunch;
    }
    if (message.servesVegetarianFood !== undefined) {
      obj.servesVegetarianFood = message.servesVegetarianFood;
    }
    if (message.currentOpeningHours !== undefined) {
      obj.currentOpeningHours = Place_OpeningHours.toJSON(message.currentOpeningHours);
    }
    if (message.currentSecondaryOpeningHours?.length) {
      obj.currentSecondaryOpeningHours = message.currentSecondaryOpeningHours.map((e) => Place_OpeningHours.toJSON(e));
    }
    if (message.regularSecondaryOpeningHours?.length) {
      obj.regularSecondaryOpeningHours = message.regularSecondaryOpeningHours.map((e) => Place_OpeningHours.toJSON(e));
    }
    if (message.editorialSummary !== undefined) {
      obj.editorialSummary = LocalizedText.toJSON(message.editorialSummary);
    }
    if (message.outdoorSeating !== undefined) {
      obj.outdoorSeating = message.outdoorSeating;
    }
    if (message.liveMusic !== undefined) {
      obj.liveMusic = message.liveMusic;
    }
    if (message.menuForChildren !== undefined) {
      obj.menuForChildren = message.menuForChildren;
    }
    if (message.servesCocktails !== undefined) {
      obj.servesCocktails = message.servesCocktails;
    }
    if (message.servesDessert !== undefined) {
      obj.servesDessert = message.servesDessert;
    }
    if (message.servesCoffee !== undefined) {
      obj.servesCoffee = message.servesCoffee;
    }
    if (message.goodForChildren !== undefined) {
      obj.goodForChildren = message.goodForChildren;
    }
    if (message.allowsDogs !== undefined) {
      obj.allowsDogs = message.allowsDogs;
    }
    if (message.restroom !== undefined) {
      obj.restroom = message.restroom;
    }
    if (message.goodForGroups !== undefined) {
      obj.goodForGroups = message.goodForGroups;
    }
    if (message.goodForWatchingSports !== undefined) {
      obj.goodForWatchingSports = message.goodForWatchingSports;
    }
    if (message.paymentOptions !== undefined) {
      obj.paymentOptions = Place_PaymentOptions.toJSON(message.paymentOptions);
    }
    if (message.parkingOptions !== undefined) {
      obj.parkingOptions = Place_ParkingOptions.toJSON(message.parkingOptions);
    }
    if (message.subDestinations?.length) {
      obj.subDestinations = message.subDestinations.map((e) => Place_SubDestination.toJSON(e));
    }
    if (message.accessibilityOptions !== undefined) {
      obj.accessibilityOptions = Place_AccessibilityOptions.toJSON(message.accessibilityOptions);
    }
    if (message.fuelOptions !== undefined) {
      obj.fuelOptions = FuelOptions.toJSON(message.fuelOptions);
    }
    if (message.evChargeOptions !== undefined) {
      obj.evChargeOptions = EVChargeOptions.toJSON(message.evChargeOptions);
    }
    if (message.generativeSummary !== undefined) {
      obj.generativeSummary = Place_GenerativeSummary.toJSON(message.generativeSummary);
    }
    if (message.areaSummary !== undefined) {
      obj.areaSummary = Place_AreaSummary.toJSON(message.areaSummary);
    }
    return obj;
  },

  create(base?: DeepPartial<Place>): Place {
    return Place.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Place>): Place {
    const message = createBasePlace();
    message.name = object.name ?? "";
    message.id = object.id ?? "";
    message.displayName = (object.displayName !== undefined && object.displayName !== null)
      ? LocalizedText.fromPartial(object.displayName)
      : undefined;
    message.types = object.types?.map((e) => e) || [];
    message.primaryType = object.primaryType ?? "";
    message.primaryTypeDisplayName =
      (object.primaryTypeDisplayName !== undefined && object.primaryTypeDisplayName !== null)
        ? LocalizedText.fromPartial(object.primaryTypeDisplayName)
        : undefined;
    message.nationalPhoneNumber = object.nationalPhoneNumber ?? "";
    message.internationalPhoneNumber = object.internationalPhoneNumber ?? "";
    message.formattedAddress = object.formattedAddress ?? "";
    message.shortFormattedAddress = object.shortFormattedAddress ?? "";
    message.addressComponents = object.addressComponents?.map((e) => Place_AddressComponent.fromPartial(e)) || [];
    message.plusCode = (object.plusCode !== undefined && object.plusCode !== null)
      ? Place_PlusCode.fromPartial(object.plusCode)
      : undefined;
    message.location = (object.location !== undefined && object.location !== null)
      ? LatLng.fromPartial(object.location)
      : undefined;
    message.viewport = (object.viewport !== undefined && object.viewport !== null)
      ? Viewport.fromPartial(object.viewport)
      : undefined;
    message.rating = object.rating ?? 0;
    message.googleMapsUri = object.googleMapsUri ?? "";
    message.websiteUri = object.websiteUri ?? "";
    message.reviews = object.reviews?.map((e) => Review.fromPartial(e)) || [];
    message.regularOpeningHours = (object.regularOpeningHours !== undefined && object.regularOpeningHours !== null)
      ? Place_OpeningHours.fromPartial(object.regularOpeningHours)
      : undefined;
    message.utcOffsetMinutes = object.utcOffsetMinutes ?? undefined;
    message.photos = object.photos?.map((e) => Photo.fromPartial(e)) || [];
    message.adrFormatAddress = object.adrFormatAddress ?? "";
    message.businessStatus = object.businessStatus ?? 0;
    message.priceLevel = object.priceLevel ?? 0;
    message.attributions = object.attributions?.map((e) => Place_Attribution.fromPartial(e)) || [];
    message.userRatingCount = object.userRatingCount ?? undefined;
    message.iconMaskBaseUri = object.iconMaskBaseUri ?? "";
    message.iconBackgroundColor = object.iconBackgroundColor ?? "";
    message.takeout = object.takeout ?? undefined;
    message.delivery = object.delivery ?? undefined;
    message.dineIn = object.dineIn ?? undefined;
    message.curbsidePickup = object.curbsidePickup ?? undefined;
    message.reservable = object.reservable ?? undefined;
    message.servesBreakfast = object.servesBreakfast ?? undefined;
    message.servesLunch = object.servesLunch ?? undefined;
    message.servesDinner = object.servesDinner ?? undefined;
    message.servesBeer = object.servesBeer ?? undefined;
    message.servesWine = object.servesWine ?? undefined;
    message.servesBrunch = object.servesBrunch ?? undefined;
    message.servesVegetarianFood = object.servesVegetarianFood ?? undefined;
    message.currentOpeningHours = (object.currentOpeningHours !== undefined && object.currentOpeningHours !== null)
      ? Place_OpeningHours.fromPartial(object.currentOpeningHours)
      : undefined;
    message.currentSecondaryOpeningHours =
      object.currentSecondaryOpeningHours?.map((e) => Place_OpeningHours.fromPartial(e)) || [];
    message.regularSecondaryOpeningHours =
      object.regularSecondaryOpeningHours?.map((e) => Place_OpeningHours.fromPartial(e)) || [];
    message.editorialSummary = (object.editorialSummary !== undefined && object.editorialSummary !== null)
      ? LocalizedText.fromPartial(object.editorialSummary)
      : undefined;
    message.outdoorSeating = object.outdoorSeating ?? undefined;
    message.liveMusic = object.liveMusic ?? undefined;
    message.menuForChildren = object.menuForChildren ?? undefined;
    message.servesCocktails = object.servesCocktails ?? undefined;
    message.servesDessert = object.servesDessert ?? undefined;
    message.servesCoffee = object.servesCoffee ?? undefined;
    message.goodForChildren = object.goodForChildren ?? undefined;
    message.allowsDogs = object.allowsDogs ?? undefined;
    message.restroom = object.restroom ?? undefined;
    message.goodForGroups = object.goodForGroups ?? undefined;
    message.goodForWatchingSports = object.goodForWatchingSports ?? undefined;
    message.paymentOptions = (object.paymentOptions !== undefined && object.paymentOptions !== null)
      ? Place_PaymentOptions.fromPartial(object.paymentOptions)
      : undefined;
    message.parkingOptions = (object.parkingOptions !== undefined && object.parkingOptions !== null)
      ? Place_ParkingOptions.fromPartial(object.parkingOptions)
      : undefined;
    message.subDestinations = object.subDestinations?.map((e) => Place_SubDestination.fromPartial(e)) || [];
    message.accessibilityOptions = (object.accessibilityOptions !== undefined && object.accessibilityOptions !== null)
      ? Place_AccessibilityOptions.fromPartial(object.accessibilityOptions)
      : undefined;
    message.fuelOptions = (object.fuelOptions !== undefined && object.fuelOptions !== null)
      ? FuelOptions.fromPartial(object.fuelOptions)
      : undefined;
    message.evChargeOptions = (object.evChargeOptions !== undefined && object.evChargeOptions !== null)
      ? EVChargeOptions.fromPartial(object.evChargeOptions)
      : undefined;
    message.generativeSummary = (object.generativeSummary !== undefined && object.generativeSummary !== null)
      ? Place_GenerativeSummary.fromPartial(object.generativeSummary)
      : undefined;
    message.areaSummary = (object.areaSummary !== undefined && object.areaSummary !== null)
      ? Place_AreaSummary.fromPartial(object.areaSummary)
      : undefined;
    return message;
  },
};

function createBasePlace_AddressComponent(): Place_AddressComponent {
  return { longText: "", shortText: "", types: [], languageCode: "" };
}

export const Place_AddressComponent: MessageFns<Place_AddressComponent> = {
  encode(message: Place_AddressComponent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.longText !== "") {
      writer.uint32(10).string(message.longText);
    }
    if (message.shortText !== "") {
      writer.uint32(18).string(message.shortText);
    }
    for (const v of message.types) {
      writer.uint32(26).string(v!);
    }
    if (message.languageCode !== "") {
      writer.uint32(34).string(message.languageCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Place_AddressComponent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlace_AddressComponent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.longText = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.shortText = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.types.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.languageCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Place_AddressComponent {
    return {
      longText: isSet(object.longText) ? globalThis.String(object.longText) : "",
      shortText: isSet(object.shortText) ? globalThis.String(object.shortText) : "",
      types: globalThis.Array.isArray(object?.types) ? object.types.map((e: any) => globalThis.String(e)) : [],
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
    };
  },

  toJSON(message: Place_AddressComponent): unknown {
    const obj: any = {};
    if (message.longText !== "") {
      obj.longText = message.longText;
    }
    if (message.shortText !== "") {
      obj.shortText = message.shortText;
    }
    if (message.types?.length) {
      obj.types = message.types;
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    return obj;
  },

  create(base?: DeepPartial<Place_AddressComponent>): Place_AddressComponent {
    return Place_AddressComponent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Place_AddressComponent>): Place_AddressComponent {
    const message = createBasePlace_AddressComponent();
    message.longText = object.longText ?? "";
    message.shortText = object.shortText ?? "";
    message.types = object.types?.map((e) => e) || [];
    message.languageCode = object.languageCode ?? "";
    return message;
  },
};

function createBasePlace_PlusCode(): Place_PlusCode {
  return { globalCode: "", compoundCode: "" };
}

export const Place_PlusCode: MessageFns<Place_PlusCode> = {
  encode(message: Place_PlusCode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.globalCode !== "") {
      writer.uint32(10).string(message.globalCode);
    }
    if (message.compoundCode !== "") {
      writer.uint32(18).string(message.compoundCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Place_PlusCode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlace_PlusCode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.globalCode = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.compoundCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Place_PlusCode {
    return {
      globalCode: isSet(object.globalCode) ? globalThis.String(object.globalCode) : "",
      compoundCode: isSet(object.compoundCode) ? globalThis.String(object.compoundCode) : "",
    };
  },

  toJSON(message: Place_PlusCode): unknown {
    const obj: any = {};
    if (message.globalCode !== "") {
      obj.globalCode = message.globalCode;
    }
    if (message.compoundCode !== "") {
      obj.compoundCode = message.compoundCode;
    }
    return obj;
  },

  create(base?: DeepPartial<Place_PlusCode>): Place_PlusCode {
    return Place_PlusCode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Place_PlusCode>): Place_PlusCode {
    const message = createBasePlace_PlusCode();
    message.globalCode = object.globalCode ?? "";
    message.compoundCode = object.compoundCode ?? "";
    return message;
  },
};

function createBasePlace_OpeningHours(): Place_OpeningHours {
  return { openNow: undefined, periods: [], weekdayDescriptions: [], secondaryHoursType: 0, specialDays: [] };
}

export const Place_OpeningHours: MessageFns<Place_OpeningHours> = {
  encode(message: Place_OpeningHours, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.openNow !== undefined) {
      writer.uint32(8).bool(message.openNow);
    }
    for (const v of message.periods) {
      Place_OpeningHours_Period.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.weekdayDescriptions) {
      writer.uint32(26).string(v!);
    }
    if (message.secondaryHoursType !== 0) {
      writer.uint32(32).int32(message.secondaryHoursType);
    }
    for (const v of message.specialDays) {
      Place_OpeningHours_SpecialDay.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Place_OpeningHours {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlace_OpeningHours();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.openNow = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.periods.push(Place_OpeningHours_Period.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.weekdayDescriptions.push(reader.string());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.secondaryHoursType = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.specialDays.push(Place_OpeningHours_SpecialDay.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Place_OpeningHours {
    return {
      openNow: isSet(object.openNow) ? globalThis.Boolean(object.openNow) : undefined,
      periods: globalThis.Array.isArray(object?.periods)
        ? object.periods.map((e: any) => Place_OpeningHours_Period.fromJSON(e))
        : [],
      weekdayDescriptions: globalThis.Array.isArray(object?.weekdayDescriptions)
        ? object.weekdayDescriptions.map((e: any) => globalThis.String(e))
        : [],
      secondaryHoursType: isSet(object.secondaryHoursType)
        ? place_OpeningHours_SecondaryHoursTypeFromJSON(object.secondaryHoursType)
        : 0,
      specialDays: globalThis.Array.isArray(object?.specialDays)
        ? object.specialDays.map((e: any) => Place_OpeningHours_SpecialDay.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Place_OpeningHours): unknown {
    const obj: any = {};
    if (message.openNow !== undefined) {
      obj.openNow = message.openNow;
    }
    if (message.periods?.length) {
      obj.periods = message.periods.map((e) => Place_OpeningHours_Period.toJSON(e));
    }
    if (message.weekdayDescriptions?.length) {
      obj.weekdayDescriptions = message.weekdayDescriptions;
    }
    if (message.secondaryHoursType !== 0) {
      obj.secondaryHoursType = place_OpeningHours_SecondaryHoursTypeToJSON(message.secondaryHoursType);
    }
    if (message.specialDays?.length) {
      obj.specialDays = message.specialDays.map((e) => Place_OpeningHours_SpecialDay.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Place_OpeningHours>): Place_OpeningHours {
    return Place_OpeningHours.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Place_OpeningHours>): Place_OpeningHours {
    const message = createBasePlace_OpeningHours();
    message.openNow = object.openNow ?? undefined;
    message.periods = object.periods?.map((e) => Place_OpeningHours_Period.fromPartial(e)) || [];
    message.weekdayDescriptions = object.weekdayDescriptions?.map((e) => e) || [];
    message.secondaryHoursType = object.secondaryHoursType ?? 0;
    message.specialDays = object.specialDays?.map((e) => Place_OpeningHours_SpecialDay.fromPartial(e)) || [];
    return message;
  },
};

function createBasePlace_OpeningHours_Period(): Place_OpeningHours_Period {
  return { open: undefined, close: undefined };
}

export const Place_OpeningHours_Period: MessageFns<Place_OpeningHours_Period> = {
  encode(message: Place_OpeningHours_Period, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.open !== undefined) {
      Place_OpeningHours_Period_Point.encode(message.open, writer.uint32(10).fork()).join();
    }
    if (message.close !== undefined) {
      Place_OpeningHours_Period_Point.encode(message.close, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Place_OpeningHours_Period {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlace_OpeningHours_Period();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.open = Place_OpeningHours_Period_Point.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.close = Place_OpeningHours_Period_Point.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Place_OpeningHours_Period {
    return {
      open: isSet(object.open) ? Place_OpeningHours_Period_Point.fromJSON(object.open) : undefined,
      close: isSet(object.close) ? Place_OpeningHours_Period_Point.fromJSON(object.close) : undefined,
    };
  },

  toJSON(message: Place_OpeningHours_Period): unknown {
    const obj: any = {};
    if (message.open !== undefined) {
      obj.open = Place_OpeningHours_Period_Point.toJSON(message.open);
    }
    if (message.close !== undefined) {
      obj.close = Place_OpeningHours_Period_Point.toJSON(message.close);
    }
    return obj;
  },

  create(base?: DeepPartial<Place_OpeningHours_Period>): Place_OpeningHours_Period {
    return Place_OpeningHours_Period.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Place_OpeningHours_Period>): Place_OpeningHours_Period {
    const message = createBasePlace_OpeningHours_Period();
    message.open = (object.open !== undefined && object.open !== null)
      ? Place_OpeningHours_Period_Point.fromPartial(object.open)
      : undefined;
    message.close = (object.close !== undefined && object.close !== null)
      ? Place_OpeningHours_Period_Point.fromPartial(object.close)
      : undefined;
    return message;
  },
};

function createBasePlace_OpeningHours_Period_Point(): Place_OpeningHours_Period_Point {
  return { day: undefined, hour: undefined, minute: undefined, date: undefined, truncated: false };
}

export const Place_OpeningHours_Period_Point: MessageFns<Place_OpeningHours_Period_Point> = {
  encode(message: Place_OpeningHours_Period_Point, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.day !== undefined) {
      writer.uint32(8).int32(message.day);
    }
    if (message.hour !== undefined) {
      writer.uint32(16).int32(message.hour);
    }
    if (message.minute !== undefined) {
      writer.uint32(24).int32(message.minute);
    }
    if (message.date !== undefined) {
      DateMessage.encode(message.date, writer.uint32(50).fork()).join();
    }
    if (message.truncated !== false) {
      writer.uint32(40).bool(message.truncated);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Place_OpeningHours_Period_Point {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlace_OpeningHours_Period_Point();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.day = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.hour = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.minute = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.date = DateMessage.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.truncated = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Place_OpeningHours_Period_Point {
    return {
      day: isSet(object.day) ? globalThis.Number(object.day) : undefined,
      hour: isSet(object.hour) ? globalThis.Number(object.hour) : undefined,
      minute: isSet(object.minute) ? globalThis.Number(object.minute) : undefined,
      date: isSet(object.date) ? DateMessage.fromJSON(object.date) : undefined,
      truncated: isSet(object.truncated) ? globalThis.Boolean(object.truncated) : false,
    };
  },

  toJSON(message: Place_OpeningHours_Period_Point): unknown {
    const obj: any = {};
    if (message.day !== undefined) {
      obj.day = Math.round(message.day);
    }
    if (message.hour !== undefined) {
      obj.hour = Math.round(message.hour);
    }
    if (message.minute !== undefined) {
      obj.minute = Math.round(message.minute);
    }
    if (message.date !== undefined) {
      obj.date = DateMessage.toJSON(message.date);
    }
    if (message.truncated !== false) {
      obj.truncated = message.truncated;
    }
    return obj;
  },

  create(base?: DeepPartial<Place_OpeningHours_Period_Point>): Place_OpeningHours_Period_Point {
    return Place_OpeningHours_Period_Point.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Place_OpeningHours_Period_Point>): Place_OpeningHours_Period_Point {
    const message = createBasePlace_OpeningHours_Period_Point();
    message.day = object.day ?? undefined;
    message.hour = object.hour ?? undefined;
    message.minute = object.minute ?? undefined;
    message.date = (object.date !== undefined && object.date !== null)
      ? DateMessage.fromPartial(object.date)
      : undefined;
    message.truncated = object.truncated ?? false;
    return message;
  },
};

function createBasePlace_OpeningHours_SpecialDay(): Place_OpeningHours_SpecialDay {
  return { date: undefined };
}

export const Place_OpeningHours_SpecialDay: MessageFns<Place_OpeningHours_SpecialDay> = {
  encode(message: Place_OpeningHours_SpecialDay, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.date !== undefined) {
      DateMessage.encode(message.date, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Place_OpeningHours_SpecialDay {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlace_OpeningHours_SpecialDay();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.date = DateMessage.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Place_OpeningHours_SpecialDay {
    return { date: isSet(object.date) ? DateMessage.fromJSON(object.date) : undefined };
  },

  toJSON(message: Place_OpeningHours_SpecialDay): unknown {
    const obj: any = {};
    if (message.date !== undefined) {
      obj.date = DateMessage.toJSON(message.date);
    }
    return obj;
  },

  create(base?: DeepPartial<Place_OpeningHours_SpecialDay>): Place_OpeningHours_SpecialDay {
    return Place_OpeningHours_SpecialDay.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Place_OpeningHours_SpecialDay>): Place_OpeningHours_SpecialDay {
    const message = createBasePlace_OpeningHours_SpecialDay();
    message.date = (object.date !== undefined && object.date !== null)
      ? DateMessage.fromPartial(object.date)
      : undefined;
    return message;
  },
};

function createBasePlace_Attribution(): Place_Attribution {
  return { provider: "", providerUri: "" };
}

export const Place_Attribution: MessageFns<Place_Attribution> = {
  encode(message: Place_Attribution, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.provider !== "") {
      writer.uint32(10).string(message.provider);
    }
    if (message.providerUri !== "") {
      writer.uint32(18).string(message.providerUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Place_Attribution {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlace_Attribution();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.provider = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.providerUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Place_Attribution {
    return {
      provider: isSet(object.provider) ? globalThis.String(object.provider) : "",
      providerUri: isSet(object.providerUri) ? globalThis.String(object.providerUri) : "",
    };
  },

  toJSON(message: Place_Attribution): unknown {
    const obj: any = {};
    if (message.provider !== "") {
      obj.provider = message.provider;
    }
    if (message.providerUri !== "") {
      obj.providerUri = message.providerUri;
    }
    return obj;
  },

  create(base?: DeepPartial<Place_Attribution>): Place_Attribution {
    return Place_Attribution.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Place_Attribution>): Place_Attribution {
    const message = createBasePlace_Attribution();
    message.provider = object.provider ?? "";
    message.providerUri = object.providerUri ?? "";
    return message;
  },
};

function createBasePlace_PaymentOptions(): Place_PaymentOptions {
  return {
    acceptsCreditCards: undefined,
    acceptsDebitCards: undefined,
    acceptsCashOnly: undefined,
    acceptsNfc: undefined,
  };
}

export const Place_PaymentOptions: MessageFns<Place_PaymentOptions> = {
  encode(message: Place_PaymentOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.acceptsCreditCards !== undefined) {
      writer.uint32(8).bool(message.acceptsCreditCards);
    }
    if (message.acceptsDebitCards !== undefined) {
      writer.uint32(16).bool(message.acceptsDebitCards);
    }
    if (message.acceptsCashOnly !== undefined) {
      writer.uint32(24).bool(message.acceptsCashOnly);
    }
    if (message.acceptsNfc !== undefined) {
      writer.uint32(32).bool(message.acceptsNfc);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Place_PaymentOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlace_PaymentOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.acceptsCreditCards = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.acceptsDebitCards = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.acceptsCashOnly = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.acceptsNfc = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Place_PaymentOptions {
    return {
      acceptsCreditCards: isSet(object.acceptsCreditCards) ? globalThis.Boolean(object.acceptsCreditCards) : undefined,
      acceptsDebitCards: isSet(object.acceptsDebitCards) ? globalThis.Boolean(object.acceptsDebitCards) : undefined,
      acceptsCashOnly: isSet(object.acceptsCashOnly) ? globalThis.Boolean(object.acceptsCashOnly) : undefined,
      acceptsNfc: isSet(object.acceptsNfc) ? globalThis.Boolean(object.acceptsNfc) : undefined,
    };
  },

  toJSON(message: Place_PaymentOptions): unknown {
    const obj: any = {};
    if (message.acceptsCreditCards !== undefined) {
      obj.acceptsCreditCards = message.acceptsCreditCards;
    }
    if (message.acceptsDebitCards !== undefined) {
      obj.acceptsDebitCards = message.acceptsDebitCards;
    }
    if (message.acceptsCashOnly !== undefined) {
      obj.acceptsCashOnly = message.acceptsCashOnly;
    }
    if (message.acceptsNfc !== undefined) {
      obj.acceptsNfc = message.acceptsNfc;
    }
    return obj;
  },

  create(base?: DeepPartial<Place_PaymentOptions>): Place_PaymentOptions {
    return Place_PaymentOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Place_PaymentOptions>): Place_PaymentOptions {
    const message = createBasePlace_PaymentOptions();
    message.acceptsCreditCards = object.acceptsCreditCards ?? undefined;
    message.acceptsDebitCards = object.acceptsDebitCards ?? undefined;
    message.acceptsCashOnly = object.acceptsCashOnly ?? undefined;
    message.acceptsNfc = object.acceptsNfc ?? undefined;
    return message;
  },
};

function createBasePlace_ParkingOptions(): Place_ParkingOptions {
  return {
    freeParkingLot: undefined,
    paidParkingLot: undefined,
    freeStreetParking: undefined,
    paidStreetParking: undefined,
    valetParking: undefined,
    freeGarageParking: undefined,
    paidGarageParking: undefined,
  };
}

export const Place_ParkingOptions: MessageFns<Place_ParkingOptions> = {
  encode(message: Place_ParkingOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.freeParkingLot !== undefined) {
      writer.uint32(8).bool(message.freeParkingLot);
    }
    if (message.paidParkingLot !== undefined) {
      writer.uint32(16).bool(message.paidParkingLot);
    }
    if (message.freeStreetParking !== undefined) {
      writer.uint32(24).bool(message.freeStreetParking);
    }
    if (message.paidStreetParking !== undefined) {
      writer.uint32(32).bool(message.paidStreetParking);
    }
    if (message.valetParking !== undefined) {
      writer.uint32(40).bool(message.valetParking);
    }
    if (message.freeGarageParking !== undefined) {
      writer.uint32(48).bool(message.freeGarageParking);
    }
    if (message.paidGarageParking !== undefined) {
      writer.uint32(56).bool(message.paidGarageParking);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Place_ParkingOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlace_ParkingOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.freeParkingLot = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.paidParkingLot = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.freeStreetParking = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.paidStreetParking = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.valetParking = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.freeGarageParking = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.paidGarageParking = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Place_ParkingOptions {
    return {
      freeParkingLot: isSet(object.freeParkingLot) ? globalThis.Boolean(object.freeParkingLot) : undefined,
      paidParkingLot: isSet(object.paidParkingLot) ? globalThis.Boolean(object.paidParkingLot) : undefined,
      freeStreetParking: isSet(object.freeStreetParking) ? globalThis.Boolean(object.freeStreetParking) : undefined,
      paidStreetParking: isSet(object.paidStreetParking) ? globalThis.Boolean(object.paidStreetParking) : undefined,
      valetParking: isSet(object.valetParking) ? globalThis.Boolean(object.valetParking) : undefined,
      freeGarageParking: isSet(object.freeGarageParking) ? globalThis.Boolean(object.freeGarageParking) : undefined,
      paidGarageParking: isSet(object.paidGarageParking) ? globalThis.Boolean(object.paidGarageParking) : undefined,
    };
  },

  toJSON(message: Place_ParkingOptions): unknown {
    const obj: any = {};
    if (message.freeParkingLot !== undefined) {
      obj.freeParkingLot = message.freeParkingLot;
    }
    if (message.paidParkingLot !== undefined) {
      obj.paidParkingLot = message.paidParkingLot;
    }
    if (message.freeStreetParking !== undefined) {
      obj.freeStreetParking = message.freeStreetParking;
    }
    if (message.paidStreetParking !== undefined) {
      obj.paidStreetParking = message.paidStreetParking;
    }
    if (message.valetParking !== undefined) {
      obj.valetParking = message.valetParking;
    }
    if (message.freeGarageParking !== undefined) {
      obj.freeGarageParking = message.freeGarageParking;
    }
    if (message.paidGarageParking !== undefined) {
      obj.paidGarageParking = message.paidGarageParking;
    }
    return obj;
  },

  create(base?: DeepPartial<Place_ParkingOptions>): Place_ParkingOptions {
    return Place_ParkingOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Place_ParkingOptions>): Place_ParkingOptions {
    const message = createBasePlace_ParkingOptions();
    message.freeParkingLot = object.freeParkingLot ?? undefined;
    message.paidParkingLot = object.paidParkingLot ?? undefined;
    message.freeStreetParking = object.freeStreetParking ?? undefined;
    message.paidStreetParking = object.paidStreetParking ?? undefined;
    message.valetParking = object.valetParking ?? undefined;
    message.freeGarageParking = object.freeGarageParking ?? undefined;
    message.paidGarageParking = object.paidGarageParking ?? undefined;
    return message;
  },
};

function createBasePlace_SubDestination(): Place_SubDestination {
  return { name: "", id: "" };
}

export const Place_SubDestination: MessageFns<Place_SubDestination> = {
  encode(message: Place_SubDestination, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Place_SubDestination {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlace_SubDestination();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Place_SubDestination {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: Place_SubDestination): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create(base?: DeepPartial<Place_SubDestination>): Place_SubDestination {
    return Place_SubDestination.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Place_SubDestination>): Place_SubDestination {
    const message = createBasePlace_SubDestination();
    message.name = object.name ?? "";
    message.id = object.id ?? "";
    return message;
  },
};

function createBasePlace_AccessibilityOptions(): Place_AccessibilityOptions {
  return {
    wheelchairAccessibleParking: undefined,
    wheelchairAccessibleEntrance: undefined,
    wheelchairAccessibleRestroom: undefined,
    wheelchairAccessibleSeating: undefined,
  };
}

export const Place_AccessibilityOptions: MessageFns<Place_AccessibilityOptions> = {
  encode(message: Place_AccessibilityOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.wheelchairAccessibleParking !== undefined) {
      writer.uint32(8).bool(message.wheelchairAccessibleParking);
    }
    if (message.wheelchairAccessibleEntrance !== undefined) {
      writer.uint32(16).bool(message.wheelchairAccessibleEntrance);
    }
    if (message.wheelchairAccessibleRestroom !== undefined) {
      writer.uint32(24).bool(message.wheelchairAccessibleRestroom);
    }
    if (message.wheelchairAccessibleSeating !== undefined) {
      writer.uint32(32).bool(message.wheelchairAccessibleSeating);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Place_AccessibilityOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlace_AccessibilityOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.wheelchairAccessibleParking = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.wheelchairAccessibleEntrance = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.wheelchairAccessibleRestroom = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.wheelchairAccessibleSeating = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Place_AccessibilityOptions {
    return {
      wheelchairAccessibleParking: isSet(object.wheelchairAccessibleParking)
        ? globalThis.Boolean(object.wheelchairAccessibleParking)
        : undefined,
      wheelchairAccessibleEntrance: isSet(object.wheelchairAccessibleEntrance)
        ? globalThis.Boolean(object.wheelchairAccessibleEntrance)
        : undefined,
      wheelchairAccessibleRestroom: isSet(object.wheelchairAccessibleRestroom)
        ? globalThis.Boolean(object.wheelchairAccessibleRestroom)
        : undefined,
      wheelchairAccessibleSeating: isSet(object.wheelchairAccessibleSeating)
        ? globalThis.Boolean(object.wheelchairAccessibleSeating)
        : undefined,
    };
  },

  toJSON(message: Place_AccessibilityOptions): unknown {
    const obj: any = {};
    if (message.wheelchairAccessibleParking !== undefined) {
      obj.wheelchairAccessibleParking = message.wheelchairAccessibleParking;
    }
    if (message.wheelchairAccessibleEntrance !== undefined) {
      obj.wheelchairAccessibleEntrance = message.wheelchairAccessibleEntrance;
    }
    if (message.wheelchairAccessibleRestroom !== undefined) {
      obj.wheelchairAccessibleRestroom = message.wheelchairAccessibleRestroom;
    }
    if (message.wheelchairAccessibleSeating !== undefined) {
      obj.wheelchairAccessibleSeating = message.wheelchairAccessibleSeating;
    }
    return obj;
  },

  create(base?: DeepPartial<Place_AccessibilityOptions>): Place_AccessibilityOptions {
    return Place_AccessibilityOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Place_AccessibilityOptions>): Place_AccessibilityOptions {
    const message = createBasePlace_AccessibilityOptions();
    message.wheelchairAccessibleParking = object.wheelchairAccessibleParking ?? undefined;
    message.wheelchairAccessibleEntrance = object.wheelchairAccessibleEntrance ?? undefined;
    message.wheelchairAccessibleRestroom = object.wheelchairAccessibleRestroom ?? undefined;
    message.wheelchairAccessibleSeating = object.wheelchairAccessibleSeating ?? undefined;
    return message;
  },
};

function createBasePlace_GenerativeSummary(): Place_GenerativeSummary {
  return { overview: undefined, description: undefined, references: undefined };
}

export const Place_GenerativeSummary: MessageFns<Place_GenerativeSummary> = {
  encode(message: Place_GenerativeSummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.overview !== undefined) {
      LocalizedText.encode(message.overview, writer.uint32(10).fork()).join();
    }
    if (message.description !== undefined) {
      LocalizedText.encode(message.description, writer.uint32(18).fork()).join();
    }
    if (message.references !== undefined) {
      References.encode(message.references, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Place_GenerativeSummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlace_GenerativeSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.overview = LocalizedText.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = LocalizedText.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.references = References.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Place_GenerativeSummary {
    return {
      overview: isSet(object.overview) ? LocalizedText.fromJSON(object.overview) : undefined,
      description: isSet(object.description) ? LocalizedText.fromJSON(object.description) : undefined,
      references: isSet(object.references) ? References.fromJSON(object.references) : undefined,
    };
  },

  toJSON(message: Place_GenerativeSummary): unknown {
    const obj: any = {};
    if (message.overview !== undefined) {
      obj.overview = LocalizedText.toJSON(message.overview);
    }
    if (message.description !== undefined) {
      obj.description = LocalizedText.toJSON(message.description);
    }
    if (message.references !== undefined) {
      obj.references = References.toJSON(message.references);
    }
    return obj;
  },

  create(base?: DeepPartial<Place_GenerativeSummary>): Place_GenerativeSummary {
    return Place_GenerativeSummary.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Place_GenerativeSummary>): Place_GenerativeSummary {
    const message = createBasePlace_GenerativeSummary();
    message.overview = (object.overview !== undefined && object.overview !== null)
      ? LocalizedText.fromPartial(object.overview)
      : undefined;
    message.description = (object.description !== undefined && object.description !== null)
      ? LocalizedText.fromPartial(object.description)
      : undefined;
    message.references = (object.references !== undefined && object.references !== null)
      ? References.fromPartial(object.references)
      : undefined;
    return message;
  },
};

function createBasePlace_AreaSummary(): Place_AreaSummary {
  return { contentBlocks: [] };
}

export const Place_AreaSummary: MessageFns<Place_AreaSummary> = {
  encode(message: Place_AreaSummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.contentBlocks) {
      ContentBlock.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Place_AreaSummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlace_AreaSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 34) {
            break;
          }

          message.contentBlocks.push(ContentBlock.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Place_AreaSummary {
    return {
      contentBlocks: globalThis.Array.isArray(object?.contentBlocks)
        ? object.contentBlocks.map((e: any) => ContentBlock.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Place_AreaSummary): unknown {
    const obj: any = {};
    if (message.contentBlocks?.length) {
      obj.contentBlocks = message.contentBlocks.map((e) => ContentBlock.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Place_AreaSummary>): Place_AreaSummary {
    return Place_AreaSummary.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Place_AreaSummary>): Place_AreaSummary {
    const message = createBasePlace_AreaSummary();
    message.contentBlocks = object.contentBlocks?.map((e) => ContentBlock.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
