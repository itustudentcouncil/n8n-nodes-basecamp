// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/maps/places/v1/fuel_options.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Money } from "../../../type/money.js";

export const protobufPackage = "google.maps.places.v1";

/**
 * The most recent information about fuel options in a gas station. This
 * information is updated regularly.
 */
export interface FuelOptions {
  /**
   * The last known fuel price for each type of fuel this station has. There is
   * one entry per fuel type this station has. Order is not important.
   */
  fuelPrices: FuelOptions_FuelPrice[];
}

/** Fuel price information for a given type. */
export interface FuelOptions_FuelPrice {
  /** The type of fuel. */
  type: FuelOptions_FuelPrice_FuelType;
  /** The price of the fuel. */
  price:
    | Money
    | undefined;
  /** The time the fuel price was last updated. */
  updateTime: Date | undefined;
}

/** Types of fuel. */
export enum FuelOptions_FuelPrice_FuelType {
  /** FUEL_TYPE_UNSPECIFIED - Unspecified fuel type. */
  FUEL_TYPE_UNSPECIFIED = 0,
  /** DIESEL - Diesel fuel. */
  DIESEL = 1,
  /** REGULAR_UNLEADED - Regular unleaded. */
  REGULAR_UNLEADED = 2,
  /** MIDGRADE - Midgrade. */
  MIDGRADE = 3,
  /** PREMIUM - Premium. */
  PREMIUM = 4,
  /** SP91 - SP 91. */
  SP91 = 5,
  /** SP91_E10 - SP 91 E10. */
  SP91_E10 = 6,
  /** SP92 - SP 92. */
  SP92 = 7,
  /** SP95 - SP 95. */
  SP95 = 8,
  /** SP95_E10 - SP95 E10. */
  SP95_E10 = 9,
  /** SP98 - SP 98. */
  SP98 = 10,
  /** SP99 - SP 99. */
  SP99 = 11,
  /** SP100 - SP 100. */
  SP100 = 12,
  /** LPG - LPG. */
  LPG = 13,
  /** E80 - E 80. */
  E80 = 14,
  /** E85 - E 85. */
  E85 = 15,
  /** METHANE - Methane. */
  METHANE = 16,
  /** BIO_DIESEL - Bio-diesel. */
  BIO_DIESEL = 17,
  /** TRUCK_DIESEL - Truck diesel. */
  TRUCK_DIESEL = 18,
  UNRECOGNIZED = -1,
}

export function fuelOptions_FuelPrice_FuelTypeFromJSON(object: any): FuelOptions_FuelPrice_FuelType {
  switch (object) {
    case 0:
    case "FUEL_TYPE_UNSPECIFIED":
      return FuelOptions_FuelPrice_FuelType.FUEL_TYPE_UNSPECIFIED;
    case 1:
    case "DIESEL":
      return FuelOptions_FuelPrice_FuelType.DIESEL;
    case 2:
    case "REGULAR_UNLEADED":
      return FuelOptions_FuelPrice_FuelType.REGULAR_UNLEADED;
    case 3:
    case "MIDGRADE":
      return FuelOptions_FuelPrice_FuelType.MIDGRADE;
    case 4:
    case "PREMIUM":
      return FuelOptions_FuelPrice_FuelType.PREMIUM;
    case 5:
    case "SP91":
      return FuelOptions_FuelPrice_FuelType.SP91;
    case 6:
    case "SP91_E10":
      return FuelOptions_FuelPrice_FuelType.SP91_E10;
    case 7:
    case "SP92":
      return FuelOptions_FuelPrice_FuelType.SP92;
    case 8:
    case "SP95":
      return FuelOptions_FuelPrice_FuelType.SP95;
    case 9:
    case "SP95_E10":
      return FuelOptions_FuelPrice_FuelType.SP95_E10;
    case 10:
    case "SP98":
      return FuelOptions_FuelPrice_FuelType.SP98;
    case 11:
    case "SP99":
      return FuelOptions_FuelPrice_FuelType.SP99;
    case 12:
    case "SP100":
      return FuelOptions_FuelPrice_FuelType.SP100;
    case 13:
    case "LPG":
      return FuelOptions_FuelPrice_FuelType.LPG;
    case 14:
    case "E80":
      return FuelOptions_FuelPrice_FuelType.E80;
    case 15:
    case "E85":
      return FuelOptions_FuelPrice_FuelType.E85;
    case 16:
    case "METHANE":
      return FuelOptions_FuelPrice_FuelType.METHANE;
    case 17:
    case "BIO_DIESEL":
      return FuelOptions_FuelPrice_FuelType.BIO_DIESEL;
    case 18:
    case "TRUCK_DIESEL":
      return FuelOptions_FuelPrice_FuelType.TRUCK_DIESEL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FuelOptions_FuelPrice_FuelType.UNRECOGNIZED;
  }
}

export function fuelOptions_FuelPrice_FuelTypeToJSON(object: FuelOptions_FuelPrice_FuelType): string {
  switch (object) {
    case FuelOptions_FuelPrice_FuelType.FUEL_TYPE_UNSPECIFIED:
      return "FUEL_TYPE_UNSPECIFIED";
    case FuelOptions_FuelPrice_FuelType.DIESEL:
      return "DIESEL";
    case FuelOptions_FuelPrice_FuelType.REGULAR_UNLEADED:
      return "REGULAR_UNLEADED";
    case FuelOptions_FuelPrice_FuelType.MIDGRADE:
      return "MIDGRADE";
    case FuelOptions_FuelPrice_FuelType.PREMIUM:
      return "PREMIUM";
    case FuelOptions_FuelPrice_FuelType.SP91:
      return "SP91";
    case FuelOptions_FuelPrice_FuelType.SP91_E10:
      return "SP91_E10";
    case FuelOptions_FuelPrice_FuelType.SP92:
      return "SP92";
    case FuelOptions_FuelPrice_FuelType.SP95:
      return "SP95";
    case FuelOptions_FuelPrice_FuelType.SP95_E10:
      return "SP95_E10";
    case FuelOptions_FuelPrice_FuelType.SP98:
      return "SP98";
    case FuelOptions_FuelPrice_FuelType.SP99:
      return "SP99";
    case FuelOptions_FuelPrice_FuelType.SP100:
      return "SP100";
    case FuelOptions_FuelPrice_FuelType.LPG:
      return "LPG";
    case FuelOptions_FuelPrice_FuelType.E80:
      return "E80";
    case FuelOptions_FuelPrice_FuelType.E85:
      return "E85";
    case FuelOptions_FuelPrice_FuelType.METHANE:
      return "METHANE";
    case FuelOptions_FuelPrice_FuelType.BIO_DIESEL:
      return "BIO_DIESEL";
    case FuelOptions_FuelPrice_FuelType.TRUCK_DIESEL:
      return "TRUCK_DIESEL";
    case FuelOptions_FuelPrice_FuelType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseFuelOptions(): FuelOptions {
  return { fuelPrices: [] };
}

export const FuelOptions: MessageFns<FuelOptions> = {
  encode(message: FuelOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.fuelPrices) {
      FuelOptions_FuelPrice.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FuelOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFuelOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fuelPrices.push(FuelOptions_FuelPrice.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FuelOptions {
    return {
      fuelPrices: globalThis.Array.isArray(object?.fuelPrices)
        ? object.fuelPrices.map((e: any) => FuelOptions_FuelPrice.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FuelOptions): unknown {
    const obj: any = {};
    if (message.fuelPrices?.length) {
      obj.fuelPrices = message.fuelPrices.map((e) => FuelOptions_FuelPrice.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<FuelOptions>): FuelOptions {
    return FuelOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FuelOptions>): FuelOptions {
    const message = createBaseFuelOptions();
    message.fuelPrices = object.fuelPrices?.map((e) => FuelOptions_FuelPrice.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFuelOptions_FuelPrice(): FuelOptions_FuelPrice {
  return { type: 0, price: undefined, updateTime: undefined };
}

export const FuelOptions_FuelPrice: MessageFns<FuelOptions_FuelPrice> = {
  encode(message: FuelOptions_FuelPrice, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.price !== undefined) {
      Money.encode(message.price, writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FuelOptions_FuelPrice {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFuelOptions_FuelPrice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.price = Money.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FuelOptions_FuelPrice {
    return {
      type: isSet(object.type) ? fuelOptions_FuelPrice_FuelTypeFromJSON(object.type) : 0,
      price: isSet(object.price) ? Money.fromJSON(object.price) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: FuelOptions_FuelPrice): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = fuelOptions_FuelPrice_FuelTypeToJSON(message.type);
    }
    if (message.price !== undefined) {
      obj.price = Money.toJSON(message.price);
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<FuelOptions_FuelPrice>): FuelOptions_FuelPrice {
    return FuelOptions_FuelPrice.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FuelOptions_FuelPrice>): FuelOptions_FuelPrice {
    const message = createBaseFuelOptions_FuelPrice();
    message.type = object.type ?? 0;
    message.price = (object.price !== undefined && object.price !== null) ? Money.fromPartial(object.price) : undefined;
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
