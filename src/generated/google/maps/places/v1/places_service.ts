// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/maps/places/v1/places_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Viewport } from "../../../geo/type/viewport.js";
import { LatLng } from "../../../type/latlng.js";
import { ContextualContent } from "./contextual_content.js";
import { EVConnectorType, eVConnectorTypeFromJSON, eVConnectorTypeToJSON } from "./ev_charging.js";
import { Circle } from "./geometry.js";
import { Place, PriceLevel, priceLevelFromJSON, priceLevelToJSON } from "./place.js";
import { Polyline } from "./polyline.js";
import { RouteModifiers } from "./route_modifiers.js";
import { RoutingPreference, routingPreferenceFromJSON, routingPreferenceToJSON } from "./routing_preference.js";
import { RoutingSummary } from "./routing_summary.js";
import { TravelMode, travelModeFromJSON, travelModeToJSON } from "./travel_mode.js";

export const protobufPackage = "google.maps.places.v1";

/**
 * Parameters to configure the routing calculations to the places in the
 * response, both along a route (where result ranking will be influenced) and
 * for calculating travel times on results.
 */
export interface RoutingParameters {
  /**
   * Optional. An explicit routing origin that overrides the origin defined in
   * the polyline. By default, the polyline origin is used.
   */
  origin:
    | LatLng
    | undefined;
  /** Optional. The travel mode. */
  travelMode: TravelMode;
  /** Optional. The route modifiers. */
  routeModifiers:
    | RouteModifiers
    | undefined;
  /**
   * Optional. Specifies how to compute the routing summaries. The server
   * attempts to use the selected routing preference to compute the route. The
   * traffic aware routing preference is only available for the `DRIVE` or
   * `TWO_WHEELER` `travelMode`.
   */
  routingPreference: RoutingPreference;
}

/** Request proto for Search Nearby. */
export interface SearchNearbyRequest {
  /**
   * Place details will be displayed with the preferred language if available.
   * If the language code is unspecified or unrecognized, place details of any
   * language may be returned, with a preference for English if such details
   * exist.
   *
   * Current list of supported languages:
   * https://developers.google.com/maps/faq#languagesupport.
   */
  languageCode: string;
  /**
   * The Unicode country/region code (CLDR) of the location where the
   * request is coming from. This parameter is used to display the place
   * details, like region-specific place name, if available. The parameter can
   * affect results based on applicable law.
   *
   * For more information, see
   * https://www.unicode.org/cldr/charts/latest/supplemental/territory_language_information.html.
   *
   * Note that 3-digit region codes are not currently supported.
   */
  regionCode: string;
  /**
   * Included Place type (eg, "restaurant" or "gas_station") from
   * https://developers.google.com/maps/documentation/places/web-service/place-types.
   *
   * Up to 50 types from [Table
   * A](https://developers.google.com/maps/documentation/places/web-service/place-types#table-a)
   * may be specified.
   *
   * If there are any conflicting types, i.e. a type appears in both
   * included_types and excluded_types, an INVALID_ARGUMENT error is
   * returned.
   *
   * If a Place type is specified with multiple type restrictions, only places
   * that satisfy all of the restrictions are returned. For example, if we
   * have {included_types = ["restaurant"], excluded_primary_types =
   * ["restaurant"]}, the returned places provide "restaurant"
   * related services but do not operate primarily as "restaurants".
   */
  includedTypes: string[];
  /**
   * Excluded Place type (eg, "restaurant" or "gas_station") from
   * https://developers.google.com/maps/documentation/places/web-service/place-types.
   *
   * Up to 50 types from [Table
   * A](https://developers.google.com/maps/documentation/places/web-service/place-types#table-a)
   * may be specified.
   *
   * If the client provides both included_types (e.g. restaurant) and
   * excluded_types (e.g. cafe), then the response should include places that
   * are restaurant but not cafe. The response includes places that match at
   * least one of the included_types and none of the excluded_types.
   *
   * If there are any conflicting types, i.e. a type appears in both
   * included_types and excluded_types, an INVALID_ARGUMENT error is returned.
   *
   * If a Place type is specified with multiple type restrictions, only places
   * that satisfy all of the restrictions are returned. For example, if we
   * have {included_types = ["restaurant"], excluded_primary_types =
   * ["restaurant"]}, the returned places provide "restaurant"
   * related services but do not operate primarily as "restaurants".
   */
  excludedTypes: string[];
  /**
   * Included primary Place type (e.g. "restaurant" or "gas_station") from
   * https://developers.google.com/maps/documentation/places/web-service/place-types.
   * A place can only have a single primary type from the supported types table
   * associated with it.
   *
   * Up to 50 types from [Table
   * A](https://developers.google.com/maps/documentation/places/web-service/place-types#table-a)
   * may be specified.
   *
   * If there are any conflicting primary types, i.e. a type appears in both
   * included_primary_types and excluded_primary_types, an INVALID_ARGUMENT
   * error is returned.
   *
   * If a Place type is specified with multiple type restrictions, only places
   * that satisfy all of the restrictions are returned. For example, if we
   * have {included_types = ["restaurant"], excluded_primary_types =
   * ["restaurant"]}, the returned places provide "restaurant"
   * related services but do not operate primarily as "restaurants".
   */
  includedPrimaryTypes: string[];
  /**
   * Excluded primary Place type (e.g. "restaurant" or "gas_station") from
   * https://developers.google.com/maps/documentation/places/web-service/place-types.
   *
   * Up to 50 types from [Table
   * A](https://developers.google.com/maps/documentation/places/web-service/place-types#table-a)
   * may be specified.
   *
   * If there are any conflicting primary types, i.e. a type appears in both
   * included_primary_types and excluded_primary_types, an INVALID_ARGUMENT
   * error is returned.
   *
   * If a Place type is specified with multiple type restrictions, only places
   * that satisfy all of the restrictions are returned. For example, if we
   * have {included_types = ["restaurant"], excluded_primary_types =
   * ["restaurant"]}, the returned places provide "restaurant"
   * related services but do not operate primarily as "restaurants".
   */
  excludedPrimaryTypes: string[];
  /**
   * Maximum number of results to return. It must be between 1 and 20 (default),
   * inclusively. If the number is unset, it falls back to the upper limit. If
   * the number is set to negative or exceeds the upper limit, an
   * INVALID_ARGUMENT error is returned.
   */
  maxResultCount: number;
  /** Required. The region to search. */
  locationRestriction:
    | SearchNearbyRequest_LocationRestriction
    | undefined;
  /** How results will be ranked in the response. */
  rankPreference: SearchNearbyRequest_RankPreference;
  /** Optional. Parameters that affect the routing to the search results. */
  routingParameters: RoutingParameters | undefined;
}

/** How results will be ranked in the response. */
export enum SearchNearbyRequest_RankPreference {
  /** RANK_PREFERENCE_UNSPECIFIED - RankPreference value not set. Will use rank by POPULARITY by default. */
  RANK_PREFERENCE_UNSPECIFIED = 0,
  /** DISTANCE - Ranks results by distance. */
  DISTANCE = 1,
  /** POPULARITY - Ranks results by popularity. */
  POPULARITY = 2,
  UNRECOGNIZED = -1,
}

export function searchNearbyRequest_RankPreferenceFromJSON(object: any): SearchNearbyRequest_RankPreference {
  switch (object) {
    case 0:
    case "RANK_PREFERENCE_UNSPECIFIED":
      return SearchNearbyRequest_RankPreference.RANK_PREFERENCE_UNSPECIFIED;
    case 1:
    case "DISTANCE":
      return SearchNearbyRequest_RankPreference.DISTANCE;
    case 2:
    case "POPULARITY":
      return SearchNearbyRequest_RankPreference.POPULARITY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SearchNearbyRequest_RankPreference.UNRECOGNIZED;
  }
}

export function searchNearbyRequest_RankPreferenceToJSON(object: SearchNearbyRequest_RankPreference): string {
  switch (object) {
    case SearchNearbyRequest_RankPreference.RANK_PREFERENCE_UNSPECIFIED:
      return "RANK_PREFERENCE_UNSPECIFIED";
    case SearchNearbyRequest_RankPreference.DISTANCE:
      return "DISTANCE";
    case SearchNearbyRequest_RankPreference.POPULARITY:
      return "POPULARITY";
    case SearchNearbyRequest_RankPreference.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The region to search. */
export interface SearchNearbyRequest_LocationRestriction {
  /** A circle defined by center point and radius. */
  circle?: Circle | undefined;
}

/** Response proto for Search Nearby. */
export interface SearchNearbyResponse {
  /**
   * A list of places that meets user's requirements like places
   * types, number of places and specific location restriction.
   */
  places: Place[];
  /**
   * A list of routing summaries where each entry associates to the
   * corresponding place in the same index in the places field. If the routing
   * summary is not available for one of the places, it will contain an empty
   * entry. This list should have as many entries as the list of places if
   * requested.
   */
  routingSummaries: RoutingSummary[];
}

/** Request proto for SearchText. */
export interface SearchTextRequest {
  /** Required. The text query for textual search. */
  textQuery: string;
  /**
   * Place details will be displayed with the preferred language if available.
   * If the language code is unspecified or unrecognized, place details of any
   * language may be returned, with a preference for English if such details
   * exist.
   *
   * Current list of supported languages:
   * https://developers.google.com/maps/faq#languagesupport.
   */
  languageCode: string;
  /**
   * The Unicode country/region code (CLDR) of the location where the
   * request is coming from. This parameter is used to display the place
   * details, like region-specific place name, if available. The parameter can
   * affect results based on applicable law.
   *
   * For more information, see
   * https://www.unicode.org/cldr/charts/latest/supplemental/territory_language_information.html.
   *
   * Note that 3-digit region codes are not currently supported.
   */
  regionCode: string;
  /** How results will be ranked in the response. */
  rankPreference: SearchTextRequest_RankPreference;
  /**
   * The requested place type. Full list of types supported:
   * https://developers.google.com/maps/documentation/places/web-service/place-types.
   * Only support one included type.
   */
  includedType: string;
  /**
   * Used to restrict the search to places that are currently open.  The default
   * is false.
   */
  openNow: boolean;
  /**
   * Filter out results whose average user rating is strictly less than this
   * limit. A valid value must be a float between 0 and 5 (inclusively) at a
   * 0.5 cadence i.e. [0, 0.5, 1.0, ... , 5.0] inclusively. The input rating
   * will round up to the nearest 0.5(ceiling). For instance, a rating of 0.6
   * will eliminate all results with a less than 1.0 rating.
   */
  minRating: number;
  /**
   * Maximum number of results to return. It must be between 1 and 20,
   * inclusively. The default is 20.  If the number is unset, it falls back to
   * the upper limit. If the number is set to negative or exceeds the upper
   * limit, an INVALID_ARGUMENT error is returned.
   */
  maxResultCount: number;
  /**
   * Used to restrict the search to places that are marked as certain price
   * levels. Users can choose any combinations of price levels. Default to
   * select all price levels.
   */
  priceLevels: PriceLevel[];
  /**
   * Used to set strict type filtering for included_type. If set to true, only
   * results of the same type will be returned. Default to false.
   */
  strictTypeFiltering: boolean;
  /**
   * The region to search. This location serves as a bias which means results
   * around given location might be returned. Cannot be set along with
   * location_restriction.
   */
  locationBias:
    | SearchTextRequest_LocationBias
    | undefined;
  /**
   * The region to search. This location serves as a restriction which means
   * results outside given location will not be returned. Cannot be set along
   * with location_bias.
   */
  locationRestriction:
    | SearchTextRequest_LocationRestriction
    | undefined;
  /** Optional. Set the searchable EV options of a place search request. */
  evOptions:
    | SearchTextRequest_EVOptions
    | undefined;
  /** Optional. Additional parameters for routing to results. */
  routingParameters:
    | RoutingParameters
    | undefined;
  /** Optional. Additional parameters proto for searching along a route. */
  searchAlongRouteParameters: SearchTextRequest_SearchAlongRouteParameters | undefined;
}

/** How results will be ranked in the response. */
export enum SearchTextRequest_RankPreference {
  /**
   * RANK_PREFERENCE_UNSPECIFIED - For a categorical query such as "Restaurants in New York City", RELEVANCE
   * is the default. For non-categorical queries such as "Mountain View, CA"
   * we recommend that you leave rankPreference unset.
   */
  RANK_PREFERENCE_UNSPECIFIED = 0,
  /** DISTANCE - Ranks results by distance. */
  DISTANCE = 1,
  /**
   * RELEVANCE - Ranks results by relevance. Sort order determined by normal ranking
   * stack.
   */
  RELEVANCE = 2,
  UNRECOGNIZED = -1,
}

export function searchTextRequest_RankPreferenceFromJSON(object: any): SearchTextRequest_RankPreference {
  switch (object) {
    case 0:
    case "RANK_PREFERENCE_UNSPECIFIED":
      return SearchTextRequest_RankPreference.RANK_PREFERENCE_UNSPECIFIED;
    case 1:
    case "DISTANCE":
      return SearchTextRequest_RankPreference.DISTANCE;
    case 2:
    case "RELEVANCE":
      return SearchTextRequest_RankPreference.RELEVANCE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SearchTextRequest_RankPreference.UNRECOGNIZED;
  }
}

export function searchTextRequest_RankPreferenceToJSON(object: SearchTextRequest_RankPreference): string {
  switch (object) {
    case SearchTextRequest_RankPreference.RANK_PREFERENCE_UNSPECIFIED:
      return "RANK_PREFERENCE_UNSPECIFIED";
    case SearchTextRequest_RankPreference.DISTANCE:
      return "DISTANCE";
    case SearchTextRequest_RankPreference.RELEVANCE:
      return "RELEVANCE";
    case SearchTextRequest_RankPreference.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The region to search. This location serves as a bias which means results
 * around given location might be returned.
 */
export interface SearchTextRequest_LocationBias {
  /**
   * A rectangle box defined by northeast and southwest corner.
   * `rectangle.high()` must be the northeast point of the rectangle
   * viewport. `rectangle.low()` must be the southwest point of the
   * rectangle viewport. `rectangle.low().latitude()` cannot be greater than
   * `rectangle.high().latitude()`. This will result in an empty latitude
   * range. A rectangle viewport cannot be wider than 180 degrees.
   */
  rectangle?:
    | Viewport
    | undefined;
  /** A circle defined by center point and radius. */
  circle?: Circle | undefined;
}

/**
 * The region to search. This location serves as a restriction which means
 * results outside given location will not be returned.
 */
export interface SearchTextRequest_LocationRestriction {
  /**
   * A rectangle box defined by northeast and southwest corner.
   * `rectangle.high()` must be the northeast point of the rectangle
   * viewport. `rectangle.low()` must be the southwest point of the
   * rectangle viewport. `rectangle.low().latitude()` cannot be greater than
   * `rectangle.high().latitude()`. This will result in an empty latitude
   * range. A rectangle viewport cannot be wider than 180 degrees.
   */
  rectangle?: Viewport | undefined;
}

/** Searchable EV options of a place search request. */
export interface SearchTextRequest_EVOptions {
  /**
   * Optional. Minimum required charging rate in kilowatts. A place with a
   * charging rate less than the specified rate is filtered out.
   */
  minimumChargingRateKw: number;
  /**
   * Optional. The list of preferred EV connector types. A place that does not
   * support any of the listed connector types is filtered out.
   */
  connectorTypes: EVConnectorType[];
}

/**
 * Specifies a precalculated polyline from the [Routes
 * API](https://developers.google.com/maps/documentation/routes) defining the
 * route to search. Searching along a route is similar to using the
 * `locationBias` or `locationRestriction` request option to bias the search
 * results. However, while the `locationBias` and `locationRestriction`
 * options let you specify a region to bias the search results, this option
 * lets you bias the results along a trip route.
 *
 * Results are not guaranteed to be along the route provided, but rather are
 * ranked within the search area defined by the polyline and, optionally, by
 * the `locationBias` or `locationRestriction` based on minimal detour times
 * from origin to destination. The results might be along an alternate route,
 * especially if the provided polyline does not define an optimal route from
 * origin to destination.
 */
export interface SearchTextRequest_SearchAlongRouteParameters {
  /** Required. The route polyline. */
  polyline: Polyline | undefined;
}

/** Response proto for SearchText. */
export interface SearchTextResponse {
  /** A list of places that meet the user's text search criteria. */
  places: Place[];
  /**
   * A list of routing summaries where each entry associates to the
   * corresponding place in the same index in the places field. If the routing
   * summary is not available for one of the places, it will contain an empty
   * entry. This list will have as many entries as the list of places if
   * requested.
   */
  routingSummaries: RoutingSummary[];
  /**
   * Experimental: See
   * https://developers.google.com/maps/documentation/places/web-service/experimental/places-generative
   * for more details.
   *
   * A list of contextual contents where each entry associates to the
   * corresponding place in the same index in the places field. The contents
   * that are relevant to the `text_query` in the request are preferred. If the
   * contextual content is not available for one of the places, it will return
   * non-contextual content. It will be empty only when the content is
   * unavailable for this place. This list will have as many entries as the
   * list of places if requested.
   */
  contextualContents: ContextualContent[];
}

/** Request for fetching a photo of a place using a photo resource name. */
export interface GetPhotoMediaRequest {
  /**
   * Required. The resource name of a photo media in the format:
   * `places/{place_id}/photos/{photo_reference}/media`.
   *
   * The resource name of a photo as returned in a Place object's `photos.name`
   * field comes with the format
   * `places/{place_id}/photos/{photo_reference}`. You need to append `/media`
   * at the end of the photo resource to get the photo media resource name.
   */
  name: string;
  /**
   * Optional. Specifies the maximum desired width, in pixels, of the image. If
   * the image is smaller than the values specified, the original image will be
   * returned. If the image is larger in either dimension, it will be scaled to
   * match the smaller of the two dimensions, restricted to its original aspect
   * ratio. Both the max_height_px and max_width_px properties accept an integer
   * between 1 and 4800, inclusively. If the value is not within the allowed
   * range, an INVALID_ARGUMENT error will be returned.
   *
   * At least one of max_height_px or max_width_px needs to be specified. If
   * neither max_height_px nor max_width_px is specified, an INVALID_ARGUMENT
   * error will be returned.
   */
  maxWidthPx: number;
  /**
   * Optional. Specifies the maximum desired height, in pixels, of the image. If
   * the image is smaller than the values specified, the original image will be
   * returned. If the image is larger in either dimension, it will be scaled to
   * match the smaller of the two dimensions, restricted to its original aspect
   * ratio. Both the max_height_px and max_width_px properties accept an integer
   * between 1 and 4800, inclusively. If the value is not within the allowed
   * range, an INVALID_ARGUMENT error will be returned.
   *
   * At least one of max_height_px or max_width_px needs to be specified. If
   * neither max_height_px nor max_width_px is specified, an INVALID_ARGUMENT
   * error will be returned.
   */
  maxHeightPx: number;
  /**
   * Optional. If set, skip the default HTTP redirect behavior and render a text
   * format (for example, in JSON format for HTTP use case) response. If not
   * set, an HTTP redirect will be issued to redirect the call to the image
   * media. This option is ignored for non-HTTP requests.
   */
  skipHttpRedirect: boolean;
}

/** A photo media from Places API. */
export interface PhotoMedia {
  /**
   * The resource name of a photo media in the format:
   * `places/{place_id}/photos/{photo_reference}/media`.
   */
  name: string;
  /** A short-lived uri that can be used to render the photo. */
  photoUri: string;
}

/**
 * Request for fetching a Place based on its resource name, which is a string in
 * the `places/{place_id}` format.
 */
export interface GetPlaceRequest {
  /** Required. The resource name of a place, in the `places/{place_id}` format. */
  name: string;
  /**
   * Optional. Place details will be displayed with the preferred language if
   * available.
   *
   * Current list of supported languages:
   * https://developers.google.com/maps/faq#languagesupport.
   */
  languageCode: string;
  /**
   * Optional. The Unicode country/region code (CLDR) of the location where the
   * request is coming from. This parameter is used to display the place
   * details, like region-specific place name, if available. The parameter can
   * affect results based on applicable law.
   * For more information, see
   * https://www.unicode.org/cldr/charts/latest/supplemental/territory_language_information.html.
   *
   * Note that 3-digit region codes are not currently supported.
   */
  regionCode: string;
  /**
   * Optional. A string which identifies an Autocomplete session for billing
   * purposes. Must be a URL and filename safe base64 string with at most 36
   * ASCII characters in length. Otherwise an INVALID_ARGUMENT error is
   * returned.
   *
   * The session begins when the user starts typing a query, and concludes when
   * they select a place and a call to Place Details or Address Validation is
   * made. Each session can have multiple queries, followed by one Place Details
   * or Address Validation request. The credentials used for each request within
   * a session must belong to the same Google Cloud Console project. Once a
   * session has concluded, the token is no longer valid; your app must generate
   * a fresh token for each session. If the `session_token` parameter is
   * omitted, or if you reuse a session token, the session is charged as if no
   * session token was provided (each request is billed separately).
   *
   * We recommend the following guidelines:
   *
   * * Use session tokens for all Place Autocomplete calls.
   * * Generate a fresh token for each session. Using a version 4 UUID is
   *   recommended.
   * * Ensure that the credentials used for all Place Autocomplete, Place
   *   Details, and Address Validation requests within a session belong to the
   *   same Cloud Console project.
   * * Be sure to pass a unique session token for each new session. Using the
   *   same token for more than one session will result in each request being
   *   billed individually.
   */
  sessionToken: string;
}

/** Request proto for AutocompletePlaces. */
export interface AutocompletePlacesRequest {
  /** Required. The text string on which to search. */
  input: string;
  /**
   * Optional. Bias results to a specified location.
   *
   * At most one of `location_bias` or `location_restriction` should be set. If
   * neither are set, the results will be biased by IP address, meaning the IP
   * address will be mapped to an imprecise location and used as a biasing
   * signal.
   */
  locationBias:
    | AutocompletePlacesRequest_LocationBias
    | undefined;
  /**
   * Optional. Restrict results to a specified location.
   *
   * At most one of `location_bias` or `location_restriction` should be set. If
   * neither are set, the results will be biased by IP address, meaning the IP
   * address will be mapped to an imprecise location and used as a biasing
   * signal.
   */
  locationRestriction:
    | AutocompletePlacesRequest_LocationRestriction
    | undefined;
  /**
   * Optional. Included primary Place type (for example, "restaurant" or
   * "gas_station") in Place Types
   * (https://developers.google.com/maps/documentation/places/web-service/place-types),
   * or only `(regions)`, or only `(cities)`. A Place is only returned if its
   * primary type is included in this list. Up to 5 values can be specified. If
   * no types are specified, all Place types are returned.
   */
  includedPrimaryTypes: string[];
  /**
   * Optional. Only include results in the specified regions, specified as up to
   * 15 CLDR two-character region codes. An empty set will not restrict the
   * results. If both `location_restriction` and `included_region_codes` are
   * set, the results will be located in the area of intersection.
   */
  includedRegionCodes: string[];
  /**
   * Optional. The language in which to return results. Defaults to en-US. The
   * results may be in mixed languages if the language used in `input` is
   * different from `language_code` or if the returned Place does not have a
   * translation from the local language to `language_code`.
   */
  languageCode: string;
  /**
   * Optional. The region code, specified as a CLDR two-character region code.
   * This affects address formatting, result ranking, and may influence what
   * results are returned. This does not restrict results to the specified
   * region. To restrict results to a region, use `region_code_restriction`.
   */
  regionCode: string;
  /**
   * Optional. The origin point from which to calculate geodesic distance to the
   * destination (returned as `distance_meters`). If this value is omitted,
   * geodesic distance will not be returned.
   */
  origin:
    | LatLng
    | undefined;
  /**
   * Optional. A zero-based Unicode character offset of `input` indicating the
   * cursor position in `input`. The cursor position may influence what
   * predictions are returned.
   *
   * If empty, defaults to the length of `input`.
   */
  inputOffset: number;
  /**
   * Optional. If true, the response will include both Place and query
   * predictions. Otherwise the response will only return Place predictions.
   */
  includeQueryPredictions: boolean;
  /**
   * Optional. A string which identifies an Autocomplete session for billing
   * purposes. Must be a URL and filename safe base64 string with at most 36
   * ASCII characters in length. Otherwise an INVALID_ARGUMENT error is
   * returned.
   *
   * The session begins when the user starts typing a query, and concludes when
   * they select a place and a call to Place Details or Address Validation is
   * made. Each session can have multiple queries, followed by one Place Details
   * or Address Validation request. The credentials used for each request within
   * a session must belong to the same Google Cloud Console project. Once a
   * session has concluded, the token is no longer valid; your app must generate
   * a fresh token for each session. If the `session_token` parameter is
   * omitted, or if you reuse a session token, the session is charged as if no
   * session token was provided (each request is billed separately).
   *
   * We recommend the following guidelines:
   *
   * * Use session tokens for all Place Autocomplete calls.
   * * Generate a fresh token for each session. Using a version 4 UUID is
   *   recommended.
   * * Ensure that the credentials used for all Place Autocomplete, Place
   *   Details, and Address Validation requests within a session belong to the
   *   same Cloud Console project.
   * * Be sure to pass a unique session token for each new session. Using the
   *   same token for more than one session will result in each request being
   *   billed individually.
   */
  sessionToken: string;
}

/**
 * The region to search. The results may be biased around the specified
 * region.
 */
export interface AutocompletePlacesRequest_LocationBias {
  /** A viewport defined by a northeast and a southwest corner. */
  rectangle?:
    | Viewport
    | undefined;
  /** A circle defined by a center point and radius. */
  circle?: Circle | undefined;
}

/**
 * The region to search. The results will be restricted to the specified
 * region.
 */
export interface AutocompletePlacesRequest_LocationRestriction {
  /** A viewport defined by a northeast and a southwest corner. */
  rectangle?:
    | Viewport
    | undefined;
  /** A circle defined by a center point and radius. */
  circle?: Circle | undefined;
}

/** Response proto for AutocompletePlaces. */
export interface AutocompletePlacesResponse {
  /** Contains a list of suggestions, ordered in descending order of relevance. */
  suggestions: AutocompletePlacesResponse_Suggestion[];
}

/** An Autocomplete suggestion result. */
export interface AutocompletePlacesResponse_Suggestion {
  /** A prediction for a Place. */
  placePrediction?:
    | AutocompletePlacesResponse_Suggestion_PlacePrediction
    | undefined;
  /** A prediction for a query. */
  queryPrediction?: AutocompletePlacesResponse_Suggestion_QueryPrediction | undefined;
}

/** Identifies a substring within a given text. */
export interface AutocompletePlacesResponse_Suggestion_StringRange {
  /**
   * Zero-based offset of the first Unicode character of the string
   * (inclusive).
   */
  startOffset: number;
  /** Zero-based offset of the last Unicode character (exclusive). */
  endOffset: number;
}

/**
 * Text representing a Place or query prediction. The text may be used as is
 * or formatted.
 */
export interface AutocompletePlacesResponse_Suggestion_FormattableText {
  /** Text that may be used as is or formatted with `matches`. */
  text: string;
  /**
   * A list of string ranges identifying where the input request matched in
   * `text`. The ranges can be used to format specific parts of `text`. The
   * substrings may not be exact matches of `input` if the matching was
   * determined by criteria other than string matching (for example, spell
   * corrections or transliterations).
   *
   * These values are Unicode character offsets of `text`. The ranges are
   * guaranteed to be ordered in increasing offset values.
   */
  matches: AutocompletePlacesResponse_Suggestion_StringRange[];
}

/**
 * Contains a breakdown of a Place or query prediction into main text
 * and secondary text.
 *
 * For Place predictions, the main text contains the specific name of the
 * Place. For query predictions, the main text contains the query.
 *
 * The secondary text contains additional disambiguating features (such as a
 * city or region) to further identify the Place or refine the query.
 */
export interface AutocompletePlacesResponse_Suggestion_StructuredFormat {
  /** Represents the name of the Place or query. */
  mainText:
    | AutocompletePlacesResponse_Suggestion_FormattableText
    | undefined;
  /**
   * Represents additional disambiguating features (such as a city or
   * region) to further identify the Place or refine the query.
   */
  secondaryText: AutocompletePlacesResponse_Suggestion_FormattableText | undefined;
}

/** Prediction results for a Place Autocomplete prediction. */
export interface AutocompletePlacesResponse_Suggestion_PlacePrediction {
  /**
   * The resource name of the suggested Place. This name can be used in
   * other APIs that accept Place names.
   */
  place: string;
  /**
   * The unique identifier of the suggested Place. This identifier can be
   * used in other APIs that accept Place IDs.
   */
  placeId: string;
  /**
   * Contains the human-readable name for the returned result. For
   * establishment results, this is usually the business name and address.
   *
   * `text` is recommended for developers who wish to show a single UI
   * element. Developers who wish to show two separate, but related, UI
   * elements may want to use `structured_format` instead. They are two
   * different ways to represent a Place prediction. Users should not try to
   * parse `structured_format` into `text` or vice versa.
   *
   * This text may be different from the `display_name` returned by
   * GetPlace.
   *
   * May be in mixed languages if the request `input` and `language_code`
   * are in different languages or if the Place does not have a translation
   * from the local language to `language_code`.
   */
  text:
    | AutocompletePlacesResponse_Suggestion_FormattableText
    | undefined;
  /**
   * A breakdown of the Place prediction into main text containing the name
   * of the Place and secondary text containing additional disambiguating
   * features (such as a city or region).
   *
   * `structured_format` is recommended for developers who wish to show two
   * separate, but related, UI elements. Developers who wish to show a
   * single UI element may want to use `text` instead. They are two
   * different ways to represent a Place prediction. Users should not try to
   * parse `structured_format` into `text` or vice versa.
   */
  structuredFormat:
    | AutocompletePlacesResponse_Suggestion_StructuredFormat
    | undefined;
  /**
   * List of types that apply to this Place from Table A or Table B in
   * https://developers.google.com/maps/documentation/places/web-service/place-types.
   *
   * A type is a categorization of a Place. Places with shared types will
   * share similar characteristics.
   */
  types: string[];
  /**
   * The length of the geodesic in meters from `origin` if `origin` is
   * specified. Certain predictions such as routes may not populate this
   * field.
   */
  distanceMeters: number;
}

/** Prediction results for a Query Autocomplete prediction. */
export interface AutocompletePlacesResponse_Suggestion_QueryPrediction {
  /**
   * The predicted text. This text does not represent a Place, but rather a
   * text query that could be used in a search endpoint (for example,
   * Text Search).
   *
   * `text` is recommended for developers who wish to show a single UI
   * element. Developers who wish to show two separate, but related, UI
   * elements may want to use `structured_format` instead. They are two
   * different ways to represent a query prediction. Users should not try to
   * parse `structured_format` into `text` or vice versa.
   *
   * May be in mixed languages if the request `input` and `language_code`
   * are in different languages or if part of the query does not have a
   * translation from the local language to `language_code`.
   */
  text:
    | AutocompletePlacesResponse_Suggestion_FormattableText
    | undefined;
  /**
   * A breakdown of the query prediction into main text containing the query
   * and secondary text containing additional disambiguating features (such
   * as a city or region).
   *
   * `structured_format` is recommended for developers who wish to show two
   * separate, but related, UI elements. Developers who wish to show a
   * single UI element may want to use `text` instead. They are two
   * different ways to represent a query prediction. Users should not try to
   * parse `structured_format` into `text` or vice versa.
   */
  structuredFormat: AutocompletePlacesResponse_Suggestion_StructuredFormat | undefined;
}

function createBaseRoutingParameters(): RoutingParameters {
  return { origin: undefined, travelMode: 0, routeModifiers: undefined, routingPreference: 0 };
}

export const RoutingParameters: MessageFns<RoutingParameters> = {
  encode(message: RoutingParameters, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.origin !== undefined) {
      LatLng.encode(message.origin, writer.uint32(10).fork()).join();
    }
    if (message.travelMode !== 0) {
      writer.uint32(16).int32(message.travelMode);
    }
    if (message.routeModifiers !== undefined) {
      RouteModifiers.encode(message.routeModifiers, writer.uint32(26).fork()).join();
    }
    if (message.routingPreference !== 0) {
      writer.uint32(32).int32(message.routingPreference);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoutingParameters {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoutingParameters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.origin = LatLng.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.travelMode = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.routeModifiers = RouteModifiers.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.routingPreference = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoutingParameters {
    return {
      origin: isSet(object.origin) ? LatLng.fromJSON(object.origin) : undefined,
      travelMode: isSet(object.travelMode) ? travelModeFromJSON(object.travelMode) : 0,
      routeModifiers: isSet(object.routeModifiers) ? RouteModifiers.fromJSON(object.routeModifiers) : undefined,
      routingPreference: isSet(object.routingPreference) ? routingPreferenceFromJSON(object.routingPreference) : 0,
    };
  },

  toJSON(message: RoutingParameters): unknown {
    const obj: any = {};
    if (message.origin !== undefined) {
      obj.origin = LatLng.toJSON(message.origin);
    }
    if (message.travelMode !== 0) {
      obj.travelMode = travelModeToJSON(message.travelMode);
    }
    if (message.routeModifiers !== undefined) {
      obj.routeModifiers = RouteModifiers.toJSON(message.routeModifiers);
    }
    if (message.routingPreference !== 0) {
      obj.routingPreference = routingPreferenceToJSON(message.routingPreference);
    }
    return obj;
  },

  create(base?: DeepPartial<RoutingParameters>): RoutingParameters {
    return RoutingParameters.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RoutingParameters>): RoutingParameters {
    const message = createBaseRoutingParameters();
    message.origin = (object.origin !== undefined && object.origin !== null)
      ? LatLng.fromPartial(object.origin)
      : undefined;
    message.travelMode = object.travelMode ?? 0;
    message.routeModifiers = (object.routeModifiers !== undefined && object.routeModifiers !== null)
      ? RouteModifiers.fromPartial(object.routeModifiers)
      : undefined;
    message.routingPreference = object.routingPreference ?? 0;
    return message;
  },
};

function createBaseSearchNearbyRequest(): SearchNearbyRequest {
  return {
    languageCode: "",
    regionCode: "",
    includedTypes: [],
    excludedTypes: [],
    includedPrimaryTypes: [],
    excludedPrimaryTypes: [],
    maxResultCount: 0,
    locationRestriction: undefined,
    rankPreference: 0,
    routingParameters: undefined,
  };
}

export const SearchNearbyRequest: MessageFns<SearchNearbyRequest> = {
  encode(message: SearchNearbyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.languageCode !== "") {
      writer.uint32(10).string(message.languageCode);
    }
    if (message.regionCode !== "") {
      writer.uint32(18).string(message.regionCode);
    }
    for (const v of message.includedTypes) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.excludedTypes) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.includedPrimaryTypes) {
      writer.uint32(42).string(v!);
    }
    for (const v of message.excludedPrimaryTypes) {
      writer.uint32(50).string(v!);
    }
    if (message.maxResultCount !== 0) {
      writer.uint32(56).int32(message.maxResultCount);
    }
    if (message.locationRestriction !== undefined) {
      SearchNearbyRequest_LocationRestriction.encode(message.locationRestriction, writer.uint32(66).fork()).join();
    }
    if (message.rankPreference !== 0) {
      writer.uint32(72).int32(message.rankPreference);
    }
    if (message.routingParameters !== undefined) {
      RoutingParameters.encode(message.routingParameters, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchNearbyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchNearbyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.regionCode = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.includedTypes.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.excludedTypes.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.includedPrimaryTypes.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.excludedPrimaryTypes.push(reader.string());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.maxResultCount = reader.int32();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.locationRestriction = SearchNearbyRequest_LocationRestriction.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.rankPreference = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.routingParameters = RoutingParameters.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchNearbyRequest {
    return {
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
      regionCode: isSet(object.regionCode) ? globalThis.String(object.regionCode) : "",
      includedTypes: globalThis.Array.isArray(object?.includedTypes)
        ? object.includedTypes.map((e: any) => globalThis.String(e))
        : [],
      excludedTypes: globalThis.Array.isArray(object?.excludedTypes)
        ? object.excludedTypes.map((e: any) => globalThis.String(e))
        : [],
      includedPrimaryTypes: globalThis.Array.isArray(object?.includedPrimaryTypes)
        ? object.includedPrimaryTypes.map((e: any) => globalThis.String(e))
        : [],
      excludedPrimaryTypes: globalThis.Array.isArray(object?.excludedPrimaryTypes)
        ? object.excludedPrimaryTypes.map((e: any) => globalThis.String(e))
        : [],
      maxResultCount: isSet(object.maxResultCount) ? globalThis.Number(object.maxResultCount) : 0,
      locationRestriction: isSet(object.locationRestriction)
        ? SearchNearbyRequest_LocationRestriction.fromJSON(object.locationRestriction)
        : undefined,
      rankPreference: isSet(object.rankPreference)
        ? searchNearbyRequest_RankPreferenceFromJSON(object.rankPreference)
        : 0,
      routingParameters: isSet(object.routingParameters)
        ? RoutingParameters.fromJSON(object.routingParameters)
        : undefined,
    };
  },

  toJSON(message: SearchNearbyRequest): unknown {
    const obj: any = {};
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (message.regionCode !== "") {
      obj.regionCode = message.regionCode;
    }
    if (message.includedTypes?.length) {
      obj.includedTypes = message.includedTypes;
    }
    if (message.excludedTypes?.length) {
      obj.excludedTypes = message.excludedTypes;
    }
    if (message.includedPrimaryTypes?.length) {
      obj.includedPrimaryTypes = message.includedPrimaryTypes;
    }
    if (message.excludedPrimaryTypes?.length) {
      obj.excludedPrimaryTypes = message.excludedPrimaryTypes;
    }
    if (message.maxResultCount !== 0) {
      obj.maxResultCount = Math.round(message.maxResultCount);
    }
    if (message.locationRestriction !== undefined) {
      obj.locationRestriction = SearchNearbyRequest_LocationRestriction.toJSON(message.locationRestriction);
    }
    if (message.rankPreference !== 0) {
      obj.rankPreference = searchNearbyRequest_RankPreferenceToJSON(message.rankPreference);
    }
    if (message.routingParameters !== undefined) {
      obj.routingParameters = RoutingParameters.toJSON(message.routingParameters);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchNearbyRequest>): SearchNearbyRequest {
    return SearchNearbyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchNearbyRequest>): SearchNearbyRequest {
    const message = createBaseSearchNearbyRequest();
    message.languageCode = object.languageCode ?? "";
    message.regionCode = object.regionCode ?? "";
    message.includedTypes = object.includedTypes?.map((e) => e) || [];
    message.excludedTypes = object.excludedTypes?.map((e) => e) || [];
    message.includedPrimaryTypes = object.includedPrimaryTypes?.map((e) => e) || [];
    message.excludedPrimaryTypes = object.excludedPrimaryTypes?.map((e) => e) || [];
    message.maxResultCount = object.maxResultCount ?? 0;
    message.locationRestriction = (object.locationRestriction !== undefined && object.locationRestriction !== null)
      ? SearchNearbyRequest_LocationRestriction.fromPartial(object.locationRestriction)
      : undefined;
    message.rankPreference = object.rankPreference ?? 0;
    message.routingParameters = (object.routingParameters !== undefined && object.routingParameters !== null)
      ? RoutingParameters.fromPartial(object.routingParameters)
      : undefined;
    return message;
  },
};

function createBaseSearchNearbyRequest_LocationRestriction(): SearchNearbyRequest_LocationRestriction {
  return { circle: undefined };
}

export const SearchNearbyRequest_LocationRestriction: MessageFns<SearchNearbyRequest_LocationRestriction> = {
  encode(message: SearchNearbyRequest_LocationRestriction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.circle !== undefined) {
      Circle.encode(message.circle, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchNearbyRequest_LocationRestriction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchNearbyRequest_LocationRestriction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.circle = Circle.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchNearbyRequest_LocationRestriction {
    return { circle: isSet(object.circle) ? Circle.fromJSON(object.circle) : undefined };
  },

  toJSON(message: SearchNearbyRequest_LocationRestriction): unknown {
    const obj: any = {};
    if (message.circle !== undefined) {
      obj.circle = Circle.toJSON(message.circle);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchNearbyRequest_LocationRestriction>): SearchNearbyRequest_LocationRestriction {
    return SearchNearbyRequest_LocationRestriction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchNearbyRequest_LocationRestriction>): SearchNearbyRequest_LocationRestriction {
    const message = createBaseSearchNearbyRequest_LocationRestriction();
    message.circle = (object.circle !== undefined && object.circle !== null)
      ? Circle.fromPartial(object.circle)
      : undefined;
    return message;
  },
};

function createBaseSearchNearbyResponse(): SearchNearbyResponse {
  return { places: [], routingSummaries: [] };
}

export const SearchNearbyResponse: MessageFns<SearchNearbyResponse> = {
  encode(message: SearchNearbyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.places) {
      Place.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.routingSummaries) {
      RoutingSummary.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchNearbyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchNearbyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.places.push(Place.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.routingSummaries.push(RoutingSummary.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchNearbyResponse {
    return {
      places: globalThis.Array.isArray(object?.places) ? object.places.map((e: any) => Place.fromJSON(e)) : [],
      routingSummaries: globalThis.Array.isArray(object?.routingSummaries)
        ? object.routingSummaries.map((e: any) => RoutingSummary.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SearchNearbyResponse): unknown {
    const obj: any = {};
    if (message.places?.length) {
      obj.places = message.places.map((e) => Place.toJSON(e));
    }
    if (message.routingSummaries?.length) {
      obj.routingSummaries = message.routingSummaries.map((e) => RoutingSummary.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SearchNearbyResponse>): SearchNearbyResponse {
    return SearchNearbyResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchNearbyResponse>): SearchNearbyResponse {
    const message = createBaseSearchNearbyResponse();
    message.places = object.places?.map((e) => Place.fromPartial(e)) || [];
    message.routingSummaries = object.routingSummaries?.map((e) => RoutingSummary.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSearchTextRequest(): SearchTextRequest {
  return {
    textQuery: "",
    languageCode: "",
    regionCode: "",
    rankPreference: 0,
    includedType: "",
    openNow: false,
    minRating: 0,
    maxResultCount: 0,
    priceLevels: [],
    strictTypeFiltering: false,
    locationBias: undefined,
    locationRestriction: undefined,
    evOptions: undefined,
    routingParameters: undefined,
    searchAlongRouteParameters: undefined,
  };
}

export const SearchTextRequest: MessageFns<SearchTextRequest> = {
  encode(message: SearchTextRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.textQuery !== "") {
      writer.uint32(10).string(message.textQuery);
    }
    if (message.languageCode !== "") {
      writer.uint32(18).string(message.languageCode);
    }
    if (message.regionCode !== "") {
      writer.uint32(26).string(message.regionCode);
    }
    if (message.rankPreference !== 0) {
      writer.uint32(32).int32(message.rankPreference);
    }
    if (message.includedType !== "") {
      writer.uint32(50).string(message.includedType);
    }
    if (message.openNow !== false) {
      writer.uint32(56).bool(message.openNow);
    }
    if (message.minRating !== 0) {
      writer.uint32(73).double(message.minRating);
    }
    if (message.maxResultCount !== 0) {
      writer.uint32(80).int32(message.maxResultCount);
    }
    writer.uint32(90).fork();
    for (const v of message.priceLevels) {
      writer.int32(v);
    }
    writer.join();
    if (message.strictTypeFiltering !== false) {
      writer.uint32(96).bool(message.strictTypeFiltering);
    }
    if (message.locationBias !== undefined) {
      SearchTextRequest_LocationBias.encode(message.locationBias, writer.uint32(106).fork()).join();
    }
    if (message.locationRestriction !== undefined) {
      SearchTextRequest_LocationRestriction.encode(message.locationRestriction, writer.uint32(114).fork()).join();
    }
    if (message.evOptions !== undefined) {
      SearchTextRequest_EVOptions.encode(message.evOptions, writer.uint32(122).fork()).join();
    }
    if (message.routingParameters !== undefined) {
      RoutingParameters.encode(message.routingParameters, writer.uint32(130).fork()).join();
    }
    if (message.searchAlongRouteParameters !== undefined) {
      SearchTextRequest_SearchAlongRouteParameters.encode(message.searchAlongRouteParameters, writer.uint32(138).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchTextRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchTextRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.textQuery = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.regionCode = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.rankPreference = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.includedType = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.openNow = reader.bool();
          continue;
        case 9:
          if (tag !== 73) {
            break;
          }

          message.minRating = reader.double();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.maxResultCount = reader.int32();
          continue;
        case 11:
          if (tag === 88) {
            message.priceLevels.push(reader.int32() as any);

            continue;
          }

          if (tag === 90) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.priceLevels.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.strictTypeFiltering = reader.bool();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.locationBias = SearchTextRequest_LocationBias.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.locationRestriction = SearchTextRequest_LocationRestriction.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.evOptions = SearchTextRequest_EVOptions.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.routingParameters = RoutingParameters.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.searchAlongRouteParameters = SearchTextRequest_SearchAlongRouteParameters.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchTextRequest {
    return {
      textQuery: isSet(object.textQuery) ? globalThis.String(object.textQuery) : "",
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
      regionCode: isSet(object.regionCode) ? globalThis.String(object.regionCode) : "",
      rankPreference: isSet(object.rankPreference)
        ? searchTextRequest_RankPreferenceFromJSON(object.rankPreference)
        : 0,
      includedType: isSet(object.includedType) ? globalThis.String(object.includedType) : "",
      openNow: isSet(object.openNow) ? globalThis.Boolean(object.openNow) : false,
      minRating: isSet(object.minRating) ? globalThis.Number(object.minRating) : 0,
      maxResultCount: isSet(object.maxResultCount) ? globalThis.Number(object.maxResultCount) : 0,
      priceLevels: globalThis.Array.isArray(object?.priceLevels)
        ? object.priceLevels.map((e: any) => priceLevelFromJSON(e))
        : [],
      strictTypeFiltering: isSet(object.strictTypeFiltering) ? globalThis.Boolean(object.strictTypeFiltering) : false,
      locationBias: isSet(object.locationBias)
        ? SearchTextRequest_LocationBias.fromJSON(object.locationBias)
        : undefined,
      locationRestriction: isSet(object.locationRestriction)
        ? SearchTextRequest_LocationRestriction.fromJSON(object.locationRestriction)
        : undefined,
      evOptions: isSet(object.evOptions) ? SearchTextRequest_EVOptions.fromJSON(object.evOptions) : undefined,
      routingParameters: isSet(object.routingParameters)
        ? RoutingParameters.fromJSON(object.routingParameters)
        : undefined,
      searchAlongRouteParameters: isSet(object.searchAlongRouteParameters)
        ? SearchTextRequest_SearchAlongRouteParameters.fromJSON(object.searchAlongRouteParameters)
        : undefined,
    };
  },

  toJSON(message: SearchTextRequest): unknown {
    const obj: any = {};
    if (message.textQuery !== "") {
      obj.textQuery = message.textQuery;
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (message.regionCode !== "") {
      obj.regionCode = message.regionCode;
    }
    if (message.rankPreference !== 0) {
      obj.rankPreference = searchTextRequest_RankPreferenceToJSON(message.rankPreference);
    }
    if (message.includedType !== "") {
      obj.includedType = message.includedType;
    }
    if (message.openNow !== false) {
      obj.openNow = message.openNow;
    }
    if (message.minRating !== 0) {
      obj.minRating = message.minRating;
    }
    if (message.maxResultCount !== 0) {
      obj.maxResultCount = Math.round(message.maxResultCount);
    }
    if (message.priceLevels?.length) {
      obj.priceLevels = message.priceLevels.map((e) => priceLevelToJSON(e));
    }
    if (message.strictTypeFiltering !== false) {
      obj.strictTypeFiltering = message.strictTypeFiltering;
    }
    if (message.locationBias !== undefined) {
      obj.locationBias = SearchTextRequest_LocationBias.toJSON(message.locationBias);
    }
    if (message.locationRestriction !== undefined) {
      obj.locationRestriction = SearchTextRequest_LocationRestriction.toJSON(message.locationRestriction);
    }
    if (message.evOptions !== undefined) {
      obj.evOptions = SearchTextRequest_EVOptions.toJSON(message.evOptions);
    }
    if (message.routingParameters !== undefined) {
      obj.routingParameters = RoutingParameters.toJSON(message.routingParameters);
    }
    if (message.searchAlongRouteParameters !== undefined) {
      obj.searchAlongRouteParameters = SearchTextRequest_SearchAlongRouteParameters.toJSON(
        message.searchAlongRouteParameters,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<SearchTextRequest>): SearchTextRequest {
    return SearchTextRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchTextRequest>): SearchTextRequest {
    const message = createBaseSearchTextRequest();
    message.textQuery = object.textQuery ?? "";
    message.languageCode = object.languageCode ?? "";
    message.regionCode = object.regionCode ?? "";
    message.rankPreference = object.rankPreference ?? 0;
    message.includedType = object.includedType ?? "";
    message.openNow = object.openNow ?? false;
    message.minRating = object.minRating ?? 0;
    message.maxResultCount = object.maxResultCount ?? 0;
    message.priceLevels = object.priceLevels?.map((e) => e) || [];
    message.strictTypeFiltering = object.strictTypeFiltering ?? false;
    message.locationBias = (object.locationBias !== undefined && object.locationBias !== null)
      ? SearchTextRequest_LocationBias.fromPartial(object.locationBias)
      : undefined;
    message.locationRestriction = (object.locationRestriction !== undefined && object.locationRestriction !== null)
      ? SearchTextRequest_LocationRestriction.fromPartial(object.locationRestriction)
      : undefined;
    message.evOptions = (object.evOptions !== undefined && object.evOptions !== null)
      ? SearchTextRequest_EVOptions.fromPartial(object.evOptions)
      : undefined;
    message.routingParameters = (object.routingParameters !== undefined && object.routingParameters !== null)
      ? RoutingParameters.fromPartial(object.routingParameters)
      : undefined;
    message.searchAlongRouteParameters =
      (object.searchAlongRouteParameters !== undefined && object.searchAlongRouteParameters !== null)
        ? SearchTextRequest_SearchAlongRouteParameters.fromPartial(object.searchAlongRouteParameters)
        : undefined;
    return message;
  },
};

function createBaseSearchTextRequest_LocationBias(): SearchTextRequest_LocationBias {
  return { rectangle: undefined, circle: undefined };
}

export const SearchTextRequest_LocationBias: MessageFns<SearchTextRequest_LocationBias> = {
  encode(message: SearchTextRequest_LocationBias, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rectangle !== undefined) {
      Viewport.encode(message.rectangle, writer.uint32(10).fork()).join();
    }
    if (message.circle !== undefined) {
      Circle.encode(message.circle, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchTextRequest_LocationBias {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchTextRequest_LocationBias();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rectangle = Viewport.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.circle = Circle.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchTextRequest_LocationBias {
    return {
      rectangle: isSet(object.rectangle) ? Viewport.fromJSON(object.rectangle) : undefined,
      circle: isSet(object.circle) ? Circle.fromJSON(object.circle) : undefined,
    };
  },

  toJSON(message: SearchTextRequest_LocationBias): unknown {
    const obj: any = {};
    if (message.rectangle !== undefined) {
      obj.rectangle = Viewport.toJSON(message.rectangle);
    }
    if (message.circle !== undefined) {
      obj.circle = Circle.toJSON(message.circle);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchTextRequest_LocationBias>): SearchTextRequest_LocationBias {
    return SearchTextRequest_LocationBias.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchTextRequest_LocationBias>): SearchTextRequest_LocationBias {
    const message = createBaseSearchTextRequest_LocationBias();
    message.rectangle = (object.rectangle !== undefined && object.rectangle !== null)
      ? Viewport.fromPartial(object.rectangle)
      : undefined;
    message.circle = (object.circle !== undefined && object.circle !== null)
      ? Circle.fromPartial(object.circle)
      : undefined;
    return message;
  },
};

function createBaseSearchTextRequest_LocationRestriction(): SearchTextRequest_LocationRestriction {
  return { rectangle: undefined };
}

export const SearchTextRequest_LocationRestriction: MessageFns<SearchTextRequest_LocationRestriction> = {
  encode(message: SearchTextRequest_LocationRestriction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rectangle !== undefined) {
      Viewport.encode(message.rectangle, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchTextRequest_LocationRestriction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchTextRequest_LocationRestriction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rectangle = Viewport.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchTextRequest_LocationRestriction {
    return { rectangle: isSet(object.rectangle) ? Viewport.fromJSON(object.rectangle) : undefined };
  },

  toJSON(message: SearchTextRequest_LocationRestriction): unknown {
    const obj: any = {};
    if (message.rectangle !== undefined) {
      obj.rectangle = Viewport.toJSON(message.rectangle);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchTextRequest_LocationRestriction>): SearchTextRequest_LocationRestriction {
    return SearchTextRequest_LocationRestriction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchTextRequest_LocationRestriction>): SearchTextRequest_LocationRestriction {
    const message = createBaseSearchTextRequest_LocationRestriction();
    message.rectangle = (object.rectangle !== undefined && object.rectangle !== null)
      ? Viewport.fromPartial(object.rectangle)
      : undefined;
    return message;
  },
};

function createBaseSearchTextRequest_EVOptions(): SearchTextRequest_EVOptions {
  return { minimumChargingRateKw: 0, connectorTypes: [] };
}

export const SearchTextRequest_EVOptions: MessageFns<SearchTextRequest_EVOptions> = {
  encode(message: SearchTextRequest_EVOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.minimumChargingRateKw !== 0) {
      writer.uint32(9).double(message.minimumChargingRateKw);
    }
    writer.uint32(18).fork();
    for (const v of message.connectorTypes) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchTextRequest_EVOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchTextRequest_EVOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.minimumChargingRateKw = reader.double();
          continue;
        case 2:
          if (tag === 16) {
            message.connectorTypes.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.connectorTypes.push(reader.int32() as any);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchTextRequest_EVOptions {
    return {
      minimumChargingRateKw: isSet(object.minimumChargingRateKw) ? globalThis.Number(object.minimumChargingRateKw) : 0,
      connectorTypes: globalThis.Array.isArray(object?.connectorTypes)
        ? object.connectorTypes.map((e: any) => eVConnectorTypeFromJSON(e))
        : [],
    };
  },

  toJSON(message: SearchTextRequest_EVOptions): unknown {
    const obj: any = {};
    if (message.minimumChargingRateKw !== 0) {
      obj.minimumChargingRateKw = message.minimumChargingRateKw;
    }
    if (message.connectorTypes?.length) {
      obj.connectorTypes = message.connectorTypes.map((e) => eVConnectorTypeToJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SearchTextRequest_EVOptions>): SearchTextRequest_EVOptions {
    return SearchTextRequest_EVOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchTextRequest_EVOptions>): SearchTextRequest_EVOptions {
    const message = createBaseSearchTextRequest_EVOptions();
    message.minimumChargingRateKw = object.minimumChargingRateKw ?? 0;
    message.connectorTypes = object.connectorTypes?.map((e) => e) || [];
    return message;
  },
};

function createBaseSearchTextRequest_SearchAlongRouteParameters(): SearchTextRequest_SearchAlongRouteParameters {
  return { polyline: undefined };
}

export const SearchTextRequest_SearchAlongRouteParameters: MessageFns<SearchTextRequest_SearchAlongRouteParameters> = {
  encode(
    message: SearchTextRequest_SearchAlongRouteParameters,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.polyline !== undefined) {
      Polyline.encode(message.polyline, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchTextRequest_SearchAlongRouteParameters {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchTextRequest_SearchAlongRouteParameters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.polyline = Polyline.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchTextRequest_SearchAlongRouteParameters {
    return { polyline: isSet(object.polyline) ? Polyline.fromJSON(object.polyline) : undefined };
  },

  toJSON(message: SearchTextRequest_SearchAlongRouteParameters): unknown {
    const obj: any = {};
    if (message.polyline !== undefined) {
      obj.polyline = Polyline.toJSON(message.polyline);
    }
    return obj;
  },

  create(
    base?: DeepPartial<SearchTextRequest_SearchAlongRouteParameters>,
  ): SearchTextRequest_SearchAlongRouteParameters {
    return SearchTextRequest_SearchAlongRouteParameters.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SearchTextRequest_SearchAlongRouteParameters>,
  ): SearchTextRequest_SearchAlongRouteParameters {
    const message = createBaseSearchTextRequest_SearchAlongRouteParameters();
    message.polyline = (object.polyline !== undefined && object.polyline !== null)
      ? Polyline.fromPartial(object.polyline)
      : undefined;
    return message;
  },
};

function createBaseSearchTextResponse(): SearchTextResponse {
  return { places: [], routingSummaries: [], contextualContents: [] };
}

export const SearchTextResponse: MessageFns<SearchTextResponse> = {
  encode(message: SearchTextResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.places) {
      Place.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.routingSummaries) {
      RoutingSummary.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.contextualContents) {
      ContextualContent.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchTextResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchTextResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.places.push(Place.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.routingSummaries.push(RoutingSummary.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.contextualContents.push(ContextualContent.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchTextResponse {
    return {
      places: globalThis.Array.isArray(object?.places) ? object.places.map((e: any) => Place.fromJSON(e)) : [],
      routingSummaries: globalThis.Array.isArray(object?.routingSummaries)
        ? object.routingSummaries.map((e: any) => RoutingSummary.fromJSON(e))
        : [],
      contextualContents: globalThis.Array.isArray(object?.contextualContents)
        ? object.contextualContents.map((e: any) => ContextualContent.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SearchTextResponse): unknown {
    const obj: any = {};
    if (message.places?.length) {
      obj.places = message.places.map((e) => Place.toJSON(e));
    }
    if (message.routingSummaries?.length) {
      obj.routingSummaries = message.routingSummaries.map((e) => RoutingSummary.toJSON(e));
    }
    if (message.contextualContents?.length) {
      obj.contextualContents = message.contextualContents.map((e) => ContextualContent.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SearchTextResponse>): SearchTextResponse {
    return SearchTextResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchTextResponse>): SearchTextResponse {
    const message = createBaseSearchTextResponse();
    message.places = object.places?.map((e) => Place.fromPartial(e)) || [];
    message.routingSummaries = object.routingSummaries?.map((e) => RoutingSummary.fromPartial(e)) || [];
    message.contextualContents = object.contextualContents?.map((e) => ContextualContent.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetPhotoMediaRequest(): GetPhotoMediaRequest {
  return { name: "", maxWidthPx: 0, maxHeightPx: 0, skipHttpRedirect: false };
}

export const GetPhotoMediaRequest: MessageFns<GetPhotoMediaRequest> = {
  encode(message: GetPhotoMediaRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.maxWidthPx !== 0) {
      writer.uint32(16).int32(message.maxWidthPx);
    }
    if (message.maxHeightPx !== 0) {
      writer.uint32(24).int32(message.maxHeightPx);
    }
    if (message.skipHttpRedirect !== false) {
      writer.uint32(32).bool(message.skipHttpRedirect);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPhotoMediaRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPhotoMediaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.maxWidthPx = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.maxHeightPx = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.skipHttpRedirect = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPhotoMediaRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      maxWidthPx: isSet(object.maxWidthPx) ? globalThis.Number(object.maxWidthPx) : 0,
      maxHeightPx: isSet(object.maxHeightPx) ? globalThis.Number(object.maxHeightPx) : 0,
      skipHttpRedirect: isSet(object.skipHttpRedirect) ? globalThis.Boolean(object.skipHttpRedirect) : false,
    };
  },

  toJSON(message: GetPhotoMediaRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.maxWidthPx !== 0) {
      obj.maxWidthPx = Math.round(message.maxWidthPx);
    }
    if (message.maxHeightPx !== 0) {
      obj.maxHeightPx = Math.round(message.maxHeightPx);
    }
    if (message.skipHttpRedirect !== false) {
      obj.skipHttpRedirect = message.skipHttpRedirect;
    }
    return obj;
  },

  create(base?: DeepPartial<GetPhotoMediaRequest>): GetPhotoMediaRequest {
    return GetPhotoMediaRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetPhotoMediaRequest>): GetPhotoMediaRequest {
    const message = createBaseGetPhotoMediaRequest();
    message.name = object.name ?? "";
    message.maxWidthPx = object.maxWidthPx ?? 0;
    message.maxHeightPx = object.maxHeightPx ?? 0;
    message.skipHttpRedirect = object.skipHttpRedirect ?? false;
    return message;
  },
};

function createBasePhotoMedia(): PhotoMedia {
  return { name: "", photoUri: "" };
}

export const PhotoMedia: MessageFns<PhotoMedia> = {
  encode(message: PhotoMedia, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.photoUri !== "") {
      writer.uint32(18).string(message.photoUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PhotoMedia {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePhotoMedia();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.photoUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PhotoMedia {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      photoUri: isSet(object.photoUri) ? globalThis.String(object.photoUri) : "",
    };
  },

  toJSON(message: PhotoMedia): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.photoUri !== "") {
      obj.photoUri = message.photoUri;
    }
    return obj;
  },

  create(base?: DeepPartial<PhotoMedia>): PhotoMedia {
    return PhotoMedia.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PhotoMedia>): PhotoMedia {
    const message = createBasePhotoMedia();
    message.name = object.name ?? "";
    message.photoUri = object.photoUri ?? "";
    return message;
  },
};

function createBaseGetPlaceRequest(): GetPlaceRequest {
  return { name: "", languageCode: "", regionCode: "", sessionToken: "" };
}

export const GetPlaceRequest: MessageFns<GetPlaceRequest> = {
  encode(message: GetPlaceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.languageCode !== "") {
      writer.uint32(18).string(message.languageCode);
    }
    if (message.regionCode !== "") {
      writer.uint32(26).string(message.regionCode);
    }
    if (message.sessionToken !== "") {
      writer.uint32(34).string(message.sessionToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPlaceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPlaceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.regionCode = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sessionToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPlaceRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
      regionCode: isSet(object.regionCode) ? globalThis.String(object.regionCode) : "",
      sessionToken: isSet(object.sessionToken) ? globalThis.String(object.sessionToken) : "",
    };
  },

  toJSON(message: GetPlaceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (message.regionCode !== "") {
      obj.regionCode = message.regionCode;
    }
    if (message.sessionToken !== "") {
      obj.sessionToken = message.sessionToken;
    }
    return obj;
  },

  create(base?: DeepPartial<GetPlaceRequest>): GetPlaceRequest {
    return GetPlaceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetPlaceRequest>): GetPlaceRequest {
    const message = createBaseGetPlaceRequest();
    message.name = object.name ?? "";
    message.languageCode = object.languageCode ?? "";
    message.regionCode = object.regionCode ?? "";
    message.sessionToken = object.sessionToken ?? "";
    return message;
  },
};

function createBaseAutocompletePlacesRequest(): AutocompletePlacesRequest {
  return {
    input: "",
    locationBias: undefined,
    locationRestriction: undefined,
    includedPrimaryTypes: [],
    includedRegionCodes: [],
    languageCode: "",
    regionCode: "",
    origin: undefined,
    inputOffset: 0,
    includeQueryPredictions: false,
    sessionToken: "",
  };
}

export const AutocompletePlacesRequest: MessageFns<AutocompletePlacesRequest> = {
  encode(message: AutocompletePlacesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.input !== "") {
      writer.uint32(10).string(message.input);
    }
    if (message.locationBias !== undefined) {
      AutocompletePlacesRequest_LocationBias.encode(message.locationBias, writer.uint32(18).fork()).join();
    }
    if (message.locationRestriction !== undefined) {
      AutocompletePlacesRequest_LocationRestriction.encode(message.locationRestriction, writer.uint32(26).fork())
        .join();
    }
    for (const v of message.includedPrimaryTypes) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.includedRegionCodes) {
      writer.uint32(42).string(v!);
    }
    if (message.languageCode !== "") {
      writer.uint32(50).string(message.languageCode);
    }
    if (message.regionCode !== "") {
      writer.uint32(58).string(message.regionCode);
    }
    if (message.origin !== undefined) {
      LatLng.encode(message.origin, writer.uint32(66).fork()).join();
    }
    if (message.inputOffset !== 0) {
      writer.uint32(72).int32(message.inputOffset);
    }
    if (message.includeQueryPredictions !== false) {
      writer.uint32(80).bool(message.includeQueryPredictions);
    }
    if (message.sessionToken !== "") {
      writer.uint32(90).string(message.sessionToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutocompletePlacesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutocompletePlacesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.input = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.locationBias = AutocompletePlacesRequest_LocationBias.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.locationRestriction = AutocompletePlacesRequest_LocationRestriction.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.includedPrimaryTypes.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.includedRegionCodes.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.regionCode = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.origin = LatLng.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.inputOffset = reader.int32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.includeQueryPredictions = reader.bool();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.sessionToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutocompletePlacesRequest {
    return {
      input: isSet(object.input) ? globalThis.String(object.input) : "",
      locationBias: isSet(object.locationBias)
        ? AutocompletePlacesRequest_LocationBias.fromJSON(object.locationBias)
        : undefined,
      locationRestriction: isSet(object.locationRestriction)
        ? AutocompletePlacesRequest_LocationRestriction.fromJSON(object.locationRestriction)
        : undefined,
      includedPrimaryTypes: globalThis.Array.isArray(object?.includedPrimaryTypes)
        ? object.includedPrimaryTypes.map((e: any) => globalThis.String(e))
        : [],
      includedRegionCodes: globalThis.Array.isArray(object?.includedRegionCodes)
        ? object.includedRegionCodes.map((e: any) => globalThis.String(e))
        : [],
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
      regionCode: isSet(object.regionCode) ? globalThis.String(object.regionCode) : "",
      origin: isSet(object.origin) ? LatLng.fromJSON(object.origin) : undefined,
      inputOffset: isSet(object.inputOffset) ? globalThis.Number(object.inputOffset) : 0,
      includeQueryPredictions: isSet(object.includeQueryPredictions)
        ? globalThis.Boolean(object.includeQueryPredictions)
        : false,
      sessionToken: isSet(object.sessionToken) ? globalThis.String(object.sessionToken) : "",
    };
  },

  toJSON(message: AutocompletePlacesRequest): unknown {
    const obj: any = {};
    if (message.input !== "") {
      obj.input = message.input;
    }
    if (message.locationBias !== undefined) {
      obj.locationBias = AutocompletePlacesRequest_LocationBias.toJSON(message.locationBias);
    }
    if (message.locationRestriction !== undefined) {
      obj.locationRestriction = AutocompletePlacesRequest_LocationRestriction.toJSON(message.locationRestriction);
    }
    if (message.includedPrimaryTypes?.length) {
      obj.includedPrimaryTypes = message.includedPrimaryTypes;
    }
    if (message.includedRegionCodes?.length) {
      obj.includedRegionCodes = message.includedRegionCodes;
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (message.regionCode !== "") {
      obj.regionCode = message.regionCode;
    }
    if (message.origin !== undefined) {
      obj.origin = LatLng.toJSON(message.origin);
    }
    if (message.inputOffset !== 0) {
      obj.inputOffset = Math.round(message.inputOffset);
    }
    if (message.includeQueryPredictions !== false) {
      obj.includeQueryPredictions = message.includeQueryPredictions;
    }
    if (message.sessionToken !== "") {
      obj.sessionToken = message.sessionToken;
    }
    return obj;
  },

  create(base?: DeepPartial<AutocompletePlacesRequest>): AutocompletePlacesRequest {
    return AutocompletePlacesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AutocompletePlacesRequest>): AutocompletePlacesRequest {
    const message = createBaseAutocompletePlacesRequest();
    message.input = object.input ?? "";
    message.locationBias = (object.locationBias !== undefined && object.locationBias !== null)
      ? AutocompletePlacesRequest_LocationBias.fromPartial(object.locationBias)
      : undefined;
    message.locationRestriction = (object.locationRestriction !== undefined && object.locationRestriction !== null)
      ? AutocompletePlacesRequest_LocationRestriction.fromPartial(object.locationRestriction)
      : undefined;
    message.includedPrimaryTypes = object.includedPrimaryTypes?.map((e) => e) || [];
    message.includedRegionCodes = object.includedRegionCodes?.map((e) => e) || [];
    message.languageCode = object.languageCode ?? "";
    message.regionCode = object.regionCode ?? "";
    message.origin = (object.origin !== undefined && object.origin !== null)
      ? LatLng.fromPartial(object.origin)
      : undefined;
    message.inputOffset = object.inputOffset ?? 0;
    message.includeQueryPredictions = object.includeQueryPredictions ?? false;
    message.sessionToken = object.sessionToken ?? "";
    return message;
  },
};

function createBaseAutocompletePlacesRequest_LocationBias(): AutocompletePlacesRequest_LocationBias {
  return { rectangle: undefined, circle: undefined };
}

export const AutocompletePlacesRequest_LocationBias: MessageFns<AutocompletePlacesRequest_LocationBias> = {
  encode(message: AutocompletePlacesRequest_LocationBias, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rectangle !== undefined) {
      Viewport.encode(message.rectangle, writer.uint32(10).fork()).join();
    }
    if (message.circle !== undefined) {
      Circle.encode(message.circle, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutocompletePlacesRequest_LocationBias {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutocompletePlacesRequest_LocationBias();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rectangle = Viewport.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.circle = Circle.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutocompletePlacesRequest_LocationBias {
    return {
      rectangle: isSet(object.rectangle) ? Viewport.fromJSON(object.rectangle) : undefined,
      circle: isSet(object.circle) ? Circle.fromJSON(object.circle) : undefined,
    };
  },

  toJSON(message: AutocompletePlacesRequest_LocationBias): unknown {
    const obj: any = {};
    if (message.rectangle !== undefined) {
      obj.rectangle = Viewport.toJSON(message.rectangle);
    }
    if (message.circle !== undefined) {
      obj.circle = Circle.toJSON(message.circle);
    }
    return obj;
  },

  create(base?: DeepPartial<AutocompletePlacesRequest_LocationBias>): AutocompletePlacesRequest_LocationBias {
    return AutocompletePlacesRequest_LocationBias.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AutocompletePlacesRequest_LocationBias>): AutocompletePlacesRequest_LocationBias {
    const message = createBaseAutocompletePlacesRequest_LocationBias();
    message.rectangle = (object.rectangle !== undefined && object.rectangle !== null)
      ? Viewport.fromPartial(object.rectangle)
      : undefined;
    message.circle = (object.circle !== undefined && object.circle !== null)
      ? Circle.fromPartial(object.circle)
      : undefined;
    return message;
  },
};

function createBaseAutocompletePlacesRequest_LocationRestriction(): AutocompletePlacesRequest_LocationRestriction {
  return { rectangle: undefined, circle: undefined };
}

export const AutocompletePlacesRequest_LocationRestriction: MessageFns<AutocompletePlacesRequest_LocationRestriction> =
  {
    encode(
      message: AutocompletePlacesRequest_LocationRestriction,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.rectangle !== undefined) {
        Viewport.encode(message.rectangle, writer.uint32(10).fork()).join();
      }
      if (message.circle !== undefined) {
        Circle.encode(message.circle, writer.uint32(18).fork()).join();
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): AutocompletePlacesRequest_LocationRestriction {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseAutocompletePlacesRequest_LocationRestriction();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.rectangle = Viewport.decode(reader, reader.uint32());
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.circle = Circle.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): AutocompletePlacesRequest_LocationRestriction {
      return {
        rectangle: isSet(object.rectangle) ? Viewport.fromJSON(object.rectangle) : undefined,
        circle: isSet(object.circle) ? Circle.fromJSON(object.circle) : undefined,
      };
    },

    toJSON(message: AutocompletePlacesRequest_LocationRestriction): unknown {
      const obj: any = {};
      if (message.rectangle !== undefined) {
        obj.rectangle = Viewport.toJSON(message.rectangle);
      }
      if (message.circle !== undefined) {
        obj.circle = Circle.toJSON(message.circle);
      }
      return obj;
    },

    create(
      base?: DeepPartial<AutocompletePlacesRequest_LocationRestriction>,
    ): AutocompletePlacesRequest_LocationRestriction {
      return AutocompletePlacesRequest_LocationRestriction.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<AutocompletePlacesRequest_LocationRestriction>,
    ): AutocompletePlacesRequest_LocationRestriction {
      const message = createBaseAutocompletePlacesRequest_LocationRestriction();
      message.rectangle = (object.rectangle !== undefined && object.rectangle !== null)
        ? Viewport.fromPartial(object.rectangle)
        : undefined;
      message.circle = (object.circle !== undefined && object.circle !== null)
        ? Circle.fromPartial(object.circle)
        : undefined;
      return message;
    },
  };

function createBaseAutocompletePlacesResponse(): AutocompletePlacesResponse {
  return { suggestions: [] };
}

export const AutocompletePlacesResponse: MessageFns<AutocompletePlacesResponse> = {
  encode(message: AutocompletePlacesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.suggestions) {
      AutocompletePlacesResponse_Suggestion.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutocompletePlacesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutocompletePlacesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.suggestions.push(AutocompletePlacesResponse_Suggestion.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutocompletePlacesResponse {
    return {
      suggestions: globalThis.Array.isArray(object?.suggestions)
        ? object.suggestions.map((e: any) => AutocompletePlacesResponse_Suggestion.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AutocompletePlacesResponse): unknown {
    const obj: any = {};
    if (message.suggestions?.length) {
      obj.suggestions = message.suggestions.map((e) => AutocompletePlacesResponse_Suggestion.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AutocompletePlacesResponse>): AutocompletePlacesResponse {
    return AutocompletePlacesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AutocompletePlacesResponse>): AutocompletePlacesResponse {
    const message = createBaseAutocompletePlacesResponse();
    message.suggestions = object.suggestions?.map((e) => AutocompletePlacesResponse_Suggestion.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAutocompletePlacesResponse_Suggestion(): AutocompletePlacesResponse_Suggestion {
  return { placePrediction: undefined, queryPrediction: undefined };
}

export const AutocompletePlacesResponse_Suggestion: MessageFns<AutocompletePlacesResponse_Suggestion> = {
  encode(message: AutocompletePlacesResponse_Suggestion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.placePrediction !== undefined) {
      AutocompletePlacesResponse_Suggestion_PlacePrediction.encode(message.placePrediction, writer.uint32(10).fork())
        .join();
    }
    if (message.queryPrediction !== undefined) {
      AutocompletePlacesResponse_Suggestion_QueryPrediction.encode(message.queryPrediction, writer.uint32(18).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutocompletePlacesResponse_Suggestion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutocompletePlacesResponse_Suggestion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.placePrediction = AutocompletePlacesResponse_Suggestion_PlacePrediction.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.queryPrediction = AutocompletePlacesResponse_Suggestion_QueryPrediction.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutocompletePlacesResponse_Suggestion {
    return {
      placePrediction: isSet(object.placePrediction)
        ? AutocompletePlacesResponse_Suggestion_PlacePrediction.fromJSON(object.placePrediction)
        : undefined,
      queryPrediction: isSet(object.queryPrediction)
        ? AutocompletePlacesResponse_Suggestion_QueryPrediction.fromJSON(object.queryPrediction)
        : undefined,
    };
  },

  toJSON(message: AutocompletePlacesResponse_Suggestion): unknown {
    const obj: any = {};
    if (message.placePrediction !== undefined) {
      obj.placePrediction = AutocompletePlacesResponse_Suggestion_PlacePrediction.toJSON(message.placePrediction);
    }
    if (message.queryPrediction !== undefined) {
      obj.queryPrediction = AutocompletePlacesResponse_Suggestion_QueryPrediction.toJSON(message.queryPrediction);
    }
    return obj;
  },

  create(base?: DeepPartial<AutocompletePlacesResponse_Suggestion>): AutocompletePlacesResponse_Suggestion {
    return AutocompletePlacesResponse_Suggestion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AutocompletePlacesResponse_Suggestion>): AutocompletePlacesResponse_Suggestion {
    const message = createBaseAutocompletePlacesResponse_Suggestion();
    message.placePrediction = (object.placePrediction !== undefined && object.placePrediction !== null)
      ? AutocompletePlacesResponse_Suggestion_PlacePrediction.fromPartial(object.placePrediction)
      : undefined;
    message.queryPrediction = (object.queryPrediction !== undefined && object.queryPrediction !== null)
      ? AutocompletePlacesResponse_Suggestion_QueryPrediction.fromPartial(object.queryPrediction)
      : undefined;
    return message;
  },
};

function createBaseAutocompletePlacesResponse_Suggestion_StringRange(): AutocompletePlacesResponse_Suggestion_StringRange {
  return { startOffset: 0, endOffset: 0 };
}

export const AutocompletePlacesResponse_Suggestion_StringRange: MessageFns<
  AutocompletePlacesResponse_Suggestion_StringRange
> = {
  encode(
    message: AutocompletePlacesResponse_Suggestion_StringRange,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.startOffset !== 0) {
      writer.uint32(8).int32(message.startOffset);
    }
    if (message.endOffset !== 0) {
      writer.uint32(16).int32(message.endOffset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutocompletePlacesResponse_Suggestion_StringRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutocompletePlacesResponse_Suggestion_StringRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.startOffset = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.endOffset = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutocompletePlacesResponse_Suggestion_StringRange {
    return {
      startOffset: isSet(object.startOffset) ? globalThis.Number(object.startOffset) : 0,
      endOffset: isSet(object.endOffset) ? globalThis.Number(object.endOffset) : 0,
    };
  },

  toJSON(message: AutocompletePlacesResponse_Suggestion_StringRange): unknown {
    const obj: any = {};
    if (message.startOffset !== 0) {
      obj.startOffset = Math.round(message.startOffset);
    }
    if (message.endOffset !== 0) {
      obj.endOffset = Math.round(message.endOffset);
    }
    return obj;
  },

  create(
    base?: DeepPartial<AutocompletePlacesResponse_Suggestion_StringRange>,
  ): AutocompletePlacesResponse_Suggestion_StringRange {
    return AutocompletePlacesResponse_Suggestion_StringRange.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AutocompletePlacesResponse_Suggestion_StringRange>,
  ): AutocompletePlacesResponse_Suggestion_StringRange {
    const message = createBaseAutocompletePlacesResponse_Suggestion_StringRange();
    message.startOffset = object.startOffset ?? 0;
    message.endOffset = object.endOffset ?? 0;
    return message;
  },
};

function createBaseAutocompletePlacesResponse_Suggestion_FormattableText(): AutocompletePlacesResponse_Suggestion_FormattableText {
  return { text: "", matches: [] };
}

export const AutocompletePlacesResponse_Suggestion_FormattableText: MessageFns<
  AutocompletePlacesResponse_Suggestion_FormattableText
> = {
  encode(
    message: AutocompletePlacesResponse_Suggestion_FormattableText,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    for (const v of message.matches) {
      AutocompletePlacesResponse_Suggestion_StringRange.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutocompletePlacesResponse_Suggestion_FormattableText {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutocompletePlacesResponse_Suggestion_FormattableText();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.matches.push(AutocompletePlacesResponse_Suggestion_StringRange.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutocompletePlacesResponse_Suggestion_FormattableText {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      matches: globalThis.Array.isArray(object?.matches)
        ? object.matches.map((e: any) => AutocompletePlacesResponse_Suggestion_StringRange.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AutocompletePlacesResponse_Suggestion_FormattableText): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.matches?.length) {
      obj.matches = message.matches.map((e) => AutocompletePlacesResponse_Suggestion_StringRange.toJSON(e));
    }
    return obj;
  },

  create(
    base?: DeepPartial<AutocompletePlacesResponse_Suggestion_FormattableText>,
  ): AutocompletePlacesResponse_Suggestion_FormattableText {
    return AutocompletePlacesResponse_Suggestion_FormattableText.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AutocompletePlacesResponse_Suggestion_FormattableText>,
  ): AutocompletePlacesResponse_Suggestion_FormattableText {
    const message = createBaseAutocompletePlacesResponse_Suggestion_FormattableText();
    message.text = object.text ?? "";
    message.matches = object.matches?.map((e) => AutocompletePlacesResponse_Suggestion_StringRange.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseAutocompletePlacesResponse_Suggestion_StructuredFormat(): AutocompletePlacesResponse_Suggestion_StructuredFormat {
  return { mainText: undefined, secondaryText: undefined };
}

export const AutocompletePlacesResponse_Suggestion_StructuredFormat: MessageFns<
  AutocompletePlacesResponse_Suggestion_StructuredFormat
> = {
  encode(
    message: AutocompletePlacesResponse_Suggestion_StructuredFormat,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.mainText !== undefined) {
      AutocompletePlacesResponse_Suggestion_FormattableText.encode(message.mainText, writer.uint32(10).fork()).join();
    }
    if (message.secondaryText !== undefined) {
      AutocompletePlacesResponse_Suggestion_FormattableText.encode(message.secondaryText, writer.uint32(18).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutocompletePlacesResponse_Suggestion_StructuredFormat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutocompletePlacesResponse_Suggestion_StructuredFormat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.mainText = AutocompletePlacesResponse_Suggestion_FormattableText.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.secondaryText = AutocompletePlacesResponse_Suggestion_FormattableText.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutocompletePlacesResponse_Suggestion_StructuredFormat {
    return {
      mainText: isSet(object.mainText)
        ? AutocompletePlacesResponse_Suggestion_FormattableText.fromJSON(object.mainText)
        : undefined,
      secondaryText: isSet(object.secondaryText)
        ? AutocompletePlacesResponse_Suggestion_FormattableText.fromJSON(object.secondaryText)
        : undefined,
    };
  },

  toJSON(message: AutocompletePlacesResponse_Suggestion_StructuredFormat): unknown {
    const obj: any = {};
    if (message.mainText !== undefined) {
      obj.mainText = AutocompletePlacesResponse_Suggestion_FormattableText.toJSON(message.mainText);
    }
    if (message.secondaryText !== undefined) {
      obj.secondaryText = AutocompletePlacesResponse_Suggestion_FormattableText.toJSON(message.secondaryText);
    }
    return obj;
  },

  create(
    base?: DeepPartial<AutocompletePlacesResponse_Suggestion_StructuredFormat>,
  ): AutocompletePlacesResponse_Suggestion_StructuredFormat {
    return AutocompletePlacesResponse_Suggestion_StructuredFormat.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AutocompletePlacesResponse_Suggestion_StructuredFormat>,
  ): AutocompletePlacesResponse_Suggestion_StructuredFormat {
    const message = createBaseAutocompletePlacesResponse_Suggestion_StructuredFormat();
    message.mainText = (object.mainText !== undefined && object.mainText !== null)
      ? AutocompletePlacesResponse_Suggestion_FormattableText.fromPartial(object.mainText)
      : undefined;
    message.secondaryText = (object.secondaryText !== undefined && object.secondaryText !== null)
      ? AutocompletePlacesResponse_Suggestion_FormattableText.fromPartial(object.secondaryText)
      : undefined;
    return message;
  },
};

function createBaseAutocompletePlacesResponse_Suggestion_PlacePrediction(): AutocompletePlacesResponse_Suggestion_PlacePrediction {
  return { place: "", placeId: "", text: undefined, structuredFormat: undefined, types: [], distanceMeters: 0 };
}

export const AutocompletePlacesResponse_Suggestion_PlacePrediction: MessageFns<
  AutocompletePlacesResponse_Suggestion_PlacePrediction
> = {
  encode(
    message: AutocompletePlacesResponse_Suggestion_PlacePrediction,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.place !== "") {
      writer.uint32(10).string(message.place);
    }
    if (message.placeId !== "") {
      writer.uint32(18).string(message.placeId);
    }
    if (message.text !== undefined) {
      AutocompletePlacesResponse_Suggestion_FormattableText.encode(message.text, writer.uint32(26).fork()).join();
    }
    if (message.structuredFormat !== undefined) {
      AutocompletePlacesResponse_Suggestion_StructuredFormat.encode(message.structuredFormat, writer.uint32(34).fork())
        .join();
    }
    for (const v of message.types) {
      writer.uint32(42).string(v!);
    }
    if (message.distanceMeters !== 0) {
      writer.uint32(48).int32(message.distanceMeters);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutocompletePlacesResponse_Suggestion_PlacePrediction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutocompletePlacesResponse_Suggestion_PlacePrediction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.place = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.placeId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.text = AutocompletePlacesResponse_Suggestion_FormattableText.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.structuredFormat = AutocompletePlacesResponse_Suggestion_StructuredFormat.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.types.push(reader.string());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.distanceMeters = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutocompletePlacesResponse_Suggestion_PlacePrediction {
    return {
      place: isSet(object.place) ? globalThis.String(object.place) : "",
      placeId: isSet(object.placeId) ? globalThis.String(object.placeId) : "",
      text: isSet(object.text)
        ? AutocompletePlacesResponse_Suggestion_FormattableText.fromJSON(object.text)
        : undefined,
      structuredFormat: isSet(object.structuredFormat)
        ? AutocompletePlacesResponse_Suggestion_StructuredFormat.fromJSON(object.structuredFormat)
        : undefined,
      types: globalThis.Array.isArray(object?.types) ? object.types.map((e: any) => globalThis.String(e)) : [],
      distanceMeters: isSet(object.distanceMeters) ? globalThis.Number(object.distanceMeters) : 0,
    };
  },

  toJSON(message: AutocompletePlacesResponse_Suggestion_PlacePrediction): unknown {
    const obj: any = {};
    if (message.place !== "") {
      obj.place = message.place;
    }
    if (message.placeId !== "") {
      obj.placeId = message.placeId;
    }
    if (message.text !== undefined) {
      obj.text = AutocompletePlacesResponse_Suggestion_FormattableText.toJSON(message.text);
    }
    if (message.structuredFormat !== undefined) {
      obj.structuredFormat = AutocompletePlacesResponse_Suggestion_StructuredFormat.toJSON(message.structuredFormat);
    }
    if (message.types?.length) {
      obj.types = message.types;
    }
    if (message.distanceMeters !== 0) {
      obj.distanceMeters = Math.round(message.distanceMeters);
    }
    return obj;
  },

  create(
    base?: DeepPartial<AutocompletePlacesResponse_Suggestion_PlacePrediction>,
  ): AutocompletePlacesResponse_Suggestion_PlacePrediction {
    return AutocompletePlacesResponse_Suggestion_PlacePrediction.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AutocompletePlacesResponse_Suggestion_PlacePrediction>,
  ): AutocompletePlacesResponse_Suggestion_PlacePrediction {
    const message = createBaseAutocompletePlacesResponse_Suggestion_PlacePrediction();
    message.place = object.place ?? "";
    message.placeId = object.placeId ?? "";
    message.text = (object.text !== undefined && object.text !== null)
      ? AutocompletePlacesResponse_Suggestion_FormattableText.fromPartial(object.text)
      : undefined;
    message.structuredFormat = (object.structuredFormat !== undefined && object.structuredFormat !== null)
      ? AutocompletePlacesResponse_Suggestion_StructuredFormat.fromPartial(object.structuredFormat)
      : undefined;
    message.types = object.types?.map((e) => e) || [];
    message.distanceMeters = object.distanceMeters ?? 0;
    return message;
  },
};

function createBaseAutocompletePlacesResponse_Suggestion_QueryPrediction(): AutocompletePlacesResponse_Suggestion_QueryPrediction {
  return { text: undefined, structuredFormat: undefined };
}

export const AutocompletePlacesResponse_Suggestion_QueryPrediction: MessageFns<
  AutocompletePlacesResponse_Suggestion_QueryPrediction
> = {
  encode(
    message: AutocompletePlacesResponse_Suggestion_QueryPrediction,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.text !== undefined) {
      AutocompletePlacesResponse_Suggestion_FormattableText.encode(message.text, writer.uint32(10).fork()).join();
    }
    if (message.structuredFormat !== undefined) {
      AutocompletePlacesResponse_Suggestion_StructuredFormat.encode(message.structuredFormat, writer.uint32(18).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutocompletePlacesResponse_Suggestion_QueryPrediction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutocompletePlacesResponse_Suggestion_QueryPrediction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = AutocompletePlacesResponse_Suggestion_FormattableText.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.structuredFormat = AutocompletePlacesResponse_Suggestion_StructuredFormat.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutocompletePlacesResponse_Suggestion_QueryPrediction {
    return {
      text: isSet(object.text)
        ? AutocompletePlacesResponse_Suggestion_FormattableText.fromJSON(object.text)
        : undefined,
      structuredFormat: isSet(object.structuredFormat)
        ? AutocompletePlacesResponse_Suggestion_StructuredFormat.fromJSON(object.structuredFormat)
        : undefined,
    };
  },

  toJSON(message: AutocompletePlacesResponse_Suggestion_QueryPrediction): unknown {
    const obj: any = {};
    if (message.text !== undefined) {
      obj.text = AutocompletePlacesResponse_Suggestion_FormattableText.toJSON(message.text);
    }
    if (message.structuredFormat !== undefined) {
      obj.structuredFormat = AutocompletePlacesResponse_Suggestion_StructuredFormat.toJSON(message.structuredFormat);
    }
    return obj;
  },

  create(
    base?: DeepPartial<AutocompletePlacesResponse_Suggestion_QueryPrediction>,
  ): AutocompletePlacesResponse_Suggestion_QueryPrediction {
    return AutocompletePlacesResponse_Suggestion_QueryPrediction.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AutocompletePlacesResponse_Suggestion_QueryPrediction>,
  ): AutocompletePlacesResponse_Suggestion_QueryPrediction {
    const message = createBaseAutocompletePlacesResponse_Suggestion_QueryPrediction();
    message.text = (object.text !== undefined && object.text !== null)
      ? AutocompletePlacesResponse_Suggestion_FormattableText.fromPartial(object.text)
      : undefined;
    message.structuredFormat = (object.structuredFormat !== undefined && object.structuredFormat !== null)
      ? AutocompletePlacesResponse_Suggestion_StructuredFormat.fromPartial(object.structuredFormat)
      : undefined;
    return message;
  },
};

/**
 * Service definition for the Places API.
 * Note: every request (except for Autocomplete requests) requires a field mask
 * set outside of the request proto (`all/*`, is not assumed). The field mask
 * can be set via the HTTP header `X-Goog-FieldMask`. See:
 * https://developers.google.com/maps/documentation/places/web-service/choose-fields
 */
export type PlacesDefinition = typeof PlacesDefinition;
export const PlacesDefinition = {
  name: "Places",
  fullName: "google.maps.places.v1.Places",
  methods: {
    /** Search for places near locations. */
    searchNearby: {
      name: "SearchNearby",
      requestType: SearchNearbyRequest,
      requestStream: false,
      responseType: SearchNearbyResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              28,
              58,
              1,
              42,
              34,
              23,
              47,
              118,
              49,
              47,
              112,
              108,
              97,
              99,
              101,
              115,
              58,
              115,
              101,
              97,
              114,
              99,
              104,
              78,
              101,
              97,
              114,
              98,
              121,
            ]),
          ],
        },
      },
    },
    /** Text query based place search. */
    searchText: {
      name: "SearchText",
      requestType: SearchTextRequest,
      requestStream: false,
      responseType: SearchTextResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              26,
              58,
              1,
              42,
              34,
              21,
              47,
              118,
              49,
              47,
              112,
              108,
              97,
              99,
              101,
              115,
              58,
              115,
              101,
              97,
              114,
              99,
              104,
              84,
              101,
              120,
              116,
            ]),
          ],
        },
      },
    },
    /** Get a photo media with a photo reference string. */
    getPhotoMedia: {
      name: "GetPhotoMedia",
      requestType: GetPhotoMediaRequest,
      requestStream: false,
      responseType: PhotoMedia,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              36,
              18,
              34,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              108,
              97,
              99,
              101,
              115,
              47,
              42,
              47,
              112,
              104,
              111,
              116,
              111,
              115,
              47,
              42,
              47,
              109,
              101,
              100,
              105,
              97,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Get the details of a place based on its resource name, which is a string
     * in the `places/{place_id}` format.
     */
    getPlace: {
      name: "GetPlace",
      requestType: GetPlaceRequest,
      requestStream: false,
      responseType: Place,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              21,
              18,
              19,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              108,
              97,
              99,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Returns predictions for the given input. */
    autocompletePlaces: {
      name: "AutocompletePlaces",
      requestType: AutocompletePlacesRequest,
      requestStream: false,
      responseType: AutocompletePlacesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              28,
              58,
              1,
              42,
              34,
              23,
              47,
              118,
              49,
              47,
              112,
              108,
              97,
              99,
              101,
              115,
              58,
              97,
              117,
              116,
              111,
              99,
              111,
              109,
              112,
              108,
              101,
              116,
              101,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface PlacesServiceImplementation<CallContextExt = {}> {
  /** Search for places near locations. */
  searchNearby(
    request: SearchNearbyRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SearchNearbyResponse>>;
  /** Text query based place search. */
  searchText(
    request: SearchTextRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SearchTextResponse>>;
  /** Get a photo media with a photo reference string. */
  getPhotoMedia(request: GetPhotoMediaRequest, context: CallContext & CallContextExt): Promise<DeepPartial<PhotoMedia>>;
  /**
   * Get the details of a place based on its resource name, which is a string
   * in the `places/{place_id}` format.
   */
  getPlace(request: GetPlaceRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Place>>;
  /** Returns predictions for the given input. */
  autocompletePlaces(
    request: AutocompletePlacesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<AutocompletePlacesResponse>>;
}

export interface PlacesClient<CallOptionsExt = {}> {
  /** Search for places near locations. */
  searchNearby(
    request: DeepPartial<SearchNearbyRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SearchNearbyResponse>;
  /** Text query based place search. */
  searchText(
    request: DeepPartial<SearchTextRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SearchTextResponse>;
  /** Get a photo media with a photo reference string. */
  getPhotoMedia(
    request: DeepPartial<GetPhotoMediaRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<PhotoMedia>;
  /**
   * Get the details of a place based on its resource name, which is a string
   * in the `places/{place_id}` format.
   */
  getPlace(request: DeepPartial<GetPlaceRequest>, options?: CallOptions & CallOptionsExt): Promise<Place>;
  /** Returns predictions for the given input. */
  autocompletePlaces(
    request: DeepPartial<AutocompletePlacesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AutocompletePlacesResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
