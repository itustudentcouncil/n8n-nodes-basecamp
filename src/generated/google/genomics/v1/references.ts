// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/genomics/v1/references.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";

export const protobufPackage = "google.genomics.v1";

/**
 * A reference is a canonical assembled DNA sequence, intended to act as a
 * reference coordinate space for other genomic annotations. A single reference
 * might represent the human chromosome 1 or mitochandrial DNA, for instance. A
 * reference belongs to one or more reference sets.
 *
 * For more genomics resource definitions, see [Fundamentals of Google
 * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
 */
export interface Reference {
  /** The server-generated reference ID, unique across all references. */
  id: string;
  /** The length of this reference's sequence. */
  length: Long;
  /**
   * MD5 of the upper-case sequence excluding all whitespace characters (this
   * is equivalent to SQ:M5 in SAM). This value is represented in lower case
   * hexadecimal format.
   */
  md5checksum: string;
  /** The name of this reference, for example `22`. */
  name: string;
  /**
   * The URI from which the sequence was obtained. Typically specifies a FASTA
   * format file.
   */
  sourceUri: string;
  /**
   * All known corresponding accession IDs in INSDC (GenBank/ENA/DDBJ) ideally
   * with a version number, for example `GCF_000001405.26`.
   */
  sourceAccessions: string[];
  /** ID from http://www.ncbi.nlm.nih.gov/taxonomy. For example, 9606 for human. */
  ncbiTaxonId: number;
}

/**
 * A reference set is a set of references which typically comprise a reference
 * assembly for a species, such as `GRCh38` which is representative
 * of the human genome. A reference set defines a common coordinate space for
 * comparing reference-aligned experimental data. A reference set contains 1 or
 * more references.
 *
 * For more genomics resource definitions, see [Fundamentals of Google
 * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
 */
export interface ReferenceSet {
  /** The server-generated reference set ID, unique across all reference sets. */
  id: string;
  /**
   * The IDs of the reference objects that are part of this set.
   * `Reference.md5checksum` must be unique within this set.
   */
  referenceIds: string[];
  /**
   * Order-independent MD5 checksum which identifies this reference set. The
   * checksum is computed by sorting all lower case hexidecimal string
   * `reference.md5checksum` (for all reference in this set) in
   * ascending lexicographic order, concatenating, and taking the MD5 of that
   * value. The resulting value is represented in lower case hexadecimal format.
   */
  md5checksum: string;
  /**
   * ID from http://www.ncbi.nlm.nih.gov/taxonomy (for example, 9606 for human)
   * indicating the species which this reference set is intended to model. Note
   * that contained references may specify a different `ncbiTaxonId`, as
   * assemblies may contain reference sequences which do not belong to the
   * modeled species, for example EBV in a human reference genome.
   */
  ncbiTaxonId: number;
  /** Free text description of this reference set. */
  description: string;
  /** Public id of this reference set, such as `GRCh37`. */
  assemblyId: string;
  /** The URI from which the references were obtained. */
  sourceUri: string;
  /**
   * All known corresponding accession IDs in INSDC (GenBank/ENA/DDBJ) ideally
   * with a version number, for example `NC_000001.11`.
   */
  sourceAccessions: string[];
}

export interface SearchReferenceSetsRequest {
  /**
   * If present, return reference sets for which the
   * [md5checksum][google.genomics.v1.ReferenceSet.md5checksum] matches exactly.
   */
  md5checksums: string[];
  /**
   * If present, return reference sets for which a prefix of any of
   * [sourceAccessions][google.genomics.v1.ReferenceSet.source_accessions]
   * match any of these strings. Accession numbers typically have a main number
   * and a version, for example `NC_000001.11`.
   */
  accessions: string[];
  /**
   * If present, return reference sets for which a substring of their
   * `assemblyId` matches this string (case insensitive).
   */
  assemblyId: string;
  /**
   * The continuation token, which is used to page through large result sets.
   * To get the next page of results, set this parameter to the value of
   * `nextPageToken` from the previous response.
   */
  pageToken: string;
  /**
   * The maximum number of results to return in a single page. If unspecified,
   * defaults to 1024. The maximum value is 4096.
   */
  pageSize: number;
}

export interface SearchReferenceSetsResponse {
  /** The matching references sets. */
  referenceSets: ReferenceSet[];
  /**
   * The continuation token, which is used to page through large result sets.
   * Provide this value in a subsequent request to return the next page of
   * results. This field will be empty if there aren't any additional results.
   */
  nextPageToken: string;
}

export interface GetReferenceSetRequest {
  /** The ID of the reference set. */
  referenceSetId: string;
}

export interface SearchReferencesRequest {
  /**
   * If present, return references for which the
   * [md5checksum][google.genomics.v1.Reference.md5checksum] matches exactly.
   */
  md5checksums: string[];
  /**
   * If present, return references for which a prefix of any of
   * [sourceAccessions][google.genomics.v1.Reference.source_accessions] match
   * any of these strings. Accession numbers typically have a main number and a
   * version, for example `GCF_000001405.26`.
   */
  accessions: string[];
  /** If present, return only references which belong to this reference set. */
  referenceSetId: string;
  /**
   * The continuation token, which is used to page through large result sets.
   * To get the next page of results, set this parameter to the value of
   * `nextPageToken` from the previous response.
   */
  pageToken: string;
  /**
   * The maximum number of results to return in a single page. If unspecified,
   * defaults to 1024. The maximum value is 4096.
   */
  pageSize: number;
}

export interface SearchReferencesResponse {
  /** The matching references. */
  references: Reference[];
  /**
   * The continuation token, which is used to page through large result sets.
   * Provide this value in a subsequent request to return the next page of
   * results. This field will be empty if there aren't any additional results.
   */
  nextPageToken: string;
}

export interface GetReferenceRequest {
  /** The ID of the reference. */
  referenceId: string;
}

export interface ListBasesRequest {
  /** The ID of the reference. */
  referenceId: string;
  /** The start position (0-based) of this query. Defaults to 0. */
  start: Long;
  /**
   * The end position (0-based, exclusive) of this query. Defaults to the length
   * of this reference.
   */
  end: Long;
  /**
   * The continuation token, which is used to page through large result sets.
   * To get the next page of results, set this parameter to the value of
   * `nextPageToken` from the previous response.
   */
  pageToken: string;
  /**
   * The maximum number of bases to return in a single page. If unspecified,
   * defaults to 200Kbp (kilo base pairs). The maximum value is 10Mbp (mega base
   * pairs).
   */
  pageSize: number;
}

export interface ListBasesResponse {
  /**
   * The offset position (0-based) of the given `sequence` from the
   * start of this `Reference`. This value will differ for each page
   * in a paginated request.
   */
  offset: Long;
  /** A substring of the bases that make up this reference. */
  sequence: string;
  /**
   * The continuation token, which is used to page through large result sets.
   * Provide this value in a subsequent request to return the next page of
   * results. This field will be empty if there aren't any additional results.
   */
  nextPageToken: string;
}

function createBaseReference(): Reference {
  return { id: "", length: Long.ZERO, md5checksum: "", name: "", sourceUri: "", sourceAccessions: [], ncbiTaxonId: 0 };
}

export const Reference: MessageFns<Reference> = {
  encode(message: Reference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (!message.length.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.length.toString());
    }
    if (message.md5checksum !== "") {
      writer.uint32(26).string(message.md5checksum);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.sourceUri !== "") {
      writer.uint32(42).string(message.sourceUri);
    }
    for (const v of message.sourceAccessions) {
      writer.uint32(50).string(v!);
    }
    if (message.ncbiTaxonId !== 0) {
      writer.uint32(56).int32(message.ncbiTaxonId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Reference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.length = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.md5checksum = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.sourceUri = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.sourceAccessions.push(reader.string());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.ncbiTaxonId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Reference {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      length: isSet(object.length) ? Long.fromValue(object.length) : Long.ZERO,
      md5checksum: isSet(object.md5checksum) ? globalThis.String(object.md5checksum) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      sourceUri: isSet(object.sourceUri) ? globalThis.String(object.sourceUri) : "",
      sourceAccessions: globalThis.Array.isArray(object?.sourceAccessions)
        ? object.sourceAccessions.map((e: any) => globalThis.String(e))
        : [],
      ncbiTaxonId: isSet(object.ncbiTaxonId) ? globalThis.Number(object.ncbiTaxonId) : 0,
    };
  },

  toJSON(message: Reference): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (!message.length.equals(Long.ZERO)) {
      obj.length = (message.length || Long.ZERO).toString();
    }
    if (message.md5checksum !== "") {
      obj.md5checksum = message.md5checksum;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.sourceUri !== "") {
      obj.sourceUri = message.sourceUri;
    }
    if (message.sourceAccessions?.length) {
      obj.sourceAccessions = message.sourceAccessions;
    }
    if (message.ncbiTaxonId !== 0) {
      obj.ncbiTaxonId = Math.round(message.ncbiTaxonId);
    }
    return obj;
  },

  create(base?: DeepPartial<Reference>): Reference {
    return Reference.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Reference>): Reference {
    const message = createBaseReference();
    message.id = object.id ?? "";
    message.length = (object.length !== undefined && object.length !== null)
      ? Long.fromValue(object.length)
      : Long.ZERO;
    message.md5checksum = object.md5checksum ?? "";
    message.name = object.name ?? "";
    message.sourceUri = object.sourceUri ?? "";
    message.sourceAccessions = object.sourceAccessions?.map((e) => e) || [];
    message.ncbiTaxonId = object.ncbiTaxonId ?? 0;
    return message;
  },
};

function createBaseReferenceSet(): ReferenceSet {
  return {
    id: "",
    referenceIds: [],
    md5checksum: "",
    ncbiTaxonId: 0,
    description: "",
    assemblyId: "",
    sourceUri: "",
    sourceAccessions: [],
  };
}

export const ReferenceSet: MessageFns<ReferenceSet> = {
  encode(message: ReferenceSet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    for (const v of message.referenceIds) {
      writer.uint32(18).string(v!);
    }
    if (message.md5checksum !== "") {
      writer.uint32(26).string(message.md5checksum);
    }
    if (message.ncbiTaxonId !== 0) {
      writer.uint32(32).int32(message.ncbiTaxonId);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.assemblyId !== "") {
      writer.uint32(50).string(message.assemblyId);
    }
    if (message.sourceUri !== "") {
      writer.uint32(58).string(message.sourceUri);
    }
    for (const v of message.sourceAccessions) {
      writer.uint32(66).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReferenceSet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReferenceSet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.referenceIds.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.md5checksum = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.ncbiTaxonId = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.assemblyId = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.sourceUri = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.sourceAccessions.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReferenceSet {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      referenceIds: globalThis.Array.isArray(object?.referenceIds)
        ? object.referenceIds.map((e: any) => globalThis.String(e))
        : [],
      md5checksum: isSet(object.md5checksum) ? globalThis.String(object.md5checksum) : "",
      ncbiTaxonId: isSet(object.ncbiTaxonId) ? globalThis.Number(object.ncbiTaxonId) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      assemblyId: isSet(object.assemblyId) ? globalThis.String(object.assemblyId) : "",
      sourceUri: isSet(object.sourceUri) ? globalThis.String(object.sourceUri) : "",
      sourceAccessions: globalThis.Array.isArray(object?.sourceAccessions)
        ? object.sourceAccessions.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ReferenceSet): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.referenceIds?.length) {
      obj.referenceIds = message.referenceIds;
    }
    if (message.md5checksum !== "") {
      obj.md5checksum = message.md5checksum;
    }
    if (message.ncbiTaxonId !== 0) {
      obj.ncbiTaxonId = Math.round(message.ncbiTaxonId);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.assemblyId !== "") {
      obj.assemblyId = message.assemblyId;
    }
    if (message.sourceUri !== "") {
      obj.sourceUri = message.sourceUri;
    }
    if (message.sourceAccessions?.length) {
      obj.sourceAccessions = message.sourceAccessions;
    }
    return obj;
  },

  create(base?: DeepPartial<ReferenceSet>): ReferenceSet {
    return ReferenceSet.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReferenceSet>): ReferenceSet {
    const message = createBaseReferenceSet();
    message.id = object.id ?? "";
    message.referenceIds = object.referenceIds?.map((e) => e) || [];
    message.md5checksum = object.md5checksum ?? "";
    message.ncbiTaxonId = object.ncbiTaxonId ?? 0;
    message.description = object.description ?? "";
    message.assemblyId = object.assemblyId ?? "";
    message.sourceUri = object.sourceUri ?? "";
    message.sourceAccessions = object.sourceAccessions?.map((e) => e) || [];
    return message;
  },
};

function createBaseSearchReferenceSetsRequest(): SearchReferenceSetsRequest {
  return { md5checksums: [], accessions: [], assemblyId: "", pageToken: "", pageSize: 0 };
}

export const SearchReferenceSetsRequest: MessageFns<SearchReferenceSetsRequest> = {
  encode(message: SearchReferenceSetsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.md5checksums) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.accessions) {
      writer.uint32(18).string(v!);
    }
    if (message.assemblyId !== "") {
      writer.uint32(26).string(message.assemblyId);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    if (message.pageSize !== 0) {
      writer.uint32(40).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchReferenceSetsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchReferenceSetsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.md5checksums.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.accessions.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.assemblyId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchReferenceSetsRequest {
    return {
      md5checksums: globalThis.Array.isArray(object?.md5checksums)
        ? object.md5checksums.map((e: any) => globalThis.String(e))
        : [],
      accessions: globalThis.Array.isArray(object?.accessions)
        ? object.accessions.map((e: any) => globalThis.String(e))
        : [],
      assemblyId: isSet(object.assemblyId) ? globalThis.String(object.assemblyId) : "",
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
    };
  },

  toJSON(message: SearchReferenceSetsRequest): unknown {
    const obj: any = {};
    if (message.md5checksums?.length) {
      obj.md5checksums = message.md5checksums;
    }
    if (message.accessions?.length) {
      obj.accessions = message.accessions;
    }
    if (message.assemblyId !== "") {
      obj.assemblyId = message.assemblyId;
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchReferenceSetsRequest>): SearchReferenceSetsRequest {
    return SearchReferenceSetsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchReferenceSetsRequest>): SearchReferenceSetsRequest {
    const message = createBaseSearchReferenceSetsRequest();
    message.md5checksums = object.md5checksums?.map((e) => e) || [];
    message.accessions = object.accessions?.map((e) => e) || [];
    message.assemblyId = object.assemblyId ?? "";
    message.pageToken = object.pageToken ?? "";
    message.pageSize = object.pageSize ?? 0;
    return message;
  },
};

function createBaseSearchReferenceSetsResponse(): SearchReferenceSetsResponse {
  return { referenceSets: [], nextPageToken: "" };
}

export const SearchReferenceSetsResponse: MessageFns<SearchReferenceSetsResponse> = {
  encode(message: SearchReferenceSetsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.referenceSets) {
      ReferenceSet.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchReferenceSetsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchReferenceSetsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.referenceSets.push(ReferenceSet.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchReferenceSetsResponse {
    return {
      referenceSets: globalThis.Array.isArray(object?.referenceSets)
        ? object.referenceSets.map((e: any) => ReferenceSet.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: SearchReferenceSetsResponse): unknown {
    const obj: any = {};
    if (message.referenceSets?.length) {
      obj.referenceSets = message.referenceSets.map((e) => ReferenceSet.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchReferenceSetsResponse>): SearchReferenceSetsResponse {
    return SearchReferenceSetsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchReferenceSetsResponse>): SearchReferenceSetsResponse {
    const message = createBaseSearchReferenceSetsResponse();
    message.referenceSets = object.referenceSets?.map((e) => ReferenceSet.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetReferenceSetRequest(): GetReferenceSetRequest {
  return { referenceSetId: "" };
}

export const GetReferenceSetRequest: MessageFns<GetReferenceSetRequest> = {
  encode(message: GetReferenceSetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.referenceSetId !== "") {
      writer.uint32(10).string(message.referenceSetId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetReferenceSetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetReferenceSetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.referenceSetId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetReferenceSetRequest {
    return { referenceSetId: isSet(object.referenceSetId) ? globalThis.String(object.referenceSetId) : "" };
  },

  toJSON(message: GetReferenceSetRequest): unknown {
    const obj: any = {};
    if (message.referenceSetId !== "") {
      obj.referenceSetId = message.referenceSetId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetReferenceSetRequest>): GetReferenceSetRequest {
    return GetReferenceSetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetReferenceSetRequest>): GetReferenceSetRequest {
    const message = createBaseGetReferenceSetRequest();
    message.referenceSetId = object.referenceSetId ?? "";
    return message;
  },
};

function createBaseSearchReferencesRequest(): SearchReferencesRequest {
  return { md5checksums: [], accessions: [], referenceSetId: "", pageToken: "", pageSize: 0 };
}

export const SearchReferencesRequest: MessageFns<SearchReferencesRequest> = {
  encode(message: SearchReferencesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.md5checksums) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.accessions) {
      writer.uint32(18).string(v!);
    }
    if (message.referenceSetId !== "") {
      writer.uint32(26).string(message.referenceSetId);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    if (message.pageSize !== 0) {
      writer.uint32(40).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchReferencesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchReferencesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.md5checksums.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.accessions.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.referenceSetId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchReferencesRequest {
    return {
      md5checksums: globalThis.Array.isArray(object?.md5checksums)
        ? object.md5checksums.map((e: any) => globalThis.String(e))
        : [],
      accessions: globalThis.Array.isArray(object?.accessions)
        ? object.accessions.map((e: any) => globalThis.String(e))
        : [],
      referenceSetId: isSet(object.referenceSetId) ? globalThis.String(object.referenceSetId) : "",
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
    };
  },

  toJSON(message: SearchReferencesRequest): unknown {
    const obj: any = {};
    if (message.md5checksums?.length) {
      obj.md5checksums = message.md5checksums;
    }
    if (message.accessions?.length) {
      obj.accessions = message.accessions;
    }
    if (message.referenceSetId !== "") {
      obj.referenceSetId = message.referenceSetId;
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchReferencesRequest>): SearchReferencesRequest {
    return SearchReferencesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchReferencesRequest>): SearchReferencesRequest {
    const message = createBaseSearchReferencesRequest();
    message.md5checksums = object.md5checksums?.map((e) => e) || [];
    message.accessions = object.accessions?.map((e) => e) || [];
    message.referenceSetId = object.referenceSetId ?? "";
    message.pageToken = object.pageToken ?? "";
    message.pageSize = object.pageSize ?? 0;
    return message;
  },
};

function createBaseSearchReferencesResponse(): SearchReferencesResponse {
  return { references: [], nextPageToken: "" };
}

export const SearchReferencesResponse: MessageFns<SearchReferencesResponse> = {
  encode(message: SearchReferencesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.references) {
      Reference.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchReferencesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchReferencesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.references.push(Reference.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchReferencesResponse {
    return {
      references: globalThis.Array.isArray(object?.references)
        ? object.references.map((e: any) => Reference.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: SearchReferencesResponse): unknown {
    const obj: any = {};
    if (message.references?.length) {
      obj.references = message.references.map((e) => Reference.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchReferencesResponse>): SearchReferencesResponse {
    return SearchReferencesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchReferencesResponse>): SearchReferencesResponse {
    const message = createBaseSearchReferencesResponse();
    message.references = object.references?.map((e) => Reference.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetReferenceRequest(): GetReferenceRequest {
  return { referenceId: "" };
}

export const GetReferenceRequest: MessageFns<GetReferenceRequest> = {
  encode(message: GetReferenceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.referenceId !== "") {
      writer.uint32(10).string(message.referenceId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetReferenceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetReferenceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.referenceId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetReferenceRequest {
    return { referenceId: isSet(object.referenceId) ? globalThis.String(object.referenceId) : "" };
  },

  toJSON(message: GetReferenceRequest): unknown {
    const obj: any = {};
    if (message.referenceId !== "") {
      obj.referenceId = message.referenceId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetReferenceRequest>): GetReferenceRequest {
    return GetReferenceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetReferenceRequest>): GetReferenceRequest {
    const message = createBaseGetReferenceRequest();
    message.referenceId = object.referenceId ?? "";
    return message;
  },
};

function createBaseListBasesRequest(): ListBasesRequest {
  return { referenceId: "", start: Long.ZERO, end: Long.ZERO, pageToken: "", pageSize: 0 };
}

export const ListBasesRequest: MessageFns<ListBasesRequest> = {
  encode(message: ListBasesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.referenceId !== "") {
      writer.uint32(10).string(message.referenceId);
    }
    if (!message.start.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.start.toString());
    }
    if (!message.end.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.end.toString());
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    if (message.pageSize !== 0) {
      writer.uint32(40).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListBasesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBasesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.referenceId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.start = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.end = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBasesRequest {
    return {
      referenceId: isSet(object.referenceId) ? globalThis.String(object.referenceId) : "",
      start: isSet(object.start) ? Long.fromValue(object.start) : Long.ZERO,
      end: isSet(object.end) ? Long.fromValue(object.end) : Long.ZERO,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
    };
  },

  toJSON(message: ListBasesRequest): unknown {
    const obj: any = {};
    if (message.referenceId !== "") {
      obj.referenceId = message.referenceId;
    }
    if (!message.start.equals(Long.ZERO)) {
      obj.start = (message.start || Long.ZERO).toString();
    }
    if (!message.end.equals(Long.ZERO)) {
      obj.end = (message.end || Long.ZERO).toString();
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create(base?: DeepPartial<ListBasesRequest>): ListBasesRequest {
    return ListBasesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListBasesRequest>): ListBasesRequest {
    const message = createBaseListBasesRequest();
    message.referenceId = object.referenceId ?? "";
    message.start = (object.start !== undefined && object.start !== null) ? Long.fromValue(object.start) : Long.ZERO;
    message.end = (object.end !== undefined && object.end !== null) ? Long.fromValue(object.end) : Long.ZERO;
    message.pageToken = object.pageToken ?? "";
    message.pageSize = object.pageSize ?? 0;
    return message;
  },
};

function createBaseListBasesResponse(): ListBasesResponse {
  return { offset: Long.ZERO, sequence: "", nextPageToken: "" };
}

export const ListBasesResponse: MessageFns<ListBasesResponse> = {
  encode(message: ListBasesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.offset.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.offset.toString());
    }
    if (message.sequence !== "") {
      writer.uint32(18).string(message.sequence);
    }
    if (message.nextPageToken !== "") {
      writer.uint32(26).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListBasesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBasesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.offset = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sequence = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBasesResponse {
    return {
      offset: isSet(object.offset) ? Long.fromValue(object.offset) : Long.ZERO,
      sequence: isSet(object.sequence) ? globalThis.String(object.sequence) : "",
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListBasesResponse): unknown {
    const obj: any = {};
    if (!message.offset.equals(Long.ZERO)) {
      obj.offset = (message.offset || Long.ZERO).toString();
    }
    if (message.sequence !== "") {
      obj.sequence = message.sequence;
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListBasesResponse>): ListBasesResponse {
    return ListBasesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListBasesResponse>): ListBasesResponse {
    const message = createBaseListBasesResponse();
    message.offset = (object.offset !== undefined && object.offset !== null)
      ? Long.fromValue(object.offset)
      : Long.ZERO;
    message.sequence = object.sequence ?? "";
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

export type ReferenceServiceV1Definition = typeof ReferenceServiceV1Definition;
export const ReferenceServiceV1Definition = {
  name: "ReferenceServiceV1",
  fullName: "google.genomics.v1.ReferenceServiceV1",
  methods: {
    /**
     * Searches for reference sets which match the given criteria.
     *
     * For the definitions of references and other genomics resources, see
     * [Fundamentals of Google
     * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
     *
     * Implements
     * [GlobalAllianceApi.searchReferenceSets](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/referencemethods.avdl#L71)
     */
    searchReferenceSets: {
      name: "SearchReferenceSets",
      requestType: SearchReferenceSetsRequest,
      requestStream: false,
      responseType: SearchReferenceSetsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              29,
              58,
              1,
              42,
              34,
              24,
              47,
              118,
              49,
              47,
              114,
              101,
              102,
              101,
              114,
              101,
              110,
              99,
              101,
              115,
              101,
              116,
              115,
              47,
              115,
              101,
              97,
              114,
              99,
              104,
            ]),
          ],
        },
      },
    },
    /**
     * Gets a reference set.
     *
     * For the definitions of references and other genomics resources, see
     * [Fundamentals of Google
     * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
     *
     * Implements
     * [GlobalAllianceApi.getReferenceSet](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/referencemethods.avdl#L83).
     */
    getReferenceSet: {
      name: "GetReferenceSet",
      requestType: GetReferenceSetRequest,
      requestStream: false,
      responseType: ReferenceSet,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              38,
              18,
              36,
              47,
              118,
              49,
              47,
              114,
              101,
              102,
              101,
              114,
              101,
              110,
              99,
              101,
              115,
              101,
              116,
              115,
              47,
              123,
              114,
              101,
              102,
              101,
              114,
              101,
              110,
              99,
              101,
              95,
              115,
              101,
              116,
              95,
              105,
              100,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Searches for references which match the given criteria.
     *
     * For the definitions of references and other genomics resources, see
     * [Fundamentals of Google
     * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
     *
     * Implements
     * [GlobalAllianceApi.searchReferences](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/referencemethods.avdl#L146).
     */
    searchReferences: {
      name: "SearchReferences",
      requestType: SearchReferencesRequest,
      requestStream: false,
      responseType: SearchReferencesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              26,
              58,
              1,
              42,
              34,
              21,
              47,
              118,
              49,
              47,
              114,
              101,
              102,
              101,
              114,
              101,
              110,
              99,
              101,
              115,
              47,
              115,
              101,
              97,
              114,
              99,
              104,
            ]),
          ],
        },
      },
    },
    /**
     * Gets a reference.
     *
     * For the definitions of references and other genomics resources, see
     * [Fundamentals of Google
     * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
     *
     * Implements
     * [GlobalAllianceApi.getReference](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/referencemethods.avdl#L158).
     */
    getReference: {
      name: "GetReference",
      requestType: GetReferenceRequest,
      requestStream: false,
      responseType: Reference,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              31,
              18,
              29,
              47,
              118,
              49,
              47,
              114,
              101,
              102,
              101,
              114,
              101,
              110,
              99,
              101,
              115,
              47,
              123,
              114,
              101,
              102,
              101,
              114,
              101,
              110,
              99,
              101,
              95,
              105,
              100,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Lists the bases in a reference, optionally restricted to a range.
     *
     * For the definitions of references and other genomics resources, see
     * [Fundamentals of Google
     * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
     *
     * Implements
     * [GlobalAllianceApi.getReferenceBases](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/referencemethods.avdl#L221).
     */
    listBases: {
      name: "ListBases",
      requestType: ListBasesRequest,
      requestStream: false,
      responseType: ListBasesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              37,
              18,
              35,
              47,
              118,
              49,
              47,
              114,
              101,
              102,
              101,
              114,
              101,
              110,
              99,
              101,
              115,
              47,
              123,
              114,
              101,
              102,
              101,
              114,
              101,
              110,
              99,
              101,
              95,
              105,
              100,
              125,
              47,
              98,
              97,
              115,
              101,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface ReferenceServiceV1ServiceImplementation<CallContextExt = {}> {
  /**
   * Searches for reference sets which match the given criteria.
   *
   * For the definitions of references and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * Implements
   * [GlobalAllianceApi.searchReferenceSets](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/referencemethods.avdl#L71)
   */
  searchReferenceSets(
    request: SearchReferenceSetsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SearchReferenceSetsResponse>>;
  /**
   * Gets a reference set.
   *
   * For the definitions of references and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * Implements
   * [GlobalAllianceApi.getReferenceSet](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/referencemethods.avdl#L83).
   */
  getReferenceSet(
    request: GetReferenceSetRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ReferenceSet>>;
  /**
   * Searches for references which match the given criteria.
   *
   * For the definitions of references and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * Implements
   * [GlobalAllianceApi.searchReferences](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/referencemethods.avdl#L146).
   */
  searchReferences(
    request: SearchReferencesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SearchReferencesResponse>>;
  /**
   * Gets a reference.
   *
   * For the definitions of references and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * Implements
   * [GlobalAllianceApi.getReference](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/referencemethods.avdl#L158).
   */
  getReference(request: GetReferenceRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Reference>>;
  /**
   * Lists the bases in a reference, optionally restricted to a range.
   *
   * For the definitions of references and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * Implements
   * [GlobalAllianceApi.getReferenceBases](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/referencemethods.avdl#L221).
   */
  listBases(request: ListBasesRequest, context: CallContext & CallContextExt): Promise<DeepPartial<ListBasesResponse>>;
}

export interface ReferenceServiceV1Client<CallOptionsExt = {}> {
  /**
   * Searches for reference sets which match the given criteria.
   *
   * For the definitions of references and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * Implements
   * [GlobalAllianceApi.searchReferenceSets](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/referencemethods.avdl#L71)
   */
  searchReferenceSets(
    request: DeepPartial<SearchReferenceSetsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SearchReferenceSetsResponse>;
  /**
   * Gets a reference set.
   *
   * For the definitions of references and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * Implements
   * [GlobalAllianceApi.getReferenceSet](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/referencemethods.avdl#L83).
   */
  getReferenceSet(
    request: DeepPartial<GetReferenceSetRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ReferenceSet>;
  /**
   * Searches for references which match the given criteria.
   *
   * For the definitions of references and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * Implements
   * [GlobalAllianceApi.searchReferences](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/referencemethods.avdl#L146).
   */
  searchReferences(
    request: DeepPartial<SearchReferencesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SearchReferencesResponse>;
  /**
   * Gets a reference.
   *
   * For the definitions of references and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * Implements
   * [GlobalAllianceApi.getReference](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/referencemethods.avdl#L158).
   */
  getReference(request: DeepPartial<GetReferenceRequest>, options?: CallOptions & CallOptionsExt): Promise<Reference>;
  /**
   * Lists the bases in a reference, optionally restricted to a range.
   *
   * For the definitions of references and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * Implements
   * [GlobalAllianceApi.getReferenceBases](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/referencemethods.avdl#L221).
   */
  listBases(request: DeepPartial<ListBasesRequest>, options?: CallOptions & CallOptionsExt): Promise<ListBasesResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
