// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/genomics/v1/annotations.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Empty } from "../../protobuf/empty.js";
import { FieldMask } from "../../protobuf/field_mask.js";
import { ListValue } from "../../protobuf/struct.js";
import { Int32Value } from "../../protobuf/wrappers.js";
import { Status } from "../../rpc/status.js";

export const protobufPackage = "google.genomics.v1";

/**
 * When an [Annotation][google.genomics.v1.Annotation] or
 * [AnnotationSet][google.genomics.v1.AnnotationSet] is created, if `type` is
 * not specified it will be set to `GENERIC`.
 */
export enum AnnotationType {
  ANNOTATION_TYPE_UNSPECIFIED = 0,
  /**
   * GENERIC - A `GENERIC` annotation type should be used when no other annotation
   * type will suffice. This represents an untyped annotation of the reference
   * genome.
   */
  GENERIC = 1,
  /** VARIANT - A `VARIANT` annotation type. */
  VARIANT = 2,
  /**
   * GENE - A `GENE` annotation type represents the existence of a gene at the
   * associated reference coordinates. The start coordinate is typically the
   * gene's transcription start site and the end is typically the end of the
   * gene's last exon.
   */
  GENE = 3,
  /**
   * TRANSCRIPT - A `TRANSCRIPT` annotation type represents the assertion that a
   * particular region of the reference genome may be transcribed as RNA.
   */
  TRANSCRIPT = 4,
  UNRECOGNIZED = -1,
}

export function annotationTypeFromJSON(object: any): AnnotationType {
  switch (object) {
    case 0:
    case "ANNOTATION_TYPE_UNSPECIFIED":
      return AnnotationType.ANNOTATION_TYPE_UNSPECIFIED;
    case 1:
    case "GENERIC":
      return AnnotationType.GENERIC;
    case 2:
    case "VARIANT":
      return AnnotationType.VARIANT;
    case 3:
    case "GENE":
      return AnnotationType.GENE;
    case 4:
    case "TRANSCRIPT":
      return AnnotationType.TRANSCRIPT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AnnotationType.UNRECOGNIZED;
  }
}

export function annotationTypeToJSON(object: AnnotationType): string {
  switch (object) {
    case AnnotationType.ANNOTATION_TYPE_UNSPECIFIED:
      return "ANNOTATION_TYPE_UNSPECIFIED";
    case AnnotationType.GENERIC:
      return "GENERIC";
    case AnnotationType.VARIANT:
      return "VARIANT";
    case AnnotationType.GENE:
      return "GENE";
    case AnnotationType.TRANSCRIPT:
      return "TRANSCRIPT";
    case AnnotationType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * An annotation set is a logical grouping of annotations that share consistent
 * type information and provenance. Examples of annotation sets include 'all
 * genes from refseq', and 'all variant annotations from ClinVar'.
 */
export interface AnnotationSet {
  /** The server-generated annotation set ID, unique across all annotation sets. */
  id: string;
  /** The dataset to which this annotation set belongs. */
  datasetId: string;
  /**
   * The ID of the reference set that defines the coordinate space for this
   * set's annotations.
   */
  referenceSetId: string;
  /** The display name for this annotation set. */
  name: string;
  /**
   * The source URI describing the file from which this annotation set was
   * generated, if any.
   */
  sourceUri: string;
  /** The type of annotations contained within this set. */
  type: AnnotationType;
  /**
   * A map of additional read alignment information. This must be of the form
   * map<string, string[]> (string key mapping to a list of string values).
   */
  info: { [key: string]: Array<any> | undefined };
}

export interface AnnotationSet_InfoEntry {
  key: string;
  value: Array<any> | undefined;
}

/**
 * An annotation describes a region of reference genome. The value of an
 * annotation may be one of several canonical types, supplemented by arbitrary
 * info tags. An annotation is not inherently associated with a specific
 * sample or individual (though a client could choose to use annotations in
 * this way). Example canonical annotation types are `GENE` and
 * `VARIANT`.
 */
export interface Annotation {
  /** The server-generated annotation ID, unique across all annotations. */
  id: string;
  /** The annotation set to which this annotation belongs. */
  annotationSetId: string;
  /** The display name of this annotation. */
  name: string;
  /** The ID of the Google Genomics reference associated with this range. */
  referenceId: string;
  /**
   * The display name corresponding to the reference specified by
   * `referenceId`, for example `chr1`, `1`, or `chrX`.
   */
  referenceName: string;
  /** The start position of the range on the reference, 0-based inclusive. */
  start: Long;
  /** The end position of the range on the reference, 0-based exclusive. */
  end: Long;
  /**
   * Whether this range refers to the reverse strand, as opposed to the forward
   * strand. Note that regardless of this field, the start/end position of the
   * range always refer to the forward strand.
   */
  reverseStrand: boolean;
  /**
   * The data type for this annotation. Must match the containing annotation
   * set's type.
   */
  type: AnnotationType;
  /**
   * A variant annotation, which describes the effect of a variant on the
   * genome, the coding sequence, and/or higher level consequences at the
   * organism level e.g. pathogenicity. This field is only set for annotations
   * of type `VARIANT`.
   */
  variant?:
    | VariantAnnotation
    | undefined;
  /**
   * A transcript value represents the assertion that a particular region of
   * the reference genome may be transcribed as RNA. An alternative splicing
   * pattern would be represented as a separate transcript object. This field
   * is only set for annotations of type `TRANSCRIPT`.
   */
  transcript?:
    | Transcript
    | undefined;
  /**
   * A map of additional read alignment information. This must be of the form
   * map<string, string[]> (string key mapping to a list of string values).
   */
  info: { [key: string]: Array<any> | undefined };
}

export interface Annotation_InfoEntry {
  key: string;
  value: Array<any> | undefined;
}

export interface VariantAnnotation {
  /** Type has been adapted from ClinVar's list of variant types. */
  type: VariantAnnotation_Type;
  /** Effect of the variant on the coding sequence. */
  effect: VariantAnnotation_Effect;
  /**
   * The alternate allele for this variant. If multiple alternate alleles
   * exist at this location, create a separate variant for each one, as they
   * may represent distinct conditions.
   */
  alternateBases: string;
  /**
   * Google annotation ID of the gene affected by this variant. This should
   * be provided when the variant is created.
   */
  geneId: string;
  /**
   * Google annotation IDs of the transcripts affected by this variant. These
   * should be provided when the variant is created.
   */
  transcriptIds: string[];
  /**
   * The set of conditions associated with this variant.
   * A condition describes the way a variant influences human health.
   */
  conditions: VariantAnnotation_ClinicalCondition[];
  /**
   * Describes the clinical significance of a variant.
   * It is adapted from the ClinVar controlled vocabulary for clinical
   * significance described at:
   * http://www.ncbi.nlm.nih.gov/clinvar/docs/clinsig/
   */
  clinicalSignificance: VariantAnnotation_ClinicalSignificance;
}

export enum VariantAnnotation_Type {
  TYPE_UNSPECIFIED = 0,
  /**
   * TYPE_OTHER - `TYPE_OTHER` should be used when no other Type will suffice.
   * Further explanation of the variant type may be included in the
   * [info][google.genomics.v1.Annotation.info] field.
   */
  TYPE_OTHER = 1,
  /** INSERTION - `INSERTION` indicates an insertion. */
  INSERTION = 2,
  /** DELETION - `DELETION` indicates a deletion. */
  DELETION = 3,
  /**
   * SUBSTITUTION - `SUBSTITUTION` indicates a block substitution of
   * two or more nucleotides.
   */
  SUBSTITUTION = 4,
  /** SNP - `SNP` indicates a single nucleotide polymorphism. */
  SNP = 5,
  /**
   * STRUCTURAL - `STRUCTURAL` indicates a large structural variant,
   * including chromosomal fusions, inversions, etc.
   */
  STRUCTURAL = 6,
  /** CNV - `CNV` indicates a variation in copy number. */
  CNV = 7,
  UNRECOGNIZED = -1,
}

export function variantAnnotation_TypeFromJSON(object: any): VariantAnnotation_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return VariantAnnotation_Type.TYPE_UNSPECIFIED;
    case 1:
    case "TYPE_OTHER":
      return VariantAnnotation_Type.TYPE_OTHER;
    case 2:
    case "INSERTION":
      return VariantAnnotation_Type.INSERTION;
    case 3:
    case "DELETION":
      return VariantAnnotation_Type.DELETION;
    case 4:
    case "SUBSTITUTION":
      return VariantAnnotation_Type.SUBSTITUTION;
    case 5:
    case "SNP":
      return VariantAnnotation_Type.SNP;
    case 6:
    case "STRUCTURAL":
      return VariantAnnotation_Type.STRUCTURAL;
    case 7:
    case "CNV":
      return VariantAnnotation_Type.CNV;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VariantAnnotation_Type.UNRECOGNIZED;
  }
}

export function variantAnnotation_TypeToJSON(object: VariantAnnotation_Type): string {
  switch (object) {
    case VariantAnnotation_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case VariantAnnotation_Type.TYPE_OTHER:
      return "TYPE_OTHER";
    case VariantAnnotation_Type.INSERTION:
      return "INSERTION";
    case VariantAnnotation_Type.DELETION:
      return "DELETION";
    case VariantAnnotation_Type.SUBSTITUTION:
      return "SUBSTITUTION";
    case VariantAnnotation_Type.SNP:
      return "SNP";
    case VariantAnnotation_Type.STRUCTURAL:
      return "STRUCTURAL";
    case VariantAnnotation_Type.CNV:
      return "CNV";
    case VariantAnnotation_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum VariantAnnotation_Effect {
  EFFECT_UNSPECIFIED = 0,
  /**
   * EFFECT_OTHER - `EFFECT_OTHER` should be used when no other Effect
   * will suffice.
   */
  EFFECT_OTHER = 1,
  /**
   * FRAMESHIFT - `FRAMESHIFT` indicates a mutation in which the insertion or
   * deletion of nucleotides resulted in a frameshift change.
   */
  FRAMESHIFT = 2,
  /**
   * FRAME_PRESERVING_INDEL - `FRAME_PRESERVING_INDEL` indicates a mutation in which a
   * multiple of three nucleotides has been inserted or deleted, resulting
   * in no change to the reading frame of the coding sequence.
   */
  FRAME_PRESERVING_INDEL = 3,
  /**
   * SYNONYMOUS_SNP - `SYNONYMOUS_SNP` indicates a single nucleotide polymorphism
   * mutation that results in no amino acid change.
   */
  SYNONYMOUS_SNP = 4,
  /**
   * NONSYNONYMOUS_SNP - `NONSYNONYMOUS_SNP` indicates a single nucleotide
   * polymorphism mutation that results in an amino acid change.
   */
  NONSYNONYMOUS_SNP = 5,
  /**
   * STOP_GAIN - `STOP_GAIN` indicates a mutation that leads to the creation
   * of a stop codon at the variant site. Frameshift mutations creating
   * downstream stop codons do not count as `STOP_GAIN`.
   */
  STOP_GAIN = 6,
  /**
   * STOP_LOSS - `STOP_LOSS` indicates a mutation that eliminates a
   * stop codon at the variant site.
   */
  STOP_LOSS = 7,
  /**
   * SPLICE_SITE_DISRUPTION - `SPLICE_SITE_DISRUPTION` indicates that this variant is
   * found in a splice site for the associated transcript, and alters the
   * normal splicing pattern.
   */
  SPLICE_SITE_DISRUPTION = 8,
  UNRECOGNIZED = -1,
}

export function variantAnnotation_EffectFromJSON(object: any): VariantAnnotation_Effect {
  switch (object) {
    case 0:
    case "EFFECT_UNSPECIFIED":
      return VariantAnnotation_Effect.EFFECT_UNSPECIFIED;
    case 1:
    case "EFFECT_OTHER":
      return VariantAnnotation_Effect.EFFECT_OTHER;
    case 2:
    case "FRAMESHIFT":
      return VariantAnnotation_Effect.FRAMESHIFT;
    case 3:
    case "FRAME_PRESERVING_INDEL":
      return VariantAnnotation_Effect.FRAME_PRESERVING_INDEL;
    case 4:
    case "SYNONYMOUS_SNP":
      return VariantAnnotation_Effect.SYNONYMOUS_SNP;
    case 5:
    case "NONSYNONYMOUS_SNP":
      return VariantAnnotation_Effect.NONSYNONYMOUS_SNP;
    case 6:
    case "STOP_GAIN":
      return VariantAnnotation_Effect.STOP_GAIN;
    case 7:
    case "STOP_LOSS":
      return VariantAnnotation_Effect.STOP_LOSS;
    case 8:
    case "SPLICE_SITE_DISRUPTION":
      return VariantAnnotation_Effect.SPLICE_SITE_DISRUPTION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VariantAnnotation_Effect.UNRECOGNIZED;
  }
}

export function variantAnnotation_EffectToJSON(object: VariantAnnotation_Effect): string {
  switch (object) {
    case VariantAnnotation_Effect.EFFECT_UNSPECIFIED:
      return "EFFECT_UNSPECIFIED";
    case VariantAnnotation_Effect.EFFECT_OTHER:
      return "EFFECT_OTHER";
    case VariantAnnotation_Effect.FRAMESHIFT:
      return "FRAMESHIFT";
    case VariantAnnotation_Effect.FRAME_PRESERVING_INDEL:
      return "FRAME_PRESERVING_INDEL";
    case VariantAnnotation_Effect.SYNONYMOUS_SNP:
      return "SYNONYMOUS_SNP";
    case VariantAnnotation_Effect.NONSYNONYMOUS_SNP:
      return "NONSYNONYMOUS_SNP";
    case VariantAnnotation_Effect.STOP_GAIN:
      return "STOP_GAIN";
    case VariantAnnotation_Effect.STOP_LOSS:
      return "STOP_LOSS";
    case VariantAnnotation_Effect.SPLICE_SITE_DISRUPTION:
      return "SPLICE_SITE_DISRUPTION";
    case VariantAnnotation_Effect.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum VariantAnnotation_ClinicalSignificance {
  CLINICAL_SIGNIFICANCE_UNSPECIFIED = 0,
  /**
   * CLINICAL_SIGNIFICANCE_OTHER - `OTHER` should be used when no other clinical significance
   * value will suffice.
   */
  CLINICAL_SIGNIFICANCE_OTHER = 1,
  UNCERTAIN = 2,
  BENIGN = 3,
  LIKELY_BENIGN = 4,
  LIKELY_PATHOGENIC = 5,
  PATHOGENIC = 6,
  DRUG_RESPONSE = 7,
  HISTOCOMPATIBILITY = 8,
  CONFERS_SENSITIVITY = 9,
  RISK_FACTOR = 10,
  ASSOCIATION = 11,
  PROTECTIVE = 12,
  /**
   * MULTIPLE_REPORTED - `MULTIPLE_REPORTED` should be used when multiple clinical
   * signficances are reported for a variant. The original clinical
   * significance values may be provided in the `info` field.
   */
  MULTIPLE_REPORTED = 13,
  UNRECOGNIZED = -1,
}

export function variantAnnotation_ClinicalSignificanceFromJSON(object: any): VariantAnnotation_ClinicalSignificance {
  switch (object) {
    case 0:
    case "CLINICAL_SIGNIFICANCE_UNSPECIFIED":
      return VariantAnnotation_ClinicalSignificance.CLINICAL_SIGNIFICANCE_UNSPECIFIED;
    case 1:
    case "CLINICAL_SIGNIFICANCE_OTHER":
      return VariantAnnotation_ClinicalSignificance.CLINICAL_SIGNIFICANCE_OTHER;
    case 2:
    case "UNCERTAIN":
      return VariantAnnotation_ClinicalSignificance.UNCERTAIN;
    case 3:
    case "BENIGN":
      return VariantAnnotation_ClinicalSignificance.BENIGN;
    case 4:
    case "LIKELY_BENIGN":
      return VariantAnnotation_ClinicalSignificance.LIKELY_BENIGN;
    case 5:
    case "LIKELY_PATHOGENIC":
      return VariantAnnotation_ClinicalSignificance.LIKELY_PATHOGENIC;
    case 6:
    case "PATHOGENIC":
      return VariantAnnotation_ClinicalSignificance.PATHOGENIC;
    case 7:
    case "DRUG_RESPONSE":
      return VariantAnnotation_ClinicalSignificance.DRUG_RESPONSE;
    case 8:
    case "HISTOCOMPATIBILITY":
      return VariantAnnotation_ClinicalSignificance.HISTOCOMPATIBILITY;
    case 9:
    case "CONFERS_SENSITIVITY":
      return VariantAnnotation_ClinicalSignificance.CONFERS_SENSITIVITY;
    case 10:
    case "RISK_FACTOR":
      return VariantAnnotation_ClinicalSignificance.RISK_FACTOR;
    case 11:
    case "ASSOCIATION":
      return VariantAnnotation_ClinicalSignificance.ASSOCIATION;
    case 12:
    case "PROTECTIVE":
      return VariantAnnotation_ClinicalSignificance.PROTECTIVE;
    case 13:
    case "MULTIPLE_REPORTED":
      return VariantAnnotation_ClinicalSignificance.MULTIPLE_REPORTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VariantAnnotation_ClinicalSignificance.UNRECOGNIZED;
  }
}

export function variantAnnotation_ClinicalSignificanceToJSON(object: VariantAnnotation_ClinicalSignificance): string {
  switch (object) {
    case VariantAnnotation_ClinicalSignificance.CLINICAL_SIGNIFICANCE_UNSPECIFIED:
      return "CLINICAL_SIGNIFICANCE_UNSPECIFIED";
    case VariantAnnotation_ClinicalSignificance.CLINICAL_SIGNIFICANCE_OTHER:
      return "CLINICAL_SIGNIFICANCE_OTHER";
    case VariantAnnotation_ClinicalSignificance.UNCERTAIN:
      return "UNCERTAIN";
    case VariantAnnotation_ClinicalSignificance.BENIGN:
      return "BENIGN";
    case VariantAnnotation_ClinicalSignificance.LIKELY_BENIGN:
      return "LIKELY_BENIGN";
    case VariantAnnotation_ClinicalSignificance.LIKELY_PATHOGENIC:
      return "LIKELY_PATHOGENIC";
    case VariantAnnotation_ClinicalSignificance.PATHOGENIC:
      return "PATHOGENIC";
    case VariantAnnotation_ClinicalSignificance.DRUG_RESPONSE:
      return "DRUG_RESPONSE";
    case VariantAnnotation_ClinicalSignificance.HISTOCOMPATIBILITY:
      return "HISTOCOMPATIBILITY";
    case VariantAnnotation_ClinicalSignificance.CONFERS_SENSITIVITY:
      return "CONFERS_SENSITIVITY";
    case VariantAnnotation_ClinicalSignificance.RISK_FACTOR:
      return "RISK_FACTOR";
    case VariantAnnotation_ClinicalSignificance.ASSOCIATION:
      return "ASSOCIATION";
    case VariantAnnotation_ClinicalSignificance.PROTECTIVE:
      return "PROTECTIVE";
    case VariantAnnotation_ClinicalSignificance.MULTIPLE_REPORTED:
      return "MULTIPLE_REPORTED";
    case VariantAnnotation_ClinicalSignificance.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface VariantAnnotation_ClinicalCondition {
  /** A set of names for the condition. */
  names: string[];
  /** The set of external IDs for this condition. */
  externalIds: ExternalId[];
  /**
   * The MedGen concept id associated with this gene.
   * Search for these IDs at http://www.ncbi.nlm.nih.gov/medgen/
   */
  conceptId: string;
  /**
   * The OMIM id for this condition.
   * Search for these IDs at http://omim.org/
   */
  omimId: string;
}

/**
 * A transcript represents the assertion that a particular region of the
 * reference genome may be transcribed as RNA.
 */
export interface Transcript {
  /** The annotation ID of the gene from which this transcript is transcribed. */
  geneId: string;
  /**
   * The <a href="http://en.wikipedia.org/wiki/Exon">exons</a> that compose
   * this transcript. This field should be unset for genomes where transcript
   * splicing does not occur, for example prokaryotes.
   *
   * Introns are regions of the transcript that are not included in the
   * spliced RNA product. Though not explicitly modeled here, intron ranges can
   * be deduced; all regions of this transcript that are not exons are introns.
   *
   * Exonic sequences do not necessarily code for a translational product
   * (amino acids). Only the regions of exons bounded by the
   * [codingSequence][google.genomics.v1.Transcript.coding_sequence] correspond
   * to coding DNA sequence.
   *
   * Exons are ordered by start position and may not overlap.
   */
  exons: Transcript_Exon[];
  /**
   * The range of the coding sequence for this transcript, if any. To determine
   * the exact ranges of coding sequence, intersect this range with those of the
   * [exons][google.genomics.v1.Transcript.exons], if any. If there are any
   * [exons][google.genomics.v1.Transcript.exons], the
   * [codingSequence][google.genomics.v1.Transcript.coding_sequence] must start
   * and end within them.
   *
   * Note that in some cases, the reference genome will not exactly match the
   * observed mRNA transcript e.g. due to variance in the source genome from
   * reference. In these cases,
   * [exon.frame][google.genomics.v1.Transcript.Exon.frame] will not necessarily
   * match the expected reference reading frame and coding exon reference bases
   * cannot necessarily be concatenated to produce the original transcript mRNA.
   */
  codingSequence: Transcript_CodingSequence | undefined;
}

export interface Transcript_Exon {
  /**
   * The start position of the exon on this annotation's reference sequence,
   * 0-based inclusive. Note that this is relative to the reference start, and
   * **not** the containing annotation start.
   */
  start: Long;
  /**
   * The end position of the exon on this annotation's reference sequence,
   * 0-based exclusive. Note that this is relative to the reference start, and
   * *not* the containing annotation start.
   */
  end: Long;
  /**
   * The frame of this exon. Contains a value of 0, 1, or 2, which indicates
   * the offset of the first coding base of the exon within the reading frame
   * of the coding DNA sequence, if any. This field is dependent on the
   * strandedness of this annotation (see
   * [Annotation.reverse_strand][google.genomics.v1.Annotation.reverse_strand]).
   * For forward stranded annotations, this offset is relative to the
   * [exon.start][google.genomics.v1.Transcript.Exon.start]. For reverse
   * strand annotations, this offset is relative to the
   * [exon.end][google.genomics.v1.Transcript.Exon.end] `- 1`.
   *
   * Unset if this exon does not intersect the coding sequence. Upon creation
   * of a transcript, the frame must be populated for all or none of the
   * coding exons.
   */
  frame: number | undefined;
}

export interface Transcript_CodingSequence {
  /**
   * The start of the coding sequence on this annotation's reference sequence,
   * 0-based inclusive. Note that this position is relative to the reference
   * start, and *not* the containing annotation start.
   */
  start: Long;
  /**
   * The end of the coding sequence on this annotation's reference sequence,
   * 0-based exclusive. Note that this position is relative to the reference
   * start, and *not* the containing annotation start.
   */
  end: Long;
}

export interface ExternalId {
  /** The name of the source of this data. */
  sourceName: string;
  /** The id used by the source of this data. */
  id: string;
}

export interface CreateAnnotationSetRequest {
  /** The annotation set to create. */
  annotationSet: AnnotationSet | undefined;
}

export interface GetAnnotationSetRequest {
  /** The ID of the annotation set to be retrieved. */
  annotationSetId: string;
}

export interface UpdateAnnotationSetRequest {
  /** The ID of the annotation set to be updated. */
  annotationSetId: string;
  /** The new annotation set. */
  annotationSet:
    | AnnotationSet
    | undefined;
  /**
   * An optional mask specifying which fields to update. Mutable fields are
   * [name][google.genomics.v1.AnnotationSet.name],
   * [source_uri][google.genomics.v1.AnnotationSet.source_uri], and
   * [info][google.genomics.v1.AnnotationSet.info]. If unspecified, all
   * mutable fields will be updated.
   */
  updateMask: string[] | undefined;
}

export interface DeleteAnnotationSetRequest {
  /** The ID of the annotation set to be deleted. */
  annotationSetId: string;
}

export interface SearchAnnotationSetsRequest {
  /**
   * Required. The dataset IDs to search within. Caller must have `READ` access
   * to these datasets.
   */
  datasetIds: string[];
  /**
   * If specified, only annotation sets associated with the given reference set
   * are returned.
   */
  referenceSetId: string;
  /**
   * Only return annotations sets for which a substring of the name matches this
   * string (case insensitive).
   */
  name: string;
  /**
   * If specified, only annotation sets that have any of these types are
   * returned.
   */
  types: AnnotationType[];
  /**
   * The continuation token, which is used to page through large result sets.
   * To get the next page of results, set this parameter to the value of
   * `nextPageToken` from the previous response.
   */
  pageToken: string;
  /**
   * The maximum number of results to return in a single page. If unspecified,
   * defaults to 128. The maximum value is 1024.
   */
  pageSize: number;
}

export interface SearchAnnotationSetsResponse {
  /** The matching annotation sets. */
  annotationSets: AnnotationSet[];
  /**
   * The continuation token, which is used to page through large result sets.
   * Provide this value in a subsequent request to return the next page of
   * results. This field will be empty if there aren't any additional results.
   */
  nextPageToken: string;
}

export interface CreateAnnotationRequest {
  /** The annotation to be created. */
  annotation: Annotation | undefined;
}

export interface BatchCreateAnnotationsRequest {
  /**
   * The annotations to be created. At most 4096 can be specified in a single
   * request.
   */
  annotations: Annotation[];
  /**
   * A unique request ID which enables the server to detect duplicated requests.
   * If provided, duplicated requests will result in the same response; if not
   * provided, duplicated requests may result in duplicated data. For a given
   * annotation set, callers should not reuse `request_id`s when writing
   * different batches of annotations - behavior in this case is undefined.
   * A common approach is to use a UUID. For batch jobs where worker crashes are
   * a possibility, consider using some unique variant of a worker or run ID.
   */
  requestId: string;
}

export interface BatchCreateAnnotationsResponse {
  /**
   * The resulting per-annotation entries, ordered consistently with the
   * original request.
   */
  entries: BatchCreateAnnotationsResponse_Entry[];
}

export interface BatchCreateAnnotationsResponse_Entry {
  /** The creation status. */
  status:
    | Status
    | undefined;
  /** The created annotation, if creation was successful. */
  annotation: Annotation | undefined;
}

export interface GetAnnotationRequest {
  /** The ID of the annotation to be retrieved. */
  annotationId: string;
}

export interface UpdateAnnotationRequest {
  /** The ID of the annotation to be updated. */
  annotationId: string;
  /** The new annotation. */
  annotation:
    | Annotation
    | undefined;
  /**
   * An optional mask specifying which fields to update. Mutable fields are
   * [name][google.genomics.v1.Annotation.name],
   * [variant][google.genomics.v1.Annotation.variant],
   * [transcript][google.genomics.v1.Annotation.transcript], and
   * [info][google.genomics.v1.Annotation.info]. If unspecified, all mutable
   * fields will be updated.
   */
  updateMask: string[] | undefined;
}

export interface DeleteAnnotationRequest {
  /** The ID of the annotation to be deleted. */
  annotationId: string;
}

export interface SearchAnnotationsRequest {
  /**
   * Required. The annotation sets to search within. The caller must have
   * `READ` access to these annotation sets.
   * All queried annotation sets must have the same type.
   */
  annotationSetIds: string[];
  /** The ID of the reference to query. */
  referenceId?:
    | string
    | undefined;
  /**
   * The name of the reference to query, within the reference set associated
   * with this query.
   */
  referenceName?:
    | string
    | undefined;
  /**
   * The start position of the range on the reference, 0-based inclusive. If
   * specified,
   * [referenceId][google.genomics.v1.SearchAnnotationsRequest.reference_id] or
   * [referenceName][google.genomics.v1.SearchAnnotationsRequest.reference_name]
   * must be specified. Defaults to 0.
   */
  start: Long;
  /**
   * The end position of the range on the reference, 0-based exclusive. If
   * [referenceId][google.genomics.v1.SearchAnnotationsRequest.reference_id] or
   * [referenceName][google.genomics.v1.SearchAnnotationsRequest.reference_name]
   * must be specified, Defaults to the length of the reference.
   */
  end: Long;
  /**
   * The continuation token, which is used to page through large result sets.
   * To get the next page of results, set this parameter to the value of
   * `nextPageToken` from the previous response.
   */
  pageToken: string;
  /**
   * The maximum number of results to return in a single page. If unspecified,
   * defaults to 256. The maximum value is 2048.
   */
  pageSize: number;
}

export interface SearchAnnotationsResponse {
  /** The matching annotations. */
  annotations: Annotation[];
  /**
   * The continuation token, which is used to page through large result sets.
   * Provide this value in a subsequent request to return the next page of
   * results. This field will be empty if there aren't any additional results.
   */
  nextPageToken: string;
}

function createBaseAnnotationSet(): AnnotationSet {
  return { id: "", datasetId: "", referenceSetId: "", name: "", sourceUri: "", type: 0, info: {} };
}

export const AnnotationSet: MessageFns<AnnotationSet> = {
  encode(message: AnnotationSet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.datasetId !== "") {
      writer.uint32(18).string(message.datasetId);
    }
    if (message.referenceSetId !== "") {
      writer.uint32(26).string(message.referenceSetId);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.sourceUri !== "") {
      writer.uint32(42).string(message.sourceUri);
    }
    if (message.type !== 0) {
      writer.uint32(48).int32(message.type);
    }
    Object.entries(message.info).forEach(([key, value]) => {
      if (value !== undefined) {
        AnnotationSet_InfoEntry.encode({ key: key as any, value }, writer.uint32(138).fork()).join();
      }
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnnotationSet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnotationSet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.datasetId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.referenceSetId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.sourceUri = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          const entry17 = AnnotationSet_InfoEntry.decode(reader, reader.uint32());
          if (entry17.value !== undefined) {
            message.info[entry17.key] = entry17.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnnotationSet {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      datasetId: isSet(object.datasetId) ? globalThis.String(object.datasetId) : "",
      referenceSetId: isSet(object.referenceSetId) ? globalThis.String(object.referenceSetId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      sourceUri: isSet(object.sourceUri) ? globalThis.String(object.sourceUri) : "",
      type: isSet(object.type) ? annotationTypeFromJSON(object.type) : 0,
      info: isObject(object.info)
        ? Object.entries(object.info).reduce<{ [key: string]: Array<any> | undefined }>((acc, [key, value]) => {
          acc[key] = value as Array<any> | undefined;
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: AnnotationSet): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.datasetId !== "") {
      obj.datasetId = message.datasetId;
    }
    if (message.referenceSetId !== "") {
      obj.referenceSetId = message.referenceSetId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.sourceUri !== "") {
      obj.sourceUri = message.sourceUri;
    }
    if (message.type !== 0) {
      obj.type = annotationTypeToJSON(message.type);
    }
    if (message.info) {
      const entries = Object.entries(message.info);
      if (entries.length > 0) {
        obj.info = {};
        entries.forEach(([k, v]) => {
          obj.info[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<AnnotationSet>): AnnotationSet {
    return AnnotationSet.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnnotationSet>): AnnotationSet {
    const message = createBaseAnnotationSet();
    message.id = object.id ?? "";
    message.datasetId = object.datasetId ?? "";
    message.referenceSetId = object.referenceSetId ?? "";
    message.name = object.name ?? "";
    message.sourceUri = object.sourceUri ?? "";
    message.type = object.type ?? 0;
    message.info = Object.entries(object.info ?? {}).reduce<{ [key: string]: Array<any> | undefined }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseAnnotationSet_InfoEntry(): AnnotationSet_InfoEntry {
  return { key: "", value: undefined };
}

export const AnnotationSet_InfoEntry: MessageFns<AnnotationSet_InfoEntry> = {
  encode(message: AnnotationSet_InfoEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ListValue.encode(ListValue.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnnotationSet_InfoEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnotationSet_InfoEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = ListValue.unwrap(ListValue.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnnotationSet_InfoEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: globalThis.Array.isArray(object.value) ? [...object.value] : undefined,
    };
  },

  toJSON(message: AnnotationSet_InfoEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<AnnotationSet_InfoEntry>): AnnotationSet_InfoEntry {
    return AnnotationSet_InfoEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnnotationSet_InfoEntry>): AnnotationSet_InfoEntry {
    const message = createBaseAnnotationSet_InfoEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseAnnotation(): Annotation {
  return {
    id: "",
    annotationSetId: "",
    name: "",
    referenceId: "",
    referenceName: "",
    start: Long.ZERO,
    end: Long.ZERO,
    reverseStrand: false,
    type: 0,
    variant: undefined,
    transcript: undefined,
    info: {},
  };
}

export const Annotation: MessageFns<Annotation> = {
  encode(message: Annotation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.annotationSetId !== "") {
      writer.uint32(18).string(message.annotationSetId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.referenceId !== "") {
      writer.uint32(34).string(message.referenceId);
    }
    if (message.referenceName !== "") {
      writer.uint32(42).string(message.referenceName);
    }
    if (!message.start.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.start.toString());
    }
    if (!message.end.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.end.toString());
    }
    if (message.reverseStrand !== false) {
      writer.uint32(64).bool(message.reverseStrand);
    }
    if (message.type !== 0) {
      writer.uint32(72).int32(message.type);
    }
    if (message.variant !== undefined) {
      VariantAnnotation.encode(message.variant, writer.uint32(82).fork()).join();
    }
    if (message.transcript !== undefined) {
      Transcript.encode(message.transcript, writer.uint32(90).fork()).join();
    }
    Object.entries(message.info).forEach(([key, value]) => {
      if (value !== undefined) {
        Annotation_InfoEntry.encode({ key: key as any, value }, writer.uint32(98).fork()).join();
      }
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Annotation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.annotationSetId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.referenceId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.referenceName = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.start = Long.fromString(reader.int64().toString());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.end = Long.fromString(reader.int64().toString());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.reverseStrand = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.variant = VariantAnnotation.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.transcript = Transcript.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          const entry12 = Annotation_InfoEntry.decode(reader, reader.uint32());
          if (entry12.value !== undefined) {
            message.info[entry12.key] = entry12.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Annotation {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      annotationSetId: isSet(object.annotationSetId) ? globalThis.String(object.annotationSetId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      referenceId: isSet(object.referenceId) ? globalThis.String(object.referenceId) : "",
      referenceName: isSet(object.referenceName) ? globalThis.String(object.referenceName) : "",
      start: isSet(object.start) ? Long.fromValue(object.start) : Long.ZERO,
      end: isSet(object.end) ? Long.fromValue(object.end) : Long.ZERO,
      reverseStrand: isSet(object.reverseStrand) ? globalThis.Boolean(object.reverseStrand) : false,
      type: isSet(object.type) ? annotationTypeFromJSON(object.type) : 0,
      variant: isSet(object.variant) ? VariantAnnotation.fromJSON(object.variant) : undefined,
      transcript: isSet(object.transcript) ? Transcript.fromJSON(object.transcript) : undefined,
      info: isObject(object.info)
        ? Object.entries(object.info).reduce<{ [key: string]: Array<any> | undefined }>((acc, [key, value]) => {
          acc[key] = value as Array<any> | undefined;
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Annotation): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.annotationSetId !== "") {
      obj.annotationSetId = message.annotationSetId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.referenceId !== "") {
      obj.referenceId = message.referenceId;
    }
    if (message.referenceName !== "") {
      obj.referenceName = message.referenceName;
    }
    if (!message.start.equals(Long.ZERO)) {
      obj.start = (message.start || Long.ZERO).toString();
    }
    if (!message.end.equals(Long.ZERO)) {
      obj.end = (message.end || Long.ZERO).toString();
    }
    if (message.reverseStrand !== false) {
      obj.reverseStrand = message.reverseStrand;
    }
    if (message.type !== 0) {
      obj.type = annotationTypeToJSON(message.type);
    }
    if (message.variant !== undefined) {
      obj.variant = VariantAnnotation.toJSON(message.variant);
    }
    if (message.transcript !== undefined) {
      obj.transcript = Transcript.toJSON(message.transcript);
    }
    if (message.info) {
      const entries = Object.entries(message.info);
      if (entries.length > 0) {
        obj.info = {};
        entries.forEach(([k, v]) => {
          obj.info[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<Annotation>): Annotation {
    return Annotation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Annotation>): Annotation {
    const message = createBaseAnnotation();
    message.id = object.id ?? "";
    message.annotationSetId = object.annotationSetId ?? "";
    message.name = object.name ?? "";
    message.referenceId = object.referenceId ?? "";
    message.referenceName = object.referenceName ?? "";
    message.start = (object.start !== undefined && object.start !== null) ? Long.fromValue(object.start) : Long.ZERO;
    message.end = (object.end !== undefined && object.end !== null) ? Long.fromValue(object.end) : Long.ZERO;
    message.reverseStrand = object.reverseStrand ?? false;
    message.type = object.type ?? 0;
    message.variant = (object.variant !== undefined && object.variant !== null)
      ? VariantAnnotation.fromPartial(object.variant)
      : undefined;
    message.transcript = (object.transcript !== undefined && object.transcript !== null)
      ? Transcript.fromPartial(object.transcript)
      : undefined;
    message.info = Object.entries(object.info ?? {}).reduce<{ [key: string]: Array<any> | undefined }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseAnnotation_InfoEntry(): Annotation_InfoEntry {
  return { key: "", value: undefined };
}

export const Annotation_InfoEntry: MessageFns<Annotation_InfoEntry> = {
  encode(message: Annotation_InfoEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ListValue.encode(ListValue.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Annotation_InfoEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnotation_InfoEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = ListValue.unwrap(ListValue.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Annotation_InfoEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: globalThis.Array.isArray(object.value) ? [...object.value] : undefined,
    };
  },

  toJSON(message: Annotation_InfoEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Annotation_InfoEntry>): Annotation_InfoEntry {
    return Annotation_InfoEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Annotation_InfoEntry>): Annotation_InfoEntry {
    const message = createBaseAnnotation_InfoEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseVariantAnnotation(): VariantAnnotation {
  return {
    type: 0,
    effect: 0,
    alternateBases: "",
    geneId: "",
    transcriptIds: [],
    conditions: [],
    clinicalSignificance: 0,
  };
}

export const VariantAnnotation: MessageFns<VariantAnnotation> = {
  encode(message: VariantAnnotation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.effect !== 0) {
      writer.uint32(16).int32(message.effect);
    }
    if (message.alternateBases !== "") {
      writer.uint32(26).string(message.alternateBases);
    }
    if (message.geneId !== "") {
      writer.uint32(34).string(message.geneId);
    }
    for (const v of message.transcriptIds) {
      writer.uint32(42).string(v!);
    }
    for (const v of message.conditions) {
      VariantAnnotation_ClinicalCondition.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.clinicalSignificance !== 0) {
      writer.uint32(56).int32(message.clinicalSignificance);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VariantAnnotation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariantAnnotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.effect = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.alternateBases = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.geneId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.transcriptIds.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.conditions.push(VariantAnnotation_ClinicalCondition.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.clinicalSignificance = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VariantAnnotation {
    return {
      type: isSet(object.type) ? variantAnnotation_TypeFromJSON(object.type) : 0,
      effect: isSet(object.effect) ? variantAnnotation_EffectFromJSON(object.effect) : 0,
      alternateBases: isSet(object.alternateBases) ? globalThis.String(object.alternateBases) : "",
      geneId: isSet(object.geneId) ? globalThis.String(object.geneId) : "",
      transcriptIds: globalThis.Array.isArray(object?.transcriptIds)
        ? object.transcriptIds.map((e: any) => globalThis.String(e))
        : [],
      conditions: globalThis.Array.isArray(object?.conditions)
        ? object.conditions.map((e: any) => VariantAnnotation_ClinicalCondition.fromJSON(e))
        : [],
      clinicalSignificance: isSet(object.clinicalSignificance)
        ? variantAnnotation_ClinicalSignificanceFromJSON(object.clinicalSignificance)
        : 0,
    };
  },

  toJSON(message: VariantAnnotation): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = variantAnnotation_TypeToJSON(message.type);
    }
    if (message.effect !== 0) {
      obj.effect = variantAnnotation_EffectToJSON(message.effect);
    }
    if (message.alternateBases !== "") {
      obj.alternateBases = message.alternateBases;
    }
    if (message.geneId !== "") {
      obj.geneId = message.geneId;
    }
    if (message.transcriptIds?.length) {
      obj.transcriptIds = message.transcriptIds;
    }
    if (message.conditions?.length) {
      obj.conditions = message.conditions.map((e) => VariantAnnotation_ClinicalCondition.toJSON(e));
    }
    if (message.clinicalSignificance !== 0) {
      obj.clinicalSignificance = variantAnnotation_ClinicalSignificanceToJSON(message.clinicalSignificance);
    }
    return obj;
  },

  create(base?: DeepPartial<VariantAnnotation>): VariantAnnotation {
    return VariantAnnotation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VariantAnnotation>): VariantAnnotation {
    const message = createBaseVariantAnnotation();
    message.type = object.type ?? 0;
    message.effect = object.effect ?? 0;
    message.alternateBases = object.alternateBases ?? "";
    message.geneId = object.geneId ?? "";
    message.transcriptIds = object.transcriptIds?.map((e) => e) || [];
    message.conditions = object.conditions?.map((e) => VariantAnnotation_ClinicalCondition.fromPartial(e)) || [];
    message.clinicalSignificance = object.clinicalSignificance ?? 0;
    return message;
  },
};

function createBaseVariantAnnotation_ClinicalCondition(): VariantAnnotation_ClinicalCondition {
  return { names: [], externalIds: [], conceptId: "", omimId: "" };
}

export const VariantAnnotation_ClinicalCondition: MessageFns<VariantAnnotation_ClinicalCondition> = {
  encode(message: VariantAnnotation_ClinicalCondition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.names) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.externalIds) {
      ExternalId.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.conceptId !== "") {
      writer.uint32(26).string(message.conceptId);
    }
    if (message.omimId !== "") {
      writer.uint32(34).string(message.omimId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VariantAnnotation_ClinicalCondition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariantAnnotation_ClinicalCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.names.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.externalIds.push(ExternalId.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.conceptId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.omimId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VariantAnnotation_ClinicalCondition {
    return {
      names: globalThis.Array.isArray(object?.names) ? object.names.map((e: any) => globalThis.String(e)) : [],
      externalIds: globalThis.Array.isArray(object?.externalIds)
        ? object.externalIds.map((e: any) => ExternalId.fromJSON(e))
        : [],
      conceptId: isSet(object.conceptId) ? globalThis.String(object.conceptId) : "",
      omimId: isSet(object.omimId) ? globalThis.String(object.omimId) : "",
    };
  },

  toJSON(message: VariantAnnotation_ClinicalCondition): unknown {
    const obj: any = {};
    if (message.names?.length) {
      obj.names = message.names;
    }
    if (message.externalIds?.length) {
      obj.externalIds = message.externalIds.map((e) => ExternalId.toJSON(e));
    }
    if (message.conceptId !== "") {
      obj.conceptId = message.conceptId;
    }
    if (message.omimId !== "") {
      obj.omimId = message.omimId;
    }
    return obj;
  },

  create(base?: DeepPartial<VariantAnnotation_ClinicalCondition>): VariantAnnotation_ClinicalCondition {
    return VariantAnnotation_ClinicalCondition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VariantAnnotation_ClinicalCondition>): VariantAnnotation_ClinicalCondition {
    const message = createBaseVariantAnnotation_ClinicalCondition();
    message.names = object.names?.map((e) => e) || [];
    message.externalIds = object.externalIds?.map((e) => ExternalId.fromPartial(e)) || [];
    message.conceptId = object.conceptId ?? "";
    message.omimId = object.omimId ?? "";
    return message;
  },
};

function createBaseTranscript(): Transcript {
  return { geneId: "", exons: [], codingSequence: undefined };
}

export const Transcript: MessageFns<Transcript> = {
  encode(message: Transcript, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.geneId !== "") {
      writer.uint32(10).string(message.geneId);
    }
    for (const v of message.exons) {
      Transcript_Exon.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.codingSequence !== undefined) {
      Transcript_CodingSequence.encode(message.codingSequence, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Transcript {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTranscript();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.geneId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.exons.push(Transcript_Exon.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.codingSequence = Transcript_CodingSequence.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Transcript {
    return {
      geneId: isSet(object.geneId) ? globalThis.String(object.geneId) : "",
      exons: globalThis.Array.isArray(object?.exons) ? object.exons.map((e: any) => Transcript_Exon.fromJSON(e)) : [],
      codingSequence: isSet(object.codingSequence)
        ? Transcript_CodingSequence.fromJSON(object.codingSequence)
        : undefined,
    };
  },

  toJSON(message: Transcript): unknown {
    const obj: any = {};
    if (message.geneId !== "") {
      obj.geneId = message.geneId;
    }
    if (message.exons?.length) {
      obj.exons = message.exons.map((e) => Transcript_Exon.toJSON(e));
    }
    if (message.codingSequence !== undefined) {
      obj.codingSequence = Transcript_CodingSequence.toJSON(message.codingSequence);
    }
    return obj;
  },

  create(base?: DeepPartial<Transcript>): Transcript {
    return Transcript.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Transcript>): Transcript {
    const message = createBaseTranscript();
    message.geneId = object.geneId ?? "";
    message.exons = object.exons?.map((e) => Transcript_Exon.fromPartial(e)) || [];
    message.codingSequence = (object.codingSequence !== undefined && object.codingSequence !== null)
      ? Transcript_CodingSequence.fromPartial(object.codingSequence)
      : undefined;
    return message;
  },
};

function createBaseTranscript_Exon(): Transcript_Exon {
  return { start: Long.ZERO, end: Long.ZERO, frame: undefined };
}

export const Transcript_Exon: MessageFns<Transcript_Exon> = {
  encode(message: Transcript_Exon, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.start.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.start.toString());
    }
    if (!message.end.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.end.toString());
    }
    if (message.frame !== undefined) {
      Int32Value.encode({ value: message.frame! }, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Transcript_Exon {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTranscript_Exon();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.start = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.end = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.frame = Int32Value.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Transcript_Exon {
    return {
      start: isSet(object.start) ? Long.fromValue(object.start) : Long.ZERO,
      end: isSet(object.end) ? Long.fromValue(object.end) : Long.ZERO,
      frame: isSet(object.frame) ? Number(object.frame) : undefined,
    };
  },

  toJSON(message: Transcript_Exon): unknown {
    const obj: any = {};
    if (!message.start.equals(Long.ZERO)) {
      obj.start = (message.start || Long.ZERO).toString();
    }
    if (!message.end.equals(Long.ZERO)) {
      obj.end = (message.end || Long.ZERO).toString();
    }
    if (message.frame !== undefined) {
      obj.frame = message.frame;
    }
    return obj;
  },

  create(base?: DeepPartial<Transcript_Exon>): Transcript_Exon {
    return Transcript_Exon.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Transcript_Exon>): Transcript_Exon {
    const message = createBaseTranscript_Exon();
    message.start = (object.start !== undefined && object.start !== null) ? Long.fromValue(object.start) : Long.ZERO;
    message.end = (object.end !== undefined && object.end !== null) ? Long.fromValue(object.end) : Long.ZERO;
    message.frame = object.frame ?? undefined;
    return message;
  },
};

function createBaseTranscript_CodingSequence(): Transcript_CodingSequence {
  return { start: Long.ZERO, end: Long.ZERO };
}

export const Transcript_CodingSequence: MessageFns<Transcript_CodingSequence> = {
  encode(message: Transcript_CodingSequence, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.start.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.start.toString());
    }
    if (!message.end.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.end.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Transcript_CodingSequence {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTranscript_CodingSequence();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.start = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.end = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Transcript_CodingSequence {
    return {
      start: isSet(object.start) ? Long.fromValue(object.start) : Long.ZERO,
      end: isSet(object.end) ? Long.fromValue(object.end) : Long.ZERO,
    };
  },

  toJSON(message: Transcript_CodingSequence): unknown {
    const obj: any = {};
    if (!message.start.equals(Long.ZERO)) {
      obj.start = (message.start || Long.ZERO).toString();
    }
    if (!message.end.equals(Long.ZERO)) {
      obj.end = (message.end || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Transcript_CodingSequence>): Transcript_CodingSequence {
    return Transcript_CodingSequence.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Transcript_CodingSequence>): Transcript_CodingSequence {
    const message = createBaseTranscript_CodingSequence();
    message.start = (object.start !== undefined && object.start !== null) ? Long.fromValue(object.start) : Long.ZERO;
    message.end = (object.end !== undefined && object.end !== null) ? Long.fromValue(object.end) : Long.ZERO;
    return message;
  },
};

function createBaseExternalId(): ExternalId {
  return { sourceName: "", id: "" };
}

export const ExternalId: MessageFns<ExternalId> = {
  encode(message: ExternalId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sourceName !== "") {
      writer.uint32(10).string(message.sourceName);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExternalId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExternalId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sourceName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExternalId {
    return {
      sourceName: isSet(object.sourceName) ? globalThis.String(object.sourceName) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: ExternalId): unknown {
    const obj: any = {};
    if (message.sourceName !== "") {
      obj.sourceName = message.sourceName;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create(base?: DeepPartial<ExternalId>): ExternalId {
    return ExternalId.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExternalId>): ExternalId {
    const message = createBaseExternalId();
    message.sourceName = object.sourceName ?? "";
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseCreateAnnotationSetRequest(): CreateAnnotationSetRequest {
  return { annotationSet: undefined };
}

export const CreateAnnotationSetRequest: MessageFns<CreateAnnotationSetRequest> = {
  encode(message: CreateAnnotationSetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.annotationSet !== undefined) {
      AnnotationSet.encode(message.annotationSet, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateAnnotationSetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateAnnotationSetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.annotationSet = AnnotationSet.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateAnnotationSetRequest {
    return { annotationSet: isSet(object.annotationSet) ? AnnotationSet.fromJSON(object.annotationSet) : undefined };
  },

  toJSON(message: CreateAnnotationSetRequest): unknown {
    const obj: any = {};
    if (message.annotationSet !== undefined) {
      obj.annotationSet = AnnotationSet.toJSON(message.annotationSet);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateAnnotationSetRequest>): CreateAnnotationSetRequest {
    return CreateAnnotationSetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateAnnotationSetRequest>): CreateAnnotationSetRequest {
    const message = createBaseCreateAnnotationSetRequest();
    message.annotationSet = (object.annotationSet !== undefined && object.annotationSet !== null)
      ? AnnotationSet.fromPartial(object.annotationSet)
      : undefined;
    return message;
  },
};

function createBaseGetAnnotationSetRequest(): GetAnnotationSetRequest {
  return { annotationSetId: "" };
}

export const GetAnnotationSetRequest: MessageFns<GetAnnotationSetRequest> = {
  encode(message: GetAnnotationSetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.annotationSetId !== "") {
      writer.uint32(10).string(message.annotationSetId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAnnotationSetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAnnotationSetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.annotationSetId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAnnotationSetRequest {
    return { annotationSetId: isSet(object.annotationSetId) ? globalThis.String(object.annotationSetId) : "" };
  },

  toJSON(message: GetAnnotationSetRequest): unknown {
    const obj: any = {};
    if (message.annotationSetId !== "") {
      obj.annotationSetId = message.annotationSetId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetAnnotationSetRequest>): GetAnnotationSetRequest {
    return GetAnnotationSetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAnnotationSetRequest>): GetAnnotationSetRequest {
    const message = createBaseGetAnnotationSetRequest();
    message.annotationSetId = object.annotationSetId ?? "";
    return message;
  },
};

function createBaseUpdateAnnotationSetRequest(): UpdateAnnotationSetRequest {
  return { annotationSetId: "", annotationSet: undefined, updateMask: undefined };
}

export const UpdateAnnotationSetRequest: MessageFns<UpdateAnnotationSetRequest> = {
  encode(message: UpdateAnnotationSetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.annotationSetId !== "") {
      writer.uint32(10).string(message.annotationSetId);
    }
    if (message.annotationSet !== undefined) {
      AnnotationSet.encode(message.annotationSet, writer.uint32(18).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateAnnotationSetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateAnnotationSetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.annotationSetId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.annotationSet = AnnotationSet.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateAnnotationSetRequest {
    return {
      annotationSetId: isSet(object.annotationSetId) ? globalThis.String(object.annotationSetId) : "",
      annotationSet: isSet(object.annotationSet) ? AnnotationSet.fromJSON(object.annotationSet) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateAnnotationSetRequest): unknown {
    const obj: any = {};
    if (message.annotationSetId !== "") {
      obj.annotationSetId = message.annotationSetId;
    }
    if (message.annotationSet !== undefined) {
      obj.annotationSet = AnnotationSet.toJSON(message.annotationSet);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateAnnotationSetRequest>): UpdateAnnotationSetRequest {
    return UpdateAnnotationSetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateAnnotationSetRequest>): UpdateAnnotationSetRequest {
    const message = createBaseUpdateAnnotationSetRequest();
    message.annotationSetId = object.annotationSetId ?? "";
    message.annotationSet = (object.annotationSet !== undefined && object.annotationSet !== null)
      ? AnnotationSet.fromPartial(object.annotationSet)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseDeleteAnnotationSetRequest(): DeleteAnnotationSetRequest {
  return { annotationSetId: "" };
}

export const DeleteAnnotationSetRequest: MessageFns<DeleteAnnotationSetRequest> = {
  encode(message: DeleteAnnotationSetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.annotationSetId !== "") {
      writer.uint32(10).string(message.annotationSetId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteAnnotationSetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteAnnotationSetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.annotationSetId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteAnnotationSetRequest {
    return { annotationSetId: isSet(object.annotationSetId) ? globalThis.String(object.annotationSetId) : "" };
  },

  toJSON(message: DeleteAnnotationSetRequest): unknown {
    const obj: any = {};
    if (message.annotationSetId !== "") {
      obj.annotationSetId = message.annotationSetId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteAnnotationSetRequest>): DeleteAnnotationSetRequest {
    return DeleteAnnotationSetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteAnnotationSetRequest>): DeleteAnnotationSetRequest {
    const message = createBaseDeleteAnnotationSetRequest();
    message.annotationSetId = object.annotationSetId ?? "";
    return message;
  },
};

function createBaseSearchAnnotationSetsRequest(): SearchAnnotationSetsRequest {
  return { datasetIds: [], referenceSetId: "", name: "", types: [], pageToken: "", pageSize: 0 };
}

export const SearchAnnotationSetsRequest: MessageFns<SearchAnnotationSetsRequest> = {
  encode(message: SearchAnnotationSetsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.datasetIds) {
      writer.uint32(10).string(v!);
    }
    if (message.referenceSetId !== "") {
      writer.uint32(18).string(message.referenceSetId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    writer.uint32(34).fork();
    for (const v of message.types) {
      writer.int32(v);
    }
    writer.join();
    if (message.pageToken !== "") {
      writer.uint32(42).string(message.pageToken);
    }
    if (message.pageSize !== 0) {
      writer.uint32(48).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchAnnotationSetsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchAnnotationSetsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.datasetIds.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.referenceSetId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag === 32) {
            message.types.push(reader.int32() as any);

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.types.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchAnnotationSetsRequest {
    return {
      datasetIds: globalThis.Array.isArray(object?.datasetIds)
        ? object.datasetIds.map((e: any) => globalThis.String(e))
        : [],
      referenceSetId: isSet(object.referenceSetId) ? globalThis.String(object.referenceSetId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      types: globalThis.Array.isArray(object?.types) ? object.types.map((e: any) => annotationTypeFromJSON(e)) : [],
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
    };
  },

  toJSON(message: SearchAnnotationSetsRequest): unknown {
    const obj: any = {};
    if (message.datasetIds?.length) {
      obj.datasetIds = message.datasetIds;
    }
    if (message.referenceSetId !== "") {
      obj.referenceSetId = message.referenceSetId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.types?.length) {
      obj.types = message.types.map((e) => annotationTypeToJSON(e));
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchAnnotationSetsRequest>): SearchAnnotationSetsRequest {
    return SearchAnnotationSetsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchAnnotationSetsRequest>): SearchAnnotationSetsRequest {
    const message = createBaseSearchAnnotationSetsRequest();
    message.datasetIds = object.datasetIds?.map((e) => e) || [];
    message.referenceSetId = object.referenceSetId ?? "";
    message.name = object.name ?? "";
    message.types = object.types?.map((e) => e) || [];
    message.pageToken = object.pageToken ?? "";
    message.pageSize = object.pageSize ?? 0;
    return message;
  },
};

function createBaseSearchAnnotationSetsResponse(): SearchAnnotationSetsResponse {
  return { annotationSets: [], nextPageToken: "" };
}

export const SearchAnnotationSetsResponse: MessageFns<SearchAnnotationSetsResponse> = {
  encode(message: SearchAnnotationSetsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.annotationSets) {
      AnnotationSet.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchAnnotationSetsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchAnnotationSetsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.annotationSets.push(AnnotationSet.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchAnnotationSetsResponse {
    return {
      annotationSets: globalThis.Array.isArray(object?.annotationSets)
        ? object.annotationSets.map((e: any) => AnnotationSet.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: SearchAnnotationSetsResponse): unknown {
    const obj: any = {};
    if (message.annotationSets?.length) {
      obj.annotationSets = message.annotationSets.map((e) => AnnotationSet.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchAnnotationSetsResponse>): SearchAnnotationSetsResponse {
    return SearchAnnotationSetsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchAnnotationSetsResponse>): SearchAnnotationSetsResponse {
    const message = createBaseSearchAnnotationSetsResponse();
    message.annotationSets = object.annotationSets?.map((e) => AnnotationSet.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseCreateAnnotationRequest(): CreateAnnotationRequest {
  return { annotation: undefined };
}

export const CreateAnnotationRequest: MessageFns<CreateAnnotationRequest> = {
  encode(message: CreateAnnotationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.annotation !== undefined) {
      Annotation.encode(message.annotation, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateAnnotationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateAnnotationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.annotation = Annotation.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateAnnotationRequest {
    return { annotation: isSet(object.annotation) ? Annotation.fromJSON(object.annotation) : undefined };
  },

  toJSON(message: CreateAnnotationRequest): unknown {
    const obj: any = {};
    if (message.annotation !== undefined) {
      obj.annotation = Annotation.toJSON(message.annotation);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateAnnotationRequest>): CreateAnnotationRequest {
    return CreateAnnotationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateAnnotationRequest>): CreateAnnotationRequest {
    const message = createBaseCreateAnnotationRequest();
    message.annotation = (object.annotation !== undefined && object.annotation !== null)
      ? Annotation.fromPartial(object.annotation)
      : undefined;
    return message;
  },
};

function createBaseBatchCreateAnnotationsRequest(): BatchCreateAnnotationsRequest {
  return { annotations: [], requestId: "" };
}

export const BatchCreateAnnotationsRequest: MessageFns<BatchCreateAnnotationsRequest> = {
  encode(message: BatchCreateAnnotationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.annotations) {
      Annotation.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchCreateAnnotationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchCreateAnnotationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.annotations.push(Annotation.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchCreateAnnotationsRequest {
    return {
      annotations: globalThis.Array.isArray(object?.annotations)
        ? object.annotations.map((e: any) => Annotation.fromJSON(e))
        : [],
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: BatchCreateAnnotationsRequest): unknown {
    const obj: any = {};
    if (message.annotations?.length) {
      obj.annotations = message.annotations.map((e) => Annotation.toJSON(e));
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<BatchCreateAnnotationsRequest>): BatchCreateAnnotationsRequest {
    return BatchCreateAnnotationsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchCreateAnnotationsRequest>): BatchCreateAnnotationsRequest {
    const message = createBaseBatchCreateAnnotationsRequest();
    message.annotations = object.annotations?.map((e) => Annotation.fromPartial(e)) || [];
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseBatchCreateAnnotationsResponse(): BatchCreateAnnotationsResponse {
  return { entries: [] };
}

export const BatchCreateAnnotationsResponse: MessageFns<BatchCreateAnnotationsResponse> = {
  encode(message: BatchCreateAnnotationsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entries) {
      BatchCreateAnnotationsResponse_Entry.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchCreateAnnotationsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchCreateAnnotationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entries.push(BatchCreateAnnotationsResponse_Entry.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchCreateAnnotationsResponse {
    return {
      entries: globalThis.Array.isArray(object?.entries)
        ? object.entries.map((e: any) => BatchCreateAnnotationsResponse_Entry.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchCreateAnnotationsResponse): unknown {
    const obj: any = {};
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => BatchCreateAnnotationsResponse_Entry.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchCreateAnnotationsResponse>): BatchCreateAnnotationsResponse {
    return BatchCreateAnnotationsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchCreateAnnotationsResponse>): BatchCreateAnnotationsResponse {
    const message = createBaseBatchCreateAnnotationsResponse();
    message.entries = object.entries?.map((e) => BatchCreateAnnotationsResponse_Entry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBatchCreateAnnotationsResponse_Entry(): BatchCreateAnnotationsResponse_Entry {
  return { status: undefined, annotation: undefined };
}

export const BatchCreateAnnotationsResponse_Entry: MessageFns<BatchCreateAnnotationsResponse_Entry> = {
  encode(message: BatchCreateAnnotationsResponse_Entry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.annotation !== undefined) {
      Annotation.encode(message.annotation, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchCreateAnnotationsResponse_Entry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchCreateAnnotationsResponse_Entry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.annotation = Annotation.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchCreateAnnotationsResponse_Entry {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      annotation: isSet(object.annotation) ? Annotation.fromJSON(object.annotation) : undefined,
    };
  },

  toJSON(message: BatchCreateAnnotationsResponse_Entry): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.annotation !== undefined) {
      obj.annotation = Annotation.toJSON(message.annotation);
    }
    return obj;
  },

  create(base?: DeepPartial<BatchCreateAnnotationsResponse_Entry>): BatchCreateAnnotationsResponse_Entry {
    return BatchCreateAnnotationsResponse_Entry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchCreateAnnotationsResponse_Entry>): BatchCreateAnnotationsResponse_Entry {
    const message = createBaseBatchCreateAnnotationsResponse_Entry();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.annotation = (object.annotation !== undefined && object.annotation !== null)
      ? Annotation.fromPartial(object.annotation)
      : undefined;
    return message;
  },
};

function createBaseGetAnnotationRequest(): GetAnnotationRequest {
  return { annotationId: "" };
}

export const GetAnnotationRequest: MessageFns<GetAnnotationRequest> = {
  encode(message: GetAnnotationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.annotationId !== "") {
      writer.uint32(10).string(message.annotationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAnnotationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAnnotationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.annotationId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAnnotationRequest {
    return { annotationId: isSet(object.annotationId) ? globalThis.String(object.annotationId) : "" };
  },

  toJSON(message: GetAnnotationRequest): unknown {
    const obj: any = {};
    if (message.annotationId !== "") {
      obj.annotationId = message.annotationId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetAnnotationRequest>): GetAnnotationRequest {
    return GetAnnotationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAnnotationRequest>): GetAnnotationRequest {
    const message = createBaseGetAnnotationRequest();
    message.annotationId = object.annotationId ?? "";
    return message;
  },
};

function createBaseUpdateAnnotationRequest(): UpdateAnnotationRequest {
  return { annotationId: "", annotation: undefined, updateMask: undefined };
}

export const UpdateAnnotationRequest: MessageFns<UpdateAnnotationRequest> = {
  encode(message: UpdateAnnotationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.annotationId !== "") {
      writer.uint32(10).string(message.annotationId);
    }
    if (message.annotation !== undefined) {
      Annotation.encode(message.annotation, writer.uint32(18).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateAnnotationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateAnnotationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.annotationId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.annotation = Annotation.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateAnnotationRequest {
    return {
      annotationId: isSet(object.annotationId) ? globalThis.String(object.annotationId) : "",
      annotation: isSet(object.annotation) ? Annotation.fromJSON(object.annotation) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateAnnotationRequest): unknown {
    const obj: any = {};
    if (message.annotationId !== "") {
      obj.annotationId = message.annotationId;
    }
    if (message.annotation !== undefined) {
      obj.annotation = Annotation.toJSON(message.annotation);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateAnnotationRequest>): UpdateAnnotationRequest {
    return UpdateAnnotationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateAnnotationRequest>): UpdateAnnotationRequest {
    const message = createBaseUpdateAnnotationRequest();
    message.annotationId = object.annotationId ?? "";
    message.annotation = (object.annotation !== undefined && object.annotation !== null)
      ? Annotation.fromPartial(object.annotation)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseDeleteAnnotationRequest(): DeleteAnnotationRequest {
  return { annotationId: "" };
}

export const DeleteAnnotationRequest: MessageFns<DeleteAnnotationRequest> = {
  encode(message: DeleteAnnotationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.annotationId !== "") {
      writer.uint32(10).string(message.annotationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteAnnotationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteAnnotationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.annotationId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteAnnotationRequest {
    return { annotationId: isSet(object.annotationId) ? globalThis.String(object.annotationId) : "" };
  },

  toJSON(message: DeleteAnnotationRequest): unknown {
    const obj: any = {};
    if (message.annotationId !== "") {
      obj.annotationId = message.annotationId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteAnnotationRequest>): DeleteAnnotationRequest {
    return DeleteAnnotationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteAnnotationRequest>): DeleteAnnotationRequest {
    const message = createBaseDeleteAnnotationRequest();
    message.annotationId = object.annotationId ?? "";
    return message;
  },
};

function createBaseSearchAnnotationsRequest(): SearchAnnotationsRequest {
  return {
    annotationSetIds: [],
    referenceId: undefined,
    referenceName: undefined,
    start: Long.ZERO,
    end: Long.ZERO,
    pageToken: "",
    pageSize: 0,
  };
}

export const SearchAnnotationsRequest: MessageFns<SearchAnnotationsRequest> = {
  encode(message: SearchAnnotationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.annotationSetIds) {
      writer.uint32(10).string(v!);
    }
    if (message.referenceId !== undefined) {
      writer.uint32(18).string(message.referenceId);
    }
    if (message.referenceName !== undefined) {
      writer.uint32(26).string(message.referenceName);
    }
    if (!message.start.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.start.toString());
    }
    if (!message.end.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.end.toString());
    }
    if (message.pageToken !== "") {
      writer.uint32(50).string(message.pageToken);
    }
    if (message.pageSize !== 0) {
      writer.uint32(56).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchAnnotationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchAnnotationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.annotationSetIds.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.referenceId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.referenceName = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.start = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.end = Long.fromString(reader.int64().toString());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchAnnotationsRequest {
    return {
      annotationSetIds: globalThis.Array.isArray(object?.annotationSetIds)
        ? object.annotationSetIds.map((e: any) => globalThis.String(e))
        : [],
      referenceId: isSet(object.referenceId) ? globalThis.String(object.referenceId) : undefined,
      referenceName: isSet(object.referenceName) ? globalThis.String(object.referenceName) : undefined,
      start: isSet(object.start) ? Long.fromValue(object.start) : Long.ZERO,
      end: isSet(object.end) ? Long.fromValue(object.end) : Long.ZERO,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
    };
  },

  toJSON(message: SearchAnnotationsRequest): unknown {
    const obj: any = {};
    if (message.annotationSetIds?.length) {
      obj.annotationSetIds = message.annotationSetIds;
    }
    if (message.referenceId !== undefined) {
      obj.referenceId = message.referenceId;
    }
    if (message.referenceName !== undefined) {
      obj.referenceName = message.referenceName;
    }
    if (!message.start.equals(Long.ZERO)) {
      obj.start = (message.start || Long.ZERO).toString();
    }
    if (!message.end.equals(Long.ZERO)) {
      obj.end = (message.end || Long.ZERO).toString();
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchAnnotationsRequest>): SearchAnnotationsRequest {
    return SearchAnnotationsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchAnnotationsRequest>): SearchAnnotationsRequest {
    const message = createBaseSearchAnnotationsRequest();
    message.annotationSetIds = object.annotationSetIds?.map((e) => e) || [];
    message.referenceId = object.referenceId ?? undefined;
    message.referenceName = object.referenceName ?? undefined;
    message.start = (object.start !== undefined && object.start !== null) ? Long.fromValue(object.start) : Long.ZERO;
    message.end = (object.end !== undefined && object.end !== null) ? Long.fromValue(object.end) : Long.ZERO;
    message.pageToken = object.pageToken ?? "";
    message.pageSize = object.pageSize ?? 0;
    return message;
  },
};

function createBaseSearchAnnotationsResponse(): SearchAnnotationsResponse {
  return { annotations: [], nextPageToken: "" };
}

export const SearchAnnotationsResponse: MessageFns<SearchAnnotationsResponse> = {
  encode(message: SearchAnnotationsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.annotations) {
      Annotation.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchAnnotationsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchAnnotationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.annotations.push(Annotation.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchAnnotationsResponse {
    return {
      annotations: globalThis.Array.isArray(object?.annotations)
        ? object.annotations.map((e: any) => Annotation.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: SearchAnnotationsResponse): unknown {
    const obj: any = {};
    if (message.annotations?.length) {
      obj.annotations = message.annotations.map((e) => Annotation.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchAnnotationsResponse>): SearchAnnotationsResponse {
    return SearchAnnotationsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchAnnotationsResponse>): SearchAnnotationsResponse {
    const message = createBaseSearchAnnotationsResponse();
    message.annotations = object.annotations?.map((e) => Annotation.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

/**
 * This service provides storage and positional retrieval of genomic
 * reference annotations, including variant annotations.
 */
export type AnnotationServiceV1Definition = typeof AnnotationServiceV1Definition;
export const AnnotationServiceV1Definition = {
  name: "AnnotationServiceV1",
  fullName: "google.genomics.v1.AnnotationServiceV1",
  methods: {
    /**
     * Creates a new annotation set. Caller must have WRITE permission for the
     * associated dataset.
     *
     * The following fields are required:
     *
     *   * [datasetId][google.genomics.v1.AnnotationSet.dataset_id]
     *   * [referenceSetId][google.genomics.v1.AnnotationSet.reference_set_id]
     *
     * All other fields may be optionally specified, unless documented as being
     * server-generated (for example, the `id` field).
     */
    createAnnotationSet: {
      name: "CreateAnnotationSet",
      requestType: CreateAnnotationSetRequest,
      requestStream: false,
      responseType: AnnotationSet,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              36,
              58,
              14,
              97,
              110,
              110,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
              95,
              115,
              101,
              116,
              34,
              18,
              47,
              118,
              49,
              47,
              97,
              110,
              110,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
              115,
              101,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Gets an annotation set. Caller must have READ permission for
     * the associated dataset.
     */
    getAnnotationSet: {
      name: "GetAnnotationSet",
      requestType: GetAnnotationSetRequest,
      requestStream: false,
      responseType: AnnotationSet,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              40,
              18,
              38,
              47,
              118,
              49,
              47,
              97,
              110,
              110,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
              115,
              101,
              116,
              115,
              47,
              123,
              97,
              110,
              110,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
              95,
              115,
              101,
              116,
              95,
              105,
              100,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Updates an annotation set. The update must respect all mutability
     * restrictions and other invariants described on the annotation set resource.
     * Caller must have WRITE permission for the associated dataset.
     */
    updateAnnotationSet: {
      name: "UpdateAnnotationSet",
      requestType: UpdateAnnotationSetRequest,
      requestStream: false,
      responseType: AnnotationSet,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              56,
              58,
              14,
              97,
              110,
              110,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
              95,
              115,
              101,
              116,
              26,
              38,
              47,
              118,
              49,
              47,
              97,
              110,
              110,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
              115,
              101,
              116,
              115,
              47,
              123,
              97,
              110,
              110,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
              95,
              115,
              101,
              116,
              95,
              105,
              100,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes an annotation set. Caller must have WRITE permission
     * for the associated annotation set.
     */
    deleteAnnotationSet: {
      name: "DeleteAnnotationSet",
      requestType: DeleteAnnotationSetRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              40,
              42,
              38,
              47,
              118,
              49,
              47,
              97,
              110,
              110,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
              115,
              101,
              116,
              115,
              47,
              123,
              97,
              110,
              110,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
              95,
              115,
              101,
              116,
              95,
              105,
              100,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Searches for annotation sets that match the given criteria. Annotation sets
     * are returned in an unspecified order. This order is consistent, such that
     * two queries for the same content (regardless of page size) yield annotation
     * sets in the same order across their respective streams of paginated
     * responses. Caller must have READ permission for the queried datasets.
     */
    searchAnnotationSets: {
      name: "SearchAnnotationSets",
      requestType: SearchAnnotationSetsRequest,
      requestStream: false,
      responseType: SearchAnnotationSetsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              30,
              58,
              1,
              42,
              34,
              25,
              47,
              118,
              49,
              47,
              97,
              110,
              110,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
              115,
              101,
              116,
              115,
              47,
              115,
              101,
              97,
              114,
              99,
              104,
            ]),
          ],
        },
      },
    },
    /**
     * Creates a new annotation. Caller must have WRITE permission
     * for the associated annotation set.
     *
     * The following fields are required:
     *
     * * [annotationSetId][google.genomics.v1.Annotation.annotation_set_id]
     * * [referenceName][google.genomics.v1.Annotation.reference_name] or
     *   [referenceId][google.genomics.v1.Annotation.reference_id]
     *
     * ### Transcripts
     *
     * For annotations of type TRANSCRIPT, the following fields of
     * [transcript][google.genomics.v1.Annotation.transcript] must be provided:
     *
     * * [exons.start][google.genomics.v1.Transcript.Exon.start]
     * * [exons.end][google.genomics.v1.Transcript.Exon.end]
     *
     * All other fields may be optionally specified, unless documented as being
     * server-generated (for example, the `id` field). The annotated
     * range must be no longer than 100Mbp (mega base pairs). See the
     * [Annotation resource][google.genomics.v1.Annotation]
     * for additional restrictions on each field.
     */
    createAnnotation: {
      name: "CreateAnnotation",
      requestType: CreateAnnotationRequest,
      requestStream: false,
      responseType: Annotation,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              29,
              58,
              10,
              97,
              110,
              110,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
              34,
              15,
              47,
              118,
              49,
              47,
              97,
              110,
              110,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Creates one or more new annotations atomically. All annotations must
     * belong to the same annotation set. Caller must have WRITE
     * permission for this annotation set. For optimal performance, batch
     * positionally adjacent annotations together.
     *
     * If the request has a systemic issue, such as an attempt to write to
     * an inaccessible annotation set, the entire RPC will fail accordingly. For
     * lesser data issues, when possible an error will be isolated to the
     * corresponding batch entry in the response; the remaining well formed
     * annotations will be created normally.
     *
     * For details on the requirements for each individual annotation resource,
     * see
     * [CreateAnnotation][google.genomics.v1.AnnotationServiceV1.CreateAnnotation].
     */
    batchCreateAnnotations: {
      name: "BatchCreateAnnotations",
      requestType: BatchCreateAnnotationsRequest,
      requestStream: false,
      responseType: BatchCreateAnnotationsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              32,
              58,
              1,
              42,
              34,
              27,
              47,
              118,
              49,
              47,
              97,
              110,
              110,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
              115,
              58,
              98,
              97,
              116,
              99,
              104,
              67,
              114,
              101,
              97,
              116,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Gets an annotation. Caller must have READ permission
     * for the associated annotation set.
     */
    getAnnotation: {
      name: "GetAnnotation",
      requestType: GetAnnotationRequest,
      requestStream: false,
      responseType: Annotation,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              33,
              18,
              31,
              47,
              118,
              49,
              47,
              97,
              110,
              110,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              123,
              97,
              110,
              110,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
              95,
              105,
              100,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Updates an annotation. Caller must have
     * WRITE permission for the associated dataset.
     */
    updateAnnotation: {
      name: "UpdateAnnotation",
      requestType: UpdateAnnotationRequest,
      requestStream: false,
      responseType: Annotation,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              45,
              58,
              10,
              97,
              110,
              110,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
              26,
              31,
              47,
              118,
              49,
              47,
              97,
              110,
              110,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              123,
              97,
              110,
              110,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
              95,
              105,
              100,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes an annotation. Caller must have WRITE permission for
     * the associated annotation set.
     */
    deleteAnnotation: {
      name: "DeleteAnnotation",
      requestType: DeleteAnnotationRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              33,
              42,
              31,
              47,
              118,
              49,
              47,
              97,
              110,
              110,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              123,
              97,
              110,
              110,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
              95,
              105,
              100,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Searches for annotations that match the given criteria. Results are
     * ordered by genomic coordinate (by reference sequence, then position).
     * Annotations with equivalent genomic coordinates are returned in an
     * unspecified order. This order is consistent, such that two queries for the
     * same content (regardless of page size) yield annotations in the same order
     * across their respective streams of paginated responses. Caller must have
     * READ permission for the queried annotation sets.
     */
    searchAnnotations: {
      name: "SearchAnnotations",
      requestType: SearchAnnotationsRequest,
      requestStream: false,
      responseType: SearchAnnotationsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              27,
              58,
              1,
              42,
              34,
              22,
              47,
              118,
              49,
              47,
              97,
              110,
              110,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              115,
              101,
              97,
              114,
              99,
              104,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface AnnotationServiceV1ServiceImplementation<CallContextExt = {}> {
  /**
   * Creates a new annotation set. Caller must have WRITE permission for the
   * associated dataset.
   *
   * The following fields are required:
   *
   *   * [datasetId][google.genomics.v1.AnnotationSet.dataset_id]
   *   * [referenceSetId][google.genomics.v1.AnnotationSet.reference_set_id]
   *
   * All other fields may be optionally specified, unless documented as being
   * server-generated (for example, the `id` field).
   */
  createAnnotationSet(
    request: CreateAnnotationSetRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<AnnotationSet>>;
  /**
   * Gets an annotation set. Caller must have READ permission for
   * the associated dataset.
   */
  getAnnotationSet(
    request: GetAnnotationSetRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<AnnotationSet>>;
  /**
   * Updates an annotation set. The update must respect all mutability
   * restrictions and other invariants described on the annotation set resource.
   * Caller must have WRITE permission for the associated dataset.
   */
  updateAnnotationSet(
    request: UpdateAnnotationSetRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<AnnotationSet>>;
  /**
   * Deletes an annotation set. Caller must have WRITE permission
   * for the associated annotation set.
   */
  deleteAnnotationSet(
    request: DeleteAnnotationSetRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /**
   * Searches for annotation sets that match the given criteria. Annotation sets
   * are returned in an unspecified order. This order is consistent, such that
   * two queries for the same content (regardless of page size) yield annotation
   * sets in the same order across their respective streams of paginated
   * responses. Caller must have READ permission for the queried datasets.
   */
  searchAnnotationSets(
    request: SearchAnnotationSetsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SearchAnnotationSetsResponse>>;
  /**
   * Creates a new annotation. Caller must have WRITE permission
   * for the associated annotation set.
   *
   * The following fields are required:
   *
   * * [annotationSetId][google.genomics.v1.Annotation.annotation_set_id]
   * * [referenceName][google.genomics.v1.Annotation.reference_name] or
   *   [referenceId][google.genomics.v1.Annotation.reference_id]
   *
   * ### Transcripts
   *
   * For annotations of type TRANSCRIPT, the following fields of
   * [transcript][google.genomics.v1.Annotation.transcript] must be provided:
   *
   * * [exons.start][google.genomics.v1.Transcript.Exon.start]
   * * [exons.end][google.genomics.v1.Transcript.Exon.end]
   *
   * All other fields may be optionally specified, unless documented as being
   * server-generated (for example, the `id` field). The annotated
   * range must be no longer than 100Mbp (mega base pairs). See the
   * [Annotation resource][google.genomics.v1.Annotation]
   * for additional restrictions on each field.
   */
  createAnnotation(
    request: CreateAnnotationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Annotation>>;
  /**
   * Creates one or more new annotations atomically. All annotations must
   * belong to the same annotation set. Caller must have WRITE
   * permission for this annotation set. For optimal performance, batch
   * positionally adjacent annotations together.
   *
   * If the request has a systemic issue, such as an attempt to write to
   * an inaccessible annotation set, the entire RPC will fail accordingly. For
   * lesser data issues, when possible an error will be isolated to the
   * corresponding batch entry in the response; the remaining well formed
   * annotations will be created normally.
   *
   * For details on the requirements for each individual annotation resource,
   * see
   * [CreateAnnotation][google.genomics.v1.AnnotationServiceV1.CreateAnnotation].
   */
  batchCreateAnnotations(
    request: BatchCreateAnnotationsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<BatchCreateAnnotationsResponse>>;
  /**
   * Gets an annotation. Caller must have READ permission
   * for the associated annotation set.
   */
  getAnnotation(request: GetAnnotationRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Annotation>>;
  /**
   * Updates an annotation. Caller must have
   * WRITE permission for the associated dataset.
   */
  updateAnnotation(
    request: UpdateAnnotationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Annotation>>;
  /**
   * Deletes an annotation. Caller must have WRITE permission for
   * the associated annotation set.
   */
  deleteAnnotation(
    request: DeleteAnnotationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /**
   * Searches for annotations that match the given criteria. Results are
   * ordered by genomic coordinate (by reference sequence, then position).
   * Annotations with equivalent genomic coordinates are returned in an
   * unspecified order. This order is consistent, such that two queries for the
   * same content (regardless of page size) yield annotations in the same order
   * across their respective streams of paginated responses. Caller must have
   * READ permission for the queried annotation sets.
   */
  searchAnnotations(
    request: SearchAnnotationsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SearchAnnotationsResponse>>;
}

export interface AnnotationServiceV1Client<CallOptionsExt = {}> {
  /**
   * Creates a new annotation set. Caller must have WRITE permission for the
   * associated dataset.
   *
   * The following fields are required:
   *
   *   * [datasetId][google.genomics.v1.AnnotationSet.dataset_id]
   *   * [referenceSetId][google.genomics.v1.AnnotationSet.reference_set_id]
   *
   * All other fields may be optionally specified, unless documented as being
   * server-generated (for example, the `id` field).
   */
  createAnnotationSet(
    request: DeepPartial<CreateAnnotationSetRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AnnotationSet>;
  /**
   * Gets an annotation set. Caller must have READ permission for
   * the associated dataset.
   */
  getAnnotationSet(
    request: DeepPartial<GetAnnotationSetRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AnnotationSet>;
  /**
   * Updates an annotation set. The update must respect all mutability
   * restrictions and other invariants described on the annotation set resource.
   * Caller must have WRITE permission for the associated dataset.
   */
  updateAnnotationSet(
    request: DeepPartial<UpdateAnnotationSetRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AnnotationSet>;
  /**
   * Deletes an annotation set. Caller must have WRITE permission
   * for the associated annotation set.
   */
  deleteAnnotationSet(
    request: DeepPartial<DeleteAnnotationSetRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /**
   * Searches for annotation sets that match the given criteria. Annotation sets
   * are returned in an unspecified order. This order is consistent, such that
   * two queries for the same content (regardless of page size) yield annotation
   * sets in the same order across their respective streams of paginated
   * responses. Caller must have READ permission for the queried datasets.
   */
  searchAnnotationSets(
    request: DeepPartial<SearchAnnotationSetsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SearchAnnotationSetsResponse>;
  /**
   * Creates a new annotation. Caller must have WRITE permission
   * for the associated annotation set.
   *
   * The following fields are required:
   *
   * * [annotationSetId][google.genomics.v1.Annotation.annotation_set_id]
   * * [referenceName][google.genomics.v1.Annotation.reference_name] or
   *   [referenceId][google.genomics.v1.Annotation.reference_id]
   *
   * ### Transcripts
   *
   * For annotations of type TRANSCRIPT, the following fields of
   * [transcript][google.genomics.v1.Annotation.transcript] must be provided:
   *
   * * [exons.start][google.genomics.v1.Transcript.Exon.start]
   * * [exons.end][google.genomics.v1.Transcript.Exon.end]
   *
   * All other fields may be optionally specified, unless documented as being
   * server-generated (for example, the `id` field). The annotated
   * range must be no longer than 100Mbp (mega base pairs). See the
   * [Annotation resource][google.genomics.v1.Annotation]
   * for additional restrictions on each field.
   */
  createAnnotation(
    request: DeepPartial<CreateAnnotationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Annotation>;
  /**
   * Creates one or more new annotations atomically. All annotations must
   * belong to the same annotation set. Caller must have WRITE
   * permission for this annotation set. For optimal performance, batch
   * positionally adjacent annotations together.
   *
   * If the request has a systemic issue, such as an attempt to write to
   * an inaccessible annotation set, the entire RPC will fail accordingly. For
   * lesser data issues, when possible an error will be isolated to the
   * corresponding batch entry in the response; the remaining well formed
   * annotations will be created normally.
   *
   * For details on the requirements for each individual annotation resource,
   * see
   * [CreateAnnotation][google.genomics.v1.AnnotationServiceV1.CreateAnnotation].
   */
  batchCreateAnnotations(
    request: DeepPartial<BatchCreateAnnotationsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<BatchCreateAnnotationsResponse>;
  /**
   * Gets an annotation. Caller must have READ permission
   * for the associated annotation set.
   */
  getAnnotation(
    request: DeepPartial<GetAnnotationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Annotation>;
  /**
   * Updates an annotation. Caller must have
   * WRITE permission for the associated dataset.
   */
  updateAnnotation(
    request: DeepPartial<UpdateAnnotationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Annotation>;
  /**
   * Deletes an annotation. Caller must have WRITE permission for
   * the associated annotation set.
   */
  deleteAnnotation(
    request: DeepPartial<DeleteAnnotationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /**
   * Searches for annotations that match the given criteria. Results are
   * ordered by genomic coordinate (by reference sequence, then position).
   * Annotations with equivalent genomic coordinates are returned in an
   * unspecified order. This order is consistent, such that two queries for the
   * same content (regardless of page size) yield annotations in the same order
   * across their respective streams of paginated responses. Caller must have
   * READ permission for the queried annotation sets.
   */
  searchAnnotations(
    request: DeepPartial<SearchAnnotationsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SearchAnnotationsResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
