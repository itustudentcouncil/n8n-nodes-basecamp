// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/genomics/v1/variants.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../longrunning/operations.js";
import { Empty } from "../../protobuf/empty.js";
import { FieldMask } from "../../protobuf/field_mask.js";
import { ListValue } from "../../protobuf/struct.js";

export const protobufPackage = "google.genomics.v1";

/**
 * Operations to be performed during import on Variant info fields.
 * These operations are set for each info field in the info_merge_config
 * map of ImportVariantsRequest, which is plumbed down to the
 * MergeVariantRequests generated by the import job.
 */
export enum InfoMergeOperation {
  INFO_MERGE_OPERATION_UNSPECIFIED = 0,
  /**
   * IGNORE_NEW - By default, Variant info fields are persisted if the Variant doesn't
   * already exist in the variantset.  If the Variant is equivalent to a
   * Variant already in the variantset, the incoming Variant's info field
   * is ignored in favor of that of the already persisted Variant.
   */
  IGNORE_NEW = 1,
  /**
   * MOVE_TO_CALLS - This operation removes an info field from the incoming Variant
   * and persists this info field in each of the incoming Variant's Calls.
   */
  MOVE_TO_CALLS = 2,
  UNRECOGNIZED = -1,
}

export function infoMergeOperationFromJSON(object: any): InfoMergeOperation {
  switch (object) {
    case 0:
    case "INFO_MERGE_OPERATION_UNSPECIFIED":
      return InfoMergeOperation.INFO_MERGE_OPERATION_UNSPECIFIED;
    case 1:
    case "IGNORE_NEW":
      return InfoMergeOperation.IGNORE_NEW;
    case 2:
    case "MOVE_TO_CALLS":
      return InfoMergeOperation.MOVE_TO_CALLS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return InfoMergeOperation.UNRECOGNIZED;
  }
}

export function infoMergeOperationToJSON(object: InfoMergeOperation): string {
  switch (object) {
    case InfoMergeOperation.INFO_MERGE_OPERATION_UNSPECIFIED:
      return "INFO_MERGE_OPERATION_UNSPECIFIED";
    case InfoMergeOperation.IGNORE_NEW:
      return "IGNORE_NEW";
    case InfoMergeOperation.MOVE_TO_CALLS:
      return "MOVE_TO_CALLS";
    case InfoMergeOperation.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Metadata describes a single piece of variant call metadata.
 * These data include a top level key and either a single value string (value)
 * or a list of key-value pairs (info.)
 * Value and info are mutually exclusive.
 */
export interface VariantSetMetadata {
  /** The top-level key. */
  key: string;
  /** The value field for simple metadata */
  value: string;
  /**
   * User-provided ID field, not enforced by this API.
   * Two or more pieces of structured metadata with identical
   * id and key fields are considered equivalent.
   */
  id: string;
  /**
   * The type of data. Possible types include: Integer, Float,
   * Flag, Character, and String.
   */
  type: VariantSetMetadata_Type;
  /**
   * The number of values that can be included in a field described by this
   * metadata.
   */
  number: string;
  /** A textual description of this metadata. */
  description: string;
  /**
   * Remaining structured metadata key-value pairs. This must be of the form
   * map<string, string[]> (string key mapping to a list of string values).
   */
  info: { [key: string]: Array<any> | undefined };
}

export enum VariantSetMetadata_Type {
  TYPE_UNSPECIFIED = 0,
  INTEGER = 1,
  FLOAT = 2,
  FLAG = 3,
  CHARACTER = 4,
  STRING = 5,
  UNRECOGNIZED = -1,
}

export function variantSetMetadata_TypeFromJSON(object: any): VariantSetMetadata_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return VariantSetMetadata_Type.TYPE_UNSPECIFIED;
    case 1:
    case "INTEGER":
      return VariantSetMetadata_Type.INTEGER;
    case 2:
    case "FLOAT":
      return VariantSetMetadata_Type.FLOAT;
    case 3:
    case "FLAG":
      return VariantSetMetadata_Type.FLAG;
    case 4:
    case "CHARACTER":
      return VariantSetMetadata_Type.CHARACTER;
    case 5:
    case "STRING":
      return VariantSetMetadata_Type.STRING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VariantSetMetadata_Type.UNRECOGNIZED;
  }
}

export function variantSetMetadata_TypeToJSON(object: VariantSetMetadata_Type): string {
  switch (object) {
    case VariantSetMetadata_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case VariantSetMetadata_Type.INTEGER:
      return "INTEGER";
    case VariantSetMetadata_Type.FLOAT:
      return "FLOAT";
    case VariantSetMetadata_Type.FLAG:
      return "FLAG";
    case VariantSetMetadata_Type.CHARACTER:
      return "CHARACTER";
    case VariantSetMetadata_Type.STRING:
      return "STRING";
    case VariantSetMetadata_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface VariantSetMetadata_InfoEntry {
  key: string;
  value: Array<any> | undefined;
}

/**
 * A variant set is a collection of call sets and variants. It contains summary
 * statistics of those contents. A variant set belongs to a dataset.
 *
 * For more genomics resource definitions, see [Fundamentals of Google
 * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
 */
export interface VariantSet {
  /** The dataset to which this variant set belongs. */
  datasetId: string;
  /** The server-generated variant set ID, unique across all variant sets. */
  id: string;
  /**
   * The reference set to which the variant set is mapped. The reference set
   * describes the alignment provenance of the variant set, while the
   * `referenceBounds` describe the shape of the actual variant data. The
   * reference set's reference names are a superset of those found in the
   * `referenceBounds`.
   *
   * For example, given a variant set that is mapped to the GRCh38 reference set
   * and contains a single variant on reference 'X', `referenceBounds` would
   * contain only an entry for 'X', while the associated reference set
   * enumerates all possible references: '1', '2', 'X', 'Y', 'MT', etc.
   */
  referenceSetId: string;
  /**
   * A list of all references used by the variants in a variant set
   * with associated coordinate upper bounds for each one.
   */
  referenceBounds: ReferenceBound[];
  /** The metadata associated with this variant set. */
  metadata: VariantSetMetadata[];
  /** User-specified, mutable name. */
  name: string;
  /** A textual description of this variant set. */
  description: string;
}

/**
 * A variant represents a change in DNA sequence relative to a reference
 * sequence. For example, a variant could represent a SNP or an insertion.
 * Variants belong to a variant set.
 *
 * For more genomics resource definitions, see [Fundamentals of Google
 * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
 *
 * Each of the calls on a variant represent a determination of genotype with
 * respect to that variant. For example, a call might assign probability of 0.32
 * to the occurrence of a SNP named rs1234 in a sample named NA12345. A call
 * belongs to a call set, which contains related calls typically from one
 * sample.
 */
export interface Variant {
  /** The ID of the variant set this variant belongs to. */
  variantSetId: string;
  /** The server-generated variant ID, unique across all variants. */
  id: string;
  /** Names for the variant, for example a RefSNP ID. */
  names: string[];
  /** The date this variant was created, in milliseconds from the epoch. */
  created: Long;
  /**
   * The reference on which this variant occurs.
   * (such as `chr20` or `X`)
   */
  referenceName: string;
  /**
   * The position at which this variant occurs (0-based).
   * This corresponds to the first base of the string of reference bases.
   */
  start: Long;
  /**
   * The end position (0-based) of this variant. This corresponds to the first
   * base after the last base in the reference allele. So, the length of
   * the reference allele is (end - start). This is useful for variants
   * that don't explicitly give alternate bases, for example large deletions.
   */
  end: Long;
  /**
   * The reference bases for this variant. They start at the given
   * position.
   */
  referenceBases: string;
  /** The bases that appear instead of the reference bases. */
  alternateBases: string[];
  /**
   * A measure of how likely this variant is to be real.
   * A higher value is better.
   */
  quality: number;
  /**
   * A list of filters (normally quality filters) this variant has failed.
   * `PASS` indicates this variant has passed all filters.
   */
  filter: string[];
  /**
   * A map of additional variant information. This must be of the form
   * map<string, string[]> (string key mapping to a list of string values).
   */
  info: { [key: string]: Array<any> | undefined };
  /**
   * The variant calls for this particular variant. Each one represents the
   * determination of genotype with respect to this variant.
   */
  calls: VariantCall[];
}

export interface Variant_InfoEntry {
  key: string;
  value: Array<any> | undefined;
}

/**
 * A call represents the determination of genotype with respect to a particular
 * variant. It may include associated information such as quality and phasing.
 * For example, a call might assign a probability of 0.32 to the occurrence of
 * a SNP named rs1234 in a call set with the name NA12345.
 */
export interface VariantCall {
  /** The ID of the call set this variant call belongs to. */
  callSetId: string;
  /** The name of the call set this variant call belongs to. */
  callSetName: string;
  /**
   * The genotype of this variant call. Each value represents either the value
   * of the `referenceBases` field or a 1-based index into
   * `alternateBases`. If a variant had a `referenceBases`
   * value of `T` and an `alternateBases`
   * value of `["A", "C"]`, and the `genotype` was
   * `[2, 1]`, that would mean the call
   * represented the heterozygous value `CA` for this variant.
   * If the `genotype` was instead `[0, 1]`, the
   * represented value would be `TA`. Ordering of the
   * genotype values is important if the `phaseset` is present.
   * If a genotype is not called (that is, a `.` is present in the
   * GT string) -1 is returned.
   */
  genotype: number[];
  /**
   * If this field is present, this variant call's genotype ordering implies
   * the phase of the bases and is consistent with any other variant calls in
   * the same reference sequence which have the same phaseset value.
   * When importing data from VCF, if the genotype data was phased but no
   * phase set was specified this field will be set to `*`.
   */
  phaseset: string;
  /**
   * The genotype likelihoods for this variant call. Each array entry
   * represents how likely a specific genotype is for this call. The value
   * ordering is defined by the GL tag in the VCF spec.
   * If Phred-scaled genotype likelihood scores (PL) are available and
   * log10(P) genotype likelihood scores (GL) are not, PL scores are converted
   * to GL scores.  If both are available, PL scores are stored in `info`.
   */
  genotypeLikelihood: number[];
  /**
   * A map of additional variant call information. This must be of the form
   * map<string, string[]> (string key mapping to a list of string values).
   */
  info: { [key: string]: Array<any> | undefined };
}

export interface VariantCall_InfoEntry {
  key: string;
  value: Array<any> | undefined;
}

/**
 * A call set is a collection of variant calls, typically for one sample. It
 * belongs to a variant set.
 *
 * For more genomics resource definitions, see [Fundamentals of Google
 * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
 */
export interface CallSet {
  /** The server-generated call set ID, unique across all call sets. */
  id: string;
  /** The call set name. */
  name: string;
  /** The sample ID this call set corresponds to. */
  sampleId: string;
  /**
   * The IDs of the variant sets this call set belongs to. This field must
   * have exactly length one, as a call set belongs to a single variant set.
   * This field is repeated for compatibility with the
   * [GA4GH 0.5.1
   * API](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/variants.avdl#L76).
   */
  variantSetIds: string[];
  /** The date this call set was created in milliseconds from the epoch. */
  created: Long;
  /**
   * A map of additional call set information. This must be of the form
   * map<string, string[]> (string key mapping to a list of string values).
   */
  info: { [key: string]: Array<any> | undefined };
}

export interface CallSet_InfoEntry {
  key: string;
  value: Array<any> | undefined;
}

/**
 * ReferenceBound records an upper bound for the starting coordinate of
 * variants in a particular reference.
 */
export interface ReferenceBound {
  /** The name of the reference associated with this reference bound. */
  referenceName: string;
  /**
   * An upper bound (inclusive) on the starting coordinate of any
   * variant in the reference sequence.
   */
  upperBound: Long;
}

/** The variant data import request. */
export interface ImportVariantsRequest {
  /** Required. The variant set to which variant data should be imported. */
  variantSetId: string;
  /**
   * A list of URIs referencing variant files in Google Cloud Storage. URIs can
   * include wildcards [as described
   * here](https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames).
   * Note that recursive wildcards ('**') are not supported.
   */
  sourceUris: string[];
  /**
   * The format of the variant data being imported. If unspecified, defaults to
   * to `VCF`.
   */
  format: ImportVariantsRequest_Format;
  /**
   * Convert reference names to the canonical representation.
   * hg19 haploytypes (those reference names containing "_hap")
   * are not modified in any way.
   * All other reference names are modified according to the following rules:
   * The reference name is capitalized.
   * The "chr" prefix is dropped for all autosomes and sex chromsomes.
   * For example "chr17" becomes "17" and "chrX" becomes "X".
   * All mitochondrial chromosomes ("chrM", "chrMT", etc) become "MT".
   */
  normalizeReferenceNames: boolean;
  /**
   * A mapping between info field keys and the InfoMergeOperations to
   * be performed on them. This is plumbed down to the MergeVariantRequests
   * generated by the resulting import job.
   */
  infoMergeConfig: { [key: string]: InfoMergeOperation };
}

export enum ImportVariantsRequest_Format {
  FORMAT_UNSPECIFIED = 0,
  /**
   * FORMAT_VCF - VCF (Variant Call Format). The VCF files may be gzip compressed. gVCF is
   * also supported.
   */
  FORMAT_VCF = 1,
  /**
   * FORMAT_COMPLETE_GENOMICS - Complete Genomics masterVarBeta format. The masterVarBeta files may
   * be bzip2 compressed.
   */
  FORMAT_COMPLETE_GENOMICS = 2,
  UNRECOGNIZED = -1,
}

export function importVariantsRequest_FormatFromJSON(object: any): ImportVariantsRequest_Format {
  switch (object) {
    case 0:
    case "FORMAT_UNSPECIFIED":
      return ImportVariantsRequest_Format.FORMAT_UNSPECIFIED;
    case 1:
    case "FORMAT_VCF":
      return ImportVariantsRequest_Format.FORMAT_VCF;
    case 2:
    case "FORMAT_COMPLETE_GENOMICS":
      return ImportVariantsRequest_Format.FORMAT_COMPLETE_GENOMICS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ImportVariantsRequest_Format.UNRECOGNIZED;
  }
}

export function importVariantsRequest_FormatToJSON(object: ImportVariantsRequest_Format): string {
  switch (object) {
    case ImportVariantsRequest_Format.FORMAT_UNSPECIFIED:
      return "FORMAT_UNSPECIFIED";
    case ImportVariantsRequest_Format.FORMAT_VCF:
      return "FORMAT_VCF";
    case ImportVariantsRequest_Format.FORMAT_COMPLETE_GENOMICS:
      return "FORMAT_COMPLETE_GENOMICS";
    case ImportVariantsRequest_Format.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ImportVariantsRequest_InfoMergeConfigEntry {
  key: string;
  value: InfoMergeOperation;
}

/** The variant data import response. */
export interface ImportVariantsResponse {
  /** IDs of the call sets created during the import. */
  callSetIds: string[];
}

/** The CreateVariantSet request */
export interface CreateVariantSetRequest {
  /** Required. The variant set to be created. Must have a valid `datasetId`. */
  variantSet: VariantSet | undefined;
}

/** The variant data export request. */
export interface ExportVariantSetRequest {
  /**
   * Required. The ID of the variant set that contains variant data which
   * should be exported. The caller must have READ access to this variant set.
   */
  variantSetId: string;
  /**
   * If provided, only variant call information from the specified call sets
   * will be exported. By default all variant calls are exported.
   */
  callSetIds: string[];
  /**
   * Required. The Google Cloud project ID that owns the destination
   * BigQuery dataset. The caller must have WRITE access to this project.  This
   * project will also own the resulting export job.
   */
  projectId: string;
  /** The format for the exported data. */
  format: ExportVariantSetRequest_Format;
  /**
   * Required. The BigQuery dataset to export data to. This dataset must already
   * exist. Note that this is distinct from the Genomics concept of "dataset".
   */
  bigqueryDataset: string;
  /**
   * Required. The BigQuery table to export data to.
   * If the table doesn't exist, it will be created. If it already exists, it
   * will be overwritten.
   */
  bigqueryTable: string;
}

export enum ExportVariantSetRequest_Format {
  FORMAT_UNSPECIFIED = 0,
  /** FORMAT_BIGQUERY - Export the data to Google BigQuery. */
  FORMAT_BIGQUERY = 1,
  UNRECOGNIZED = -1,
}

export function exportVariantSetRequest_FormatFromJSON(object: any): ExportVariantSetRequest_Format {
  switch (object) {
    case 0:
    case "FORMAT_UNSPECIFIED":
      return ExportVariantSetRequest_Format.FORMAT_UNSPECIFIED;
    case 1:
    case "FORMAT_BIGQUERY":
      return ExportVariantSetRequest_Format.FORMAT_BIGQUERY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ExportVariantSetRequest_Format.UNRECOGNIZED;
  }
}

export function exportVariantSetRequest_FormatToJSON(object: ExportVariantSetRequest_Format): string {
  switch (object) {
    case ExportVariantSetRequest_Format.FORMAT_UNSPECIFIED:
      return "FORMAT_UNSPECIFIED";
    case ExportVariantSetRequest_Format.FORMAT_BIGQUERY:
      return "FORMAT_BIGQUERY";
    case ExportVariantSetRequest_Format.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The variant set request. */
export interface GetVariantSetRequest {
  /** Required. The ID of the variant set. */
  variantSetId: string;
}

/** The search variant sets request. */
export interface SearchVariantSetsRequest {
  /**
   * Exactly one dataset ID must be provided here. Only variant sets which
   * belong to this dataset will be returned.
   */
  datasetIds: string[];
  /**
   * The continuation token, which is used to page through large result sets.
   * To get the next page of results, set this parameter to the value of
   * `nextPageToken` from the previous response.
   */
  pageToken: string;
  /**
   * The maximum number of results to return in a single page. If unspecified,
   * defaults to 1024.
   */
  pageSize: number;
}

/** The search variant sets response. */
export interface SearchVariantSetsResponse {
  /** The variant sets belonging to the requested dataset. */
  variantSets: VariantSet[];
  /**
   * The continuation token, which is used to page through large result sets.
   * Provide this value in a subsequent request to return the next page of
   * results. This field will be empty if there aren't any additional results.
   */
  nextPageToken: string;
}

/** The delete variant set request. */
export interface DeleteVariantSetRequest {
  /** The ID of the variant set to be deleted. */
  variantSetId: string;
}

export interface UpdateVariantSetRequest {
  /** The ID of the variant to be updated (must already exist). */
  variantSetId: string;
  /**
   * The new variant data. Only the variant_set.metadata will be considered
   * for update.
   */
  variantSet:
    | VariantSet
    | undefined;
  /**
   * An optional mask specifying which fields to update. Supported fields:
   *
   * * [metadata][google.genomics.v1.VariantSet.metadata].
   * * [name][google.genomics.v1.VariantSet.name].
   * * [description][google.genomics.v1.VariantSet.description].
   *
   * Leaving `updateMask` unset is equivalent to specifying all mutable
   * fields.
   */
  updateMask: string[] | undefined;
}

/** The variant search request. */
export interface SearchVariantsRequest {
  /**
   * At most one variant set ID must be provided. Only variants from this
   * variant set will be returned. If omitted, a call set id must be included in
   * the request.
   */
  variantSetIds: string[];
  /** Only return variants which have exactly this name. */
  variantName: string;
  /**
   * Only return variant calls which belong to call sets with these ids.
   * Leaving this blank returns all variant calls. If a variant has no
   * calls belonging to any of these call sets, it won't be returned at all.
   */
  callSetIds: string[];
  /** Required. Only return variants in this reference sequence. */
  referenceName: string;
  /**
   * The beginning of the window (0-based, inclusive) for which
   * overlapping variants should be returned. If unspecified, defaults to 0.
   */
  start: Long;
  /**
   * The end of the window, 0-based exclusive. If unspecified or 0, defaults to
   * the length of the reference.
   */
  end: Long;
  /**
   * The continuation token, which is used to page through large result sets.
   * To get the next page of results, set this parameter to the value of
   * `nextPageToken` from the previous response.
   */
  pageToken: string;
  /**
   * The maximum number of variants to return in a single page. If unspecified,
   * defaults to 5000. The maximum value is 10000.
   */
  pageSize: number;
  /**
   * The maximum number of calls to return in a single page. Note that this
   * limit may be exceeded in the event that a matching variant contains more
   * calls than the requested maximum. If unspecified, defaults to 5000. The
   * maximum value is 10000.
   */
  maxCalls: number;
}

/** The variant search response. */
export interface SearchVariantsResponse {
  /** The list of matching Variants. */
  variants: Variant[];
  /**
   * The continuation token, which is used to page through large result sets.
   * Provide this value in a subsequent request to return the next page of
   * results. This field will be empty if there aren't any additional results.
   */
  nextPageToken: string;
}

export interface CreateVariantRequest {
  /** The variant to be created. */
  variant: Variant | undefined;
}

export interface UpdateVariantRequest {
  /** The ID of the variant to be updated. */
  variantId: string;
  /** The new variant data. */
  variant:
    | Variant
    | undefined;
  /**
   * An optional mask specifying which fields to update. At this time, mutable
   * fields are [names][google.genomics.v1.Variant.names] and
   * [info][google.genomics.v1.Variant.info]. Acceptable values are "names" and
   * "info". If unspecified, all mutable fields will be updated.
   */
  updateMask: string[] | undefined;
}

export interface DeleteVariantRequest {
  /** The ID of the variant to be deleted. */
  variantId: string;
}

export interface GetVariantRequest {
  /** The ID of the variant. */
  variantId: string;
}

export interface MergeVariantsRequest {
  /** The destination variant set. */
  variantSetId: string;
  /** The variants to be merged with existing variants. */
  variants: Variant[];
  /**
   * A mapping between info field keys and the InfoMergeOperations to
   * be performed on them.
   */
  infoMergeConfig: { [key: string]: InfoMergeOperation };
}

export interface MergeVariantsRequest_InfoMergeConfigEntry {
  key: string;
  value: InfoMergeOperation;
}

/** The call set search request. */
export interface SearchCallSetsRequest {
  /**
   * Restrict the query to call sets within the given variant sets. At least one
   * ID must be provided.
   */
  variantSetIds: string[];
  /**
   * Only return call sets for which a substring of the name matches this
   * string.
   */
  name: string;
  /**
   * The continuation token, which is used to page through large result sets.
   * To get the next page of results, set this parameter to the value of
   * `nextPageToken` from the previous response.
   */
  pageToken: string;
  /**
   * The maximum number of results to return in a single page. If unspecified,
   * defaults to 1024.
   */
  pageSize: number;
}

/** The call set search response. */
export interface SearchCallSetsResponse {
  /** The list of matching call sets. */
  callSets: CallSet[];
  /**
   * The continuation token, which is used to page through large result sets.
   * Provide this value in a subsequent request to return the next page of
   * results. This field will be empty if there aren't any additional results.
   */
  nextPageToken: string;
}

export interface CreateCallSetRequest {
  /** The call set to be created. */
  callSet: CallSet | undefined;
}

export interface UpdateCallSetRequest {
  /** The ID of the call set to be updated. */
  callSetId: string;
  /** The new call set data. */
  callSet:
    | CallSet
    | undefined;
  /**
   * An optional mask specifying which fields to update. At this time, the only
   * mutable field is [name][google.genomics.v1.CallSet.name]. The only
   * acceptable value is "name". If unspecified, all mutable fields will be
   * updated.
   */
  updateMask: string[] | undefined;
}

export interface DeleteCallSetRequest {
  /** The ID of the call set to be deleted. */
  callSetId: string;
}

export interface GetCallSetRequest {
  /** The ID of the call set. */
  callSetId: string;
}

/** The stream variants request. */
export interface StreamVariantsRequest {
  /**
   * The Google Cloud project ID which will be billed
   * for this access. The caller must have WRITE access to this project.
   * Required.
   */
  projectId: string;
  /** The variant set ID from which to stream variants. */
  variantSetId: string;
  /**
   * Only return variant calls which belong to call sets with these IDs.
   * Leaving this blank returns all variant calls.
   */
  callSetIds: string[];
  /** Required. Only return variants in this reference sequence. */
  referenceName: string;
  /**
   * The beginning of the window (0-based, inclusive) for which
   * overlapping variants should be returned.
   */
  start: Long;
  /**
   * The end of the window (0-based, exclusive) for which overlapping
   * variants should be returned.
   */
  end: Long;
}

export interface StreamVariantsResponse {
  variants: Variant[];
}

function createBaseVariantSetMetadata(): VariantSetMetadata {
  return { key: "", value: "", id: "", type: 0, number: "", description: "", info: {} };
}

export const VariantSetMetadata: MessageFns<VariantSetMetadata> = {
  encode(message: VariantSetMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    if (message.id !== "") {
      writer.uint32(34).string(message.id);
    }
    if (message.type !== 0) {
      writer.uint32(40).int32(message.type);
    }
    if (message.number !== "") {
      writer.uint32(66).string(message.number);
    }
    if (message.description !== "") {
      writer.uint32(58).string(message.description);
    }
    Object.entries(message.info).forEach(([key, value]) => {
      if (value !== undefined) {
        VariantSetMetadata_InfoEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
      }
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VariantSetMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariantSetMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.id = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.number = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = VariantSetMetadata_InfoEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.info[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VariantSetMetadata {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      type: isSet(object.type) ? variantSetMetadata_TypeFromJSON(object.type) : 0,
      number: isSet(object.number) ? globalThis.String(object.number) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      info: isObject(object.info)
        ? Object.entries(object.info).reduce<{ [key: string]: Array<any> | undefined }>((acc, [key, value]) => {
          acc[key] = value as Array<any> | undefined;
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: VariantSetMetadata): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.type !== 0) {
      obj.type = variantSetMetadata_TypeToJSON(message.type);
    }
    if (message.number !== "") {
      obj.number = message.number;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.info) {
      const entries = Object.entries(message.info);
      if (entries.length > 0) {
        obj.info = {};
        entries.forEach(([k, v]) => {
          obj.info[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<VariantSetMetadata>): VariantSetMetadata {
    return VariantSetMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VariantSetMetadata>): VariantSetMetadata {
    const message = createBaseVariantSetMetadata();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    message.id = object.id ?? "";
    message.type = object.type ?? 0;
    message.number = object.number ?? "";
    message.description = object.description ?? "";
    message.info = Object.entries(object.info ?? {}).reduce<{ [key: string]: Array<any> | undefined }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseVariantSetMetadata_InfoEntry(): VariantSetMetadata_InfoEntry {
  return { key: "", value: undefined };
}

export const VariantSetMetadata_InfoEntry: MessageFns<VariantSetMetadata_InfoEntry> = {
  encode(message: VariantSetMetadata_InfoEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ListValue.encode(ListValue.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VariantSetMetadata_InfoEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariantSetMetadata_InfoEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = ListValue.unwrap(ListValue.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VariantSetMetadata_InfoEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: globalThis.Array.isArray(object.value) ? [...object.value] : undefined,
    };
  },

  toJSON(message: VariantSetMetadata_InfoEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<VariantSetMetadata_InfoEntry>): VariantSetMetadata_InfoEntry {
    return VariantSetMetadata_InfoEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VariantSetMetadata_InfoEntry>): VariantSetMetadata_InfoEntry {
    const message = createBaseVariantSetMetadata_InfoEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseVariantSet(): VariantSet {
  return { datasetId: "", id: "", referenceSetId: "", referenceBounds: [], metadata: [], name: "", description: "" };
}

export const VariantSet: MessageFns<VariantSet> = {
  encode(message: VariantSet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.datasetId !== "") {
      writer.uint32(10).string(message.datasetId);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.referenceSetId !== "") {
      writer.uint32(50).string(message.referenceSetId);
    }
    for (const v of message.referenceBounds) {
      ReferenceBound.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.metadata) {
      VariantSetMetadata.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(58).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(66).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VariantSet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariantSet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.datasetId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.referenceSetId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.referenceBounds.push(ReferenceBound.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.metadata.push(VariantSetMetadata.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.name = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VariantSet {
    return {
      datasetId: isSet(object.datasetId) ? globalThis.String(object.datasetId) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      referenceSetId: isSet(object.referenceSetId) ? globalThis.String(object.referenceSetId) : "",
      referenceBounds: globalThis.Array.isArray(object?.referenceBounds)
        ? object.referenceBounds.map((e: any) => ReferenceBound.fromJSON(e))
        : [],
      metadata: globalThis.Array.isArray(object?.metadata)
        ? object.metadata.map((e: any) => VariantSetMetadata.fromJSON(e))
        : [],
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: VariantSet): unknown {
    const obj: any = {};
    if (message.datasetId !== "") {
      obj.datasetId = message.datasetId;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.referenceSetId !== "") {
      obj.referenceSetId = message.referenceSetId;
    }
    if (message.referenceBounds?.length) {
      obj.referenceBounds = message.referenceBounds.map((e) => ReferenceBound.toJSON(e));
    }
    if (message.metadata?.length) {
      obj.metadata = message.metadata.map((e) => VariantSetMetadata.toJSON(e));
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create(base?: DeepPartial<VariantSet>): VariantSet {
    return VariantSet.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VariantSet>): VariantSet {
    const message = createBaseVariantSet();
    message.datasetId = object.datasetId ?? "";
    message.id = object.id ?? "";
    message.referenceSetId = object.referenceSetId ?? "";
    message.referenceBounds = object.referenceBounds?.map((e) => ReferenceBound.fromPartial(e)) || [];
    message.metadata = object.metadata?.map((e) => VariantSetMetadata.fromPartial(e)) || [];
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseVariant(): Variant {
  return {
    variantSetId: "",
    id: "",
    names: [],
    created: Long.ZERO,
    referenceName: "",
    start: Long.ZERO,
    end: Long.ZERO,
    referenceBases: "",
    alternateBases: [],
    quality: 0,
    filter: [],
    info: {},
    calls: [],
  };
}

export const Variant: MessageFns<Variant> = {
  encode(message: Variant, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.variantSetId !== "") {
      writer.uint32(122).string(message.variantSetId);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    for (const v of message.names) {
      writer.uint32(26).string(v!);
    }
    if (!message.created.equals(Long.ZERO)) {
      writer.uint32(96).int64(message.created.toString());
    }
    if (message.referenceName !== "") {
      writer.uint32(114).string(message.referenceName);
    }
    if (!message.start.equals(Long.ZERO)) {
      writer.uint32(128).int64(message.start.toString());
    }
    if (!message.end.equals(Long.ZERO)) {
      writer.uint32(104).int64(message.end.toString());
    }
    if (message.referenceBases !== "") {
      writer.uint32(50).string(message.referenceBases);
    }
    for (const v of message.alternateBases) {
      writer.uint32(58).string(v!);
    }
    if (message.quality !== 0) {
      writer.uint32(65).double(message.quality);
    }
    for (const v of message.filter) {
      writer.uint32(74).string(v!);
    }
    Object.entries(message.info).forEach(([key, value]) => {
      if (value !== undefined) {
        Variant_InfoEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).join();
      }
    });
    for (const v of message.calls) {
      VariantCall.encode(v!, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Variant {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 15:
          if (tag !== 122) {
            break;
          }

          message.variantSetId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.names.push(reader.string());
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.created = Long.fromString(reader.int64().toString());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.referenceName = reader.string();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.start = Long.fromString(reader.int64().toString());
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.end = Long.fromString(reader.int64().toString());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.referenceBases = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.alternateBases.push(reader.string());
          continue;
        case 8:
          if (tag !== 65) {
            break;
          }

          message.quality = reader.double();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.filter.push(reader.string());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          const entry10 = Variant_InfoEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.info[entry10.key] = entry10.value;
          }
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.calls.push(VariantCall.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Variant {
    return {
      variantSetId: isSet(object.variantSetId) ? globalThis.String(object.variantSetId) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      names: globalThis.Array.isArray(object?.names) ? object.names.map((e: any) => globalThis.String(e)) : [],
      created: isSet(object.created) ? Long.fromValue(object.created) : Long.ZERO,
      referenceName: isSet(object.referenceName) ? globalThis.String(object.referenceName) : "",
      start: isSet(object.start) ? Long.fromValue(object.start) : Long.ZERO,
      end: isSet(object.end) ? Long.fromValue(object.end) : Long.ZERO,
      referenceBases: isSet(object.referenceBases) ? globalThis.String(object.referenceBases) : "",
      alternateBases: globalThis.Array.isArray(object?.alternateBases)
        ? object.alternateBases.map((e: any) => globalThis.String(e))
        : [],
      quality: isSet(object.quality) ? globalThis.Number(object.quality) : 0,
      filter: globalThis.Array.isArray(object?.filter) ? object.filter.map((e: any) => globalThis.String(e)) : [],
      info: isObject(object.info)
        ? Object.entries(object.info).reduce<{ [key: string]: Array<any> | undefined }>((acc, [key, value]) => {
          acc[key] = value as Array<any> | undefined;
          return acc;
        }, {})
        : {},
      calls: globalThis.Array.isArray(object?.calls) ? object.calls.map((e: any) => VariantCall.fromJSON(e)) : [],
    };
  },

  toJSON(message: Variant): unknown {
    const obj: any = {};
    if (message.variantSetId !== "") {
      obj.variantSetId = message.variantSetId;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.names?.length) {
      obj.names = message.names;
    }
    if (!message.created.equals(Long.ZERO)) {
      obj.created = (message.created || Long.ZERO).toString();
    }
    if (message.referenceName !== "") {
      obj.referenceName = message.referenceName;
    }
    if (!message.start.equals(Long.ZERO)) {
      obj.start = (message.start || Long.ZERO).toString();
    }
    if (!message.end.equals(Long.ZERO)) {
      obj.end = (message.end || Long.ZERO).toString();
    }
    if (message.referenceBases !== "") {
      obj.referenceBases = message.referenceBases;
    }
    if (message.alternateBases?.length) {
      obj.alternateBases = message.alternateBases;
    }
    if (message.quality !== 0) {
      obj.quality = message.quality;
    }
    if (message.filter?.length) {
      obj.filter = message.filter;
    }
    if (message.info) {
      const entries = Object.entries(message.info);
      if (entries.length > 0) {
        obj.info = {};
        entries.forEach(([k, v]) => {
          obj.info[k] = v;
        });
      }
    }
    if (message.calls?.length) {
      obj.calls = message.calls.map((e) => VariantCall.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Variant>): Variant {
    return Variant.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Variant>): Variant {
    const message = createBaseVariant();
    message.variantSetId = object.variantSetId ?? "";
    message.id = object.id ?? "";
    message.names = object.names?.map((e) => e) || [];
    message.created = (object.created !== undefined && object.created !== null)
      ? Long.fromValue(object.created)
      : Long.ZERO;
    message.referenceName = object.referenceName ?? "";
    message.start = (object.start !== undefined && object.start !== null) ? Long.fromValue(object.start) : Long.ZERO;
    message.end = (object.end !== undefined && object.end !== null) ? Long.fromValue(object.end) : Long.ZERO;
    message.referenceBases = object.referenceBases ?? "";
    message.alternateBases = object.alternateBases?.map((e) => e) || [];
    message.quality = object.quality ?? 0;
    message.filter = object.filter?.map((e) => e) || [];
    message.info = Object.entries(object.info ?? {}).reduce<{ [key: string]: Array<any> | undefined }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    message.calls = object.calls?.map((e) => VariantCall.fromPartial(e)) || [];
    return message;
  },
};

function createBaseVariant_InfoEntry(): Variant_InfoEntry {
  return { key: "", value: undefined };
}

export const Variant_InfoEntry: MessageFns<Variant_InfoEntry> = {
  encode(message: Variant_InfoEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ListValue.encode(ListValue.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Variant_InfoEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariant_InfoEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = ListValue.unwrap(ListValue.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Variant_InfoEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: globalThis.Array.isArray(object.value) ? [...object.value] : undefined,
    };
  },

  toJSON(message: Variant_InfoEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Variant_InfoEntry>): Variant_InfoEntry {
    return Variant_InfoEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Variant_InfoEntry>): Variant_InfoEntry {
    const message = createBaseVariant_InfoEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseVariantCall(): VariantCall {
  return { callSetId: "", callSetName: "", genotype: [], phaseset: "", genotypeLikelihood: [], info: {} };
}

export const VariantCall: MessageFns<VariantCall> = {
  encode(message: VariantCall, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.callSetId !== "") {
      writer.uint32(66).string(message.callSetId);
    }
    if (message.callSetName !== "") {
      writer.uint32(74).string(message.callSetName);
    }
    writer.uint32(58).fork();
    for (const v of message.genotype) {
      writer.int32(v);
    }
    writer.join();
    if (message.phaseset !== "") {
      writer.uint32(42).string(message.phaseset);
    }
    writer.uint32(50).fork();
    for (const v of message.genotypeLikelihood) {
      writer.double(v);
    }
    writer.join();
    Object.entries(message.info).forEach(([key, value]) => {
      if (value !== undefined) {
        VariantCall_InfoEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
      }
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VariantCall {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariantCall();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 8:
          if (tag !== 66) {
            break;
          }

          message.callSetId = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.callSetName = reader.string();
          continue;
        case 7:
          if (tag === 56) {
            message.genotype.push(reader.int32());

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.genotype.push(reader.int32());
            }

            continue;
          }

          break;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.phaseset = reader.string();
          continue;
        case 6:
          if (tag === 49) {
            message.genotypeLikelihood.push(reader.double());

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.genotypeLikelihood.push(reader.double());
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = VariantCall_InfoEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.info[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VariantCall {
    return {
      callSetId: isSet(object.callSetId) ? globalThis.String(object.callSetId) : "",
      callSetName: isSet(object.callSetName) ? globalThis.String(object.callSetName) : "",
      genotype: globalThis.Array.isArray(object?.genotype) ? object.genotype.map((e: any) => globalThis.Number(e)) : [],
      phaseset: isSet(object.phaseset) ? globalThis.String(object.phaseset) : "",
      genotypeLikelihood: globalThis.Array.isArray(object?.genotypeLikelihood)
        ? object.genotypeLikelihood.map((e: any) => globalThis.Number(e))
        : [],
      info: isObject(object.info)
        ? Object.entries(object.info).reduce<{ [key: string]: Array<any> | undefined }>((acc, [key, value]) => {
          acc[key] = value as Array<any> | undefined;
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: VariantCall): unknown {
    const obj: any = {};
    if (message.callSetId !== "") {
      obj.callSetId = message.callSetId;
    }
    if (message.callSetName !== "") {
      obj.callSetName = message.callSetName;
    }
    if (message.genotype?.length) {
      obj.genotype = message.genotype.map((e) => Math.round(e));
    }
    if (message.phaseset !== "") {
      obj.phaseset = message.phaseset;
    }
    if (message.genotypeLikelihood?.length) {
      obj.genotypeLikelihood = message.genotypeLikelihood;
    }
    if (message.info) {
      const entries = Object.entries(message.info);
      if (entries.length > 0) {
        obj.info = {};
        entries.forEach(([k, v]) => {
          obj.info[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<VariantCall>): VariantCall {
    return VariantCall.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VariantCall>): VariantCall {
    const message = createBaseVariantCall();
    message.callSetId = object.callSetId ?? "";
    message.callSetName = object.callSetName ?? "";
    message.genotype = object.genotype?.map((e) => e) || [];
    message.phaseset = object.phaseset ?? "";
    message.genotypeLikelihood = object.genotypeLikelihood?.map((e) => e) || [];
    message.info = Object.entries(object.info ?? {}).reduce<{ [key: string]: Array<any> | undefined }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseVariantCall_InfoEntry(): VariantCall_InfoEntry {
  return { key: "", value: undefined };
}

export const VariantCall_InfoEntry: MessageFns<VariantCall_InfoEntry> = {
  encode(message: VariantCall_InfoEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ListValue.encode(ListValue.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VariantCall_InfoEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariantCall_InfoEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = ListValue.unwrap(ListValue.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VariantCall_InfoEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: globalThis.Array.isArray(object.value) ? [...object.value] : undefined,
    };
  },

  toJSON(message: VariantCall_InfoEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<VariantCall_InfoEntry>): VariantCall_InfoEntry {
    return VariantCall_InfoEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VariantCall_InfoEntry>): VariantCall_InfoEntry {
    const message = createBaseVariantCall_InfoEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseCallSet(): CallSet {
  return { id: "", name: "", sampleId: "", variantSetIds: [], created: Long.ZERO, info: {} };
}

export const CallSet: MessageFns<CallSet> = {
  encode(message: CallSet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.sampleId !== "") {
      writer.uint32(58).string(message.sampleId);
    }
    for (const v of message.variantSetIds) {
      writer.uint32(50).string(v!);
    }
    if (!message.created.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.created.toString());
    }
    Object.entries(message.info).forEach(([key, value]) => {
      if (value !== undefined) {
        CallSet_InfoEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
      }
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CallSet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCallSet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.sampleId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.variantSetIds.push(reader.string());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.created = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = CallSet_InfoEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.info[entry4.key] = entry4.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CallSet {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      sampleId: isSet(object.sampleId) ? globalThis.String(object.sampleId) : "",
      variantSetIds: globalThis.Array.isArray(object?.variantSetIds)
        ? object.variantSetIds.map((e: any) => globalThis.String(e))
        : [],
      created: isSet(object.created) ? Long.fromValue(object.created) : Long.ZERO,
      info: isObject(object.info)
        ? Object.entries(object.info).reduce<{ [key: string]: Array<any> | undefined }>((acc, [key, value]) => {
          acc[key] = value as Array<any> | undefined;
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: CallSet): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.sampleId !== "") {
      obj.sampleId = message.sampleId;
    }
    if (message.variantSetIds?.length) {
      obj.variantSetIds = message.variantSetIds;
    }
    if (!message.created.equals(Long.ZERO)) {
      obj.created = (message.created || Long.ZERO).toString();
    }
    if (message.info) {
      const entries = Object.entries(message.info);
      if (entries.length > 0) {
        obj.info = {};
        entries.forEach(([k, v]) => {
          obj.info[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<CallSet>): CallSet {
    return CallSet.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CallSet>): CallSet {
    const message = createBaseCallSet();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.sampleId = object.sampleId ?? "";
    message.variantSetIds = object.variantSetIds?.map((e) => e) || [];
    message.created = (object.created !== undefined && object.created !== null)
      ? Long.fromValue(object.created)
      : Long.ZERO;
    message.info = Object.entries(object.info ?? {}).reduce<{ [key: string]: Array<any> | undefined }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseCallSet_InfoEntry(): CallSet_InfoEntry {
  return { key: "", value: undefined };
}

export const CallSet_InfoEntry: MessageFns<CallSet_InfoEntry> = {
  encode(message: CallSet_InfoEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ListValue.encode(ListValue.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CallSet_InfoEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCallSet_InfoEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = ListValue.unwrap(ListValue.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CallSet_InfoEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: globalThis.Array.isArray(object.value) ? [...object.value] : undefined,
    };
  },

  toJSON(message: CallSet_InfoEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<CallSet_InfoEntry>): CallSet_InfoEntry {
    return CallSet_InfoEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CallSet_InfoEntry>): CallSet_InfoEntry {
    const message = createBaseCallSet_InfoEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseReferenceBound(): ReferenceBound {
  return { referenceName: "", upperBound: Long.ZERO };
}

export const ReferenceBound: MessageFns<ReferenceBound> = {
  encode(message: ReferenceBound, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.referenceName !== "") {
      writer.uint32(10).string(message.referenceName);
    }
    if (!message.upperBound.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.upperBound.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReferenceBound {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReferenceBound();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.referenceName = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.upperBound = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReferenceBound {
    return {
      referenceName: isSet(object.referenceName) ? globalThis.String(object.referenceName) : "",
      upperBound: isSet(object.upperBound) ? Long.fromValue(object.upperBound) : Long.ZERO,
    };
  },

  toJSON(message: ReferenceBound): unknown {
    const obj: any = {};
    if (message.referenceName !== "") {
      obj.referenceName = message.referenceName;
    }
    if (!message.upperBound.equals(Long.ZERO)) {
      obj.upperBound = (message.upperBound || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<ReferenceBound>): ReferenceBound {
    return ReferenceBound.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReferenceBound>): ReferenceBound {
    const message = createBaseReferenceBound();
    message.referenceName = object.referenceName ?? "";
    message.upperBound = (object.upperBound !== undefined && object.upperBound !== null)
      ? Long.fromValue(object.upperBound)
      : Long.ZERO;
    return message;
  },
};

function createBaseImportVariantsRequest(): ImportVariantsRequest {
  return { variantSetId: "", sourceUris: [], format: 0, normalizeReferenceNames: false, infoMergeConfig: {} };
}

export const ImportVariantsRequest: MessageFns<ImportVariantsRequest> = {
  encode(message: ImportVariantsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.variantSetId !== "") {
      writer.uint32(10).string(message.variantSetId);
    }
    for (const v of message.sourceUris) {
      writer.uint32(18).string(v!);
    }
    if (message.format !== 0) {
      writer.uint32(24).int32(message.format);
    }
    if (message.normalizeReferenceNames !== false) {
      writer.uint32(40).bool(message.normalizeReferenceNames);
    }
    Object.entries(message.infoMergeConfig).forEach(([key, value]) => {
      ImportVariantsRequest_InfoMergeConfigEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportVariantsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportVariantsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.variantSetId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sourceUris.push(reader.string());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.format = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.normalizeReferenceNames = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = ImportVariantsRequest_InfoMergeConfigEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.infoMergeConfig[entry6.key] = entry6.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportVariantsRequest {
    return {
      variantSetId: isSet(object.variantSetId) ? globalThis.String(object.variantSetId) : "",
      sourceUris: globalThis.Array.isArray(object?.sourceUris)
        ? object.sourceUris.map((e: any) => globalThis.String(e))
        : [],
      format: isSet(object.format) ? importVariantsRequest_FormatFromJSON(object.format) : 0,
      normalizeReferenceNames: isSet(object.normalizeReferenceNames)
        ? globalThis.Boolean(object.normalizeReferenceNames)
        : false,
      infoMergeConfig: isObject(object.infoMergeConfig)
        ? Object.entries(object.infoMergeConfig).reduce<{ [key: string]: InfoMergeOperation }>((acc, [key, value]) => {
          acc[key] = infoMergeOperationFromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ImportVariantsRequest): unknown {
    const obj: any = {};
    if (message.variantSetId !== "") {
      obj.variantSetId = message.variantSetId;
    }
    if (message.sourceUris?.length) {
      obj.sourceUris = message.sourceUris;
    }
    if (message.format !== 0) {
      obj.format = importVariantsRequest_FormatToJSON(message.format);
    }
    if (message.normalizeReferenceNames !== false) {
      obj.normalizeReferenceNames = message.normalizeReferenceNames;
    }
    if (message.infoMergeConfig) {
      const entries = Object.entries(message.infoMergeConfig);
      if (entries.length > 0) {
        obj.infoMergeConfig = {};
        entries.forEach(([k, v]) => {
          obj.infoMergeConfig[k] = infoMergeOperationToJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<ImportVariantsRequest>): ImportVariantsRequest {
    return ImportVariantsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImportVariantsRequest>): ImportVariantsRequest {
    const message = createBaseImportVariantsRequest();
    message.variantSetId = object.variantSetId ?? "";
    message.sourceUris = object.sourceUris?.map((e) => e) || [];
    message.format = object.format ?? 0;
    message.normalizeReferenceNames = object.normalizeReferenceNames ?? false;
    message.infoMergeConfig = Object.entries(object.infoMergeConfig ?? {}).reduce<
      { [key: string]: InfoMergeOperation }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = value as InfoMergeOperation;
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseImportVariantsRequest_InfoMergeConfigEntry(): ImportVariantsRequest_InfoMergeConfigEntry {
  return { key: "", value: 0 };
}

export const ImportVariantsRequest_InfoMergeConfigEntry: MessageFns<ImportVariantsRequest_InfoMergeConfigEntry> = {
  encode(message: ImportVariantsRequest_InfoMergeConfigEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportVariantsRequest_InfoMergeConfigEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportVariantsRequest_InfoMergeConfigEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportVariantsRequest_InfoMergeConfigEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? infoMergeOperationFromJSON(object.value) : 0,
    };
  },

  toJSON(message: ImportVariantsRequest_InfoMergeConfigEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = infoMergeOperationToJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<ImportVariantsRequest_InfoMergeConfigEntry>): ImportVariantsRequest_InfoMergeConfigEntry {
    return ImportVariantsRequest_InfoMergeConfigEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ImportVariantsRequest_InfoMergeConfigEntry>,
  ): ImportVariantsRequest_InfoMergeConfigEntry {
    const message = createBaseImportVariantsRequest_InfoMergeConfigEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseImportVariantsResponse(): ImportVariantsResponse {
  return { callSetIds: [] };
}

export const ImportVariantsResponse: MessageFns<ImportVariantsResponse> = {
  encode(message: ImportVariantsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.callSetIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportVariantsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportVariantsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.callSetIds.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportVariantsResponse {
    return {
      callSetIds: globalThis.Array.isArray(object?.callSetIds)
        ? object.callSetIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ImportVariantsResponse): unknown {
    const obj: any = {};
    if (message.callSetIds?.length) {
      obj.callSetIds = message.callSetIds;
    }
    return obj;
  },

  create(base?: DeepPartial<ImportVariantsResponse>): ImportVariantsResponse {
    return ImportVariantsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImportVariantsResponse>): ImportVariantsResponse {
    const message = createBaseImportVariantsResponse();
    message.callSetIds = object.callSetIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseCreateVariantSetRequest(): CreateVariantSetRequest {
  return { variantSet: undefined };
}

export const CreateVariantSetRequest: MessageFns<CreateVariantSetRequest> = {
  encode(message: CreateVariantSetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.variantSet !== undefined) {
      VariantSet.encode(message.variantSet, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateVariantSetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateVariantSetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.variantSet = VariantSet.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateVariantSetRequest {
    return { variantSet: isSet(object.variantSet) ? VariantSet.fromJSON(object.variantSet) : undefined };
  },

  toJSON(message: CreateVariantSetRequest): unknown {
    const obj: any = {};
    if (message.variantSet !== undefined) {
      obj.variantSet = VariantSet.toJSON(message.variantSet);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateVariantSetRequest>): CreateVariantSetRequest {
    return CreateVariantSetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateVariantSetRequest>): CreateVariantSetRequest {
    const message = createBaseCreateVariantSetRequest();
    message.variantSet = (object.variantSet !== undefined && object.variantSet !== null)
      ? VariantSet.fromPartial(object.variantSet)
      : undefined;
    return message;
  },
};

function createBaseExportVariantSetRequest(): ExportVariantSetRequest {
  return { variantSetId: "", callSetIds: [], projectId: "", format: 0, bigqueryDataset: "", bigqueryTable: "" };
}

export const ExportVariantSetRequest: MessageFns<ExportVariantSetRequest> = {
  encode(message: ExportVariantSetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.variantSetId !== "") {
      writer.uint32(10).string(message.variantSetId);
    }
    for (const v of message.callSetIds) {
      writer.uint32(18).string(v!);
    }
    if (message.projectId !== "") {
      writer.uint32(26).string(message.projectId);
    }
    if (message.format !== 0) {
      writer.uint32(32).int32(message.format);
    }
    if (message.bigqueryDataset !== "") {
      writer.uint32(42).string(message.bigqueryDataset);
    }
    if (message.bigqueryTable !== "") {
      writer.uint32(50).string(message.bigqueryTable);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportVariantSetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportVariantSetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.variantSetId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.callSetIds.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.format = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.bigqueryDataset = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.bigqueryTable = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportVariantSetRequest {
    return {
      variantSetId: isSet(object.variantSetId) ? globalThis.String(object.variantSetId) : "",
      callSetIds: globalThis.Array.isArray(object?.callSetIds)
        ? object.callSetIds.map((e: any) => globalThis.String(e))
        : [],
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      format: isSet(object.format) ? exportVariantSetRequest_FormatFromJSON(object.format) : 0,
      bigqueryDataset: isSet(object.bigqueryDataset) ? globalThis.String(object.bigqueryDataset) : "",
      bigqueryTable: isSet(object.bigqueryTable) ? globalThis.String(object.bigqueryTable) : "",
    };
  },

  toJSON(message: ExportVariantSetRequest): unknown {
    const obj: any = {};
    if (message.variantSetId !== "") {
      obj.variantSetId = message.variantSetId;
    }
    if (message.callSetIds?.length) {
      obj.callSetIds = message.callSetIds;
    }
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.format !== 0) {
      obj.format = exportVariantSetRequest_FormatToJSON(message.format);
    }
    if (message.bigqueryDataset !== "") {
      obj.bigqueryDataset = message.bigqueryDataset;
    }
    if (message.bigqueryTable !== "") {
      obj.bigqueryTable = message.bigqueryTable;
    }
    return obj;
  },

  create(base?: DeepPartial<ExportVariantSetRequest>): ExportVariantSetRequest {
    return ExportVariantSetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportVariantSetRequest>): ExportVariantSetRequest {
    const message = createBaseExportVariantSetRequest();
    message.variantSetId = object.variantSetId ?? "";
    message.callSetIds = object.callSetIds?.map((e) => e) || [];
    message.projectId = object.projectId ?? "";
    message.format = object.format ?? 0;
    message.bigqueryDataset = object.bigqueryDataset ?? "";
    message.bigqueryTable = object.bigqueryTable ?? "";
    return message;
  },
};

function createBaseGetVariantSetRequest(): GetVariantSetRequest {
  return { variantSetId: "" };
}

export const GetVariantSetRequest: MessageFns<GetVariantSetRequest> = {
  encode(message: GetVariantSetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.variantSetId !== "") {
      writer.uint32(10).string(message.variantSetId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetVariantSetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetVariantSetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.variantSetId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetVariantSetRequest {
    return { variantSetId: isSet(object.variantSetId) ? globalThis.String(object.variantSetId) : "" };
  },

  toJSON(message: GetVariantSetRequest): unknown {
    const obj: any = {};
    if (message.variantSetId !== "") {
      obj.variantSetId = message.variantSetId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetVariantSetRequest>): GetVariantSetRequest {
    return GetVariantSetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetVariantSetRequest>): GetVariantSetRequest {
    const message = createBaseGetVariantSetRequest();
    message.variantSetId = object.variantSetId ?? "";
    return message;
  },
};

function createBaseSearchVariantSetsRequest(): SearchVariantSetsRequest {
  return { datasetIds: [], pageToken: "", pageSize: 0 };
}

export const SearchVariantSetsRequest: MessageFns<SearchVariantSetsRequest> = {
  encode(message: SearchVariantSetsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.datasetIds) {
      writer.uint32(10).string(v!);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchVariantSetsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchVariantSetsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.datasetIds.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchVariantSetsRequest {
    return {
      datasetIds: globalThis.Array.isArray(object?.datasetIds)
        ? object.datasetIds.map((e: any) => globalThis.String(e))
        : [],
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
    };
  },

  toJSON(message: SearchVariantSetsRequest): unknown {
    const obj: any = {};
    if (message.datasetIds?.length) {
      obj.datasetIds = message.datasetIds;
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchVariantSetsRequest>): SearchVariantSetsRequest {
    return SearchVariantSetsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchVariantSetsRequest>): SearchVariantSetsRequest {
    const message = createBaseSearchVariantSetsRequest();
    message.datasetIds = object.datasetIds?.map((e) => e) || [];
    message.pageToken = object.pageToken ?? "";
    message.pageSize = object.pageSize ?? 0;
    return message;
  },
};

function createBaseSearchVariantSetsResponse(): SearchVariantSetsResponse {
  return { variantSets: [], nextPageToken: "" };
}

export const SearchVariantSetsResponse: MessageFns<SearchVariantSetsResponse> = {
  encode(message: SearchVariantSetsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.variantSets) {
      VariantSet.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchVariantSetsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchVariantSetsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.variantSets.push(VariantSet.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchVariantSetsResponse {
    return {
      variantSets: globalThis.Array.isArray(object?.variantSets)
        ? object.variantSets.map((e: any) => VariantSet.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: SearchVariantSetsResponse): unknown {
    const obj: any = {};
    if (message.variantSets?.length) {
      obj.variantSets = message.variantSets.map((e) => VariantSet.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchVariantSetsResponse>): SearchVariantSetsResponse {
    return SearchVariantSetsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchVariantSetsResponse>): SearchVariantSetsResponse {
    const message = createBaseSearchVariantSetsResponse();
    message.variantSets = object.variantSets?.map((e) => VariantSet.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseDeleteVariantSetRequest(): DeleteVariantSetRequest {
  return { variantSetId: "" };
}

export const DeleteVariantSetRequest: MessageFns<DeleteVariantSetRequest> = {
  encode(message: DeleteVariantSetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.variantSetId !== "") {
      writer.uint32(10).string(message.variantSetId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteVariantSetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteVariantSetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.variantSetId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteVariantSetRequest {
    return { variantSetId: isSet(object.variantSetId) ? globalThis.String(object.variantSetId) : "" };
  },

  toJSON(message: DeleteVariantSetRequest): unknown {
    const obj: any = {};
    if (message.variantSetId !== "") {
      obj.variantSetId = message.variantSetId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteVariantSetRequest>): DeleteVariantSetRequest {
    return DeleteVariantSetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteVariantSetRequest>): DeleteVariantSetRequest {
    const message = createBaseDeleteVariantSetRequest();
    message.variantSetId = object.variantSetId ?? "";
    return message;
  },
};

function createBaseUpdateVariantSetRequest(): UpdateVariantSetRequest {
  return { variantSetId: "", variantSet: undefined, updateMask: undefined };
}

export const UpdateVariantSetRequest: MessageFns<UpdateVariantSetRequest> = {
  encode(message: UpdateVariantSetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.variantSetId !== "") {
      writer.uint32(10).string(message.variantSetId);
    }
    if (message.variantSet !== undefined) {
      VariantSet.encode(message.variantSet, writer.uint32(18).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateVariantSetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateVariantSetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.variantSetId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.variantSet = VariantSet.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateVariantSetRequest {
    return {
      variantSetId: isSet(object.variantSetId) ? globalThis.String(object.variantSetId) : "",
      variantSet: isSet(object.variantSet) ? VariantSet.fromJSON(object.variantSet) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateVariantSetRequest): unknown {
    const obj: any = {};
    if (message.variantSetId !== "") {
      obj.variantSetId = message.variantSetId;
    }
    if (message.variantSet !== undefined) {
      obj.variantSet = VariantSet.toJSON(message.variantSet);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateVariantSetRequest>): UpdateVariantSetRequest {
    return UpdateVariantSetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateVariantSetRequest>): UpdateVariantSetRequest {
    const message = createBaseUpdateVariantSetRequest();
    message.variantSetId = object.variantSetId ?? "";
    message.variantSet = (object.variantSet !== undefined && object.variantSet !== null)
      ? VariantSet.fromPartial(object.variantSet)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseSearchVariantsRequest(): SearchVariantsRequest {
  return {
    variantSetIds: [],
    variantName: "",
    callSetIds: [],
    referenceName: "",
    start: Long.ZERO,
    end: Long.ZERO,
    pageToken: "",
    pageSize: 0,
    maxCalls: 0,
  };
}

export const SearchVariantsRequest: MessageFns<SearchVariantsRequest> = {
  encode(message: SearchVariantsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.variantSetIds) {
      writer.uint32(10).string(v!);
    }
    if (message.variantName !== "") {
      writer.uint32(18).string(message.variantName);
    }
    for (const v of message.callSetIds) {
      writer.uint32(26).string(v!);
    }
    if (message.referenceName !== "") {
      writer.uint32(34).string(message.referenceName);
    }
    if (!message.start.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.start.toString());
    }
    if (!message.end.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.end.toString());
    }
    if (message.pageToken !== "") {
      writer.uint32(58).string(message.pageToken);
    }
    if (message.pageSize !== 0) {
      writer.uint32(64).int32(message.pageSize);
    }
    if (message.maxCalls !== 0) {
      writer.uint32(72).int32(message.maxCalls);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchVariantsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchVariantsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.variantSetIds.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.variantName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.callSetIds.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.referenceName = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.start = Long.fromString(reader.int64().toString());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.end = Long.fromString(reader.int64().toString());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.maxCalls = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchVariantsRequest {
    return {
      variantSetIds: globalThis.Array.isArray(object?.variantSetIds)
        ? object.variantSetIds.map((e: any) => globalThis.String(e))
        : [],
      variantName: isSet(object.variantName) ? globalThis.String(object.variantName) : "",
      callSetIds: globalThis.Array.isArray(object?.callSetIds)
        ? object.callSetIds.map((e: any) => globalThis.String(e))
        : [],
      referenceName: isSet(object.referenceName) ? globalThis.String(object.referenceName) : "",
      start: isSet(object.start) ? Long.fromValue(object.start) : Long.ZERO,
      end: isSet(object.end) ? Long.fromValue(object.end) : Long.ZERO,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      maxCalls: isSet(object.maxCalls) ? globalThis.Number(object.maxCalls) : 0,
    };
  },

  toJSON(message: SearchVariantsRequest): unknown {
    const obj: any = {};
    if (message.variantSetIds?.length) {
      obj.variantSetIds = message.variantSetIds;
    }
    if (message.variantName !== "") {
      obj.variantName = message.variantName;
    }
    if (message.callSetIds?.length) {
      obj.callSetIds = message.callSetIds;
    }
    if (message.referenceName !== "") {
      obj.referenceName = message.referenceName;
    }
    if (!message.start.equals(Long.ZERO)) {
      obj.start = (message.start || Long.ZERO).toString();
    }
    if (!message.end.equals(Long.ZERO)) {
      obj.end = (message.end || Long.ZERO).toString();
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.maxCalls !== 0) {
      obj.maxCalls = Math.round(message.maxCalls);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchVariantsRequest>): SearchVariantsRequest {
    return SearchVariantsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchVariantsRequest>): SearchVariantsRequest {
    const message = createBaseSearchVariantsRequest();
    message.variantSetIds = object.variantSetIds?.map((e) => e) || [];
    message.variantName = object.variantName ?? "";
    message.callSetIds = object.callSetIds?.map((e) => e) || [];
    message.referenceName = object.referenceName ?? "";
    message.start = (object.start !== undefined && object.start !== null) ? Long.fromValue(object.start) : Long.ZERO;
    message.end = (object.end !== undefined && object.end !== null) ? Long.fromValue(object.end) : Long.ZERO;
    message.pageToken = object.pageToken ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.maxCalls = object.maxCalls ?? 0;
    return message;
  },
};

function createBaseSearchVariantsResponse(): SearchVariantsResponse {
  return { variants: [], nextPageToken: "" };
}

export const SearchVariantsResponse: MessageFns<SearchVariantsResponse> = {
  encode(message: SearchVariantsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.variants) {
      Variant.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchVariantsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchVariantsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.variants.push(Variant.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchVariantsResponse {
    return {
      variants: globalThis.Array.isArray(object?.variants) ? object.variants.map((e: any) => Variant.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: SearchVariantsResponse): unknown {
    const obj: any = {};
    if (message.variants?.length) {
      obj.variants = message.variants.map((e) => Variant.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchVariantsResponse>): SearchVariantsResponse {
    return SearchVariantsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchVariantsResponse>): SearchVariantsResponse {
    const message = createBaseSearchVariantsResponse();
    message.variants = object.variants?.map((e) => Variant.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseCreateVariantRequest(): CreateVariantRequest {
  return { variant: undefined };
}

export const CreateVariantRequest: MessageFns<CreateVariantRequest> = {
  encode(message: CreateVariantRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.variant !== undefined) {
      Variant.encode(message.variant, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateVariantRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateVariantRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.variant = Variant.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateVariantRequest {
    return { variant: isSet(object.variant) ? Variant.fromJSON(object.variant) : undefined };
  },

  toJSON(message: CreateVariantRequest): unknown {
    const obj: any = {};
    if (message.variant !== undefined) {
      obj.variant = Variant.toJSON(message.variant);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateVariantRequest>): CreateVariantRequest {
    return CreateVariantRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateVariantRequest>): CreateVariantRequest {
    const message = createBaseCreateVariantRequest();
    message.variant = (object.variant !== undefined && object.variant !== null)
      ? Variant.fromPartial(object.variant)
      : undefined;
    return message;
  },
};

function createBaseUpdateVariantRequest(): UpdateVariantRequest {
  return { variantId: "", variant: undefined, updateMask: undefined };
}

export const UpdateVariantRequest: MessageFns<UpdateVariantRequest> = {
  encode(message: UpdateVariantRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.variantId !== "") {
      writer.uint32(10).string(message.variantId);
    }
    if (message.variant !== undefined) {
      Variant.encode(message.variant, writer.uint32(18).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateVariantRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateVariantRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.variantId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.variant = Variant.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateVariantRequest {
    return {
      variantId: isSet(object.variantId) ? globalThis.String(object.variantId) : "",
      variant: isSet(object.variant) ? Variant.fromJSON(object.variant) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateVariantRequest): unknown {
    const obj: any = {};
    if (message.variantId !== "") {
      obj.variantId = message.variantId;
    }
    if (message.variant !== undefined) {
      obj.variant = Variant.toJSON(message.variant);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateVariantRequest>): UpdateVariantRequest {
    return UpdateVariantRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateVariantRequest>): UpdateVariantRequest {
    const message = createBaseUpdateVariantRequest();
    message.variantId = object.variantId ?? "";
    message.variant = (object.variant !== undefined && object.variant !== null)
      ? Variant.fromPartial(object.variant)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseDeleteVariantRequest(): DeleteVariantRequest {
  return { variantId: "" };
}

export const DeleteVariantRequest: MessageFns<DeleteVariantRequest> = {
  encode(message: DeleteVariantRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.variantId !== "") {
      writer.uint32(10).string(message.variantId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteVariantRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteVariantRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.variantId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteVariantRequest {
    return { variantId: isSet(object.variantId) ? globalThis.String(object.variantId) : "" };
  },

  toJSON(message: DeleteVariantRequest): unknown {
    const obj: any = {};
    if (message.variantId !== "") {
      obj.variantId = message.variantId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteVariantRequest>): DeleteVariantRequest {
    return DeleteVariantRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteVariantRequest>): DeleteVariantRequest {
    const message = createBaseDeleteVariantRequest();
    message.variantId = object.variantId ?? "";
    return message;
  },
};

function createBaseGetVariantRequest(): GetVariantRequest {
  return { variantId: "" };
}

export const GetVariantRequest: MessageFns<GetVariantRequest> = {
  encode(message: GetVariantRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.variantId !== "") {
      writer.uint32(10).string(message.variantId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetVariantRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetVariantRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.variantId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetVariantRequest {
    return { variantId: isSet(object.variantId) ? globalThis.String(object.variantId) : "" };
  },

  toJSON(message: GetVariantRequest): unknown {
    const obj: any = {};
    if (message.variantId !== "") {
      obj.variantId = message.variantId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetVariantRequest>): GetVariantRequest {
    return GetVariantRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetVariantRequest>): GetVariantRequest {
    const message = createBaseGetVariantRequest();
    message.variantId = object.variantId ?? "";
    return message;
  },
};

function createBaseMergeVariantsRequest(): MergeVariantsRequest {
  return { variantSetId: "", variants: [], infoMergeConfig: {} };
}

export const MergeVariantsRequest: MessageFns<MergeVariantsRequest> = {
  encode(message: MergeVariantsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.variantSetId !== "") {
      writer.uint32(10).string(message.variantSetId);
    }
    for (const v of message.variants) {
      Variant.encode(v!, writer.uint32(18).fork()).join();
    }
    Object.entries(message.infoMergeConfig).forEach(([key, value]) => {
      MergeVariantsRequest_InfoMergeConfigEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MergeVariantsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMergeVariantsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.variantSetId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.variants.push(Variant.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = MergeVariantsRequest_InfoMergeConfigEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.infoMergeConfig[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MergeVariantsRequest {
    return {
      variantSetId: isSet(object.variantSetId) ? globalThis.String(object.variantSetId) : "",
      variants: globalThis.Array.isArray(object?.variants) ? object.variants.map((e: any) => Variant.fromJSON(e)) : [],
      infoMergeConfig: isObject(object.infoMergeConfig)
        ? Object.entries(object.infoMergeConfig).reduce<{ [key: string]: InfoMergeOperation }>((acc, [key, value]) => {
          acc[key] = infoMergeOperationFromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: MergeVariantsRequest): unknown {
    const obj: any = {};
    if (message.variantSetId !== "") {
      obj.variantSetId = message.variantSetId;
    }
    if (message.variants?.length) {
      obj.variants = message.variants.map((e) => Variant.toJSON(e));
    }
    if (message.infoMergeConfig) {
      const entries = Object.entries(message.infoMergeConfig);
      if (entries.length > 0) {
        obj.infoMergeConfig = {};
        entries.forEach(([k, v]) => {
          obj.infoMergeConfig[k] = infoMergeOperationToJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<MergeVariantsRequest>): MergeVariantsRequest {
    return MergeVariantsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MergeVariantsRequest>): MergeVariantsRequest {
    const message = createBaseMergeVariantsRequest();
    message.variantSetId = object.variantSetId ?? "";
    message.variants = object.variants?.map((e) => Variant.fromPartial(e)) || [];
    message.infoMergeConfig = Object.entries(object.infoMergeConfig ?? {}).reduce<
      { [key: string]: InfoMergeOperation }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = value as InfoMergeOperation;
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseMergeVariantsRequest_InfoMergeConfigEntry(): MergeVariantsRequest_InfoMergeConfigEntry {
  return { key: "", value: 0 };
}

export const MergeVariantsRequest_InfoMergeConfigEntry: MessageFns<MergeVariantsRequest_InfoMergeConfigEntry> = {
  encode(message: MergeVariantsRequest_InfoMergeConfigEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MergeVariantsRequest_InfoMergeConfigEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMergeVariantsRequest_InfoMergeConfigEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MergeVariantsRequest_InfoMergeConfigEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? infoMergeOperationFromJSON(object.value) : 0,
    };
  },

  toJSON(message: MergeVariantsRequest_InfoMergeConfigEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = infoMergeOperationToJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<MergeVariantsRequest_InfoMergeConfigEntry>): MergeVariantsRequest_InfoMergeConfigEntry {
    return MergeVariantsRequest_InfoMergeConfigEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<MergeVariantsRequest_InfoMergeConfigEntry>,
  ): MergeVariantsRequest_InfoMergeConfigEntry {
    const message = createBaseMergeVariantsRequest_InfoMergeConfigEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseSearchCallSetsRequest(): SearchCallSetsRequest {
  return { variantSetIds: [], name: "", pageToken: "", pageSize: 0 };
}

export const SearchCallSetsRequest: MessageFns<SearchCallSetsRequest> = {
  encode(message: SearchCallSetsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.variantSetIds) {
      writer.uint32(10).string(v!);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.pageSize !== 0) {
      writer.uint32(32).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchCallSetsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchCallSetsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.variantSetIds.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchCallSetsRequest {
    return {
      variantSetIds: globalThis.Array.isArray(object?.variantSetIds)
        ? object.variantSetIds.map((e: any) => globalThis.String(e))
        : [],
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
    };
  },

  toJSON(message: SearchCallSetsRequest): unknown {
    const obj: any = {};
    if (message.variantSetIds?.length) {
      obj.variantSetIds = message.variantSetIds;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchCallSetsRequest>): SearchCallSetsRequest {
    return SearchCallSetsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchCallSetsRequest>): SearchCallSetsRequest {
    const message = createBaseSearchCallSetsRequest();
    message.variantSetIds = object.variantSetIds?.map((e) => e) || [];
    message.name = object.name ?? "";
    message.pageToken = object.pageToken ?? "";
    message.pageSize = object.pageSize ?? 0;
    return message;
  },
};

function createBaseSearchCallSetsResponse(): SearchCallSetsResponse {
  return { callSets: [], nextPageToken: "" };
}

export const SearchCallSetsResponse: MessageFns<SearchCallSetsResponse> = {
  encode(message: SearchCallSetsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.callSets) {
      CallSet.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchCallSetsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchCallSetsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.callSets.push(CallSet.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchCallSetsResponse {
    return {
      callSets: globalThis.Array.isArray(object?.callSets) ? object.callSets.map((e: any) => CallSet.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: SearchCallSetsResponse): unknown {
    const obj: any = {};
    if (message.callSets?.length) {
      obj.callSets = message.callSets.map((e) => CallSet.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchCallSetsResponse>): SearchCallSetsResponse {
    return SearchCallSetsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchCallSetsResponse>): SearchCallSetsResponse {
    const message = createBaseSearchCallSetsResponse();
    message.callSets = object.callSets?.map((e) => CallSet.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseCreateCallSetRequest(): CreateCallSetRequest {
  return { callSet: undefined };
}

export const CreateCallSetRequest: MessageFns<CreateCallSetRequest> = {
  encode(message: CreateCallSetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.callSet !== undefined) {
      CallSet.encode(message.callSet, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCallSetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCallSetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.callSet = CallSet.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCallSetRequest {
    return { callSet: isSet(object.callSet) ? CallSet.fromJSON(object.callSet) : undefined };
  },

  toJSON(message: CreateCallSetRequest): unknown {
    const obj: any = {};
    if (message.callSet !== undefined) {
      obj.callSet = CallSet.toJSON(message.callSet);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateCallSetRequest>): CreateCallSetRequest {
    return CreateCallSetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateCallSetRequest>): CreateCallSetRequest {
    const message = createBaseCreateCallSetRequest();
    message.callSet = (object.callSet !== undefined && object.callSet !== null)
      ? CallSet.fromPartial(object.callSet)
      : undefined;
    return message;
  },
};

function createBaseUpdateCallSetRequest(): UpdateCallSetRequest {
  return { callSetId: "", callSet: undefined, updateMask: undefined };
}

export const UpdateCallSetRequest: MessageFns<UpdateCallSetRequest> = {
  encode(message: UpdateCallSetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.callSetId !== "") {
      writer.uint32(10).string(message.callSetId);
    }
    if (message.callSet !== undefined) {
      CallSet.encode(message.callSet, writer.uint32(18).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateCallSetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCallSetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.callSetId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.callSet = CallSet.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateCallSetRequest {
    return {
      callSetId: isSet(object.callSetId) ? globalThis.String(object.callSetId) : "",
      callSet: isSet(object.callSet) ? CallSet.fromJSON(object.callSet) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateCallSetRequest): unknown {
    const obj: any = {};
    if (message.callSetId !== "") {
      obj.callSetId = message.callSetId;
    }
    if (message.callSet !== undefined) {
      obj.callSet = CallSet.toJSON(message.callSet);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateCallSetRequest>): UpdateCallSetRequest {
    return UpdateCallSetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateCallSetRequest>): UpdateCallSetRequest {
    const message = createBaseUpdateCallSetRequest();
    message.callSetId = object.callSetId ?? "";
    message.callSet = (object.callSet !== undefined && object.callSet !== null)
      ? CallSet.fromPartial(object.callSet)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseDeleteCallSetRequest(): DeleteCallSetRequest {
  return { callSetId: "" };
}

export const DeleteCallSetRequest: MessageFns<DeleteCallSetRequest> = {
  encode(message: DeleteCallSetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.callSetId !== "") {
      writer.uint32(10).string(message.callSetId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteCallSetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteCallSetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.callSetId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteCallSetRequest {
    return { callSetId: isSet(object.callSetId) ? globalThis.String(object.callSetId) : "" };
  },

  toJSON(message: DeleteCallSetRequest): unknown {
    const obj: any = {};
    if (message.callSetId !== "") {
      obj.callSetId = message.callSetId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteCallSetRequest>): DeleteCallSetRequest {
    return DeleteCallSetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteCallSetRequest>): DeleteCallSetRequest {
    const message = createBaseDeleteCallSetRequest();
    message.callSetId = object.callSetId ?? "";
    return message;
  },
};

function createBaseGetCallSetRequest(): GetCallSetRequest {
  return { callSetId: "" };
}

export const GetCallSetRequest: MessageFns<GetCallSetRequest> = {
  encode(message: GetCallSetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.callSetId !== "") {
      writer.uint32(10).string(message.callSetId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCallSetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCallSetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.callSetId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCallSetRequest {
    return { callSetId: isSet(object.callSetId) ? globalThis.String(object.callSetId) : "" };
  },

  toJSON(message: GetCallSetRequest): unknown {
    const obj: any = {};
    if (message.callSetId !== "") {
      obj.callSetId = message.callSetId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetCallSetRequest>): GetCallSetRequest {
    return GetCallSetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetCallSetRequest>): GetCallSetRequest {
    const message = createBaseGetCallSetRequest();
    message.callSetId = object.callSetId ?? "";
    return message;
  },
};

function createBaseStreamVariantsRequest(): StreamVariantsRequest {
  return { projectId: "", variantSetId: "", callSetIds: [], referenceName: "", start: Long.ZERO, end: Long.ZERO };
}

export const StreamVariantsRequest: MessageFns<StreamVariantsRequest> = {
  encode(message: StreamVariantsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.variantSetId !== "") {
      writer.uint32(18).string(message.variantSetId);
    }
    for (const v of message.callSetIds) {
      writer.uint32(26).string(v!);
    }
    if (message.referenceName !== "") {
      writer.uint32(34).string(message.referenceName);
    }
    if (!message.start.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.start.toString());
    }
    if (!message.end.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.end.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamVariantsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamVariantsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.variantSetId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.callSetIds.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.referenceName = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.start = Long.fromString(reader.int64().toString());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.end = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamVariantsRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      variantSetId: isSet(object.variantSetId) ? globalThis.String(object.variantSetId) : "",
      callSetIds: globalThis.Array.isArray(object?.callSetIds)
        ? object.callSetIds.map((e: any) => globalThis.String(e))
        : [],
      referenceName: isSet(object.referenceName) ? globalThis.String(object.referenceName) : "",
      start: isSet(object.start) ? Long.fromValue(object.start) : Long.ZERO,
      end: isSet(object.end) ? Long.fromValue(object.end) : Long.ZERO,
    };
  },

  toJSON(message: StreamVariantsRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.variantSetId !== "") {
      obj.variantSetId = message.variantSetId;
    }
    if (message.callSetIds?.length) {
      obj.callSetIds = message.callSetIds;
    }
    if (message.referenceName !== "") {
      obj.referenceName = message.referenceName;
    }
    if (!message.start.equals(Long.ZERO)) {
      obj.start = (message.start || Long.ZERO).toString();
    }
    if (!message.end.equals(Long.ZERO)) {
      obj.end = (message.end || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<StreamVariantsRequest>): StreamVariantsRequest {
    return StreamVariantsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamVariantsRequest>): StreamVariantsRequest {
    const message = createBaseStreamVariantsRequest();
    message.projectId = object.projectId ?? "";
    message.variantSetId = object.variantSetId ?? "";
    message.callSetIds = object.callSetIds?.map((e) => e) || [];
    message.referenceName = object.referenceName ?? "";
    message.start = (object.start !== undefined && object.start !== null) ? Long.fromValue(object.start) : Long.ZERO;
    message.end = (object.end !== undefined && object.end !== null) ? Long.fromValue(object.end) : Long.ZERO;
    return message;
  },
};

function createBaseStreamVariantsResponse(): StreamVariantsResponse {
  return { variants: [] };
}

export const StreamVariantsResponse: MessageFns<StreamVariantsResponse> = {
  encode(message: StreamVariantsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.variants) {
      Variant.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamVariantsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamVariantsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.variants.push(Variant.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamVariantsResponse {
    return {
      variants: globalThis.Array.isArray(object?.variants) ? object.variants.map((e: any) => Variant.fromJSON(e)) : [],
    };
  },

  toJSON(message: StreamVariantsResponse): unknown {
    const obj: any = {};
    if (message.variants?.length) {
      obj.variants = message.variants.map((e) => Variant.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<StreamVariantsResponse>): StreamVariantsResponse {
    return StreamVariantsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamVariantsResponse>): StreamVariantsResponse {
    const message = createBaseStreamVariantsResponse();
    message.variants = object.variants?.map((e) => Variant.fromPartial(e)) || [];
    return message;
  },
};

export type StreamingVariantServiceDefinition = typeof StreamingVariantServiceDefinition;
export const StreamingVariantServiceDefinition = {
  name: "StreamingVariantService",
  fullName: "google.genomics.v1.StreamingVariantService",
  methods: {
    /**
     * Returns a stream of all the variants matching the search request, ordered
     * by reference name, position, and ID.
     */
    streamVariants: {
      name: "StreamVariants",
      requestType: StreamVariantsRequest,
      requestStream: false,
      responseType: StreamVariantsResponse,
      responseStream: true,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              24,
              58,
              1,
              42,
              34,
              19,
              47,
              118,
              49,
              47,
              118,
              97,
              114,
              105,
              97,
              110,
              116,
              115,
              58,
              115,
              116,
              114,
              101,
              97,
              109,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface StreamingVariantServiceImplementation<CallContextExt = {}> {
  /**
   * Returns a stream of all the variants matching the search request, ordered
   * by reference name, position, and ID.
   */
  streamVariants(
    request: StreamVariantsRequest,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<DeepPartial<StreamVariantsResponse>>;
}

export interface StreamingVariantServiceClient<CallOptionsExt = {}> {
  /**
   * Returns a stream of all the variants matching the search request, ordered
   * by reference name, position, and ID.
   */
  streamVariants(
    request: DeepPartial<StreamVariantsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<StreamVariantsResponse>;
}

export type VariantServiceV1Definition = typeof VariantServiceV1Definition;
export const VariantServiceV1Definition = {
  name: "VariantServiceV1",
  fullName: "google.genomics.v1.VariantServiceV1",
  methods: {
    /**
     * Creates variant data by asynchronously importing the provided information.
     *
     * For the definitions of variant sets and other genomics resources, see
     * [Fundamentals of Google
     * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
     *
     * The variants for import will be merged with any existing variant that
     * matches its reference sequence, start, end, reference bases, and
     * alternative bases. If no such variant exists, a new one will be created.
     *
     * When variants are merged, the call information from the new variant
     * is added to the existing variant, and Variant info fields are merged
     * as specified in
     * [infoMergeConfig][google.genomics.v1.ImportVariantsRequest.info_merge_config].
     * As a special case, for single-sample VCF files, QUAL and FILTER fields will
     * be moved to the call level; these are sometimes interpreted in a
     * call-specific context.
     * Imported VCF headers are appended to the metadata already in a variant set.
     */
    importVariants: {
      name: "ImportVariants",
      requestType: ImportVariantsRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              24,
              58,
              1,
              42,
              34,
              19,
              47,
              118,
              49,
              47,
              118,
              97,
              114,
              105,
              97,
              110,
              116,
              115,
              58,
              105,
              109,
              112,
              111,
              114,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * Creates a new variant set.
     *
     * For the definitions of variant sets and other genomics resources, see
     * [Fundamentals of Google
     * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
     *
     * The provided variant set must have a valid `datasetId` set - all other
     * fields are optional. Note that the `id` field will be ignored, as this is
     * assigned by the server.
     */
    createVariantSet: {
      name: "CreateVariantSet",
      requestType: CreateVariantSetRequest,
      requestStream: false,
      responseType: VariantSet,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              30,
              58,
              11,
              118,
              97,
              114,
              105,
              97,
              110,
              116,
              95,
              115,
              101,
              116,
              34,
              15,
              47,
              118,
              49,
              47,
              118,
              97,
              114,
              105,
              97,
              110,
              116,
              115,
              101,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Exports variant set data to an external destination.
     *
     * For the definitions of variant sets and other genomics resources, see
     * [Fundamentals of Google
     * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
     */
    exportVariantSet: {
      name: "ExportVariantSet",
      requestType: ExportVariantSetRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              44,
              58,
              1,
              42,
              34,
              39,
              47,
              118,
              49,
              47,
              118,
              97,
              114,
              105,
              97,
              110,
              116,
              115,
              101,
              116,
              115,
              47,
              123,
              118,
              97,
              114,
              105,
              97,
              110,
              116,
              95,
              115,
              101,
              116,
              95,
              105,
              100,
              125,
              58,
              101,
              120,
              112,
              111,
              114,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * Gets a variant set by ID.
     *
     * For the definitions of variant sets and other genomics resources, see
     * [Fundamentals of Google
     * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
     */
    getVariantSet: {
      name: "GetVariantSet",
      requestType: GetVariantSetRequest,
      requestStream: false,
      responseType: VariantSet,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              34,
              18,
              32,
              47,
              118,
              49,
              47,
              118,
              97,
              114,
              105,
              97,
              110,
              116,
              115,
              101,
              116,
              115,
              47,
              123,
              118,
              97,
              114,
              105,
              97,
              110,
              116,
              95,
              115,
              101,
              116,
              95,
              105,
              100,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Returns a list of all variant sets matching search criteria.
     *
     * For the definitions of variant sets and other genomics resources, see
     * [Fundamentals of Google
     * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
     *
     * Implements
     * [GlobalAllianceApi.searchVariantSets](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/variantmethods.avdl#L49).
     */
    searchVariantSets: {
      name: "SearchVariantSets",
      requestType: SearchVariantSetsRequest,
      requestStream: false,
      responseType: SearchVariantSetsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              27,
              58,
              1,
              42,
              34,
              22,
              47,
              118,
              49,
              47,
              118,
              97,
              114,
              105,
              97,
              110,
              116,
              115,
              101,
              116,
              115,
              47,
              115,
              101,
              97,
              114,
              99,
              104,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes a variant set including all variants, call sets, and calls within.
     * This is not reversible.
     *
     * For the definitions of variant sets and other genomics resources, see
     * [Fundamentals of Google
     * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
     */
    deleteVariantSet: {
      name: "DeleteVariantSet",
      requestType: DeleteVariantSetRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              34,
              42,
              32,
              47,
              118,
              49,
              47,
              118,
              97,
              114,
              105,
              97,
              110,
              116,
              115,
              101,
              116,
              115,
              47,
              123,
              118,
              97,
              114,
              105,
              97,
              110,
              116,
              95,
              115,
              101,
              116,
              95,
              105,
              100,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Updates a variant set using patch semantics.
     *
     * For the definitions of variant sets and other genomics resources, see
     * [Fundamentals of Google
     * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
     */
    updateVariantSet: {
      name: "UpdateVariantSet",
      requestType: UpdateVariantSetRequest,
      requestStream: false,
      responseType: VariantSet,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              47,
              58,
              11,
              118,
              97,
              114,
              105,
              97,
              110,
              116,
              95,
              115,
              101,
              116,
              50,
              32,
              47,
              118,
              49,
              47,
              118,
              97,
              114,
              105,
              97,
              110,
              116,
              115,
              101,
              116,
              115,
              47,
              123,
              118,
              97,
              114,
              105,
              97,
              110,
              116,
              95,
              115,
              101,
              116,
              95,
              105,
              100,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Gets a list of variants matching the criteria.
     *
     * For the definitions of variants and other genomics resources, see
     * [Fundamentals of Google
     * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
     *
     * Implements
     * [GlobalAllianceApi.searchVariants](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/variantmethods.avdl#L126).
     */
    searchVariants: {
      name: "SearchVariants",
      requestType: SearchVariantsRequest,
      requestStream: false,
      responseType: SearchVariantsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              24,
              58,
              1,
              42,
              34,
              19,
              47,
              118,
              49,
              47,
              118,
              97,
              114,
              105,
              97,
              110,
              116,
              115,
              47,
              115,
              101,
              97,
              114,
              99,
              104,
            ]),
          ],
        },
      },
    },
    /**
     * Creates a new variant.
     *
     * For the definitions of variants and other genomics resources, see
     * [Fundamentals of Google
     * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
     */
    createVariant: {
      name: "CreateVariant",
      requestType: CreateVariantRequest,
      requestStream: false,
      responseType: Variant,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              23,
              58,
              7,
              118,
              97,
              114,
              105,
              97,
              110,
              116,
              34,
              12,
              47,
              118,
              49,
              47,
              118,
              97,
              114,
              105,
              97,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Updates a variant.
     *
     * For the definitions of variants and other genomics resources, see
     * [Fundamentals of Google
     * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
     *
     * This method supports patch semantics. Returns the modified variant without
     * its calls.
     */
    updateVariant: {
      name: "UpdateVariant",
      requestType: UpdateVariantRequest,
      requestStream: false,
      responseType: Variant,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              36,
              58,
              7,
              118,
              97,
              114,
              105,
              97,
              110,
              116,
              50,
              25,
              47,
              118,
              49,
              47,
              118,
              97,
              114,
              105,
              97,
              110,
              116,
              115,
              47,
              123,
              118,
              97,
              114,
              105,
              97,
              110,
              116,
              95,
              105,
              100,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes a variant.
     *
     * For the definitions of variants and other genomics resources, see
     * [Fundamentals of Google
     * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
     */
    deleteVariant: {
      name: "DeleteVariant",
      requestType: DeleteVariantRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              27,
              42,
              25,
              47,
              118,
              49,
              47,
              118,
              97,
              114,
              105,
              97,
              110,
              116,
              115,
              47,
              123,
              118,
              97,
              114,
              105,
              97,
              110,
              116,
              95,
              105,
              100,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Gets a variant by ID.
     *
     * For the definitions of variants and other genomics resources, see
     * [Fundamentals of Google
     * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
     */
    getVariant: {
      name: "GetVariant",
      requestType: GetVariantRequest,
      requestStream: false,
      responseType: Variant,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              27,
              18,
              25,
              47,
              118,
              49,
              47,
              118,
              97,
              114,
              105,
              97,
              110,
              116,
              115,
              47,
              123,
              118,
              97,
              114,
              105,
              97,
              110,
              116,
              95,
              105,
              100,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Merges the given variants with existing variants.
     *
     * For the definitions of variants and other genomics resources, see
     * [Fundamentals of Google
     * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
     *
     * Each variant will be
     * merged with an existing variant that matches its reference sequence,
     * start, end, reference bases, and alternative bases. If no such variant
     * exists, a new one will be created.
     *
     * When variants are merged, the call information from the new variant
     * is added to the existing variant. Variant info fields are merged as
     * specified in the
     * [infoMergeConfig][google.genomics.v1.MergeVariantsRequest.info_merge_config]
     * field of the MergeVariantsRequest.
     *
     * Please exercise caution when using this method!  It is easy to introduce
     * mistakes in existing variants and difficult to back out of them.  For
     * example,
     * suppose you were trying to merge a new variant with an existing one and
     * both
     * variants contain calls that belong to callsets with the same callset ID.
     *
     *     // Existing variant - irrelevant fields trimmed for clarity
     *     {
     *         "variantSetId": "10473108253681171589",
     *         "referenceName": "1",
     *         "start": "10582",
     *         "referenceBases": "G",
     *         "alternateBases": [
     *             "A"
     *         ],
     *         "calls": [
     *             {
     *                 "callSetId": "10473108253681171589-0",
     *                 "callSetName": "CALLSET0",
     *                 "genotype": [
     *                     0,
     *                     1
     *                 ],
     *             }
     *         ]
     *     }
     *
     *     // New variant with conflicting call information
     *     {
     *         "variantSetId": "10473108253681171589",
     *         "referenceName": "1",
     *         "start": "10582",
     *         "referenceBases": "G",
     *         "alternateBases": [
     *             "A"
     *         ],
     *         "calls": [
     *             {
     *                 "callSetId": "10473108253681171589-0",
     *                 "callSetName": "CALLSET0",
     *                 "genotype": [
     *                     1,
     *                     1
     *                 ],
     *             }
     *         ]
     *     }
     *
     * The resulting merged variant would overwrite the existing calls with those
     * from the new variant:
     *
     *     {
     *         "variantSetId": "10473108253681171589",
     *         "referenceName": "1",
     *         "start": "10582",
     *         "referenceBases": "G",
     *         "alternateBases": [
     *             "A"
     *         ],
     *         "calls": [
     *             {
     *                 "callSetId": "10473108253681171589-0",
     *                 "callSetName": "CALLSET0",
     *                 "genotype": [
     *                     1,
     *                     1
     *                 ],
     *             }
     *         ]
     *     }
     *
     * This may be the desired outcome, but it is up to the user to determine if
     * if that is indeed the case.
     */
    mergeVariants: {
      name: "MergeVariants",
      requestType: MergeVariantsRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              23,
              58,
              1,
              42,
              34,
              18,
              47,
              118,
              49,
              47,
              118,
              97,
              114,
              105,
              97,
              110,
              116,
              115,
              58,
              109,
              101,
              114,
              103,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Gets a list of call sets matching the criteria.
     *
     * For the definitions of call sets and other genomics resources, see
     * [Fundamentals of Google
     * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
     *
     * Implements
     * [GlobalAllianceApi.searchCallSets](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/variantmethods.avdl#L178).
     */
    searchCallSets: {
      name: "SearchCallSets",
      requestType: SearchCallSetsRequest,
      requestStream: false,
      responseType: SearchCallSetsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              24,
              58,
              1,
              42,
              34,
              19,
              47,
              118,
              49,
              47,
              99,
              97,
              108,
              108,
              115,
              101,
              116,
              115,
              47,
              115,
              101,
              97,
              114,
              99,
              104,
            ]),
          ],
        },
      },
    },
    /**
     * Creates a new call set.
     *
     * For the definitions of call sets and other genomics resources, see
     * [Fundamentals of Google
     * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
     */
    createCallSet: {
      name: "CreateCallSet",
      requestType: CreateCallSetRequest,
      requestStream: false,
      responseType: CallSet,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              24,
              58,
              8,
              99,
              97,
              108,
              108,
              95,
              115,
              101,
              116,
              34,
              12,
              47,
              118,
              49,
              47,
              99,
              97,
              108,
              108,
              115,
              101,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Updates a call set.
     *
     * For the definitions of call sets and other genomics resources, see
     * [Fundamentals of Google
     * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
     *
     * This method supports patch semantics.
     */
    updateCallSet: {
      name: "UpdateCallSet",
      requestType: UpdateCallSetRequest,
      requestStream: false,
      responseType: CallSet,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              38,
              58,
              8,
              99,
              97,
              108,
              108,
              95,
              115,
              101,
              116,
              50,
              26,
              47,
              118,
              49,
              47,
              99,
              97,
              108,
              108,
              115,
              101,
              116,
              115,
              47,
              123,
              99,
              97,
              108,
              108,
              95,
              115,
              101,
              116,
              95,
              105,
              100,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes a call set.
     *
     * For the definitions of call sets and other genomics resources, see
     * [Fundamentals of Google
     * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
     */
    deleteCallSet: {
      name: "DeleteCallSet",
      requestType: DeleteCallSetRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              28,
              42,
              26,
              47,
              118,
              49,
              47,
              99,
              97,
              108,
              108,
              115,
              101,
              116,
              115,
              47,
              123,
              99,
              97,
              108,
              108,
              95,
              115,
              101,
              116,
              95,
              105,
              100,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Gets a call set by ID.
     *
     * For the definitions of call sets and other genomics resources, see
     * [Fundamentals of Google
     * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
     */
    getCallSet: {
      name: "GetCallSet",
      requestType: GetCallSetRequest,
      requestStream: false,
      responseType: CallSet,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              28,
              18,
              26,
              47,
              118,
              49,
              47,
              99,
              97,
              108,
              108,
              115,
              101,
              116,
              115,
              47,
              123,
              99,
              97,
              108,
              108,
              95,
              115,
              101,
              116,
              95,
              105,
              100,
              125,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface VariantServiceV1ServiceImplementation<CallContextExt = {}> {
  /**
   * Creates variant data by asynchronously importing the provided information.
   *
   * For the definitions of variant sets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * The variants for import will be merged with any existing variant that
   * matches its reference sequence, start, end, reference bases, and
   * alternative bases. If no such variant exists, a new one will be created.
   *
   * When variants are merged, the call information from the new variant
   * is added to the existing variant, and Variant info fields are merged
   * as specified in
   * [infoMergeConfig][google.genomics.v1.ImportVariantsRequest.info_merge_config].
   * As a special case, for single-sample VCF files, QUAL and FILTER fields will
   * be moved to the call level; these are sometimes interpreted in a
   * call-specific context.
   * Imported VCF headers are appended to the metadata already in a variant set.
   */
  importVariants(
    request: ImportVariantsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Creates a new variant set.
   *
   * For the definitions of variant sets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * The provided variant set must have a valid `datasetId` set - all other
   * fields are optional. Note that the `id` field will be ignored, as this is
   * assigned by the server.
   */
  createVariantSet(
    request: CreateVariantSetRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<VariantSet>>;
  /**
   * Exports variant set data to an external destination.
   *
   * For the definitions of variant sets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   */
  exportVariantSet(
    request: ExportVariantSetRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Gets a variant set by ID.
   *
   * For the definitions of variant sets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   */
  getVariantSet(request: GetVariantSetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<VariantSet>>;
  /**
   * Returns a list of all variant sets matching search criteria.
   *
   * For the definitions of variant sets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * Implements
   * [GlobalAllianceApi.searchVariantSets](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/variantmethods.avdl#L49).
   */
  searchVariantSets(
    request: SearchVariantSetsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SearchVariantSetsResponse>>;
  /**
   * Deletes a variant set including all variants, call sets, and calls within.
   * This is not reversible.
   *
   * For the definitions of variant sets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   */
  deleteVariantSet(
    request: DeleteVariantSetRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /**
   * Updates a variant set using patch semantics.
   *
   * For the definitions of variant sets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   */
  updateVariantSet(
    request: UpdateVariantSetRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<VariantSet>>;
  /**
   * Gets a list of variants matching the criteria.
   *
   * For the definitions of variants and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * Implements
   * [GlobalAllianceApi.searchVariants](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/variantmethods.avdl#L126).
   */
  searchVariants(
    request: SearchVariantsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SearchVariantsResponse>>;
  /**
   * Creates a new variant.
   *
   * For the definitions of variants and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   */
  createVariant(request: CreateVariantRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Variant>>;
  /**
   * Updates a variant.
   *
   * For the definitions of variants and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * This method supports patch semantics. Returns the modified variant without
   * its calls.
   */
  updateVariant(request: UpdateVariantRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Variant>>;
  /**
   * Deletes a variant.
   *
   * For the definitions of variants and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   */
  deleteVariant(request: DeleteVariantRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /**
   * Gets a variant by ID.
   *
   * For the definitions of variants and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   */
  getVariant(request: GetVariantRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Variant>>;
  /**
   * Merges the given variants with existing variants.
   *
   * For the definitions of variants and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * Each variant will be
   * merged with an existing variant that matches its reference sequence,
   * start, end, reference bases, and alternative bases. If no such variant
   * exists, a new one will be created.
   *
   * When variants are merged, the call information from the new variant
   * is added to the existing variant. Variant info fields are merged as
   * specified in the
   * [infoMergeConfig][google.genomics.v1.MergeVariantsRequest.info_merge_config]
   * field of the MergeVariantsRequest.
   *
   * Please exercise caution when using this method!  It is easy to introduce
   * mistakes in existing variants and difficult to back out of them.  For
   * example,
   * suppose you were trying to merge a new variant with an existing one and
   * both
   * variants contain calls that belong to callsets with the same callset ID.
   *
   *     // Existing variant - irrelevant fields trimmed for clarity
   *     {
   *         "variantSetId": "10473108253681171589",
   *         "referenceName": "1",
   *         "start": "10582",
   *         "referenceBases": "G",
   *         "alternateBases": [
   *             "A"
   *         ],
   *         "calls": [
   *             {
   *                 "callSetId": "10473108253681171589-0",
   *                 "callSetName": "CALLSET0",
   *                 "genotype": [
   *                     0,
   *                     1
   *                 ],
   *             }
   *         ]
   *     }
   *
   *     // New variant with conflicting call information
   *     {
   *         "variantSetId": "10473108253681171589",
   *         "referenceName": "1",
   *         "start": "10582",
   *         "referenceBases": "G",
   *         "alternateBases": [
   *             "A"
   *         ],
   *         "calls": [
   *             {
   *                 "callSetId": "10473108253681171589-0",
   *                 "callSetName": "CALLSET0",
   *                 "genotype": [
   *                     1,
   *                     1
   *                 ],
   *             }
   *         ]
   *     }
   *
   * The resulting merged variant would overwrite the existing calls with those
   * from the new variant:
   *
   *     {
   *         "variantSetId": "10473108253681171589",
   *         "referenceName": "1",
   *         "start": "10582",
   *         "referenceBases": "G",
   *         "alternateBases": [
   *             "A"
   *         ],
   *         "calls": [
   *             {
   *                 "callSetId": "10473108253681171589-0",
   *                 "callSetName": "CALLSET0",
   *                 "genotype": [
   *                     1,
   *                     1
   *                 ],
   *             }
   *         ]
   *     }
   *
   * This may be the desired outcome, but it is up to the user to determine if
   * if that is indeed the case.
   */
  mergeVariants(request: MergeVariantsRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /**
   * Gets a list of call sets matching the criteria.
   *
   * For the definitions of call sets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * Implements
   * [GlobalAllianceApi.searchCallSets](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/variantmethods.avdl#L178).
   */
  searchCallSets(
    request: SearchCallSetsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SearchCallSetsResponse>>;
  /**
   * Creates a new call set.
   *
   * For the definitions of call sets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   */
  createCallSet(request: CreateCallSetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<CallSet>>;
  /**
   * Updates a call set.
   *
   * For the definitions of call sets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * This method supports patch semantics.
   */
  updateCallSet(request: UpdateCallSetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<CallSet>>;
  /**
   * Deletes a call set.
   *
   * For the definitions of call sets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   */
  deleteCallSet(request: DeleteCallSetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /**
   * Gets a call set by ID.
   *
   * For the definitions of call sets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   */
  getCallSet(request: GetCallSetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<CallSet>>;
}

export interface VariantServiceV1Client<CallOptionsExt = {}> {
  /**
   * Creates variant data by asynchronously importing the provided information.
   *
   * For the definitions of variant sets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * The variants for import will be merged with any existing variant that
   * matches its reference sequence, start, end, reference bases, and
   * alternative bases. If no such variant exists, a new one will be created.
   *
   * When variants are merged, the call information from the new variant
   * is added to the existing variant, and Variant info fields are merged
   * as specified in
   * [infoMergeConfig][google.genomics.v1.ImportVariantsRequest.info_merge_config].
   * As a special case, for single-sample VCF files, QUAL and FILTER fields will
   * be moved to the call level; these are sometimes interpreted in a
   * call-specific context.
   * Imported VCF headers are appended to the metadata already in a variant set.
   */
  importVariants(
    request: DeepPartial<ImportVariantsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Creates a new variant set.
   *
   * For the definitions of variant sets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * The provided variant set must have a valid `datasetId` set - all other
   * fields are optional. Note that the `id` field will be ignored, as this is
   * assigned by the server.
   */
  createVariantSet(
    request: DeepPartial<CreateVariantSetRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<VariantSet>;
  /**
   * Exports variant set data to an external destination.
   *
   * For the definitions of variant sets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   */
  exportVariantSet(
    request: DeepPartial<ExportVariantSetRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Gets a variant set by ID.
   *
   * For the definitions of variant sets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   */
  getVariantSet(
    request: DeepPartial<GetVariantSetRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<VariantSet>;
  /**
   * Returns a list of all variant sets matching search criteria.
   *
   * For the definitions of variant sets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * Implements
   * [GlobalAllianceApi.searchVariantSets](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/variantmethods.avdl#L49).
   */
  searchVariantSets(
    request: DeepPartial<SearchVariantSetsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SearchVariantSetsResponse>;
  /**
   * Deletes a variant set including all variants, call sets, and calls within.
   * This is not reversible.
   *
   * For the definitions of variant sets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   */
  deleteVariantSet(
    request: DeepPartial<DeleteVariantSetRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /**
   * Updates a variant set using patch semantics.
   *
   * For the definitions of variant sets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   */
  updateVariantSet(
    request: DeepPartial<UpdateVariantSetRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<VariantSet>;
  /**
   * Gets a list of variants matching the criteria.
   *
   * For the definitions of variants and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * Implements
   * [GlobalAllianceApi.searchVariants](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/variantmethods.avdl#L126).
   */
  searchVariants(
    request: DeepPartial<SearchVariantsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SearchVariantsResponse>;
  /**
   * Creates a new variant.
   *
   * For the definitions of variants and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   */
  createVariant(request: DeepPartial<CreateVariantRequest>, options?: CallOptions & CallOptionsExt): Promise<Variant>;
  /**
   * Updates a variant.
   *
   * For the definitions of variants and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * This method supports patch semantics. Returns the modified variant without
   * its calls.
   */
  updateVariant(request: DeepPartial<UpdateVariantRequest>, options?: CallOptions & CallOptionsExt): Promise<Variant>;
  /**
   * Deletes a variant.
   *
   * For the definitions of variants and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   */
  deleteVariant(request: DeepPartial<DeleteVariantRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /**
   * Gets a variant by ID.
   *
   * For the definitions of variants and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   */
  getVariant(request: DeepPartial<GetVariantRequest>, options?: CallOptions & CallOptionsExt): Promise<Variant>;
  /**
   * Merges the given variants with existing variants.
   *
   * For the definitions of variants and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * Each variant will be
   * merged with an existing variant that matches its reference sequence,
   * start, end, reference bases, and alternative bases. If no such variant
   * exists, a new one will be created.
   *
   * When variants are merged, the call information from the new variant
   * is added to the existing variant. Variant info fields are merged as
   * specified in the
   * [infoMergeConfig][google.genomics.v1.MergeVariantsRequest.info_merge_config]
   * field of the MergeVariantsRequest.
   *
   * Please exercise caution when using this method!  It is easy to introduce
   * mistakes in existing variants and difficult to back out of them.  For
   * example,
   * suppose you were trying to merge a new variant with an existing one and
   * both
   * variants contain calls that belong to callsets with the same callset ID.
   *
   *     // Existing variant - irrelevant fields trimmed for clarity
   *     {
   *         "variantSetId": "10473108253681171589",
   *         "referenceName": "1",
   *         "start": "10582",
   *         "referenceBases": "G",
   *         "alternateBases": [
   *             "A"
   *         ],
   *         "calls": [
   *             {
   *                 "callSetId": "10473108253681171589-0",
   *                 "callSetName": "CALLSET0",
   *                 "genotype": [
   *                     0,
   *                     1
   *                 ],
   *             }
   *         ]
   *     }
   *
   *     // New variant with conflicting call information
   *     {
   *         "variantSetId": "10473108253681171589",
   *         "referenceName": "1",
   *         "start": "10582",
   *         "referenceBases": "G",
   *         "alternateBases": [
   *             "A"
   *         ],
   *         "calls": [
   *             {
   *                 "callSetId": "10473108253681171589-0",
   *                 "callSetName": "CALLSET0",
   *                 "genotype": [
   *                     1,
   *                     1
   *                 ],
   *             }
   *         ]
   *     }
   *
   * The resulting merged variant would overwrite the existing calls with those
   * from the new variant:
   *
   *     {
   *         "variantSetId": "10473108253681171589",
   *         "referenceName": "1",
   *         "start": "10582",
   *         "referenceBases": "G",
   *         "alternateBases": [
   *             "A"
   *         ],
   *         "calls": [
   *             {
   *                 "callSetId": "10473108253681171589-0",
   *                 "callSetName": "CALLSET0",
   *                 "genotype": [
   *                     1,
   *                     1
   *                 ],
   *             }
   *         ]
   *     }
   *
   * This may be the desired outcome, but it is up to the user to determine if
   * if that is indeed the case.
   */
  mergeVariants(request: DeepPartial<MergeVariantsRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /**
   * Gets a list of call sets matching the criteria.
   *
   * For the definitions of call sets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * Implements
   * [GlobalAllianceApi.searchCallSets](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/variantmethods.avdl#L178).
   */
  searchCallSets(
    request: DeepPartial<SearchCallSetsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SearchCallSetsResponse>;
  /**
   * Creates a new call set.
   *
   * For the definitions of call sets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   */
  createCallSet(request: DeepPartial<CreateCallSetRequest>, options?: CallOptions & CallOptionsExt): Promise<CallSet>;
  /**
   * Updates a call set.
   *
   * For the definitions of call sets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * This method supports patch semantics.
   */
  updateCallSet(request: DeepPartial<UpdateCallSetRequest>, options?: CallOptions & CallOptionsExt): Promise<CallSet>;
  /**
   * Deletes a call set.
   *
   * For the definitions of call sets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   */
  deleteCallSet(request: DeepPartial<DeleteCallSetRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /**
   * Gets a call set by ID.
   *
   * For the definitions of call sets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   */
  getCallSet(request: DeepPartial<GetCallSetRequest>, options?: CallOptions & CallOptionsExt): Promise<CallSet>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export type ServerStreamingMethodResult<Response> = { [Symbol.asyncIterator](): AsyncIterator<Response, void> };

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
