// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/analytics/data/v1alpha/data.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../protobuf/duration.js";

export const protobufPackage = "google.analytics.data.v1alpha";

/**
 * Scoping specifies which events are considered when evaluating if a user
 * meets a criteria.
 */
export enum UserCriteriaScoping {
  /** USER_CRITERIA_SCOPING_UNSPECIFIED - Unspecified criteria scoping. Do not specify. */
  USER_CRITERIA_SCOPING_UNSPECIFIED = 0,
  /**
   * USER_CRITERIA_WITHIN_SAME_EVENT - If the criteria is satisfied within one event, the user matches the
   * criteria.
   */
  USER_CRITERIA_WITHIN_SAME_EVENT = 1,
  /**
   * USER_CRITERIA_WITHIN_SAME_SESSION - If the criteria is satisfied within one session, the user matches the
   * criteria.
   */
  USER_CRITERIA_WITHIN_SAME_SESSION = 2,
  /**
   * USER_CRITERIA_ACROSS_ALL_SESSIONS - If the criteria is satisfied by any events for the user, the user
   * matches the criteria.
   */
  USER_CRITERIA_ACROSS_ALL_SESSIONS = 3,
  UNRECOGNIZED = -1,
}

export function userCriteriaScopingFromJSON(object: any): UserCriteriaScoping {
  switch (object) {
    case 0:
    case "USER_CRITERIA_SCOPING_UNSPECIFIED":
      return UserCriteriaScoping.USER_CRITERIA_SCOPING_UNSPECIFIED;
    case 1:
    case "USER_CRITERIA_WITHIN_SAME_EVENT":
      return UserCriteriaScoping.USER_CRITERIA_WITHIN_SAME_EVENT;
    case 2:
    case "USER_CRITERIA_WITHIN_SAME_SESSION":
      return UserCriteriaScoping.USER_CRITERIA_WITHIN_SAME_SESSION;
    case 3:
    case "USER_CRITERIA_ACROSS_ALL_SESSIONS":
      return UserCriteriaScoping.USER_CRITERIA_ACROSS_ALL_SESSIONS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UserCriteriaScoping.UNRECOGNIZED;
  }
}

export function userCriteriaScopingToJSON(object: UserCriteriaScoping): string {
  switch (object) {
    case UserCriteriaScoping.USER_CRITERIA_SCOPING_UNSPECIFIED:
      return "USER_CRITERIA_SCOPING_UNSPECIFIED";
    case UserCriteriaScoping.USER_CRITERIA_WITHIN_SAME_EVENT:
      return "USER_CRITERIA_WITHIN_SAME_EVENT";
    case UserCriteriaScoping.USER_CRITERIA_WITHIN_SAME_SESSION:
      return "USER_CRITERIA_WITHIN_SAME_SESSION";
    case UserCriteriaScoping.USER_CRITERIA_ACROSS_ALL_SESSIONS:
      return "USER_CRITERIA_ACROSS_ALL_SESSIONS";
    case UserCriteriaScoping.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Enumerates options for how long an exclusion will last if a user matches
 * the `userExclusionCriteria`.
 */
export enum UserExclusionDuration {
  /** USER_EXCLUSION_DURATION_UNSPECIFIED - Unspecified exclusion duration. Do not specify. */
  USER_EXCLUSION_DURATION_UNSPECIFIED = 0,
  /**
   * USER_EXCLUSION_TEMPORARY - Temporarily exclude users from the segment during periods when the
   * user meets the `userExclusionCriteria` condition.
   */
  USER_EXCLUSION_TEMPORARY = 1,
  /**
   * USER_EXCLUSION_PERMANENT - Permanently exclude users from the segment if the user ever meets the
   * `userExclusionCriteria` condition.
   */
  USER_EXCLUSION_PERMANENT = 2,
  UNRECOGNIZED = -1,
}

export function userExclusionDurationFromJSON(object: any): UserExclusionDuration {
  switch (object) {
    case 0:
    case "USER_EXCLUSION_DURATION_UNSPECIFIED":
      return UserExclusionDuration.USER_EXCLUSION_DURATION_UNSPECIFIED;
    case 1:
    case "USER_EXCLUSION_TEMPORARY":
      return UserExclusionDuration.USER_EXCLUSION_TEMPORARY;
    case 2:
    case "USER_EXCLUSION_PERMANENT":
      return UserExclusionDuration.USER_EXCLUSION_PERMANENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UserExclusionDuration.UNRECOGNIZED;
  }
}

export function userExclusionDurationToJSON(object: UserExclusionDuration): string {
  switch (object) {
    case UserExclusionDuration.USER_EXCLUSION_DURATION_UNSPECIFIED:
      return "USER_EXCLUSION_DURATION_UNSPECIFIED";
    case UserExclusionDuration.USER_EXCLUSION_TEMPORARY:
      return "USER_EXCLUSION_TEMPORARY";
    case UserExclusionDuration.USER_EXCLUSION_PERMANENT:
      return "USER_EXCLUSION_PERMANENT";
    case UserExclusionDuration.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Scoping specifies which events are considered when evaluating if a
 * session meets a criteria.
 */
export enum SessionCriteriaScoping {
  /** SESSION_CRITERIA_SCOPING_UNSPECIFIED - Unspecified criteria scoping. Do not specify. */
  SESSION_CRITERIA_SCOPING_UNSPECIFIED = 0,
  /**
   * SESSION_CRITERIA_WITHIN_SAME_EVENT - If the criteria is satisfied within one event, the session matches the
   * criteria.
   */
  SESSION_CRITERIA_WITHIN_SAME_EVENT = 1,
  /**
   * SESSION_CRITERIA_WITHIN_SAME_SESSION - If the criteria is satisfied within one session, the session matches
   * the criteria.
   */
  SESSION_CRITERIA_WITHIN_SAME_SESSION = 2,
  UNRECOGNIZED = -1,
}

export function sessionCriteriaScopingFromJSON(object: any): SessionCriteriaScoping {
  switch (object) {
    case 0:
    case "SESSION_CRITERIA_SCOPING_UNSPECIFIED":
      return SessionCriteriaScoping.SESSION_CRITERIA_SCOPING_UNSPECIFIED;
    case 1:
    case "SESSION_CRITERIA_WITHIN_SAME_EVENT":
      return SessionCriteriaScoping.SESSION_CRITERIA_WITHIN_SAME_EVENT;
    case 2:
    case "SESSION_CRITERIA_WITHIN_SAME_SESSION":
      return SessionCriteriaScoping.SESSION_CRITERIA_WITHIN_SAME_SESSION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SessionCriteriaScoping.UNRECOGNIZED;
  }
}

export function sessionCriteriaScopingToJSON(object: SessionCriteriaScoping): string {
  switch (object) {
    case SessionCriteriaScoping.SESSION_CRITERIA_SCOPING_UNSPECIFIED:
      return "SESSION_CRITERIA_SCOPING_UNSPECIFIED";
    case SessionCriteriaScoping.SESSION_CRITERIA_WITHIN_SAME_EVENT:
      return "SESSION_CRITERIA_WITHIN_SAME_EVENT";
    case SessionCriteriaScoping.SESSION_CRITERIA_WITHIN_SAME_SESSION:
      return "SESSION_CRITERIA_WITHIN_SAME_SESSION";
    case SessionCriteriaScoping.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Enumerates options for how long an exclusion will last if a session
 * matches the `sessionExclusionCriteria`.
 */
export enum SessionExclusionDuration {
  /** SESSION_EXCLUSION_DURATION_UNSPECIFIED - Unspecified exclusion duration. Do not specify. */
  SESSION_EXCLUSION_DURATION_UNSPECIFIED = 0,
  /**
   * SESSION_EXCLUSION_TEMPORARY - Temporarily exclude sessions from the segment during periods when the
   * session meets the `sessionExclusionCriteria` condition.
   */
  SESSION_EXCLUSION_TEMPORARY = 1,
  /**
   * SESSION_EXCLUSION_PERMANENT - Permanently exclude sessions from the segment if the session ever meets
   * the `sessionExclusionCriteria` condition.
   */
  SESSION_EXCLUSION_PERMANENT = 2,
  UNRECOGNIZED = -1,
}

export function sessionExclusionDurationFromJSON(object: any): SessionExclusionDuration {
  switch (object) {
    case 0:
    case "SESSION_EXCLUSION_DURATION_UNSPECIFIED":
      return SessionExclusionDuration.SESSION_EXCLUSION_DURATION_UNSPECIFIED;
    case 1:
    case "SESSION_EXCLUSION_TEMPORARY":
      return SessionExclusionDuration.SESSION_EXCLUSION_TEMPORARY;
    case 2:
    case "SESSION_EXCLUSION_PERMANENT":
      return SessionExclusionDuration.SESSION_EXCLUSION_PERMANENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SessionExclusionDuration.UNRECOGNIZED;
  }
}

export function sessionExclusionDurationToJSON(object: SessionExclusionDuration): string {
  switch (object) {
    case SessionExclusionDuration.SESSION_EXCLUSION_DURATION_UNSPECIFIED:
      return "SESSION_EXCLUSION_DURATION_UNSPECIFIED";
    case SessionExclusionDuration.SESSION_EXCLUSION_TEMPORARY:
      return "SESSION_EXCLUSION_TEMPORARY";
    case SessionExclusionDuration.SESSION_EXCLUSION_PERMANENT:
      return "SESSION_EXCLUSION_PERMANENT";
    case SessionExclusionDuration.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Scoping specifies which events are considered when evaluating if an event
 * meets a criteria.
 */
export enum EventCriteriaScoping {
  /** EVENT_CRITERIA_SCOPING_UNSPECIFIED - Unspecified criteria scoping. Do not specify. */
  EVENT_CRITERIA_SCOPING_UNSPECIFIED = 0,
  /**
   * EVENT_CRITERIA_WITHIN_SAME_EVENT - If the criteria is satisfied within one event, the event matches the
   * criteria.
   */
  EVENT_CRITERIA_WITHIN_SAME_EVENT = 1,
  UNRECOGNIZED = -1,
}

export function eventCriteriaScopingFromJSON(object: any): EventCriteriaScoping {
  switch (object) {
    case 0:
    case "EVENT_CRITERIA_SCOPING_UNSPECIFIED":
      return EventCriteriaScoping.EVENT_CRITERIA_SCOPING_UNSPECIFIED;
    case 1:
    case "EVENT_CRITERIA_WITHIN_SAME_EVENT":
      return EventCriteriaScoping.EVENT_CRITERIA_WITHIN_SAME_EVENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EventCriteriaScoping.UNRECOGNIZED;
  }
}

export function eventCriteriaScopingToJSON(object: EventCriteriaScoping): string {
  switch (object) {
    case EventCriteriaScoping.EVENT_CRITERIA_SCOPING_UNSPECIFIED:
      return "EVENT_CRITERIA_SCOPING_UNSPECIFIED";
    case EventCriteriaScoping.EVENT_CRITERIA_WITHIN_SAME_EVENT:
      return "EVENT_CRITERIA_WITHIN_SAME_EVENT";
    case EventCriteriaScoping.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Enumerates options for how long an exclusion will last if an event
 * matches the `eventExclusionCriteria`.
 */
export enum EventExclusionDuration {
  /** EVENT_EXCLUSION_DURATION_UNSPECIFIED - Unspecified exclusion duration. Do not specify. */
  EVENT_EXCLUSION_DURATION_UNSPECIFIED = 0,
  /**
   * EVENT_EXCLUSION_PERMANENT - Permanently exclude events from the segment if the event ever meets
   * the `eventExclusionCriteria` condition.
   */
  EVENT_EXCLUSION_PERMANENT = 1,
  UNRECOGNIZED = -1,
}

export function eventExclusionDurationFromJSON(object: any): EventExclusionDuration {
  switch (object) {
    case 0:
    case "EVENT_EXCLUSION_DURATION_UNSPECIFIED":
      return EventExclusionDuration.EVENT_EXCLUSION_DURATION_UNSPECIFIED;
    case 1:
    case "EVENT_EXCLUSION_PERMANENT":
      return EventExclusionDuration.EVENT_EXCLUSION_PERMANENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EventExclusionDuration.UNRECOGNIZED;
  }
}

export function eventExclusionDurationToJSON(object: EventExclusionDuration): string {
  switch (object) {
    case EventExclusionDuration.EVENT_EXCLUSION_DURATION_UNSPECIFIED:
      return "EVENT_EXCLUSION_DURATION_UNSPECIFIED";
    case EventExclusionDuration.EVENT_EXCLUSION_PERMANENT:
      return "EVENT_EXCLUSION_PERMANENT";
    case EventExclusionDuration.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Represents aggregation of metrics. */
export enum MetricAggregation {
  /** METRIC_AGGREGATION_UNSPECIFIED - Unspecified operator. */
  METRIC_AGGREGATION_UNSPECIFIED = 0,
  /** TOTAL - SUM operator. */
  TOTAL = 1,
  /** MINIMUM - Minimum operator. */
  MINIMUM = 5,
  /** MAXIMUM - Maximum operator. */
  MAXIMUM = 6,
  /** COUNT - Count operator. */
  COUNT = 4,
  UNRECOGNIZED = -1,
}

export function metricAggregationFromJSON(object: any): MetricAggregation {
  switch (object) {
    case 0:
    case "METRIC_AGGREGATION_UNSPECIFIED":
      return MetricAggregation.METRIC_AGGREGATION_UNSPECIFIED;
    case 1:
    case "TOTAL":
      return MetricAggregation.TOTAL;
    case 5:
    case "MINIMUM":
      return MetricAggregation.MINIMUM;
    case 6:
    case "MAXIMUM":
      return MetricAggregation.MAXIMUM;
    case 4:
    case "COUNT":
      return MetricAggregation.COUNT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MetricAggregation.UNRECOGNIZED;
  }
}

export function metricAggregationToJSON(object: MetricAggregation): string {
  switch (object) {
    case MetricAggregation.METRIC_AGGREGATION_UNSPECIFIED:
      return "METRIC_AGGREGATION_UNSPECIFIED";
    case MetricAggregation.TOTAL:
      return "TOTAL";
    case MetricAggregation.MINIMUM:
      return "MINIMUM";
    case MetricAggregation.MAXIMUM:
      return "MAXIMUM";
    case MetricAggregation.COUNT:
      return "COUNT";
    case MetricAggregation.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A metric's value type. */
export enum MetricType {
  /** METRIC_TYPE_UNSPECIFIED - Unspecified type. */
  METRIC_TYPE_UNSPECIFIED = 0,
  /** TYPE_INTEGER - Integer type. */
  TYPE_INTEGER = 1,
  /** TYPE_FLOAT - Floating point type. */
  TYPE_FLOAT = 2,
  /** TYPE_SECONDS - A duration of seconds; a special floating point type. */
  TYPE_SECONDS = 4,
  /** TYPE_MILLISECONDS - A duration in milliseconds; a special floating point type. */
  TYPE_MILLISECONDS = 5,
  /** TYPE_MINUTES - A duration in minutes; a special floating point type. */
  TYPE_MINUTES = 6,
  /** TYPE_HOURS - A duration in hours; a special floating point type. */
  TYPE_HOURS = 7,
  /** TYPE_STANDARD - A custom metric of standard type; a special floating point type. */
  TYPE_STANDARD = 8,
  /** TYPE_CURRENCY - An amount of money; a special floating point type. */
  TYPE_CURRENCY = 9,
  /** TYPE_FEET - A length in feet; a special floating point type. */
  TYPE_FEET = 10,
  /** TYPE_MILES - A length in miles; a special floating point type. */
  TYPE_MILES = 11,
  /** TYPE_METERS - A length in meters; a special floating point type. */
  TYPE_METERS = 12,
  /** TYPE_KILOMETERS - A length in kilometers; a special floating point type. */
  TYPE_KILOMETERS = 13,
  UNRECOGNIZED = -1,
}

export function metricTypeFromJSON(object: any): MetricType {
  switch (object) {
    case 0:
    case "METRIC_TYPE_UNSPECIFIED":
      return MetricType.METRIC_TYPE_UNSPECIFIED;
    case 1:
    case "TYPE_INTEGER":
      return MetricType.TYPE_INTEGER;
    case 2:
    case "TYPE_FLOAT":
      return MetricType.TYPE_FLOAT;
    case 4:
    case "TYPE_SECONDS":
      return MetricType.TYPE_SECONDS;
    case 5:
    case "TYPE_MILLISECONDS":
      return MetricType.TYPE_MILLISECONDS;
    case 6:
    case "TYPE_MINUTES":
      return MetricType.TYPE_MINUTES;
    case 7:
    case "TYPE_HOURS":
      return MetricType.TYPE_HOURS;
    case 8:
    case "TYPE_STANDARD":
      return MetricType.TYPE_STANDARD;
    case 9:
    case "TYPE_CURRENCY":
      return MetricType.TYPE_CURRENCY;
    case 10:
    case "TYPE_FEET":
      return MetricType.TYPE_FEET;
    case 11:
    case "TYPE_MILES":
      return MetricType.TYPE_MILES;
    case 12:
    case "TYPE_METERS":
      return MetricType.TYPE_METERS;
    case 13:
    case "TYPE_KILOMETERS":
      return MetricType.TYPE_KILOMETERS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MetricType.UNRECOGNIZED;
  }
}

export function metricTypeToJSON(object: MetricType): string {
  switch (object) {
    case MetricType.METRIC_TYPE_UNSPECIFIED:
      return "METRIC_TYPE_UNSPECIFIED";
    case MetricType.TYPE_INTEGER:
      return "TYPE_INTEGER";
    case MetricType.TYPE_FLOAT:
      return "TYPE_FLOAT";
    case MetricType.TYPE_SECONDS:
      return "TYPE_SECONDS";
    case MetricType.TYPE_MILLISECONDS:
      return "TYPE_MILLISECONDS";
    case MetricType.TYPE_MINUTES:
      return "TYPE_MINUTES";
    case MetricType.TYPE_HOURS:
      return "TYPE_HOURS";
    case MetricType.TYPE_STANDARD:
      return "TYPE_STANDARD";
    case MetricType.TYPE_CURRENCY:
      return "TYPE_CURRENCY";
    case MetricType.TYPE_FEET:
      return "TYPE_FEET";
    case MetricType.TYPE_MILES:
      return "TYPE_MILES";
    case MetricType.TYPE_METERS:
      return "TYPE_METERS";
    case MetricType.TYPE_KILOMETERS:
      return "TYPE_KILOMETERS";
    case MetricType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Categories of data that you may be restricted from viewing on certain
 * Google Analytics properties.
 */
export enum RestrictedMetricType {
  /** RESTRICTED_METRIC_TYPE_UNSPECIFIED - Unspecified type. */
  RESTRICTED_METRIC_TYPE_UNSPECIFIED = 0,
  /** COST_DATA - Cost metrics such as `adCost`. */
  COST_DATA = 1,
  /** REVENUE_DATA - Revenue metrics such as `purchaseRevenue`. */
  REVENUE_DATA = 2,
  UNRECOGNIZED = -1,
}

export function restrictedMetricTypeFromJSON(object: any): RestrictedMetricType {
  switch (object) {
    case 0:
    case "RESTRICTED_METRIC_TYPE_UNSPECIFIED":
      return RestrictedMetricType.RESTRICTED_METRIC_TYPE_UNSPECIFIED;
    case 1:
    case "COST_DATA":
      return RestrictedMetricType.COST_DATA;
    case 2:
    case "REVENUE_DATA":
      return RestrictedMetricType.REVENUE_DATA;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RestrictedMetricType.UNRECOGNIZED;
  }
}

export function restrictedMetricTypeToJSON(object: RestrictedMetricType): string {
  switch (object) {
    case RestrictedMetricType.RESTRICTED_METRIC_TYPE_UNSPECIFIED:
      return "RESTRICTED_METRIC_TYPE_UNSPECIFIED";
    case RestrictedMetricType.COST_DATA:
      return "COST_DATA";
    case RestrictedMetricType.REVENUE_DATA:
      return "REVENUE_DATA";
    case RestrictedMetricType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A contiguous set of days: `startDate`, `startDate + 1`, ..., `endDate`.
 * Requests are allowed up to 4 date ranges.
 */
export interface DateRange {
  /**
   * The inclusive start date for the query in the format `YYYY-MM-DD`. Cannot
   * be after `end_date`. The format `NdaysAgo`, `yesterday`, or `today` is also
   * accepted, and in that case, the date is inferred based on the property's
   * reporting time zone.
   */
  startDate: string;
  /**
   * The inclusive end date for the query in the format `YYYY-MM-DD`. Cannot
   * be before `start_date`. The format `NdaysAgo`, `yesterday`, or `today` is
   * also accepted, and in that case, the date is inferred based on the
   * property's reporting time zone.
   */
  endDate: string;
  /**
   * Assigns a name to this date range. The dimension `dateRange` is valued to
   * this name in a report response. If set, cannot begin with `date_range_` or
   * `RESERVED_`. If not set, date ranges are named by their zero based index in
   * the request: `date_range_0`, `date_range_1`, etc.
   */
  name: string;
}

/**
 * Dimensions are attributes of your data. For example, the dimension city
 * indicates the city from which an event originates. Dimension values in report
 * responses are strings; for example, the city could be "Paris" or "New York".
 */
export interface Dimension {
  /**
   * The name of the dimension. See the [API
   * Dimensions](https://developers.google.com/analytics/devguides/reporting/data/v1/api-schema#dimensions)
   * for the list of dimension names supported by core reporting methods such
   * as `runReport` and `batchRunReports`. See
   * [Realtime
   * Dimensions](https://developers.google.com/analytics/devguides/reporting/data/v1/realtime-api-schema#dimensions)
   * for the list of dimension names supported by the `runRealtimeReport`
   * method. See
   * [Funnel
   * Dimensions](https://developers.google.com/analytics/devguides/reporting/data/v1/exploration-api-schema#dimensions)
   * for the list of dimension names supported by the `runFunnelReport`
   * method.
   *
   * If `dimensionExpression` is specified, `name` can be any string that you
   * would like within the allowed character set. For example if a
   * `dimensionExpression` concatenates `country` and `city`, you could call
   * that dimension `countryAndCity`. Dimension names that you choose must match
   * the regular expression `^[a-zA-Z0-9_]$`.
   *
   * Dimensions are referenced by `name` in `dimensionFilter`, `orderBys`,
   * `dimensionExpression`, and `pivots`.
   */
  name: string;
  /**
   * One dimension can be the result of an expression of multiple dimensions.
   * For example, dimension "country, city": concatenate(country, ", ", city).
   */
  dimensionExpression: DimensionExpression | undefined;
}

/**
 * Used to express a dimension which is the result of a formula of multiple
 * dimensions. Example usages:
 * 1) lower_case(dimension)
 * 2) concatenate(dimension1, symbol, dimension2).
 */
export interface DimensionExpression {
  /** Used to convert a dimension value to lower case. */
  lowerCase?:
    | DimensionExpression_CaseExpression
    | undefined;
  /** Used to convert a dimension value to upper case. */
  upperCase?:
    | DimensionExpression_CaseExpression
    | undefined;
  /**
   * Used to combine dimension values to a single dimension.
   * For example, dimension "country, city": concatenate(country, ", ", city).
   */
  concatenate?: DimensionExpression_ConcatenateExpression | undefined;
}

/** Used to convert a dimension value to a single case. */
export interface DimensionExpression_CaseExpression {
  /**
   * Name of a dimension. The name must refer back to a name in dimensions
   * field of the request.
   */
  dimensionName: string;
}

/** Used to combine dimension values to a single dimension. */
export interface DimensionExpression_ConcatenateExpression {
  /**
   * Names of dimensions. The names must refer back to names in the dimensions
   * field of the request.
   */
  dimensionNames: string[];
  /**
   * The delimiter placed between dimension names.
   *
   * Delimiters are often single characters such as "|" or "," but can be
   * longer strings. If a dimension value contains the delimiter, both will be
   * present in response with no distinction. For example if dimension 1 value
   * = "US,FR", dimension 2 value = "JP", and delimiter = ",", then the
   * response will contain "US,FR,JP".
   */
  delimiter: string;
}

/**
 * The quantitative measurements of a report. For example, the metric
 * `eventCount` is the total number of events. Requests are allowed up to 10
 * metrics.
 */
export interface Metric {
  /**
   * The name of the metric. See the [API
   * Metrics](https://developers.google.com/analytics/devguides/reporting/data/v1/api-schema#metrics)
   * for the list of metric names supported by core reporting methods such
   * as `runReport` and `batchRunReports`. See
   * [Realtime
   * Metrics](https://developers.google.com/analytics/devguides/reporting/data/v1/realtime-api-schema#metrics)
   * for the list of metric names supported by the `runRealtimeReport`
   * method. See
   * [Funnel
   * Metrics](https://developers.google.com/analytics/devguides/reporting/data/v1/exploration-api-schema#metrics)
   * for the list of metric names supported by the `runFunnelReport`
   * method.
   *
   * If `expression` is specified, `name` can be any string that you would like
   * within the allowed character set. For example if `expression` is
   * `screenPageViews/sessions`, you could call that metric's name =
   * `viewsPerSession`. Metric names that you choose must match the regular
   * expression `^[a-zA-Z0-9_]$`.
   *
   * Metrics are referenced by `name` in `metricFilter`, `orderBys`, and metric
   * `expression`.
   */
  name: string;
  /**
   * A mathematical expression for derived metrics. For example, the metric
   * Event count per user is `eventCount/totalUsers`.
   */
  expression: string;
  /**
   * Indicates if a metric is invisible in the report response. If a metric is
   * invisible, the metric will not produce a column in the response, but can be
   * used in `metricFilter`, `orderBys`, or a metric `expression`.
   */
  invisible: boolean;
}

/**
 * To express dimension or metric filters. The fields in the same
 * FilterExpression need to be either all dimensions or all metrics.
 */
export interface FilterExpression {
  /** The FilterExpressions in and_group have an AND relationship. */
  andGroup?:
    | FilterExpressionList
    | undefined;
  /** The FilterExpressions in or_group have an OR relationship. */
  orGroup?:
    | FilterExpressionList
    | undefined;
  /** The FilterExpression is NOT of not_expression. */
  notExpression?:
    | FilterExpression
    | undefined;
  /**
   * A primitive filter. In the same FilterExpression, all of the filter's
   * field names need to be either all dimensions or all metrics.
   */
  filter?: Filter | undefined;
}

/** A list of filter expressions. */
export interface FilterExpressionList {
  /** A list of filter expressions. */
  expressions: FilterExpression[];
}

/** An expression to filter dimension or metric values. */
export interface Filter {
  /**
   * The dimension name or metric name. Must be a name defined in dimensions
   * or metrics.
   */
  fieldName: string;
  /** Strings related filter. */
  stringFilter?:
    | StringFilter
    | undefined;
  /** A filter for in list values. */
  inListFilter?:
    | InListFilter
    | undefined;
  /** A filter for numeric or date values. */
  numericFilter?:
    | NumericFilter
    | undefined;
  /** A filter for between two values. */
  betweenFilter?: BetweenFilter | undefined;
}

/** The filter for string */
export interface StringFilter {
  /** The match type for this filter. */
  matchType: StringFilter_MatchType;
  /** The string value used for the matching. */
  value: string;
  /** If true, the string value is case sensitive. */
  caseSensitive: boolean;
}

/** The match type of a string filter */
export enum StringFilter_MatchType {
  /** MATCH_TYPE_UNSPECIFIED - Unspecified */
  MATCH_TYPE_UNSPECIFIED = 0,
  /** EXACT - Exact match of the string value. */
  EXACT = 1,
  /** BEGINS_WITH - Begins with the string value. */
  BEGINS_WITH = 2,
  /** ENDS_WITH - Ends with the string value. */
  ENDS_WITH = 3,
  /** CONTAINS - Contains the string value. */
  CONTAINS = 4,
  /** FULL_REGEXP - Full match for the regular expression with the string value. */
  FULL_REGEXP = 5,
  /** PARTIAL_REGEXP - Partial match for the regular expression with the string value. */
  PARTIAL_REGEXP = 6,
  UNRECOGNIZED = -1,
}

export function stringFilter_MatchTypeFromJSON(object: any): StringFilter_MatchType {
  switch (object) {
    case 0:
    case "MATCH_TYPE_UNSPECIFIED":
      return StringFilter_MatchType.MATCH_TYPE_UNSPECIFIED;
    case 1:
    case "EXACT":
      return StringFilter_MatchType.EXACT;
    case 2:
    case "BEGINS_WITH":
      return StringFilter_MatchType.BEGINS_WITH;
    case 3:
    case "ENDS_WITH":
      return StringFilter_MatchType.ENDS_WITH;
    case 4:
    case "CONTAINS":
      return StringFilter_MatchType.CONTAINS;
    case 5:
    case "FULL_REGEXP":
      return StringFilter_MatchType.FULL_REGEXP;
    case 6:
    case "PARTIAL_REGEXP":
      return StringFilter_MatchType.PARTIAL_REGEXP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StringFilter_MatchType.UNRECOGNIZED;
  }
}

export function stringFilter_MatchTypeToJSON(object: StringFilter_MatchType): string {
  switch (object) {
    case StringFilter_MatchType.MATCH_TYPE_UNSPECIFIED:
      return "MATCH_TYPE_UNSPECIFIED";
    case StringFilter_MatchType.EXACT:
      return "EXACT";
    case StringFilter_MatchType.BEGINS_WITH:
      return "BEGINS_WITH";
    case StringFilter_MatchType.ENDS_WITH:
      return "ENDS_WITH";
    case StringFilter_MatchType.CONTAINS:
      return "CONTAINS";
    case StringFilter_MatchType.FULL_REGEXP:
      return "FULL_REGEXP";
    case StringFilter_MatchType.PARTIAL_REGEXP:
      return "PARTIAL_REGEXP";
    case StringFilter_MatchType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The result needs to be in a list of string values. */
export interface InListFilter {
  /**
   * The list of string values.
   * Must be non-empty.
   */
  values: string[];
  /** If true, the string value is case sensitive. */
  caseSensitive: boolean;
}

/** Filters for numeric or date values. */
export interface NumericFilter {
  /** The operation type for this filter. */
  operation: NumericFilter_Operation;
  /** A numeric value or a date value. */
  value: NumericValue | undefined;
}

/** The operation applied to a numeric filter */
export enum NumericFilter_Operation {
  /** OPERATION_UNSPECIFIED - Unspecified. */
  OPERATION_UNSPECIFIED = 0,
  /** EQUAL - Equal */
  EQUAL = 1,
  /** LESS_THAN - Less than */
  LESS_THAN = 2,
  /** LESS_THAN_OR_EQUAL - Less than or equal */
  LESS_THAN_OR_EQUAL = 3,
  /** GREATER_THAN - Greater than */
  GREATER_THAN = 4,
  /** GREATER_THAN_OR_EQUAL - Greater than or equal */
  GREATER_THAN_OR_EQUAL = 5,
  UNRECOGNIZED = -1,
}

export function numericFilter_OperationFromJSON(object: any): NumericFilter_Operation {
  switch (object) {
    case 0:
    case "OPERATION_UNSPECIFIED":
      return NumericFilter_Operation.OPERATION_UNSPECIFIED;
    case 1:
    case "EQUAL":
      return NumericFilter_Operation.EQUAL;
    case 2:
    case "LESS_THAN":
      return NumericFilter_Operation.LESS_THAN;
    case 3:
    case "LESS_THAN_OR_EQUAL":
      return NumericFilter_Operation.LESS_THAN_OR_EQUAL;
    case 4:
    case "GREATER_THAN":
      return NumericFilter_Operation.GREATER_THAN;
    case 5:
    case "GREATER_THAN_OR_EQUAL":
      return NumericFilter_Operation.GREATER_THAN_OR_EQUAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NumericFilter_Operation.UNRECOGNIZED;
  }
}

export function numericFilter_OperationToJSON(object: NumericFilter_Operation): string {
  switch (object) {
    case NumericFilter_Operation.OPERATION_UNSPECIFIED:
      return "OPERATION_UNSPECIFIED";
    case NumericFilter_Operation.EQUAL:
      return "EQUAL";
    case NumericFilter_Operation.LESS_THAN:
      return "LESS_THAN";
    case NumericFilter_Operation.LESS_THAN_OR_EQUAL:
      return "LESS_THAN_OR_EQUAL";
    case NumericFilter_Operation.GREATER_THAN:
      return "GREATER_THAN";
    case NumericFilter_Operation.GREATER_THAN_OR_EQUAL:
      return "GREATER_THAN_OR_EQUAL";
    case NumericFilter_Operation.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Order bys define how rows will be sorted in the response. For example,
 * ordering rows by descending event count is one ordering, and ordering rows by
 * the event name string is a different ordering.
 */
export interface OrderBy {
  /** Sorts results by a metric's values. */
  metric?:
    | OrderBy_MetricOrderBy
    | undefined;
  /** Sorts results by a dimension's values. */
  dimension?:
    | OrderBy_DimensionOrderBy
    | undefined;
  /** If true, sorts by descending order. */
  desc: boolean;
}

/** Sorts by metric values. */
export interface OrderBy_MetricOrderBy {
  /** A metric name in the request to order by. */
  metricName: string;
}

/** Sorts by dimension values. */
export interface OrderBy_DimensionOrderBy {
  /** A dimension name in the request to order by. */
  dimensionName: string;
  /** Controls the rule for dimension value ordering. */
  orderType: OrderBy_DimensionOrderBy_OrderType;
}

/** Rule to order the string dimension values by. */
export enum OrderBy_DimensionOrderBy_OrderType {
  /** ORDER_TYPE_UNSPECIFIED - Unspecified. */
  ORDER_TYPE_UNSPECIFIED = 0,
  /**
   * ALPHANUMERIC - Alphanumeric sort by Unicode code point. For example, "2" < "A" < "X" <
   * "b" < "z".
   */
  ALPHANUMERIC = 1,
  /**
   * CASE_INSENSITIVE_ALPHANUMERIC - Case insensitive alphanumeric sort by lower case Unicode code point.
   * For example, "2" < "A" < "b" < "X" < "z".
   */
  CASE_INSENSITIVE_ALPHANUMERIC = 2,
  /**
   * NUMERIC - Dimension values are converted to numbers before sorting. For example
   * in NUMERIC sort, "25" < "100", and in `ALPHANUMERIC` sort, "100" <
   * "25". Non-numeric dimension values all have equal ordering value below
   * all numeric values.
   */
  NUMERIC = 3,
  UNRECOGNIZED = -1,
}

export function orderBy_DimensionOrderBy_OrderTypeFromJSON(object: any): OrderBy_DimensionOrderBy_OrderType {
  switch (object) {
    case 0:
    case "ORDER_TYPE_UNSPECIFIED":
      return OrderBy_DimensionOrderBy_OrderType.ORDER_TYPE_UNSPECIFIED;
    case 1:
    case "ALPHANUMERIC":
      return OrderBy_DimensionOrderBy_OrderType.ALPHANUMERIC;
    case 2:
    case "CASE_INSENSITIVE_ALPHANUMERIC":
      return OrderBy_DimensionOrderBy_OrderType.CASE_INSENSITIVE_ALPHANUMERIC;
    case 3:
    case "NUMERIC":
      return OrderBy_DimensionOrderBy_OrderType.NUMERIC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OrderBy_DimensionOrderBy_OrderType.UNRECOGNIZED;
  }
}

export function orderBy_DimensionOrderBy_OrderTypeToJSON(object: OrderBy_DimensionOrderBy_OrderType): string {
  switch (object) {
    case OrderBy_DimensionOrderBy_OrderType.ORDER_TYPE_UNSPECIFIED:
      return "ORDER_TYPE_UNSPECIFIED";
    case OrderBy_DimensionOrderBy_OrderType.ALPHANUMERIC:
      return "ALPHANUMERIC";
    case OrderBy_DimensionOrderBy_OrderType.CASE_INSENSITIVE_ALPHANUMERIC:
      return "CASE_INSENSITIVE_ALPHANUMERIC";
    case OrderBy_DimensionOrderBy_OrderType.NUMERIC:
      return "NUMERIC";
    case OrderBy_DimensionOrderBy_OrderType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** To express that the result needs to be between two numbers (inclusive). */
export interface BetweenFilter {
  /** Begins with this number. */
  fromValue:
    | NumericValue
    | undefined;
  /** Ends with this number. */
  toValue: NumericValue | undefined;
}

/** To represent a number. */
export interface NumericValue {
  /** Integer value */
  int64Value?:
    | Long
    | undefined;
  /** Double value */
  doubleValue?: number | undefined;
}

/**
 * The specification of cohorts for a cohort report.
 *
 * Cohort reports create a time series of user retention for the cohort. For
 * example, you could select the cohort of users that were acquired in the first
 * week of September and follow that cohort for the next six weeks. Selecting
 * the users acquired in the first week of September cohort is specified in the
 * `cohort` object. Following that cohort for the next six weeks is specified in
 * the `cohortsRange` object.
 *
 * For examples, see [Cohort Report
 * Examples](https://developers.google.com/analytics/devguides/reporting/data/v1/advanced#cohort_report_examples).
 *
 * The report response could show a weekly time series where say your app has
 * retained 60% of this cohort after three weeks and 25% of this cohort after
 * six weeks. These two percentages can be calculated by the metric
 * `cohortActiveUsers/cohortTotalUsers` and will be separate rows in the report.
 */
export interface CohortSpec {
  /**
   * Defines the selection criteria to group users into cohorts.
   *
   * Most cohort reports define only a single cohort. If multiple cohorts are
   * specified, each cohort can be recognized in the report by their name.
   */
  cohorts: Cohort[];
  /**
   * Cohort reports follow cohorts over an extended reporting date range. This
   * range specifies an offset duration to follow the cohorts over.
   */
  cohortsRange:
    | CohortsRange
    | undefined;
  /** Optional settings for a cohort report. */
  cohortReportSettings: CohortReportSettings | undefined;
}

/**
 * Defines a cohort selection criteria. A cohort is a group of users who share
 * a common characteristic. For example, users with the same `firstSessionDate`
 * belong to the same cohort.
 */
export interface Cohort {
  /**
   * Assigns a name to this cohort. The dimension `cohort` is valued to this
   * name in a report response. If set, cannot begin with `cohort_` or
   * `RESERVED_`. If not set, cohorts are named by their zero based index
   * `cohort_0`, `cohort_1`, etc.
   */
  name: string;
  /**
   * Dimension used by the cohort. Required and only supports
   * `firstSessionDate`.
   */
  dimension: string;
  /**
   * The cohort selects users whose first touch date is between start date and
   * end date defined in the `dateRange`. This `dateRange` does not specify the
   * full date range of event data that is present in a cohort report. In a
   * cohort report, this `dateRange` is extended by the granularity and offset
   * present in the `cohortsRange`; event data for the extended reporting date
   * range is present in a cohort report.
   *
   * In a cohort request, this `dateRange` is required and the `dateRanges` in
   * the `RunReportRequest` or `RunPivotReportRequest` must be unspecified.
   *
   * This `dateRange` should generally be aligned with the cohort's granularity.
   * If `CohortsRange` uses daily granularity, this `dateRange` can be a single
   * day. If `CohortsRange` uses weekly granularity, this `dateRange` can be
   * aligned to a week boundary, starting at Sunday and ending Saturday. If
   * `CohortsRange` uses monthly granularity, this `dateRange` can be aligned to
   * a month, starting at the first and ending on the last day of the month.
   */
  dateRange: DateRange | undefined;
}

/**
 * Configures the extended reporting date range for a cohort report. Specifies
 * an offset duration to follow the cohorts over.
 */
export interface CohortsRange {
  /**
   * Required. The granularity used to interpret the `startOffset` and
   * `endOffset` for the extended reporting date range for a cohort report.
   */
  granularity: CohortsRange_Granularity;
  /**
   * `startOffset` specifies the start date of the extended reporting date range
   * for a cohort report. `startOffset` is commonly set to 0 so that reports
   * contain data from the acquisition of the cohort forward.
   *
   * If `granularity` is `DAILY`, the `startDate` of the extended reporting date
   * range is `startDate` of the cohort plus `startOffset` days.
   *
   * If `granularity` is `WEEKLY`, the `startDate` of the extended reporting
   * date range is `startDate` of the cohort plus `startOffset * 7` days.
   *
   * If `granularity` is `MONTHLY`, the `startDate` of the extended reporting
   * date range is `startDate` of the cohort plus `startOffset * 30` days.
   */
  startOffset: number;
  /**
   * Required. `endOffset` specifies the end date of the extended reporting date
   * range for a cohort report. `endOffset` can be any positive integer but is
   * commonly set to 5 to 10 so that reports contain data on the cohort for the
   * next several granularity time periods.
   *
   * If `granularity` is `DAILY`, the `endDate` of the extended reporting date
   * range is `endDate` of the cohort plus `endOffset` days.
   *
   * If `granularity` is `WEEKLY`, the `endDate` of the extended reporting date
   * range is `endDate` of the cohort plus `endOffset * 7` days.
   *
   * If `granularity` is `MONTHLY`, the `endDate` of the extended reporting date
   * range is `endDate` of the cohort plus `endOffset * 30` days.
   */
  endOffset: number;
}

/**
 * The granularity used to interpret the `startOffset` and `endOffset` for the
 * extended reporting date range for a cohort report.
 */
export enum CohortsRange_Granularity {
  /** GRANULARITY_UNSPECIFIED - Should never be specified. */
  GRANULARITY_UNSPECIFIED = 0,
  /**
   * DAILY - Daily granularity. Commonly used if the cohort's `dateRange` is a single
   * day and the request contains `cohortNthDay`.
   */
  DAILY = 1,
  /**
   * WEEKLY - Weekly granularity. Commonly used if the cohort's `dateRange` is a week
   * in duration (starting on Sunday and ending on Saturday) and the request
   * contains `cohortNthWeek`.
   */
  WEEKLY = 2,
  /**
   * MONTHLY - Monthly granularity. Commonly used if the cohort's `dateRange` is a month
   * in duration and the request contains `cohortNthMonth`.
   */
  MONTHLY = 3,
  UNRECOGNIZED = -1,
}

export function cohortsRange_GranularityFromJSON(object: any): CohortsRange_Granularity {
  switch (object) {
    case 0:
    case "GRANULARITY_UNSPECIFIED":
      return CohortsRange_Granularity.GRANULARITY_UNSPECIFIED;
    case 1:
    case "DAILY":
      return CohortsRange_Granularity.DAILY;
    case 2:
    case "WEEKLY":
      return CohortsRange_Granularity.WEEKLY;
    case 3:
    case "MONTHLY":
      return CohortsRange_Granularity.MONTHLY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CohortsRange_Granularity.UNRECOGNIZED;
  }
}

export function cohortsRange_GranularityToJSON(object: CohortsRange_Granularity): string {
  switch (object) {
    case CohortsRange_Granularity.GRANULARITY_UNSPECIFIED:
      return "GRANULARITY_UNSPECIFIED";
    case CohortsRange_Granularity.DAILY:
      return "DAILY";
    case CohortsRange_Granularity.WEEKLY:
      return "WEEKLY";
    case CohortsRange_Granularity.MONTHLY:
      return "MONTHLY";
    case CohortsRange_Granularity.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Optional settings of a cohort report. */
export interface CohortReportSettings {
  /**
   * If true, accumulates the result from first touch day to the end day. Not
   * supported in `RunReportRequest`.
   */
  accumulate: boolean;
}

/** Response's metadata carrying additional information about the report content. */
export interface ResponseMetaData {
  /**
   * If true, indicates some buckets of dimension combinations are rolled into
   * "(other)" row. This can happen for high cardinality reports.
   *
   * The metadata parameter dataLossFromOtherRow is populated based on the
   * aggregated data table used in the report. The parameter will be accurately
   * populated regardless of the filters and limits in the report.
   *
   * For example, the (other) row could be dropped from the report because the
   * request contains a filter on sessionSource = google. This parameter will
   * still be populated if data loss from other row was present in the input
   * aggregate data used to generate this report.
   *
   * To learn more, see [About the (other) row and data
   * sampling](https://support.google.com/analytics/answer/13208658#reports).
   */
  dataLossFromOtherRow: boolean;
  /**
   * Describes the schema restrictions actively enforced in creating this
   * report. To learn more, see [Access and data-restriction
   * management](https://support.google.com/analytics/answer/10851388).
   */
  schemaRestrictionResponse?:
    | ResponseMetaData_SchemaRestrictionResponse
    | undefined;
  /**
   * The currency code used in this report. Intended to be used in formatting
   * currency metrics like `purchaseRevenue` for visualization. If currency_code
   * was specified in the request, this response parameter will echo the request
   * parameter; otherwise, this response parameter is the property's current
   * currency_code.
   *
   * Currency codes are string encodings of currency types from the ISO 4217
   * standard (https://en.wikipedia.org/wiki/ISO_4217); for example "USD",
   * "EUR", "JPY". To learn more, see
   * https://support.google.com/analytics/answer/9796179.
   */
  currencyCode?:
    | string
    | undefined;
  /**
   * The property's current timezone. Intended to be used to interpret
   * time-based dimensions like `hour` and `minute`. Formatted as strings from
   * the IANA Time Zone database (https://www.iana.org/time-zones); for example
   * "America/New_York" or "Asia/Tokyo".
   */
  timeZone?:
    | string
    | undefined;
  /** If empty reason is specified, the report is empty for this reason. */
  emptyReason?:
    | string
    | undefined;
  /**
   * If `subjectToThresholding` is true, this report is subject to thresholding
   * and only returns data that meets the minimum aggregation thresholds. It is
   * possible for a request to be subject to thresholding thresholding and no
   * data is absent from the report, and this happens when all data is above the
   * thresholds. To learn more, see [Data
   * thresholds](https://support.google.com/analytics/answer/9383630) and [About
   * Demographics and
   * Interests](https://support.google.com/analytics/answer/2799357).
   */
  subjectToThresholding?: boolean | undefined;
}

/**
 * The schema restrictions actively enforced in creating this report. To learn
 * more, see [Access and data-restriction
 * management](https://support.google.com/analytics/answer/10851388).
 */
export interface ResponseMetaData_SchemaRestrictionResponse {
  /**
   * All restrictions actively enforced in creating the report. For example,
   * `purchaseRevenue` always has the restriction type `REVENUE_DATA`.
   * However, this active response restriction is only populated if the user's
   * custom role disallows access to `REVENUE_DATA`.
   */
  activeMetricRestrictions: ResponseMetaData_SchemaRestrictionResponse_ActiveMetricRestriction[];
}

/** A metric actively restricted in creating the report. */
export interface ResponseMetaData_SchemaRestrictionResponse_ActiveMetricRestriction {
  /** The name of the restricted metric. */
  metricName?:
    | string
    | undefined;
  /** The reason for this metric's restriction. */
  restrictedMetricTypes: RestrictedMetricType[];
}

/**
 * Describes a dimension column in the report. Dimensions requested in a report
 * produce column entries within rows and DimensionHeaders. However, dimensions
 * used exclusively within filters or expressions do not produce columns in a
 * report; correspondingly, those dimensions do not produce headers.
 */
export interface DimensionHeader {
  /** The dimension's name. */
  name: string;
}

/**
 * Describes a metric column in the report. Visible metrics requested in a
 * report produce column entries within rows and MetricHeaders. However,
 * metrics used exclusively within filters or expressions do not produce columns
 * in a report; correspondingly, those metrics do not produce headers.
 */
export interface MetricHeader {
  /** The metric's name. */
  name: string;
  /** The metric's data type. */
  type: MetricType;
}

/**
 * Report data for each row.
 * For example if RunReportRequest contains:
 *
 * ```none
 * "dimensions": [
 *   {
 *     "name": "eventName"
 *   },
 *   {
 *     "name": "countryId"
 *   }
 * ],
 * "metrics": [
 *   {
 *     "name": "eventCount"
 *   }
 * ]
 * ```
 *
 * One row with 'in_app_purchase' as the eventName, 'JP' as the countryId, and
 * 15 as the eventCount, would be:
 *
 * ```none
 * "dimensionValues": [
 *   {
 *     "value": "in_app_purchase"
 *   },
 *   {
 *     "value": "JP"
 *   }
 * ],
 * "metricValues": [
 *   {
 *     "value": "15"
 *   }
 * ]
 * ```
 */
export interface Row {
  /**
   * List of requested dimension values. In a PivotReport, dimension_values
   * are only listed for dimensions included in a pivot.
   */
  dimensionValues: DimensionValue[];
  /** List of requested visible metric values. */
  metricValues: MetricValue[];
}

/** The value of a dimension. */
export interface DimensionValue {
  /** Value as a string if the dimension type is a string. */
  value?: string | undefined;
}

/** The value of a metric. */
export interface MetricValue {
  /** Measurement value. See MetricHeader for type. */
  value?: string | undefined;
}

/**
 * Current state of all quotas for this Analytics Property. If any quota for a
 * property is exhausted, all requests to that property will return Resource
 * Exhausted errors.
 */
export interface PropertyQuota {
  /**
   * Standard Analytics Properties can use up to 200,000 tokens per day;
   * Analytics 360 Properties can use 2,000,000 tokens per day. Most requests
   * consume fewer than 10 tokens.
   */
  tokensPerDay:
    | QuotaStatus
    | undefined;
  /**
   * Standard Analytics Properties can use up to 40,000 tokens per hour;
   * Analytics 360 Properties can use 400,000 tokens per hour. An API request
   * consumes a single number of tokens, and that number is deducted from all of
   * the hourly, daily, and per project hourly quotas.
   */
  tokensPerHour:
    | QuotaStatus
    | undefined;
  /**
   * Standard Analytics Properties can send up to 10 concurrent requests;
   * Analytics 360 Properties can use up to 50 concurrent requests.
   */
  concurrentRequests:
    | QuotaStatus
    | undefined;
  /**
   * Standard Analytics Properties and cloud project pairs can have up to 10
   * server errors per hour; Analytics 360 Properties and cloud project pairs
   * can have up to 50 server errors per hour.
   */
  serverErrorsPerProjectPerHour:
    | QuotaStatus
    | undefined;
  /**
   * Analytics Properties can send up to 120 requests with potentially
   * thresholded dimensions per hour. In a batch request, each report request
   * is individually counted for this quota if the request contains potentially
   * thresholded dimensions.
   */
  potentiallyThresholdedRequestsPerHour:
    | QuotaStatus
    | undefined;
  /**
   * Analytics Properties can use up to 35% of their tokens per project per
   * hour. This amounts to standard Analytics Properties can use up to 14,000
   * tokens per project per hour, and Analytics 360 Properties can use 140,000
   * tokens per project per hour. An API request consumes a single number of
   * tokens, and that number is deducted from all of the hourly, daily, and per
   * project hourly quotas.
   */
  tokensPerProjectPerHour: QuotaStatus | undefined;
}

/** Current state for a particular quota group. */
export interface QuotaStatus {
  /** Quota consumed by this request. */
  consumed: number;
  /** Quota remaining after this request. */
  remaining: number;
}

/** Breakdowns add a dimension to the funnel table sub report response. */
export interface FunnelBreakdown {
  /**
   * The dimension column added to the funnel table sub report response. The
   * breakdown dimension breaks down each funnel step. A valid
   * `breakdownDimension` is required if `funnelBreakdown` is specified.
   */
  breakdownDimension:
    | Dimension
    | undefined;
  /**
   * The maximum number of distinct values of the breakdown dimension to return
   * in the response. A `limit` of `5` is used if limit is not specified. Limit
   * must exceed zero and cannot exceed 15.
   */
  limit?: Long | undefined;
}

/**
 * Next actions state the value for a dimension after the user has achieved
 * a step but before the same user has achieved the next step. For example if
 * the `nextActionDimension` is `eventName`, then `nextActionDimension` in the
 * `i`th funnel step row will return first event after the event that qualified
 * the user into the `i`th funnel step but before the user achieved the `i+1`th
 * funnel step.
 */
export interface FunnelNextAction {
  /**
   * The dimension column added to the funnel visualization sub report response.
   * The next action dimension returns the next dimension value of this
   * dimension after the user has attained the `i`th funnel step.
   *
   * `nextActionDimension` currently only supports `eventName` and most Page /
   * Screen dimensions like `pageTitle` and `pagePath`. `nextActionDimension`
   * cannot be a dimension expression.
   */
  nextActionDimension:
    | Dimension
    | undefined;
  /**
   * The maximum number of distinct values of the breakdown dimension to return
   * in the response. A `limit` of `5` is used if limit is not specified. Limit
   * must exceed zero and cannot exceed 5.
   */
  limit?: Long | undefined;
}

/**
 * Configures the funnel in a funnel report request. A funnel reports on users
 * as they pass through a sequence of steps.
 *
 * Funnel exploration lets you visualize the steps your users take to complete a
 * task and quickly see how well they are succeeding or failing at each step.
 * For example, how do prospects become shoppers and then become buyers? How do
 * one time buyers become repeat buyers? With this information, you can improve
 * inefficient or abandoned customer journeys.
 */
export interface Funnel {
  /**
   * In an open funnel, users can enter the funnel in any step, and in a closed
   * funnel, users must enter the funnel in the first step. Optional. If
   * unspecified, a closed funnel is used.
   */
  isOpenFunnel: boolean;
  /** The sequential steps of this funnel. */
  steps: FunnelStep[];
}

/**
 * Steps define the user journey you want to measure. Steps contain one or
 * more conditions that your users must meet to be included in that step of
 * the funnel journey.
 */
export interface FunnelStep {
  /**
   * The distinctive name for this step. If unspecified, steps will be named
   * by a 1 based indexed name (for example "0. ", "1. ", etc.). This name
   * defines string value returned by the `funnelStepName` dimension. For
   * example, specifying `name = Purchase` in the request's third funnel step
   * will produce `3. Purchase` in the funnel report response.
   */
  name: string;
  /**
   * If true, this step must directly follow the previous step. If false,
   * there can be events between the previous step and this step. If
   * unspecified, `isDirectlyFollowedBy` is treated as false.
   */
  isDirectlyFollowedBy: boolean;
  /**
   * If specified, this step must complete within this duration of the
   * completion of the prior step. `withinDurationFromPriorStep` is inclusive
   * of the endpoint at the microsecond granularity. For example a duration of
   * 5 seconds can be completed at 4.9 or 5.0 seconds, but not 5 seconds and 1
   * microsecond.
   *
   * `withinDurationFromPriorStep` is optional, and if unspecified, steps may
   * be separated by any time duration.
   */
  withinDurationFromPriorStep?:
    | Duration
    | undefined;
  /**
   * The condition that your users must meet to be included in this step of
   * the funnel journey.
   */
  filterExpression: FunnelFilterExpression | undefined;
}

/**
 * Funnel sub reports contain the dimension and metric data values. For example,
 * 12 users reached the second step of the funnel.
 */
export interface FunnelSubReport {
  /**
   * Describes dimension columns. Funnel reports always include the funnel step
   * dimension in sub report responses. Additional dimensions like breakdowns,
   * dates, and next actions may be present in the response if requested.
   */
  dimensionHeaders: DimensionHeader[];
  /**
   * Describes metric columns. Funnel reports always include active users in sub
   * report responses. The funnel table includes additional metrics like
   * completion rate, abandonments, and abandonments rate.
   */
  metricHeaders: MetricHeader[];
  /** Rows of dimension value combinations and metric values in the report. */
  rows: Row[];
  /** Metadata for the funnel report. */
  metadata: FunnelResponseMetadata | undefined;
}

/**
 * User segments are subsets of users who engaged with your site or app. For
 * example, users who have previously purchased; users who added items to their
 * shopping carts, but didnt complete a purchase.
 */
export interface UserSegment {
  /** Defines which users are included in this segment. Optional. */
  userInclusionCriteria:
    | UserSegmentCriteria
    | undefined;
  /** Defines which users are excluded in this segment. Optional. */
  exclusion: UserSegmentExclusion | undefined;
}

/**
 * A user matches a criteria if the user's events meet the conditions in the
 * criteria.
 */
export interface UserSegmentCriteria {
  /**
   * A user matches this criteria if the user matches each of these
   * `andConditionGroups` and each of the `andSequenceGroups`.
   * `andConditionGroups` may be empty if `andSequenceGroups` are specified.
   */
  andConditionGroups: UserSegmentConditionGroup[];
  /**
   * A user matches this criteria if the user matches each of these
   * `andSequenceGroups` and each of the `andConditionGroups`.
   * `andSequenceGroups` may be empty if `andConditionGroups` are specified.
   */
  andSequenceGroups: UserSegmentSequenceGroup[];
}

/**
 * Conditions tell Analytics what data to include in or exclude from the
 * segment.
 */
export interface UserSegmentConditionGroup {
  /**
   * Data is included or excluded from the segment based on if it matches
   * the condition group. This scoping defines how many events the
   * `segmentFilterExpression` is evaluated on before the condition group
   * is determined to be matched or not. For example if `conditionScoping =
   * USER_CRITERIA_WITHIN_SAME_SESSION`, the expression is evaluated on all
   * events in a session, and then, the condition group is determined to be
   * matched or not for this user. For example if `conditionScoping =
   * USER_CRITERIA_WITHIN_SAME_EVENT`, the expression is evaluated on a single
   * event, and then, the condition group is determined to be matched or not for
   * this user.
   *
   * Optional. If unspecified, `conditionScoping = ACROSS_ALL_SESSIONS` is
   * used.
   */
  conditionScoping: UserCriteriaScoping;
  /**
   * Data is included or excluded from the segment based on if it matches
   * this expression. Expressions express criteria on dimension, metrics,
   * and/or parameters.
   */
  segmentFilterExpression: SegmentFilterExpression | undefined;
}

/**
 * Define conditions that must occur in a specific order for the user to be
 * a member of the segment.
 */
export interface UserSegmentSequenceGroup {
  /**
   * All sequence steps must be satisfied in the scoping for the user to
   * match the sequence. For example if `sequenceScoping =
   * USER_CRITERIA_WITHIN_SAME_SESSION`, all sequence steps must complete within
   * one session for the user to match the sequence. `sequenceScoping =
   * USER_CRITERIA_WITHIN_SAME_EVENT` is not supported.
   *
   * Optional. If unspecified, `conditionScoping = ACROSS_ALL_SESSIONS` is
   * used.
   */
  sequenceScoping: UserCriteriaScoping;
  /**
   * Defines the time period in which the whole sequence must occur; for
   * example, 30 Minutes. `sequenceMaximumDuration` is inclusive
   * of the endpoint at the microsecond granularity. For example a sequence
   * with a maximum duration of 5 seconds can be completed at 4.9 or 5.0
   * seconds, but not 5 seconds and 1 microsecond.
   *
   * `sequenceMaximumDuration` is optional, and if unspecified, sequences can
   * be completed in any time duration.
   */
  sequenceMaximumDuration:
    | Duration
    | undefined;
  /**
   * An ordered sequence of condition steps. A user's events must complete
   * each step in order for the user to match the
   * `UserSegmentSequenceGroup`.
   */
  userSequenceSteps: UserSequenceStep[];
}

/**
 * A condition that must occur in the specified step order for this user
 * to match the sequence.
 */
export interface UserSequenceStep {
  /**
   * If true, the event satisfying this step must be the very next event
   * after the event satifying the last step. If false, this step indirectly
   * follows the prior step; for example, there may be events between the
   * prior step and this step. `isDirectlyFollowedBy` must be false for
   * the first step.
   */
  isDirectlyFollowedBy: boolean;
  /**
   * This sequence step must be satisfied in the scoping for the user to
   * match the sequence. For example if `sequenceScoping =
   * WITHIN_SAME_SESSION`, this sequence steps must complete within one
   * session for the user to match the sequence. `stepScoping =
   * ACROSS_ALL_SESSIONS` is only allowed if the `sequenceScoping =
   * ACROSS_ALL_SESSIONS`.
   *
   * Optional. If unspecified, `stepScoping` uses the same
   * `UserCriteriaScoping` as the `sequenceScoping`.
   */
  stepScoping: UserCriteriaScoping;
  /**
   * A user matches this sequence step if their events match this
   * expression. Expressions express criteria on dimension, metrics,
   * and/or parameters.
   */
  segmentFilterExpression: SegmentFilterExpression | undefined;
}

/** Specifies which users are excluded in this segment. */
export interface UserSegmentExclusion {
  /**
   * Specifies how long an exclusion will last if a user matches the
   * `userExclusionCriteria`.
   *
   * Optional. If unspecified, `userExclusionDuration` of
   * `USER_EXCLUSION_TEMPORARY` is used.
   */
  userExclusionDuration: UserExclusionDuration;
  /**
   * If a user meets this condition, the user is excluded from membership in
   * the segment for the `userExclusionDuration`.
   */
  userExclusionCriteria: UserSegmentCriteria | undefined;
}

/**
 * Session segments are subsets of the sessions that occurred on your site or
 * app: for example, all the sessions that originated from a particular
 * advertising campaign.
 */
export interface SessionSegment {
  /** Defines which sessions are included in this segment. Optional. */
  sessionInclusionCriteria:
    | SessionSegmentCriteria
    | undefined;
  /** Defines which sessions are excluded in this segment. Optional. */
  exclusion: SessionSegmentExclusion | undefined;
}

/**
 * A session matches a criteria if the session's events meet the conditions in
 * the criteria.
 */
export interface SessionSegmentCriteria {
  /**
   * A session matches this criteria if the session matches each of these
   * `andConditionGroups`.
   */
  andConditionGroups: SessionSegmentConditionGroup[];
}

/**
 * Conditions tell Analytics what data to include in or exclude from the
 * segment.
 */
export interface SessionSegmentConditionGroup {
  /**
   * Data is included or excluded from the segment based on if it matches
   * the condition group. This scoping defines how many events the
   * `segmentFilterExpression` is evaluated on before the condition group
   * is determined to be matched or not. For example if `conditionScoping =
   * SESSION_CRITERIA_WITHIN_SAME_SESSION`, the expression is evaluated on all
   * events in a session, and then, the condition group is determined to be
   * matched or not for this session. For example if `conditionScoping =
   * SESSION_CRITERIA_WITHIN_SAME_EVENT`, the expression is evaluated on a
   * single event, and then, the condition group is determined to be matched or
   * not for this session.
   *
   * Optional. If unspecified, a `conditionScoping` of `WITHIN_SAME_SESSION`
   * is used.
   */
  conditionScoping: SessionCriteriaScoping;
  /**
   * Data is included or excluded from the segment based on if it matches
   * this expression. Expressions express criteria on dimension, metrics,
   * and/or parameters.
   */
  segmentFilterExpression: SegmentFilterExpression | undefined;
}

/** Specifies which sessions are excluded in this segment. */
export interface SessionSegmentExclusion {
  /**
   * Specifies how long an exclusion will last if a session matches the
   * `sessionExclusionCriteria`.
   *
   * Optional. If unspecified, a `sessionExclusionDuration` of
   * `SESSION_EXCLUSION_TEMPORARY` is used.
   */
  sessionExclusionDuration: SessionExclusionDuration;
  /**
   * If a session meets this condition, the session is excluded from
   * membership in the segment for the `sessionExclusionDuration`.
   */
  sessionExclusionCriteria: SessionSegmentCriteria | undefined;
}

/**
 * Event segments are subsets of events that were triggered on your site or app.
 * for example, all purchase events made in a particular location; app_exception
 * events that occurred on a specific operating system.
 */
export interface EventSegment {
  /** Defines which events are included in this segment. Optional. */
  eventInclusionCriteria:
    | EventSegmentCriteria
    | undefined;
  /** Defines which events are excluded in this segment. Optional. */
  exclusion: EventSegmentExclusion | undefined;
}

/**
 * An event matches a criteria if the event meet the conditions in the
 * criteria.
 */
export interface EventSegmentCriteria {
  /**
   * An event matches this criteria if the event matches each of these
   * `andConditionGroups`.
   */
  andConditionGroups: EventSegmentConditionGroup[];
}

/**
 * Conditions tell Analytics what data to include in or exclude from the
 * segment.
 */
export interface EventSegmentConditionGroup {
  /**
   * `conditionScoping` should always be `EVENT_CRITERIA_WITHIN_SAME_EVENT`.
   *
   * Optional. If unspecified, a `conditionScoping` of
   * `EVENT_CRITERIA_WITHIN_SAME_EVENT` is used.
   */
  conditionScoping: EventCriteriaScoping;
  /**
   * Data is included or excluded from the segment based on if it matches
   * this expression. Expressions express criteria on dimension, metrics,
   * and/or parameters.
   */
  segmentFilterExpression: SegmentFilterExpression | undefined;
}

/** Specifies which events are excluded in this segment. */
export interface EventSegmentExclusion {
  /**
   * `eventExclusionDuration` should always be `PERMANENTLY_EXCLUDE`.
   *
   * Optional. If unspecified, an `eventExclusionDuration` of
   * `EVENT_EXCLUSION_PERMANENT` is used.
   */
  eventExclusionDuration: EventExclusionDuration;
  /**
   * If an event meets this condition, the event is excluded from membership
   * in the segment for the `eventExclusionDuration`.
   */
  eventExclusionCriteria: EventSegmentCriteria | undefined;
}

/**
 * A segment is a subset of your Analytics data. For example, of your entire set
 * of users, one segment might be users from a particular country or city.
 * Another segment might be users who purchase a particular line of products or
 * who visit a specific part of your site or trigger certain events in your app.
 *
 * To learn more, see [Segment
 * Builder](https://support.google.com/analytics/answer/9304353).
 */
export interface Segment {
  /**
   * The name for this segment. If unspecified, segments are named "Segment".
   * This name defines string value returned by the `segment` dimension. The
   * `segment` dimension prefixes segment names by the 1-based index number of
   * the segment in the request (for example "1. Segment", "2. Segment", etc.).
   */
  name: string;
  /** User segments are subsets of users who engaged with your site or app. */
  userSegment?:
    | UserSegment
    | undefined;
  /**
   * Session segments are subsets of the sessions that occurred on your site
   * or app.
   */
  sessionSegment?:
    | SessionSegment
    | undefined;
  /**
   * Event segments are subsets of events that were triggered on your site or
   * app.
   */
  eventSegment?: EventSegment | undefined;
}

/** Expresses combinations of segment filters. */
export interface SegmentFilterExpression {
  /** The SegmentFilterExpression in `andGroup` have an AND relationship. */
  andGroup?:
    | SegmentFilterExpressionList
    | undefined;
  /** The SegmentFilterExpression in `orGroup` have an OR relationship. */
  orGroup?:
    | SegmentFilterExpressionList
    | undefined;
  /** The SegmentFilterExpression is NOT of `notExpression`. */
  notExpression?:
    | SegmentFilterExpression
    | undefined;
  /** A primitive segment filter. */
  segmentFilter?:
    | SegmentFilter
    | undefined;
  /**
   * Creates a filter that matches events of a single event name. If a
   * parameter filter expression is specified, only the subset of events that
   * match both the single event name and the parameter filter expressions
   * match this event filter.
   */
  segmentEventFilter?: SegmentEventFilter | undefined;
}

/** A list of segment filter expressions. */
export interface SegmentFilterExpressionList {
  /** The list of segment filter expressions */
  expressions: SegmentFilterExpression[];
}

/** An expression to filter dimension or metric values. */
export interface SegmentFilter {
  /** The dimension name or metric name. */
  fieldName: string;
  /** Strings related filter. */
  stringFilter?:
    | StringFilter
    | undefined;
  /** A filter for in list values. */
  inListFilter?:
    | InListFilter
    | undefined;
  /** A filter for numeric or date values. */
  numericFilter?:
    | NumericFilter
    | undefined;
  /** A filter for between two values. */
  betweenFilter?:
    | BetweenFilter
    | undefined;
  /** Specifies the scope for the filter. */
  filterScoping: SegmentFilterScoping | undefined;
}

/**
 * Scopings specify how the dimensions & metrics of multiple events
 * should be considered when evaluating a segment filter.
 */
export interface SegmentFilterScoping {
  /**
   * If `atAnyPointInTime` is true, this filter evaluates to true for all
   * events if it evaluates to true for any event in the date range of the
   * request.
   *
   * This `atAnyPointInTime` parameter does not extend the date range of
   * events in the report. If `atAnyPointInTime` is true, only events within
   * the report's date range are considered when evaluating this filter.
   *
   * This `atAnyPointInTime` is only able to be specified if the criteria
   * scoping is `ACROSS_ALL_SESSIONS` and is not able to be specified in
   * sequences.
   *
   * If the criteria scoping is `ACROSS_ALL_SESSIONS`, `atAnyPointInTime` =
   * false is used if unspecified.
   */
  atAnyPointInTime?: boolean | undefined;
}

/**
 * Creates a filter that matches events of a single event name. If a parameter
 * filter expression is specified, only the subset of events that match both the
 * single event name and the parameter filter expressions match this event
 * filter.
 */
export interface SegmentEventFilter {
  /**
   * This filter matches events of this single event name. Event name is
   * required.
   */
  eventName?:
    | string
    | undefined;
  /**
   * If specified, this filter matches events that match both the single event
   * name and the parameter filter expressions.
   *
   * Inside the parameter filter expression, only parameter filters are
   * available.
   */
  segmentParameterFilterExpression?: SegmentParameterFilterExpression | undefined;
}

/** Expresses combinations of segment filter on parameters. */
export interface SegmentParameterFilterExpression {
  /**
   * The SegmentParameterFilterExpression in `andGroup` have an AND
   * relationship.
   */
  andGroup?:
    | SegmentParameterFilterExpressionList
    | undefined;
  /**
   * The SegmentParameterFilterExpression in `orGroup` have an OR
   * relationship.
   */
  orGroup?:
    | SegmentParameterFilterExpressionList
    | undefined;
  /** The SegmentParameterFilterExpression is NOT of `notExpression`. */
  notExpression?:
    | SegmentParameterFilterExpression
    | undefined;
  /** A primitive segment parameter filter. */
  segmentParameterFilter?: SegmentParameterFilter | undefined;
}

/** A list of segment parameter filter expressions. */
export interface SegmentParameterFilterExpressionList {
  /** The list of segment parameter filter expressions. */
  expressions: SegmentParameterFilterExpression[];
}

/** An expression to filter parameter values in a segment. */
export interface SegmentParameterFilter {
  /**
   * This filter will be evaluated on the specified event parameter. Event
   * parameters are logged as parameters of the event. Event parameters
   * include fields like "firebase_screen" & "currency".
   *
   * Event parameters can only be used in segments & funnels and can only be
   * used in a descendent filter from an EventFilter. In a descendent filter
   * from an EventFilter either event or item parameters should be used.
   */
  eventParameterName?:
    | string
    | undefined;
  /**
   * This filter will be evaluated on the specified item parameter. Item
   * parameters are logged as parameters in the item array. Item parameters
   * include fields like "item_name" & "item_category".
   *
   * Item parameters can only be used in segments & funnels and can only be
   * used in a descendent filter from an EventFilter. In a descendent filter
   * from an EventFilter either event or item parameters should be used.
   *
   * Item parameters are only available in ecommerce events. To learn more
   * about ecommerce events, see the [Measure ecommerce]
   * (https://developers.google.com/analytics/devguides/collection/ga4/ecommerce)
   * guide.
   */
  itemParameterName?:
    | string
    | undefined;
  /** Strings related filter. */
  stringFilter?:
    | StringFilter
    | undefined;
  /** A filter for in list values. */
  inListFilter?:
    | InListFilter
    | undefined;
  /** A filter for numeric or date values. */
  numericFilter?:
    | NumericFilter
    | undefined;
  /** A filter for between two values. */
  betweenFilter?:
    | BetweenFilter
    | undefined;
  /** Specifies the scope for the filter. */
  filterScoping: SegmentParameterFilterScoping | undefined;
}

/**
 * Scopings specify how multiple events should be considered when evaluating a
 * segment parameter filter.
 */
export interface SegmentParameterFilterScoping {
  /**
   * Accumulates the parameter over the specified period of days before
   * applying the filter. Only supported if criteria scoping is
   * `ACROSS_ALL_SESSIONS` or `WITHIN_SAME_SESSION`. Only supported if the
   * parameter is `event_count`.
   *
   * For example if `inAnyNDayPeriod` is 3, the event_name is "purchase",
   * the event parameter is "event_count", and the Filter's criteria is
   * greater than 5, this filter will accumulate the event count of purchase
   * events over every 3 consecutive day period in the report's date range; a
   * user will pass this Filter's criteria to be included in this segment if
   * their count of purchase events exceeds 5 in any 3 consecutive day period.
   * For example, the periods 2021-11-01 to 2021-11-03, 2021-11-02 to
   * 2021-11-04, 2021-11-03 to 2021-11-05, and etc. will be considered.
   *
   * The date range is not extended for the purpose of having a full N day
   * window near the start of the date range. For example if a report is for
   * 2021-11-01 to 2021-11-10 and `inAnyNDayPeriod` = 3, the first two day
   * period will be effectively shortened because no event data outside the
   * report's date range will be read. For example, the first four periods
   * will effectively be: 2021-11-01 to 2021-11-01, 2021-11-01 to 2021-11-02,
   * 2021-11-01 to 2021-11-03, and 2021-11-02 to 2021-11-04.
   *
   * `inAnyNDayPeriod` is optional. If not specified, the
   * `segmentParameterFilter` is applied to each event individually.
   */
  inAnyNDayPeriod?: Long | undefined;
}

/** Expresses combinations of funnel filters. */
export interface FunnelFilterExpression {
  /** The FunnelFilterExpression in `andGroup` have an AND relationship. */
  andGroup?:
    | FunnelFilterExpressionList
    | undefined;
  /** The FunnelFilterExpression in `orGroup` have an OR relationship. */
  orGroup?:
    | FunnelFilterExpressionList
    | undefined;
  /** The FunnelFilterExpression is NOT of `notExpression`. */
  notExpression?:
    | FunnelFilterExpression
    | undefined;
  /** A funnel filter for a dimension or metric. */
  funnelFieldFilter?:
    | FunnelFieldFilter
    | undefined;
  /**
   * Creates a filter that matches events of a single event name. If a
   * parameter filter expression is specified, only the subset of events that
   * match both the single event name and the parameter filter expressions
   * match this event filter.
   */
  funnelEventFilter?: FunnelEventFilter | undefined;
}

/** A list of funnel filter expressions. */
export interface FunnelFilterExpressionList {
  /** The list of funnel filter expressions. */
  expressions: FunnelFilterExpression[];
}

/** An expression to filter dimension or metric values. */
export interface FunnelFieldFilter {
  /** The dimension name or metric name. */
  fieldName: string;
  /** Strings related filter. */
  stringFilter?:
    | StringFilter
    | undefined;
  /** A filter for in list values. */
  inListFilter?:
    | InListFilter
    | undefined;
  /** A filter for numeric or date values. */
  numericFilter?:
    | NumericFilter
    | undefined;
  /** A filter for between two values. */
  betweenFilter?: BetweenFilter | undefined;
}

/**
 * Creates a filter that matches events of a single event name. If a parameter
 * filter expression is specified, only the subset of events that match both the
 * single event name and the parameter filter expressions match this event
 * filter.
 */
export interface FunnelEventFilter {
  /**
   * This filter matches events of this single event name. Event name is
   * required.
   */
  eventName?:
    | string
    | undefined;
  /**
   * If specified, this filter matches events that match both the single event
   * name and the parameter filter expressions.
   *
   * Inside the parameter filter expression, only parameter filters are
   * available.
   */
  funnelParameterFilterExpression?: FunnelParameterFilterExpression | undefined;
}

/** Expresses combinations of funnel filters on parameters. */
export interface FunnelParameterFilterExpression {
  /**
   * The FunnelParameterFilterExpression in `andGroup` have an AND
   * relationship.
   */
  andGroup?:
    | FunnelParameterFilterExpressionList
    | undefined;
  /**
   * The FunnelParameterFilterExpression in `orGroup` have an OR
   * relationship.
   */
  orGroup?:
    | FunnelParameterFilterExpressionList
    | undefined;
  /** The FunnelParameterFilterExpression is NOT of `notExpression`. */
  notExpression?:
    | FunnelParameterFilterExpression
    | undefined;
  /** A primitive funnel parameter filter. */
  funnelParameterFilter?: FunnelParameterFilter | undefined;
}

/** A list of funnel parameter filter expressions. */
export interface FunnelParameterFilterExpressionList {
  /** The list of funnel parameter filter expressions. */
  expressions: FunnelParameterFilterExpression[];
}

/** An expression to filter parameter values in a funnel. */
export interface FunnelParameterFilter {
  /**
   * This filter will be evaluated on the specified event parameter. Event
   * parameters are logged as parameters of the event. Event parameters
   * include fields like "firebase_screen" & "currency".
   *
   * Event parameters can only be used in segments & funnels and can only be
   * used in a descendent filter from an EventFilter. In a descendent filter
   * from an EventFilter either event or item parameters should be used.
   */
  eventParameterName?:
    | string
    | undefined;
  /**
   * This filter will be evaluated on the specified item parameter. Item
   * parameters are logged as parameters in the item array. Item parameters
   * include fields like "item_name" & "item_category".
   *
   * Item parameters can only be used in segments & funnels and can only be
   * used in a descendent filter from an EventFilter. In a descendent filter
   * from an EventFilter either event or item parameters should be used.
   *
   * Item parameters are only available in ecommerce events. To learn more
   * about ecommerce events, see the [Measure ecommerce]
   * (https://developers.google.com/analytics/devguides/collection/ga4/ecommerce)
   * guide.
   */
  itemParameterName?:
    | string
    | undefined;
  /** Strings related filter. */
  stringFilter?:
    | StringFilter
    | undefined;
  /** A filter for in list values. */
  inListFilter?:
    | InListFilter
    | undefined;
  /** A filter for numeric or date values. */
  numericFilter?:
    | NumericFilter
    | undefined;
  /** A filter for between two values. */
  betweenFilter?: BetweenFilter | undefined;
}

/**
 * The funnel report's response metadata carries additional information about
 * the funnel report.
 */
export interface FunnelResponseMetadata {
  /**
   * If funnel report results are
   * [sampled](https://support.google.com/analytics/answer/13331292), this
   * describes what percentage of events were used in this funnel report. One
   * `samplingMetadatas` is populated for each date range. Each
   * `samplingMetadatas` corresponds to a date range in order that date ranges
   * were specified in the request.
   *
   * However if the results are not sampled, this field will not be defined.
   */
  samplingMetadatas: SamplingMetadata[];
}

/**
 * If funnel report results are
 * [sampled](https://support.google.com/analytics/answer/13331292), this
 * metadata describes what percentage of events were used in this funnel
 * report for a date range. Sampling is the practice of analyzing a subset of
 * all data in order to uncover the meaningful information in the larger data
 * set.
 */
export interface SamplingMetadata {
  /**
   * The total number of events read in this sampled report for a date range.
   * This is the size of the subset this property's data that was analyzed in
   * this funnel report.
   */
  samplesReadCount: Long;
  /**
   * The total number of events present in this property's data that could
   * have been analyzed in this funnel report for a date range. Sampling
   * uncovers the meaningful information about the larger data set, and this
   * is the size of the larger data set.
   *
   * To calculate the percentage of available data that was used in this
   * funnel report, compute `samplesReadCount/samplingSpaceSize`.
   */
  samplingSpaceSize: Long;
}

function createBaseDateRange(): DateRange {
  return { startDate: "", endDate: "", name: "" };
}

export const DateRange: MessageFns<DateRange> = {
  encode(message: DateRange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startDate !== "") {
      writer.uint32(10).string(message.startDate);
    }
    if (message.endDate !== "") {
      writer.uint32(18).string(message.endDate);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DateRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDateRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startDate = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endDate = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DateRange {
    return {
      startDate: isSet(object.startDate) ? globalThis.String(object.startDate) : "",
      endDate: isSet(object.endDate) ? globalThis.String(object.endDate) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: DateRange): unknown {
    const obj: any = {};
    if (message.startDate !== "") {
      obj.startDate = message.startDate;
    }
    if (message.endDate !== "") {
      obj.endDate = message.endDate;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DateRange>): DateRange {
    return DateRange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DateRange>): DateRange {
    const message = createBaseDateRange();
    message.startDate = object.startDate ?? "";
    message.endDate = object.endDate ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDimension(): Dimension {
  return { name: "", dimensionExpression: undefined };
}

export const Dimension: MessageFns<Dimension> = {
  encode(message: Dimension, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.dimensionExpression !== undefined) {
      DimensionExpression.encode(message.dimensionExpression, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Dimension {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDimension();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dimensionExpression = DimensionExpression.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Dimension {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      dimensionExpression: isSet(object.dimensionExpression)
        ? DimensionExpression.fromJSON(object.dimensionExpression)
        : undefined,
    };
  },

  toJSON(message: Dimension): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.dimensionExpression !== undefined) {
      obj.dimensionExpression = DimensionExpression.toJSON(message.dimensionExpression);
    }
    return obj;
  },

  create(base?: DeepPartial<Dimension>): Dimension {
    return Dimension.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Dimension>): Dimension {
    const message = createBaseDimension();
    message.name = object.name ?? "";
    message.dimensionExpression = (object.dimensionExpression !== undefined && object.dimensionExpression !== null)
      ? DimensionExpression.fromPartial(object.dimensionExpression)
      : undefined;
    return message;
  },
};

function createBaseDimensionExpression(): DimensionExpression {
  return { lowerCase: undefined, upperCase: undefined, concatenate: undefined };
}

export const DimensionExpression: MessageFns<DimensionExpression> = {
  encode(message: DimensionExpression, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lowerCase !== undefined) {
      DimensionExpression_CaseExpression.encode(message.lowerCase, writer.uint32(34).fork()).join();
    }
    if (message.upperCase !== undefined) {
      DimensionExpression_CaseExpression.encode(message.upperCase, writer.uint32(42).fork()).join();
    }
    if (message.concatenate !== undefined) {
      DimensionExpression_ConcatenateExpression.encode(message.concatenate, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DimensionExpression {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDimensionExpression();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 34) {
            break;
          }

          message.lowerCase = DimensionExpression_CaseExpression.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.upperCase = DimensionExpression_CaseExpression.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.concatenate = DimensionExpression_ConcatenateExpression.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DimensionExpression {
    return {
      lowerCase: isSet(object.lowerCase) ? DimensionExpression_CaseExpression.fromJSON(object.lowerCase) : undefined,
      upperCase: isSet(object.upperCase) ? DimensionExpression_CaseExpression.fromJSON(object.upperCase) : undefined,
      concatenate: isSet(object.concatenate)
        ? DimensionExpression_ConcatenateExpression.fromJSON(object.concatenate)
        : undefined,
    };
  },

  toJSON(message: DimensionExpression): unknown {
    const obj: any = {};
    if (message.lowerCase !== undefined) {
      obj.lowerCase = DimensionExpression_CaseExpression.toJSON(message.lowerCase);
    }
    if (message.upperCase !== undefined) {
      obj.upperCase = DimensionExpression_CaseExpression.toJSON(message.upperCase);
    }
    if (message.concatenate !== undefined) {
      obj.concatenate = DimensionExpression_ConcatenateExpression.toJSON(message.concatenate);
    }
    return obj;
  },

  create(base?: DeepPartial<DimensionExpression>): DimensionExpression {
    return DimensionExpression.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DimensionExpression>): DimensionExpression {
    const message = createBaseDimensionExpression();
    message.lowerCase = (object.lowerCase !== undefined && object.lowerCase !== null)
      ? DimensionExpression_CaseExpression.fromPartial(object.lowerCase)
      : undefined;
    message.upperCase = (object.upperCase !== undefined && object.upperCase !== null)
      ? DimensionExpression_CaseExpression.fromPartial(object.upperCase)
      : undefined;
    message.concatenate = (object.concatenate !== undefined && object.concatenate !== null)
      ? DimensionExpression_ConcatenateExpression.fromPartial(object.concatenate)
      : undefined;
    return message;
  },
};

function createBaseDimensionExpression_CaseExpression(): DimensionExpression_CaseExpression {
  return { dimensionName: "" };
}

export const DimensionExpression_CaseExpression: MessageFns<DimensionExpression_CaseExpression> = {
  encode(message: DimensionExpression_CaseExpression, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dimensionName !== "") {
      writer.uint32(10).string(message.dimensionName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DimensionExpression_CaseExpression {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDimensionExpression_CaseExpression();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dimensionName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DimensionExpression_CaseExpression {
    return { dimensionName: isSet(object.dimensionName) ? globalThis.String(object.dimensionName) : "" };
  },

  toJSON(message: DimensionExpression_CaseExpression): unknown {
    const obj: any = {};
    if (message.dimensionName !== "") {
      obj.dimensionName = message.dimensionName;
    }
    return obj;
  },

  create(base?: DeepPartial<DimensionExpression_CaseExpression>): DimensionExpression_CaseExpression {
    return DimensionExpression_CaseExpression.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DimensionExpression_CaseExpression>): DimensionExpression_CaseExpression {
    const message = createBaseDimensionExpression_CaseExpression();
    message.dimensionName = object.dimensionName ?? "";
    return message;
  },
};

function createBaseDimensionExpression_ConcatenateExpression(): DimensionExpression_ConcatenateExpression {
  return { dimensionNames: [], delimiter: "" };
}

export const DimensionExpression_ConcatenateExpression: MessageFns<DimensionExpression_ConcatenateExpression> = {
  encode(message: DimensionExpression_ConcatenateExpression, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.dimensionNames) {
      writer.uint32(10).string(v!);
    }
    if (message.delimiter !== "") {
      writer.uint32(18).string(message.delimiter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DimensionExpression_ConcatenateExpression {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDimensionExpression_ConcatenateExpression();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dimensionNames.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.delimiter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DimensionExpression_ConcatenateExpression {
    return {
      dimensionNames: globalThis.Array.isArray(object?.dimensionNames)
        ? object.dimensionNames.map((e: any) => globalThis.String(e))
        : [],
      delimiter: isSet(object.delimiter) ? globalThis.String(object.delimiter) : "",
    };
  },

  toJSON(message: DimensionExpression_ConcatenateExpression): unknown {
    const obj: any = {};
    if (message.dimensionNames?.length) {
      obj.dimensionNames = message.dimensionNames;
    }
    if (message.delimiter !== "") {
      obj.delimiter = message.delimiter;
    }
    return obj;
  },

  create(base?: DeepPartial<DimensionExpression_ConcatenateExpression>): DimensionExpression_ConcatenateExpression {
    return DimensionExpression_ConcatenateExpression.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<DimensionExpression_ConcatenateExpression>,
  ): DimensionExpression_ConcatenateExpression {
    const message = createBaseDimensionExpression_ConcatenateExpression();
    message.dimensionNames = object.dimensionNames?.map((e) => e) || [];
    message.delimiter = object.delimiter ?? "";
    return message;
  },
};

function createBaseMetric(): Metric {
  return { name: "", expression: "", invisible: false };
}

export const Metric: MessageFns<Metric> = {
  encode(message: Metric, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.expression !== "") {
      writer.uint32(18).string(message.expression);
    }
    if (message.invisible !== false) {
      writer.uint32(24).bool(message.invisible);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Metric {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetric();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.expression = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.invisible = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Metric {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      expression: isSet(object.expression) ? globalThis.String(object.expression) : "",
      invisible: isSet(object.invisible) ? globalThis.Boolean(object.invisible) : false,
    };
  },

  toJSON(message: Metric): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.expression !== "") {
      obj.expression = message.expression;
    }
    if (message.invisible !== false) {
      obj.invisible = message.invisible;
    }
    return obj;
  },

  create(base?: DeepPartial<Metric>): Metric {
    return Metric.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Metric>): Metric {
    const message = createBaseMetric();
    message.name = object.name ?? "";
    message.expression = object.expression ?? "";
    message.invisible = object.invisible ?? false;
    return message;
  },
};

function createBaseFilterExpression(): FilterExpression {
  return { andGroup: undefined, orGroup: undefined, notExpression: undefined, filter: undefined };
}

export const FilterExpression: MessageFns<FilterExpression> = {
  encode(message: FilterExpression, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.andGroup !== undefined) {
      FilterExpressionList.encode(message.andGroup, writer.uint32(10).fork()).join();
    }
    if (message.orGroup !== undefined) {
      FilterExpressionList.encode(message.orGroup, writer.uint32(18).fork()).join();
    }
    if (message.notExpression !== undefined) {
      FilterExpression.encode(message.notExpression, writer.uint32(26).fork()).join();
    }
    if (message.filter !== undefined) {
      Filter.encode(message.filter, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FilterExpression {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilterExpression();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.andGroup = FilterExpressionList.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.orGroup = FilterExpressionList.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.notExpression = FilterExpression.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = Filter.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FilterExpression {
    return {
      andGroup: isSet(object.andGroup) ? FilterExpressionList.fromJSON(object.andGroup) : undefined,
      orGroup: isSet(object.orGroup) ? FilterExpressionList.fromJSON(object.orGroup) : undefined,
      notExpression: isSet(object.notExpression) ? FilterExpression.fromJSON(object.notExpression) : undefined,
      filter: isSet(object.filter) ? Filter.fromJSON(object.filter) : undefined,
    };
  },

  toJSON(message: FilterExpression): unknown {
    const obj: any = {};
    if (message.andGroup !== undefined) {
      obj.andGroup = FilterExpressionList.toJSON(message.andGroup);
    }
    if (message.orGroup !== undefined) {
      obj.orGroup = FilterExpressionList.toJSON(message.orGroup);
    }
    if (message.notExpression !== undefined) {
      obj.notExpression = FilterExpression.toJSON(message.notExpression);
    }
    if (message.filter !== undefined) {
      obj.filter = Filter.toJSON(message.filter);
    }
    return obj;
  },

  create(base?: DeepPartial<FilterExpression>): FilterExpression {
    return FilterExpression.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FilterExpression>): FilterExpression {
    const message = createBaseFilterExpression();
    message.andGroup = (object.andGroup !== undefined && object.andGroup !== null)
      ? FilterExpressionList.fromPartial(object.andGroup)
      : undefined;
    message.orGroup = (object.orGroup !== undefined && object.orGroup !== null)
      ? FilterExpressionList.fromPartial(object.orGroup)
      : undefined;
    message.notExpression = (object.notExpression !== undefined && object.notExpression !== null)
      ? FilterExpression.fromPartial(object.notExpression)
      : undefined;
    message.filter = (object.filter !== undefined && object.filter !== null)
      ? Filter.fromPartial(object.filter)
      : undefined;
    return message;
  },
};

function createBaseFilterExpressionList(): FilterExpressionList {
  return { expressions: [] };
}

export const FilterExpressionList: MessageFns<FilterExpressionList> = {
  encode(message: FilterExpressionList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.expressions) {
      FilterExpression.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FilterExpressionList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilterExpressionList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.expressions.push(FilterExpression.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FilterExpressionList {
    return {
      expressions: globalThis.Array.isArray(object?.expressions)
        ? object.expressions.map((e: any) => FilterExpression.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FilterExpressionList): unknown {
    const obj: any = {};
    if (message.expressions?.length) {
      obj.expressions = message.expressions.map((e) => FilterExpression.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<FilterExpressionList>): FilterExpressionList {
    return FilterExpressionList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FilterExpressionList>): FilterExpressionList {
    const message = createBaseFilterExpressionList();
    message.expressions = object.expressions?.map((e) => FilterExpression.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFilter(): Filter {
  return {
    fieldName: "",
    stringFilter: undefined,
    inListFilter: undefined,
    numericFilter: undefined,
    betweenFilter: undefined,
  };
}

export const Filter: MessageFns<Filter> = {
  encode(message: Filter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fieldName !== "") {
      writer.uint32(10).string(message.fieldName);
    }
    if (message.stringFilter !== undefined) {
      StringFilter.encode(message.stringFilter, writer.uint32(18).fork()).join();
    }
    if (message.inListFilter !== undefined) {
      InListFilter.encode(message.inListFilter, writer.uint32(26).fork()).join();
    }
    if (message.numericFilter !== undefined) {
      NumericFilter.encode(message.numericFilter, writer.uint32(34).fork()).join();
    }
    if (message.betweenFilter !== undefined) {
      BetweenFilter.encode(message.betweenFilter, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Filter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fieldName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stringFilter = StringFilter.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.inListFilter = InListFilter.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.numericFilter = NumericFilter.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.betweenFilter = BetweenFilter.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Filter {
    return {
      fieldName: isSet(object.fieldName) ? globalThis.String(object.fieldName) : "",
      stringFilter: isSet(object.stringFilter) ? StringFilter.fromJSON(object.stringFilter) : undefined,
      inListFilter: isSet(object.inListFilter) ? InListFilter.fromJSON(object.inListFilter) : undefined,
      numericFilter: isSet(object.numericFilter) ? NumericFilter.fromJSON(object.numericFilter) : undefined,
      betweenFilter: isSet(object.betweenFilter) ? BetweenFilter.fromJSON(object.betweenFilter) : undefined,
    };
  },

  toJSON(message: Filter): unknown {
    const obj: any = {};
    if (message.fieldName !== "") {
      obj.fieldName = message.fieldName;
    }
    if (message.stringFilter !== undefined) {
      obj.stringFilter = StringFilter.toJSON(message.stringFilter);
    }
    if (message.inListFilter !== undefined) {
      obj.inListFilter = InListFilter.toJSON(message.inListFilter);
    }
    if (message.numericFilter !== undefined) {
      obj.numericFilter = NumericFilter.toJSON(message.numericFilter);
    }
    if (message.betweenFilter !== undefined) {
      obj.betweenFilter = BetweenFilter.toJSON(message.betweenFilter);
    }
    return obj;
  },

  create(base?: DeepPartial<Filter>): Filter {
    return Filter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Filter>): Filter {
    const message = createBaseFilter();
    message.fieldName = object.fieldName ?? "";
    message.stringFilter = (object.stringFilter !== undefined && object.stringFilter !== null)
      ? StringFilter.fromPartial(object.stringFilter)
      : undefined;
    message.inListFilter = (object.inListFilter !== undefined && object.inListFilter !== null)
      ? InListFilter.fromPartial(object.inListFilter)
      : undefined;
    message.numericFilter = (object.numericFilter !== undefined && object.numericFilter !== null)
      ? NumericFilter.fromPartial(object.numericFilter)
      : undefined;
    message.betweenFilter = (object.betweenFilter !== undefined && object.betweenFilter !== null)
      ? BetweenFilter.fromPartial(object.betweenFilter)
      : undefined;
    return message;
  },
};

function createBaseStringFilter(): StringFilter {
  return { matchType: 0, value: "", caseSensitive: false };
}

export const StringFilter: MessageFns<StringFilter> = {
  encode(message: StringFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.matchType !== 0) {
      writer.uint32(8).int32(message.matchType);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    if (message.caseSensitive !== false) {
      writer.uint32(24).bool(message.caseSensitive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.matchType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.caseSensitive = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringFilter {
    return {
      matchType: isSet(object.matchType) ? stringFilter_MatchTypeFromJSON(object.matchType) : 0,
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      caseSensitive: isSet(object.caseSensitive) ? globalThis.Boolean(object.caseSensitive) : false,
    };
  },

  toJSON(message: StringFilter): unknown {
    const obj: any = {};
    if (message.matchType !== 0) {
      obj.matchType = stringFilter_MatchTypeToJSON(message.matchType);
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.caseSensitive !== false) {
      obj.caseSensitive = message.caseSensitive;
    }
    return obj;
  },

  create(base?: DeepPartial<StringFilter>): StringFilter {
    return StringFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StringFilter>): StringFilter {
    const message = createBaseStringFilter();
    message.matchType = object.matchType ?? 0;
    message.value = object.value ?? "";
    message.caseSensitive = object.caseSensitive ?? false;
    return message;
  },
};

function createBaseInListFilter(): InListFilter {
  return { values: [], caseSensitive: false };
}

export const InListFilter: MessageFns<InListFilter> = {
  encode(message: InListFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.values) {
      writer.uint32(10).string(v!);
    }
    if (message.caseSensitive !== false) {
      writer.uint32(16).bool(message.caseSensitive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InListFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInListFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.values.push(reader.string());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.caseSensitive = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InListFilter {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.String(e)) : [],
      caseSensitive: isSet(object.caseSensitive) ? globalThis.Boolean(object.caseSensitive) : false,
    };
  },

  toJSON(message: InListFilter): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    if (message.caseSensitive !== false) {
      obj.caseSensitive = message.caseSensitive;
    }
    return obj;
  },

  create(base?: DeepPartial<InListFilter>): InListFilter {
    return InListFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InListFilter>): InListFilter {
    const message = createBaseInListFilter();
    message.values = object.values?.map((e) => e) || [];
    message.caseSensitive = object.caseSensitive ?? false;
    return message;
  },
};

function createBaseNumericFilter(): NumericFilter {
  return { operation: 0, value: undefined };
}

export const NumericFilter: MessageFns<NumericFilter> = {
  encode(message: NumericFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operation !== 0) {
      writer.uint32(8).int32(message.operation);
    }
    if (message.value !== undefined) {
      NumericValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NumericFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNumericFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.operation = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = NumericValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NumericFilter {
    return {
      operation: isSet(object.operation) ? numericFilter_OperationFromJSON(object.operation) : 0,
      value: isSet(object.value) ? NumericValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: NumericFilter): unknown {
    const obj: any = {};
    if (message.operation !== 0) {
      obj.operation = numericFilter_OperationToJSON(message.operation);
    }
    if (message.value !== undefined) {
      obj.value = NumericValue.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<NumericFilter>): NumericFilter {
    return NumericFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NumericFilter>): NumericFilter {
    const message = createBaseNumericFilter();
    message.operation = object.operation ?? 0;
    message.value = (object.value !== undefined && object.value !== null)
      ? NumericValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseOrderBy(): OrderBy {
  return { metric: undefined, dimension: undefined, desc: false };
}

export const OrderBy: MessageFns<OrderBy> = {
  encode(message: OrderBy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metric !== undefined) {
      OrderBy_MetricOrderBy.encode(message.metric, writer.uint32(10).fork()).join();
    }
    if (message.dimension !== undefined) {
      OrderBy_DimensionOrderBy.encode(message.dimension, writer.uint32(18).fork()).join();
    }
    if (message.desc !== false) {
      writer.uint32(32).bool(message.desc);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderBy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderBy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metric = OrderBy_MetricOrderBy.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dimension = OrderBy_DimensionOrderBy.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.desc = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderBy {
    return {
      metric: isSet(object.metric) ? OrderBy_MetricOrderBy.fromJSON(object.metric) : undefined,
      dimension: isSet(object.dimension) ? OrderBy_DimensionOrderBy.fromJSON(object.dimension) : undefined,
      desc: isSet(object.desc) ? globalThis.Boolean(object.desc) : false,
    };
  },

  toJSON(message: OrderBy): unknown {
    const obj: any = {};
    if (message.metric !== undefined) {
      obj.metric = OrderBy_MetricOrderBy.toJSON(message.metric);
    }
    if (message.dimension !== undefined) {
      obj.dimension = OrderBy_DimensionOrderBy.toJSON(message.dimension);
    }
    if (message.desc !== false) {
      obj.desc = message.desc;
    }
    return obj;
  },

  create(base?: DeepPartial<OrderBy>): OrderBy {
    return OrderBy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OrderBy>): OrderBy {
    const message = createBaseOrderBy();
    message.metric = (object.metric !== undefined && object.metric !== null)
      ? OrderBy_MetricOrderBy.fromPartial(object.metric)
      : undefined;
    message.dimension = (object.dimension !== undefined && object.dimension !== null)
      ? OrderBy_DimensionOrderBy.fromPartial(object.dimension)
      : undefined;
    message.desc = object.desc ?? false;
    return message;
  },
};

function createBaseOrderBy_MetricOrderBy(): OrderBy_MetricOrderBy {
  return { metricName: "" };
}

export const OrderBy_MetricOrderBy: MessageFns<OrderBy_MetricOrderBy> = {
  encode(message: OrderBy_MetricOrderBy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metricName !== "") {
      writer.uint32(10).string(message.metricName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderBy_MetricOrderBy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderBy_MetricOrderBy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metricName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderBy_MetricOrderBy {
    return { metricName: isSet(object.metricName) ? globalThis.String(object.metricName) : "" };
  },

  toJSON(message: OrderBy_MetricOrderBy): unknown {
    const obj: any = {};
    if (message.metricName !== "") {
      obj.metricName = message.metricName;
    }
    return obj;
  },

  create(base?: DeepPartial<OrderBy_MetricOrderBy>): OrderBy_MetricOrderBy {
    return OrderBy_MetricOrderBy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OrderBy_MetricOrderBy>): OrderBy_MetricOrderBy {
    const message = createBaseOrderBy_MetricOrderBy();
    message.metricName = object.metricName ?? "";
    return message;
  },
};

function createBaseOrderBy_DimensionOrderBy(): OrderBy_DimensionOrderBy {
  return { dimensionName: "", orderType: 0 };
}

export const OrderBy_DimensionOrderBy: MessageFns<OrderBy_DimensionOrderBy> = {
  encode(message: OrderBy_DimensionOrderBy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dimensionName !== "") {
      writer.uint32(10).string(message.dimensionName);
    }
    if (message.orderType !== 0) {
      writer.uint32(16).int32(message.orderType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderBy_DimensionOrderBy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderBy_DimensionOrderBy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dimensionName = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.orderType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderBy_DimensionOrderBy {
    return {
      dimensionName: isSet(object.dimensionName) ? globalThis.String(object.dimensionName) : "",
      orderType: isSet(object.orderType) ? orderBy_DimensionOrderBy_OrderTypeFromJSON(object.orderType) : 0,
    };
  },

  toJSON(message: OrderBy_DimensionOrderBy): unknown {
    const obj: any = {};
    if (message.dimensionName !== "") {
      obj.dimensionName = message.dimensionName;
    }
    if (message.orderType !== 0) {
      obj.orderType = orderBy_DimensionOrderBy_OrderTypeToJSON(message.orderType);
    }
    return obj;
  },

  create(base?: DeepPartial<OrderBy_DimensionOrderBy>): OrderBy_DimensionOrderBy {
    return OrderBy_DimensionOrderBy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OrderBy_DimensionOrderBy>): OrderBy_DimensionOrderBy {
    const message = createBaseOrderBy_DimensionOrderBy();
    message.dimensionName = object.dimensionName ?? "";
    message.orderType = object.orderType ?? 0;
    return message;
  },
};

function createBaseBetweenFilter(): BetweenFilter {
  return { fromValue: undefined, toValue: undefined };
}

export const BetweenFilter: MessageFns<BetweenFilter> = {
  encode(message: BetweenFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromValue !== undefined) {
      NumericValue.encode(message.fromValue, writer.uint32(10).fork()).join();
    }
    if (message.toValue !== undefined) {
      NumericValue.encode(message.toValue, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BetweenFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBetweenFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fromValue = NumericValue.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.toValue = NumericValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BetweenFilter {
    return {
      fromValue: isSet(object.fromValue) ? NumericValue.fromJSON(object.fromValue) : undefined,
      toValue: isSet(object.toValue) ? NumericValue.fromJSON(object.toValue) : undefined,
    };
  },

  toJSON(message: BetweenFilter): unknown {
    const obj: any = {};
    if (message.fromValue !== undefined) {
      obj.fromValue = NumericValue.toJSON(message.fromValue);
    }
    if (message.toValue !== undefined) {
      obj.toValue = NumericValue.toJSON(message.toValue);
    }
    return obj;
  },

  create(base?: DeepPartial<BetweenFilter>): BetweenFilter {
    return BetweenFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BetweenFilter>): BetweenFilter {
    const message = createBaseBetweenFilter();
    message.fromValue = (object.fromValue !== undefined && object.fromValue !== null)
      ? NumericValue.fromPartial(object.fromValue)
      : undefined;
    message.toValue = (object.toValue !== undefined && object.toValue !== null)
      ? NumericValue.fromPartial(object.toValue)
      : undefined;
    return message;
  },
};

function createBaseNumericValue(): NumericValue {
  return { int64Value: undefined, doubleValue: undefined };
}

export const NumericValue: MessageFns<NumericValue> = {
  encode(message: NumericValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.int64Value !== undefined) {
      writer.uint32(8).int64(message.int64Value.toString());
    }
    if (message.doubleValue !== undefined) {
      writer.uint32(17).double(message.doubleValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NumericValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNumericValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.int64Value = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.doubleValue = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NumericValue {
    return {
      int64Value: isSet(object.int64Value) ? Long.fromValue(object.int64Value) : undefined,
      doubleValue: isSet(object.doubleValue) ? globalThis.Number(object.doubleValue) : undefined,
    };
  },

  toJSON(message: NumericValue): unknown {
    const obj: any = {};
    if (message.int64Value !== undefined) {
      obj.int64Value = (message.int64Value || Long.ZERO).toString();
    }
    if (message.doubleValue !== undefined) {
      obj.doubleValue = message.doubleValue;
    }
    return obj;
  },

  create(base?: DeepPartial<NumericValue>): NumericValue {
    return NumericValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NumericValue>): NumericValue {
    const message = createBaseNumericValue();
    message.int64Value = (object.int64Value !== undefined && object.int64Value !== null)
      ? Long.fromValue(object.int64Value)
      : undefined;
    message.doubleValue = object.doubleValue ?? undefined;
    return message;
  },
};

function createBaseCohortSpec(): CohortSpec {
  return { cohorts: [], cohortsRange: undefined, cohortReportSettings: undefined };
}

export const CohortSpec: MessageFns<CohortSpec> = {
  encode(message: CohortSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.cohorts) {
      Cohort.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.cohortsRange !== undefined) {
      CohortsRange.encode(message.cohortsRange, writer.uint32(18).fork()).join();
    }
    if (message.cohortReportSettings !== undefined) {
      CohortReportSettings.encode(message.cohortReportSettings, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CohortSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCohortSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cohorts.push(Cohort.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cohortsRange = CohortsRange.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cohortReportSettings = CohortReportSettings.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CohortSpec {
    return {
      cohorts: globalThis.Array.isArray(object?.cohorts) ? object.cohorts.map((e: any) => Cohort.fromJSON(e)) : [],
      cohortsRange: isSet(object.cohortsRange) ? CohortsRange.fromJSON(object.cohortsRange) : undefined,
      cohortReportSettings: isSet(object.cohortReportSettings)
        ? CohortReportSettings.fromJSON(object.cohortReportSettings)
        : undefined,
    };
  },

  toJSON(message: CohortSpec): unknown {
    const obj: any = {};
    if (message.cohorts?.length) {
      obj.cohorts = message.cohorts.map((e) => Cohort.toJSON(e));
    }
    if (message.cohortsRange !== undefined) {
      obj.cohortsRange = CohortsRange.toJSON(message.cohortsRange);
    }
    if (message.cohortReportSettings !== undefined) {
      obj.cohortReportSettings = CohortReportSettings.toJSON(message.cohortReportSettings);
    }
    return obj;
  },

  create(base?: DeepPartial<CohortSpec>): CohortSpec {
    return CohortSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CohortSpec>): CohortSpec {
    const message = createBaseCohortSpec();
    message.cohorts = object.cohorts?.map((e) => Cohort.fromPartial(e)) || [];
    message.cohortsRange = (object.cohortsRange !== undefined && object.cohortsRange !== null)
      ? CohortsRange.fromPartial(object.cohortsRange)
      : undefined;
    message.cohortReportSettings = (object.cohortReportSettings !== undefined && object.cohortReportSettings !== null)
      ? CohortReportSettings.fromPartial(object.cohortReportSettings)
      : undefined;
    return message;
  },
};

function createBaseCohort(): Cohort {
  return { name: "", dimension: "", dateRange: undefined };
}

export const Cohort: MessageFns<Cohort> = {
  encode(message: Cohort, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.dimension !== "") {
      writer.uint32(18).string(message.dimension);
    }
    if (message.dateRange !== undefined) {
      DateRange.encode(message.dateRange, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cohort {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCohort();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dimension = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.dateRange = DateRange.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cohort {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      dimension: isSet(object.dimension) ? globalThis.String(object.dimension) : "",
      dateRange: isSet(object.dateRange) ? DateRange.fromJSON(object.dateRange) : undefined,
    };
  },

  toJSON(message: Cohort): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.dimension !== "") {
      obj.dimension = message.dimension;
    }
    if (message.dateRange !== undefined) {
      obj.dateRange = DateRange.toJSON(message.dateRange);
    }
    return obj;
  },

  create(base?: DeepPartial<Cohort>): Cohort {
    return Cohort.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Cohort>): Cohort {
    const message = createBaseCohort();
    message.name = object.name ?? "";
    message.dimension = object.dimension ?? "";
    message.dateRange = (object.dateRange !== undefined && object.dateRange !== null)
      ? DateRange.fromPartial(object.dateRange)
      : undefined;
    return message;
  },
};

function createBaseCohortsRange(): CohortsRange {
  return { granularity: 0, startOffset: 0, endOffset: 0 };
}

export const CohortsRange: MessageFns<CohortsRange> = {
  encode(message: CohortsRange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.granularity !== 0) {
      writer.uint32(8).int32(message.granularity);
    }
    if (message.startOffset !== 0) {
      writer.uint32(16).int32(message.startOffset);
    }
    if (message.endOffset !== 0) {
      writer.uint32(24).int32(message.endOffset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CohortsRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCohortsRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.granularity = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.startOffset = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.endOffset = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CohortsRange {
    return {
      granularity: isSet(object.granularity) ? cohortsRange_GranularityFromJSON(object.granularity) : 0,
      startOffset: isSet(object.startOffset) ? globalThis.Number(object.startOffset) : 0,
      endOffset: isSet(object.endOffset) ? globalThis.Number(object.endOffset) : 0,
    };
  },

  toJSON(message: CohortsRange): unknown {
    const obj: any = {};
    if (message.granularity !== 0) {
      obj.granularity = cohortsRange_GranularityToJSON(message.granularity);
    }
    if (message.startOffset !== 0) {
      obj.startOffset = Math.round(message.startOffset);
    }
    if (message.endOffset !== 0) {
      obj.endOffset = Math.round(message.endOffset);
    }
    return obj;
  },

  create(base?: DeepPartial<CohortsRange>): CohortsRange {
    return CohortsRange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CohortsRange>): CohortsRange {
    const message = createBaseCohortsRange();
    message.granularity = object.granularity ?? 0;
    message.startOffset = object.startOffset ?? 0;
    message.endOffset = object.endOffset ?? 0;
    return message;
  },
};

function createBaseCohortReportSettings(): CohortReportSettings {
  return { accumulate: false };
}

export const CohortReportSettings: MessageFns<CohortReportSettings> = {
  encode(message: CohortReportSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accumulate !== false) {
      writer.uint32(8).bool(message.accumulate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CohortReportSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCohortReportSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accumulate = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CohortReportSettings {
    return { accumulate: isSet(object.accumulate) ? globalThis.Boolean(object.accumulate) : false };
  },

  toJSON(message: CohortReportSettings): unknown {
    const obj: any = {};
    if (message.accumulate !== false) {
      obj.accumulate = message.accumulate;
    }
    return obj;
  },

  create(base?: DeepPartial<CohortReportSettings>): CohortReportSettings {
    return CohortReportSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CohortReportSettings>): CohortReportSettings {
    const message = createBaseCohortReportSettings();
    message.accumulate = object.accumulate ?? false;
    return message;
  },
};

function createBaseResponseMetaData(): ResponseMetaData {
  return {
    dataLossFromOtherRow: false,
    schemaRestrictionResponse: undefined,
    currencyCode: undefined,
    timeZone: undefined,
    emptyReason: undefined,
    subjectToThresholding: undefined,
  };
}

export const ResponseMetaData: MessageFns<ResponseMetaData> = {
  encode(message: ResponseMetaData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dataLossFromOtherRow !== false) {
      writer.uint32(24).bool(message.dataLossFromOtherRow);
    }
    if (message.schemaRestrictionResponse !== undefined) {
      ResponseMetaData_SchemaRestrictionResponse.encode(message.schemaRestrictionResponse, writer.uint32(34).fork())
        .join();
    }
    if (message.currencyCode !== undefined) {
      writer.uint32(42).string(message.currencyCode);
    }
    if (message.timeZone !== undefined) {
      writer.uint32(50).string(message.timeZone);
    }
    if (message.emptyReason !== undefined) {
      writer.uint32(58).string(message.emptyReason);
    }
    if (message.subjectToThresholding !== undefined) {
      writer.uint32(64).bool(message.subjectToThresholding);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResponseMetaData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponseMetaData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 24) {
            break;
          }

          message.dataLossFromOtherRow = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.schemaRestrictionResponse = ResponseMetaData_SchemaRestrictionResponse.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.currencyCode = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.timeZone = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.emptyReason = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.subjectToThresholding = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResponseMetaData {
    return {
      dataLossFromOtherRow: isSet(object.dataLossFromOtherRow)
        ? globalThis.Boolean(object.dataLossFromOtherRow)
        : false,
      schemaRestrictionResponse: isSet(object.schemaRestrictionResponse)
        ? ResponseMetaData_SchemaRestrictionResponse.fromJSON(object.schemaRestrictionResponse)
        : undefined,
      currencyCode: isSet(object.currencyCode) ? globalThis.String(object.currencyCode) : undefined,
      timeZone: isSet(object.timeZone) ? globalThis.String(object.timeZone) : undefined,
      emptyReason: isSet(object.emptyReason) ? globalThis.String(object.emptyReason) : undefined,
      subjectToThresholding: isSet(object.subjectToThresholding)
        ? globalThis.Boolean(object.subjectToThresholding)
        : undefined,
    };
  },

  toJSON(message: ResponseMetaData): unknown {
    const obj: any = {};
    if (message.dataLossFromOtherRow !== false) {
      obj.dataLossFromOtherRow = message.dataLossFromOtherRow;
    }
    if (message.schemaRestrictionResponse !== undefined) {
      obj.schemaRestrictionResponse = ResponseMetaData_SchemaRestrictionResponse.toJSON(
        message.schemaRestrictionResponse,
      );
    }
    if (message.currencyCode !== undefined) {
      obj.currencyCode = message.currencyCode;
    }
    if (message.timeZone !== undefined) {
      obj.timeZone = message.timeZone;
    }
    if (message.emptyReason !== undefined) {
      obj.emptyReason = message.emptyReason;
    }
    if (message.subjectToThresholding !== undefined) {
      obj.subjectToThresholding = message.subjectToThresholding;
    }
    return obj;
  },

  create(base?: DeepPartial<ResponseMetaData>): ResponseMetaData {
    return ResponseMetaData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResponseMetaData>): ResponseMetaData {
    const message = createBaseResponseMetaData();
    message.dataLossFromOtherRow = object.dataLossFromOtherRow ?? false;
    message.schemaRestrictionResponse =
      (object.schemaRestrictionResponse !== undefined && object.schemaRestrictionResponse !== null)
        ? ResponseMetaData_SchemaRestrictionResponse.fromPartial(object.schemaRestrictionResponse)
        : undefined;
    message.currencyCode = object.currencyCode ?? undefined;
    message.timeZone = object.timeZone ?? undefined;
    message.emptyReason = object.emptyReason ?? undefined;
    message.subjectToThresholding = object.subjectToThresholding ?? undefined;
    return message;
  },
};

function createBaseResponseMetaData_SchemaRestrictionResponse(): ResponseMetaData_SchemaRestrictionResponse {
  return { activeMetricRestrictions: [] };
}

export const ResponseMetaData_SchemaRestrictionResponse: MessageFns<ResponseMetaData_SchemaRestrictionResponse> = {
  encode(message: ResponseMetaData_SchemaRestrictionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.activeMetricRestrictions) {
      ResponseMetaData_SchemaRestrictionResponse_ActiveMetricRestriction.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResponseMetaData_SchemaRestrictionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponseMetaData_SchemaRestrictionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.activeMetricRestrictions.push(
            ResponseMetaData_SchemaRestrictionResponse_ActiveMetricRestriction.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResponseMetaData_SchemaRestrictionResponse {
    return {
      activeMetricRestrictions: globalThis.Array.isArray(object?.activeMetricRestrictions)
        ? object.activeMetricRestrictions.map((e: any) =>
          ResponseMetaData_SchemaRestrictionResponse_ActiveMetricRestriction.fromJSON(e)
        )
        : [],
    };
  },

  toJSON(message: ResponseMetaData_SchemaRestrictionResponse): unknown {
    const obj: any = {};
    if (message.activeMetricRestrictions?.length) {
      obj.activeMetricRestrictions = message.activeMetricRestrictions.map((e) =>
        ResponseMetaData_SchemaRestrictionResponse_ActiveMetricRestriction.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<ResponseMetaData_SchemaRestrictionResponse>): ResponseMetaData_SchemaRestrictionResponse {
    return ResponseMetaData_SchemaRestrictionResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ResponseMetaData_SchemaRestrictionResponse>,
  ): ResponseMetaData_SchemaRestrictionResponse {
    const message = createBaseResponseMetaData_SchemaRestrictionResponse();
    message.activeMetricRestrictions =
      object.activeMetricRestrictions?.map((e) =>
        ResponseMetaData_SchemaRestrictionResponse_ActiveMetricRestriction.fromPartial(e)
      ) || [];
    return message;
  },
};

function createBaseResponseMetaData_SchemaRestrictionResponse_ActiveMetricRestriction(): ResponseMetaData_SchemaRestrictionResponse_ActiveMetricRestriction {
  return { metricName: undefined, restrictedMetricTypes: [] };
}

export const ResponseMetaData_SchemaRestrictionResponse_ActiveMetricRestriction: MessageFns<
  ResponseMetaData_SchemaRestrictionResponse_ActiveMetricRestriction
> = {
  encode(
    message: ResponseMetaData_SchemaRestrictionResponse_ActiveMetricRestriction,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.metricName !== undefined) {
      writer.uint32(10).string(message.metricName);
    }
    writer.uint32(18).fork();
    for (const v of message.restrictedMetricTypes) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ResponseMetaData_SchemaRestrictionResponse_ActiveMetricRestriction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponseMetaData_SchemaRestrictionResponse_ActiveMetricRestriction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metricName = reader.string();
          continue;
        case 2:
          if (tag === 16) {
            message.restrictedMetricTypes.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.restrictedMetricTypes.push(reader.int32() as any);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResponseMetaData_SchemaRestrictionResponse_ActiveMetricRestriction {
    return {
      metricName: isSet(object.metricName) ? globalThis.String(object.metricName) : undefined,
      restrictedMetricTypes: globalThis.Array.isArray(object?.restrictedMetricTypes)
        ? object.restrictedMetricTypes.map((e: any) => restrictedMetricTypeFromJSON(e))
        : [],
    };
  },

  toJSON(message: ResponseMetaData_SchemaRestrictionResponse_ActiveMetricRestriction): unknown {
    const obj: any = {};
    if (message.metricName !== undefined) {
      obj.metricName = message.metricName;
    }
    if (message.restrictedMetricTypes?.length) {
      obj.restrictedMetricTypes = message.restrictedMetricTypes.map((e) => restrictedMetricTypeToJSON(e));
    }
    return obj;
  },

  create(
    base?: DeepPartial<ResponseMetaData_SchemaRestrictionResponse_ActiveMetricRestriction>,
  ): ResponseMetaData_SchemaRestrictionResponse_ActiveMetricRestriction {
    return ResponseMetaData_SchemaRestrictionResponse_ActiveMetricRestriction.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ResponseMetaData_SchemaRestrictionResponse_ActiveMetricRestriction>,
  ): ResponseMetaData_SchemaRestrictionResponse_ActiveMetricRestriction {
    const message = createBaseResponseMetaData_SchemaRestrictionResponse_ActiveMetricRestriction();
    message.metricName = object.metricName ?? undefined;
    message.restrictedMetricTypes = object.restrictedMetricTypes?.map((e) => e) || [];
    return message;
  },
};

function createBaseDimensionHeader(): DimensionHeader {
  return { name: "" };
}

export const DimensionHeader: MessageFns<DimensionHeader> = {
  encode(message: DimensionHeader, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DimensionHeader {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDimensionHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DimensionHeader {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DimensionHeader): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DimensionHeader>): DimensionHeader {
    return DimensionHeader.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DimensionHeader>): DimensionHeader {
    const message = createBaseDimensionHeader();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseMetricHeader(): MetricHeader {
  return { name: "", type: 0 };
}

export const MetricHeader: MessageFns<MetricHeader> = {
  encode(message: MetricHeader, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MetricHeader {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricHeader {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? metricTypeFromJSON(object.type) : 0,
    };
  },

  toJSON(message: MetricHeader): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== 0) {
      obj.type = metricTypeToJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<MetricHeader>): MetricHeader {
    return MetricHeader.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MetricHeader>): MetricHeader {
    const message = createBaseMetricHeader();
    message.name = object.name ?? "";
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseRow(): Row {
  return { dimensionValues: [], metricValues: [] };
}

export const Row: MessageFns<Row> = {
  encode(message: Row, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.dimensionValues) {
      DimensionValue.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.metricValues) {
      MetricValue.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Row {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dimensionValues.push(DimensionValue.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.metricValues.push(MetricValue.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Row {
    return {
      dimensionValues: globalThis.Array.isArray(object?.dimensionValues)
        ? object.dimensionValues.map((e: any) => DimensionValue.fromJSON(e))
        : [],
      metricValues: globalThis.Array.isArray(object?.metricValues)
        ? object.metricValues.map((e: any) => MetricValue.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Row): unknown {
    const obj: any = {};
    if (message.dimensionValues?.length) {
      obj.dimensionValues = message.dimensionValues.map((e) => DimensionValue.toJSON(e));
    }
    if (message.metricValues?.length) {
      obj.metricValues = message.metricValues.map((e) => MetricValue.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Row>): Row {
    return Row.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Row>): Row {
    const message = createBaseRow();
    message.dimensionValues = object.dimensionValues?.map((e) => DimensionValue.fromPartial(e)) || [];
    message.metricValues = object.metricValues?.map((e) => MetricValue.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDimensionValue(): DimensionValue {
  return { value: undefined };
}

export const DimensionValue: MessageFns<DimensionValue> = {
  encode(message: DimensionValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== undefined) {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DimensionValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDimensionValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DimensionValue {
    return { value: isSet(object.value) ? globalThis.String(object.value) : undefined };
  },

  toJSON(message: DimensionValue): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<DimensionValue>): DimensionValue {
    return DimensionValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DimensionValue>): DimensionValue {
    const message = createBaseDimensionValue();
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseMetricValue(): MetricValue {
  return { value: undefined };
}

export const MetricValue: MessageFns<MetricValue> = {
  encode(message: MetricValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== undefined) {
      writer.uint32(34).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MetricValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 34) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricValue {
    return { value: isSet(object.value) ? globalThis.String(object.value) : undefined };
  },

  toJSON(message: MetricValue): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<MetricValue>): MetricValue {
    return MetricValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MetricValue>): MetricValue {
    const message = createBaseMetricValue();
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBasePropertyQuota(): PropertyQuota {
  return {
    tokensPerDay: undefined,
    tokensPerHour: undefined,
    concurrentRequests: undefined,
    serverErrorsPerProjectPerHour: undefined,
    potentiallyThresholdedRequestsPerHour: undefined,
    tokensPerProjectPerHour: undefined,
  };
}

export const PropertyQuota: MessageFns<PropertyQuota> = {
  encode(message: PropertyQuota, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tokensPerDay !== undefined) {
      QuotaStatus.encode(message.tokensPerDay, writer.uint32(10).fork()).join();
    }
    if (message.tokensPerHour !== undefined) {
      QuotaStatus.encode(message.tokensPerHour, writer.uint32(18).fork()).join();
    }
    if (message.concurrentRequests !== undefined) {
      QuotaStatus.encode(message.concurrentRequests, writer.uint32(26).fork()).join();
    }
    if (message.serverErrorsPerProjectPerHour !== undefined) {
      QuotaStatus.encode(message.serverErrorsPerProjectPerHour, writer.uint32(34).fork()).join();
    }
    if (message.potentiallyThresholdedRequestsPerHour !== undefined) {
      QuotaStatus.encode(message.potentiallyThresholdedRequestsPerHour, writer.uint32(42).fork()).join();
    }
    if (message.tokensPerProjectPerHour !== undefined) {
      QuotaStatus.encode(message.tokensPerProjectPerHour, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PropertyQuota {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePropertyQuota();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tokensPerDay = QuotaStatus.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tokensPerHour = QuotaStatus.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.concurrentRequests = QuotaStatus.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.serverErrorsPerProjectPerHour = QuotaStatus.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.potentiallyThresholdedRequestsPerHour = QuotaStatus.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.tokensPerProjectPerHour = QuotaStatus.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PropertyQuota {
    return {
      tokensPerDay: isSet(object.tokensPerDay) ? QuotaStatus.fromJSON(object.tokensPerDay) : undefined,
      tokensPerHour: isSet(object.tokensPerHour) ? QuotaStatus.fromJSON(object.tokensPerHour) : undefined,
      concurrentRequests: isSet(object.concurrentRequests)
        ? QuotaStatus.fromJSON(object.concurrentRequests)
        : undefined,
      serverErrorsPerProjectPerHour: isSet(object.serverErrorsPerProjectPerHour)
        ? QuotaStatus.fromJSON(object.serverErrorsPerProjectPerHour)
        : undefined,
      potentiallyThresholdedRequestsPerHour: isSet(object.potentiallyThresholdedRequestsPerHour)
        ? QuotaStatus.fromJSON(object.potentiallyThresholdedRequestsPerHour)
        : undefined,
      tokensPerProjectPerHour: isSet(object.tokensPerProjectPerHour)
        ? QuotaStatus.fromJSON(object.tokensPerProjectPerHour)
        : undefined,
    };
  },

  toJSON(message: PropertyQuota): unknown {
    const obj: any = {};
    if (message.tokensPerDay !== undefined) {
      obj.tokensPerDay = QuotaStatus.toJSON(message.tokensPerDay);
    }
    if (message.tokensPerHour !== undefined) {
      obj.tokensPerHour = QuotaStatus.toJSON(message.tokensPerHour);
    }
    if (message.concurrentRequests !== undefined) {
      obj.concurrentRequests = QuotaStatus.toJSON(message.concurrentRequests);
    }
    if (message.serverErrorsPerProjectPerHour !== undefined) {
      obj.serverErrorsPerProjectPerHour = QuotaStatus.toJSON(message.serverErrorsPerProjectPerHour);
    }
    if (message.potentiallyThresholdedRequestsPerHour !== undefined) {
      obj.potentiallyThresholdedRequestsPerHour = QuotaStatus.toJSON(message.potentiallyThresholdedRequestsPerHour);
    }
    if (message.tokensPerProjectPerHour !== undefined) {
      obj.tokensPerProjectPerHour = QuotaStatus.toJSON(message.tokensPerProjectPerHour);
    }
    return obj;
  },

  create(base?: DeepPartial<PropertyQuota>): PropertyQuota {
    return PropertyQuota.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PropertyQuota>): PropertyQuota {
    const message = createBasePropertyQuota();
    message.tokensPerDay = (object.tokensPerDay !== undefined && object.tokensPerDay !== null)
      ? QuotaStatus.fromPartial(object.tokensPerDay)
      : undefined;
    message.tokensPerHour = (object.tokensPerHour !== undefined && object.tokensPerHour !== null)
      ? QuotaStatus.fromPartial(object.tokensPerHour)
      : undefined;
    message.concurrentRequests = (object.concurrentRequests !== undefined && object.concurrentRequests !== null)
      ? QuotaStatus.fromPartial(object.concurrentRequests)
      : undefined;
    message.serverErrorsPerProjectPerHour =
      (object.serverErrorsPerProjectPerHour !== undefined && object.serverErrorsPerProjectPerHour !== null)
        ? QuotaStatus.fromPartial(object.serverErrorsPerProjectPerHour)
        : undefined;
    message.potentiallyThresholdedRequestsPerHour =
      (object.potentiallyThresholdedRequestsPerHour !== undefined &&
          object.potentiallyThresholdedRequestsPerHour !== null)
        ? QuotaStatus.fromPartial(object.potentiallyThresholdedRequestsPerHour)
        : undefined;
    message.tokensPerProjectPerHour =
      (object.tokensPerProjectPerHour !== undefined && object.tokensPerProjectPerHour !== null)
        ? QuotaStatus.fromPartial(object.tokensPerProjectPerHour)
        : undefined;
    return message;
  },
};

function createBaseQuotaStatus(): QuotaStatus {
  return { consumed: 0, remaining: 0 };
}

export const QuotaStatus: MessageFns<QuotaStatus> = {
  encode(message: QuotaStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.consumed !== 0) {
      writer.uint32(8).int32(message.consumed);
    }
    if (message.remaining !== 0) {
      writer.uint32(16).int32(message.remaining);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuotaStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuotaStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.consumed = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.remaining = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuotaStatus {
    return {
      consumed: isSet(object.consumed) ? globalThis.Number(object.consumed) : 0,
      remaining: isSet(object.remaining) ? globalThis.Number(object.remaining) : 0,
    };
  },

  toJSON(message: QuotaStatus): unknown {
    const obj: any = {};
    if (message.consumed !== 0) {
      obj.consumed = Math.round(message.consumed);
    }
    if (message.remaining !== 0) {
      obj.remaining = Math.round(message.remaining);
    }
    return obj;
  },

  create(base?: DeepPartial<QuotaStatus>): QuotaStatus {
    return QuotaStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QuotaStatus>): QuotaStatus {
    const message = createBaseQuotaStatus();
    message.consumed = object.consumed ?? 0;
    message.remaining = object.remaining ?? 0;
    return message;
  },
};

function createBaseFunnelBreakdown(): FunnelBreakdown {
  return { breakdownDimension: undefined, limit: undefined };
}

export const FunnelBreakdown: MessageFns<FunnelBreakdown> = {
  encode(message: FunnelBreakdown, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.breakdownDimension !== undefined) {
      Dimension.encode(message.breakdownDimension, writer.uint32(10).fork()).join();
    }
    if (message.limit !== undefined) {
      writer.uint32(16).int64(message.limit.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunnelBreakdown {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunnelBreakdown();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.breakdownDimension = Dimension.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.limit = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunnelBreakdown {
    return {
      breakdownDimension: isSet(object.breakdownDimension) ? Dimension.fromJSON(object.breakdownDimension) : undefined,
      limit: isSet(object.limit) ? Long.fromValue(object.limit) : undefined,
    };
  },

  toJSON(message: FunnelBreakdown): unknown {
    const obj: any = {};
    if (message.breakdownDimension !== undefined) {
      obj.breakdownDimension = Dimension.toJSON(message.breakdownDimension);
    }
    if (message.limit !== undefined) {
      obj.limit = (message.limit || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<FunnelBreakdown>): FunnelBreakdown {
    return FunnelBreakdown.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FunnelBreakdown>): FunnelBreakdown {
    const message = createBaseFunnelBreakdown();
    message.breakdownDimension = (object.breakdownDimension !== undefined && object.breakdownDimension !== null)
      ? Dimension.fromPartial(object.breakdownDimension)
      : undefined;
    message.limit = (object.limit !== undefined && object.limit !== null) ? Long.fromValue(object.limit) : undefined;
    return message;
  },
};

function createBaseFunnelNextAction(): FunnelNextAction {
  return { nextActionDimension: undefined, limit: undefined };
}

export const FunnelNextAction: MessageFns<FunnelNextAction> = {
  encode(message: FunnelNextAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nextActionDimension !== undefined) {
      Dimension.encode(message.nextActionDimension, writer.uint32(10).fork()).join();
    }
    if (message.limit !== undefined) {
      writer.uint32(16).int64(message.limit.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunnelNextAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunnelNextAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nextActionDimension = Dimension.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.limit = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunnelNextAction {
    return {
      nextActionDimension: isSet(object.nextActionDimension)
        ? Dimension.fromJSON(object.nextActionDimension)
        : undefined,
      limit: isSet(object.limit) ? Long.fromValue(object.limit) : undefined,
    };
  },

  toJSON(message: FunnelNextAction): unknown {
    const obj: any = {};
    if (message.nextActionDimension !== undefined) {
      obj.nextActionDimension = Dimension.toJSON(message.nextActionDimension);
    }
    if (message.limit !== undefined) {
      obj.limit = (message.limit || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<FunnelNextAction>): FunnelNextAction {
    return FunnelNextAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FunnelNextAction>): FunnelNextAction {
    const message = createBaseFunnelNextAction();
    message.nextActionDimension = (object.nextActionDimension !== undefined && object.nextActionDimension !== null)
      ? Dimension.fromPartial(object.nextActionDimension)
      : undefined;
    message.limit = (object.limit !== undefined && object.limit !== null) ? Long.fromValue(object.limit) : undefined;
    return message;
  },
};

function createBaseFunnel(): Funnel {
  return { isOpenFunnel: false, steps: [] };
}

export const Funnel: MessageFns<Funnel> = {
  encode(message: Funnel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isOpenFunnel !== false) {
      writer.uint32(8).bool(message.isOpenFunnel);
    }
    for (const v of message.steps) {
      FunnelStep.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Funnel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunnel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.isOpenFunnel = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.steps.push(FunnelStep.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Funnel {
    return {
      isOpenFunnel: isSet(object.isOpenFunnel) ? globalThis.Boolean(object.isOpenFunnel) : false,
      steps: globalThis.Array.isArray(object?.steps) ? object.steps.map((e: any) => FunnelStep.fromJSON(e)) : [],
    };
  },

  toJSON(message: Funnel): unknown {
    const obj: any = {};
    if (message.isOpenFunnel !== false) {
      obj.isOpenFunnel = message.isOpenFunnel;
    }
    if (message.steps?.length) {
      obj.steps = message.steps.map((e) => FunnelStep.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Funnel>): Funnel {
    return Funnel.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Funnel>): Funnel {
    const message = createBaseFunnel();
    message.isOpenFunnel = object.isOpenFunnel ?? false;
    message.steps = object.steps?.map((e) => FunnelStep.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFunnelStep(): FunnelStep {
  return { name: "", isDirectlyFollowedBy: false, withinDurationFromPriorStep: undefined, filterExpression: undefined };
}

export const FunnelStep: MessageFns<FunnelStep> = {
  encode(message: FunnelStep, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.isDirectlyFollowedBy !== false) {
      writer.uint32(16).bool(message.isDirectlyFollowedBy);
    }
    if (message.withinDurationFromPriorStep !== undefined) {
      Duration.encode(message.withinDurationFromPriorStep, writer.uint32(26).fork()).join();
    }
    if (message.filterExpression !== undefined) {
      FunnelFilterExpression.encode(message.filterExpression, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunnelStep {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunnelStep();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.isDirectlyFollowedBy = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.withinDurationFromPriorStep = Duration.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filterExpression = FunnelFilterExpression.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunnelStep {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      isDirectlyFollowedBy: isSet(object.isDirectlyFollowedBy)
        ? globalThis.Boolean(object.isDirectlyFollowedBy)
        : false,
      withinDurationFromPriorStep: isSet(object.withinDurationFromPriorStep)
        ? Duration.fromJSON(object.withinDurationFromPriorStep)
        : undefined,
      filterExpression: isSet(object.filterExpression)
        ? FunnelFilterExpression.fromJSON(object.filterExpression)
        : undefined,
    };
  },

  toJSON(message: FunnelStep): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.isDirectlyFollowedBy !== false) {
      obj.isDirectlyFollowedBy = message.isDirectlyFollowedBy;
    }
    if (message.withinDurationFromPriorStep !== undefined) {
      obj.withinDurationFromPriorStep = Duration.toJSON(message.withinDurationFromPriorStep);
    }
    if (message.filterExpression !== undefined) {
      obj.filterExpression = FunnelFilterExpression.toJSON(message.filterExpression);
    }
    return obj;
  },

  create(base?: DeepPartial<FunnelStep>): FunnelStep {
    return FunnelStep.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FunnelStep>): FunnelStep {
    const message = createBaseFunnelStep();
    message.name = object.name ?? "";
    message.isDirectlyFollowedBy = object.isDirectlyFollowedBy ?? false;
    message.withinDurationFromPriorStep =
      (object.withinDurationFromPriorStep !== undefined && object.withinDurationFromPriorStep !== null)
        ? Duration.fromPartial(object.withinDurationFromPriorStep)
        : undefined;
    message.filterExpression = (object.filterExpression !== undefined && object.filterExpression !== null)
      ? FunnelFilterExpression.fromPartial(object.filterExpression)
      : undefined;
    return message;
  },
};

function createBaseFunnelSubReport(): FunnelSubReport {
  return { dimensionHeaders: [], metricHeaders: [], rows: [], metadata: undefined };
}

export const FunnelSubReport: MessageFns<FunnelSubReport> = {
  encode(message: FunnelSubReport, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.dimensionHeaders) {
      DimensionHeader.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.metricHeaders) {
      MetricHeader.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.rows) {
      Row.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined) {
      FunnelResponseMetadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunnelSubReport {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunnelSubReport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dimensionHeaders.push(DimensionHeader.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.metricHeaders.push(MetricHeader.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.rows.push(Row.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.metadata = FunnelResponseMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunnelSubReport {
    return {
      dimensionHeaders: globalThis.Array.isArray(object?.dimensionHeaders)
        ? object.dimensionHeaders.map((e: any) => DimensionHeader.fromJSON(e))
        : [],
      metricHeaders: globalThis.Array.isArray(object?.metricHeaders)
        ? object.metricHeaders.map((e: any) => MetricHeader.fromJSON(e))
        : [],
      rows: globalThis.Array.isArray(object?.rows) ? object.rows.map((e: any) => Row.fromJSON(e)) : [],
      metadata: isSet(object.metadata) ? FunnelResponseMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: FunnelSubReport): unknown {
    const obj: any = {};
    if (message.dimensionHeaders?.length) {
      obj.dimensionHeaders = message.dimensionHeaders.map((e) => DimensionHeader.toJSON(e));
    }
    if (message.metricHeaders?.length) {
      obj.metricHeaders = message.metricHeaders.map((e) => MetricHeader.toJSON(e));
    }
    if (message.rows?.length) {
      obj.rows = message.rows.map((e) => Row.toJSON(e));
    }
    if (message.metadata !== undefined) {
      obj.metadata = FunnelResponseMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create(base?: DeepPartial<FunnelSubReport>): FunnelSubReport {
    return FunnelSubReport.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FunnelSubReport>): FunnelSubReport {
    const message = createBaseFunnelSubReport();
    message.dimensionHeaders = object.dimensionHeaders?.map((e) => DimensionHeader.fromPartial(e)) || [];
    message.metricHeaders = object.metricHeaders?.map((e) => MetricHeader.fromPartial(e)) || [];
    message.rows = object.rows?.map((e) => Row.fromPartial(e)) || [];
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? FunnelResponseMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseUserSegment(): UserSegment {
  return { userInclusionCriteria: undefined, exclusion: undefined };
}

export const UserSegment: MessageFns<UserSegment> = {
  encode(message: UserSegment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userInclusionCriteria !== undefined) {
      UserSegmentCriteria.encode(message.userInclusionCriteria, writer.uint32(10).fork()).join();
    }
    if (message.exclusion !== undefined) {
      UserSegmentExclusion.encode(message.exclusion, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserSegment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserSegment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userInclusionCriteria = UserSegmentCriteria.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.exclusion = UserSegmentExclusion.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserSegment {
    return {
      userInclusionCriteria: isSet(object.userInclusionCriteria)
        ? UserSegmentCriteria.fromJSON(object.userInclusionCriteria)
        : undefined,
      exclusion: isSet(object.exclusion) ? UserSegmentExclusion.fromJSON(object.exclusion) : undefined,
    };
  },

  toJSON(message: UserSegment): unknown {
    const obj: any = {};
    if (message.userInclusionCriteria !== undefined) {
      obj.userInclusionCriteria = UserSegmentCriteria.toJSON(message.userInclusionCriteria);
    }
    if (message.exclusion !== undefined) {
      obj.exclusion = UserSegmentExclusion.toJSON(message.exclusion);
    }
    return obj;
  },

  create(base?: DeepPartial<UserSegment>): UserSegment {
    return UserSegment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserSegment>): UserSegment {
    const message = createBaseUserSegment();
    message.userInclusionCriteria =
      (object.userInclusionCriteria !== undefined && object.userInclusionCriteria !== null)
        ? UserSegmentCriteria.fromPartial(object.userInclusionCriteria)
        : undefined;
    message.exclusion = (object.exclusion !== undefined && object.exclusion !== null)
      ? UserSegmentExclusion.fromPartial(object.exclusion)
      : undefined;
    return message;
  },
};

function createBaseUserSegmentCriteria(): UserSegmentCriteria {
  return { andConditionGroups: [], andSequenceGroups: [] };
}

export const UserSegmentCriteria: MessageFns<UserSegmentCriteria> = {
  encode(message: UserSegmentCriteria, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.andConditionGroups) {
      UserSegmentConditionGroup.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.andSequenceGroups) {
      UserSegmentSequenceGroup.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserSegmentCriteria {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserSegmentCriteria();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.andConditionGroups.push(UserSegmentConditionGroup.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.andSequenceGroups.push(UserSegmentSequenceGroup.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserSegmentCriteria {
    return {
      andConditionGroups: globalThis.Array.isArray(object?.andConditionGroups)
        ? object.andConditionGroups.map((e: any) => UserSegmentConditionGroup.fromJSON(e))
        : [],
      andSequenceGroups: globalThis.Array.isArray(object?.andSequenceGroups)
        ? object.andSequenceGroups.map((e: any) => UserSegmentSequenceGroup.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UserSegmentCriteria): unknown {
    const obj: any = {};
    if (message.andConditionGroups?.length) {
      obj.andConditionGroups = message.andConditionGroups.map((e) => UserSegmentConditionGroup.toJSON(e));
    }
    if (message.andSequenceGroups?.length) {
      obj.andSequenceGroups = message.andSequenceGroups.map((e) => UserSegmentSequenceGroup.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<UserSegmentCriteria>): UserSegmentCriteria {
    return UserSegmentCriteria.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserSegmentCriteria>): UserSegmentCriteria {
    const message = createBaseUserSegmentCriteria();
    message.andConditionGroups = object.andConditionGroups?.map((e) => UserSegmentConditionGroup.fromPartial(e)) || [];
    message.andSequenceGroups = object.andSequenceGroups?.map((e) => UserSegmentSequenceGroup.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUserSegmentConditionGroup(): UserSegmentConditionGroup {
  return { conditionScoping: 0, segmentFilterExpression: undefined };
}

export const UserSegmentConditionGroup: MessageFns<UserSegmentConditionGroup> = {
  encode(message: UserSegmentConditionGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.conditionScoping !== 0) {
      writer.uint32(8).int32(message.conditionScoping);
    }
    if (message.segmentFilterExpression !== undefined) {
      SegmentFilterExpression.encode(message.segmentFilterExpression, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserSegmentConditionGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserSegmentConditionGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.conditionScoping = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.segmentFilterExpression = SegmentFilterExpression.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserSegmentConditionGroup {
    return {
      conditionScoping: isSet(object.conditionScoping) ? userCriteriaScopingFromJSON(object.conditionScoping) : 0,
      segmentFilterExpression: isSet(object.segmentFilterExpression)
        ? SegmentFilterExpression.fromJSON(object.segmentFilterExpression)
        : undefined,
    };
  },

  toJSON(message: UserSegmentConditionGroup): unknown {
    const obj: any = {};
    if (message.conditionScoping !== 0) {
      obj.conditionScoping = userCriteriaScopingToJSON(message.conditionScoping);
    }
    if (message.segmentFilterExpression !== undefined) {
      obj.segmentFilterExpression = SegmentFilterExpression.toJSON(message.segmentFilterExpression);
    }
    return obj;
  },

  create(base?: DeepPartial<UserSegmentConditionGroup>): UserSegmentConditionGroup {
    return UserSegmentConditionGroup.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserSegmentConditionGroup>): UserSegmentConditionGroup {
    const message = createBaseUserSegmentConditionGroup();
    message.conditionScoping = object.conditionScoping ?? 0;
    message.segmentFilterExpression =
      (object.segmentFilterExpression !== undefined && object.segmentFilterExpression !== null)
        ? SegmentFilterExpression.fromPartial(object.segmentFilterExpression)
        : undefined;
    return message;
  },
};

function createBaseUserSegmentSequenceGroup(): UserSegmentSequenceGroup {
  return { sequenceScoping: 0, sequenceMaximumDuration: undefined, userSequenceSteps: [] };
}

export const UserSegmentSequenceGroup: MessageFns<UserSegmentSequenceGroup> = {
  encode(message: UserSegmentSequenceGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sequenceScoping !== 0) {
      writer.uint32(8).int32(message.sequenceScoping);
    }
    if (message.sequenceMaximumDuration !== undefined) {
      Duration.encode(message.sequenceMaximumDuration, writer.uint32(18).fork()).join();
    }
    for (const v of message.userSequenceSteps) {
      UserSequenceStep.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserSegmentSequenceGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserSegmentSequenceGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sequenceScoping = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sequenceMaximumDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.userSequenceSteps.push(UserSequenceStep.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserSegmentSequenceGroup {
    return {
      sequenceScoping: isSet(object.sequenceScoping) ? userCriteriaScopingFromJSON(object.sequenceScoping) : 0,
      sequenceMaximumDuration: isSet(object.sequenceMaximumDuration)
        ? Duration.fromJSON(object.sequenceMaximumDuration)
        : undefined,
      userSequenceSteps: globalThis.Array.isArray(object?.userSequenceSteps)
        ? object.userSequenceSteps.map((e: any) => UserSequenceStep.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UserSegmentSequenceGroup): unknown {
    const obj: any = {};
    if (message.sequenceScoping !== 0) {
      obj.sequenceScoping = userCriteriaScopingToJSON(message.sequenceScoping);
    }
    if (message.sequenceMaximumDuration !== undefined) {
      obj.sequenceMaximumDuration = Duration.toJSON(message.sequenceMaximumDuration);
    }
    if (message.userSequenceSteps?.length) {
      obj.userSequenceSteps = message.userSequenceSteps.map((e) => UserSequenceStep.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<UserSegmentSequenceGroup>): UserSegmentSequenceGroup {
    return UserSegmentSequenceGroup.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserSegmentSequenceGroup>): UserSegmentSequenceGroup {
    const message = createBaseUserSegmentSequenceGroup();
    message.sequenceScoping = object.sequenceScoping ?? 0;
    message.sequenceMaximumDuration =
      (object.sequenceMaximumDuration !== undefined && object.sequenceMaximumDuration !== null)
        ? Duration.fromPartial(object.sequenceMaximumDuration)
        : undefined;
    message.userSequenceSteps = object.userSequenceSteps?.map((e) => UserSequenceStep.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUserSequenceStep(): UserSequenceStep {
  return { isDirectlyFollowedBy: false, stepScoping: 0, segmentFilterExpression: undefined };
}

export const UserSequenceStep: MessageFns<UserSequenceStep> = {
  encode(message: UserSequenceStep, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isDirectlyFollowedBy !== false) {
      writer.uint32(8).bool(message.isDirectlyFollowedBy);
    }
    if (message.stepScoping !== 0) {
      writer.uint32(16).int32(message.stepScoping);
    }
    if (message.segmentFilterExpression !== undefined) {
      SegmentFilterExpression.encode(message.segmentFilterExpression, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserSequenceStep {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserSequenceStep();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.isDirectlyFollowedBy = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.stepScoping = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.segmentFilterExpression = SegmentFilterExpression.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserSequenceStep {
    return {
      isDirectlyFollowedBy: isSet(object.isDirectlyFollowedBy)
        ? globalThis.Boolean(object.isDirectlyFollowedBy)
        : false,
      stepScoping: isSet(object.stepScoping) ? userCriteriaScopingFromJSON(object.stepScoping) : 0,
      segmentFilterExpression: isSet(object.segmentFilterExpression)
        ? SegmentFilterExpression.fromJSON(object.segmentFilterExpression)
        : undefined,
    };
  },

  toJSON(message: UserSequenceStep): unknown {
    const obj: any = {};
    if (message.isDirectlyFollowedBy !== false) {
      obj.isDirectlyFollowedBy = message.isDirectlyFollowedBy;
    }
    if (message.stepScoping !== 0) {
      obj.stepScoping = userCriteriaScopingToJSON(message.stepScoping);
    }
    if (message.segmentFilterExpression !== undefined) {
      obj.segmentFilterExpression = SegmentFilterExpression.toJSON(message.segmentFilterExpression);
    }
    return obj;
  },

  create(base?: DeepPartial<UserSequenceStep>): UserSequenceStep {
    return UserSequenceStep.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserSequenceStep>): UserSequenceStep {
    const message = createBaseUserSequenceStep();
    message.isDirectlyFollowedBy = object.isDirectlyFollowedBy ?? false;
    message.stepScoping = object.stepScoping ?? 0;
    message.segmentFilterExpression =
      (object.segmentFilterExpression !== undefined && object.segmentFilterExpression !== null)
        ? SegmentFilterExpression.fromPartial(object.segmentFilterExpression)
        : undefined;
    return message;
  },
};

function createBaseUserSegmentExclusion(): UserSegmentExclusion {
  return { userExclusionDuration: 0, userExclusionCriteria: undefined };
}

export const UserSegmentExclusion: MessageFns<UserSegmentExclusion> = {
  encode(message: UserSegmentExclusion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userExclusionDuration !== 0) {
      writer.uint32(8).int32(message.userExclusionDuration);
    }
    if (message.userExclusionCriteria !== undefined) {
      UserSegmentCriteria.encode(message.userExclusionCriteria, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserSegmentExclusion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserSegmentExclusion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.userExclusionDuration = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userExclusionCriteria = UserSegmentCriteria.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserSegmentExclusion {
    return {
      userExclusionDuration: isSet(object.userExclusionDuration)
        ? userExclusionDurationFromJSON(object.userExclusionDuration)
        : 0,
      userExclusionCriteria: isSet(object.userExclusionCriteria)
        ? UserSegmentCriteria.fromJSON(object.userExclusionCriteria)
        : undefined,
    };
  },

  toJSON(message: UserSegmentExclusion): unknown {
    const obj: any = {};
    if (message.userExclusionDuration !== 0) {
      obj.userExclusionDuration = userExclusionDurationToJSON(message.userExclusionDuration);
    }
    if (message.userExclusionCriteria !== undefined) {
      obj.userExclusionCriteria = UserSegmentCriteria.toJSON(message.userExclusionCriteria);
    }
    return obj;
  },

  create(base?: DeepPartial<UserSegmentExclusion>): UserSegmentExclusion {
    return UserSegmentExclusion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserSegmentExclusion>): UserSegmentExclusion {
    const message = createBaseUserSegmentExclusion();
    message.userExclusionDuration = object.userExclusionDuration ?? 0;
    message.userExclusionCriteria =
      (object.userExclusionCriteria !== undefined && object.userExclusionCriteria !== null)
        ? UserSegmentCriteria.fromPartial(object.userExclusionCriteria)
        : undefined;
    return message;
  },
};

function createBaseSessionSegment(): SessionSegment {
  return { sessionInclusionCriteria: undefined, exclusion: undefined };
}

export const SessionSegment: MessageFns<SessionSegment> = {
  encode(message: SessionSegment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionInclusionCriteria !== undefined) {
      SessionSegmentCriteria.encode(message.sessionInclusionCriteria, writer.uint32(10).fork()).join();
    }
    if (message.exclusion !== undefined) {
      SessionSegmentExclusion.encode(message.exclusion, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SessionSegment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionSegment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sessionInclusionCriteria = SessionSegmentCriteria.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.exclusion = SessionSegmentExclusion.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionSegment {
    return {
      sessionInclusionCriteria: isSet(object.sessionInclusionCriteria)
        ? SessionSegmentCriteria.fromJSON(object.sessionInclusionCriteria)
        : undefined,
      exclusion: isSet(object.exclusion) ? SessionSegmentExclusion.fromJSON(object.exclusion) : undefined,
    };
  },

  toJSON(message: SessionSegment): unknown {
    const obj: any = {};
    if (message.sessionInclusionCriteria !== undefined) {
      obj.sessionInclusionCriteria = SessionSegmentCriteria.toJSON(message.sessionInclusionCriteria);
    }
    if (message.exclusion !== undefined) {
      obj.exclusion = SessionSegmentExclusion.toJSON(message.exclusion);
    }
    return obj;
  },

  create(base?: DeepPartial<SessionSegment>): SessionSegment {
    return SessionSegment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SessionSegment>): SessionSegment {
    const message = createBaseSessionSegment();
    message.sessionInclusionCriteria =
      (object.sessionInclusionCriteria !== undefined && object.sessionInclusionCriteria !== null)
        ? SessionSegmentCriteria.fromPartial(object.sessionInclusionCriteria)
        : undefined;
    message.exclusion = (object.exclusion !== undefined && object.exclusion !== null)
      ? SessionSegmentExclusion.fromPartial(object.exclusion)
      : undefined;
    return message;
  },
};

function createBaseSessionSegmentCriteria(): SessionSegmentCriteria {
  return { andConditionGroups: [] };
}

export const SessionSegmentCriteria: MessageFns<SessionSegmentCriteria> = {
  encode(message: SessionSegmentCriteria, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.andConditionGroups) {
      SessionSegmentConditionGroup.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SessionSegmentCriteria {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionSegmentCriteria();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.andConditionGroups.push(SessionSegmentConditionGroup.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionSegmentCriteria {
    return {
      andConditionGroups: globalThis.Array.isArray(object?.andConditionGroups)
        ? object.andConditionGroups.map((e: any) => SessionSegmentConditionGroup.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SessionSegmentCriteria): unknown {
    const obj: any = {};
    if (message.andConditionGroups?.length) {
      obj.andConditionGroups = message.andConditionGroups.map((e) => SessionSegmentConditionGroup.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SessionSegmentCriteria>): SessionSegmentCriteria {
    return SessionSegmentCriteria.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SessionSegmentCriteria>): SessionSegmentCriteria {
    const message = createBaseSessionSegmentCriteria();
    message.andConditionGroups = object.andConditionGroups?.map((e) => SessionSegmentConditionGroup.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseSessionSegmentConditionGroup(): SessionSegmentConditionGroup {
  return { conditionScoping: 0, segmentFilterExpression: undefined };
}

export const SessionSegmentConditionGroup: MessageFns<SessionSegmentConditionGroup> = {
  encode(message: SessionSegmentConditionGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.conditionScoping !== 0) {
      writer.uint32(8).int32(message.conditionScoping);
    }
    if (message.segmentFilterExpression !== undefined) {
      SegmentFilterExpression.encode(message.segmentFilterExpression, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SessionSegmentConditionGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionSegmentConditionGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.conditionScoping = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.segmentFilterExpression = SegmentFilterExpression.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionSegmentConditionGroup {
    return {
      conditionScoping: isSet(object.conditionScoping) ? sessionCriteriaScopingFromJSON(object.conditionScoping) : 0,
      segmentFilterExpression: isSet(object.segmentFilterExpression)
        ? SegmentFilterExpression.fromJSON(object.segmentFilterExpression)
        : undefined,
    };
  },

  toJSON(message: SessionSegmentConditionGroup): unknown {
    const obj: any = {};
    if (message.conditionScoping !== 0) {
      obj.conditionScoping = sessionCriteriaScopingToJSON(message.conditionScoping);
    }
    if (message.segmentFilterExpression !== undefined) {
      obj.segmentFilterExpression = SegmentFilterExpression.toJSON(message.segmentFilterExpression);
    }
    return obj;
  },

  create(base?: DeepPartial<SessionSegmentConditionGroup>): SessionSegmentConditionGroup {
    return SessionSegmentConditionGroup.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SessionSegmentConditionGroup>): SessionSegmentConditionGroup {
    const message = createBaseSessionSegmentConditionGroup();
    message.conditionScoping = object.conditionScoping ?? 0;
    message.segmentFilterExpression =
      (object.segmentFilterExpression !== undefined && object.segmentFilterExpression !== null)
        ? SegmentFilterExpression.fromPartial(object.segmentFilterExpression)
        : undefined;
    return message;
  },
};

function createBaseSessionSegmentExclusion(): SessionSegmentExclusion {
  return { sessionExclusionDuration: 0, sessionExclusionCriteria: undefined };
}

export const SessionSegmentExclusion: MessageFns<SessionSegmentExclusion> = {
  encode(message: SessionSegmentExclusion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionExclusionDuration !== 0) {
      writer.uint32(8).int32(message.sessionExclusionDuration);
    }
    if (message.sessionExclusionCriteria !== undefined) {
      SessionSegmentCriteria.encode(message.sessionExclusionCriteria, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SessionSegmentExclusion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionSegmentExclusion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionExclusionDuration = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sessionExclusionCriteria = SessionSegmentCriteria.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionSegmentExclusion {
    return {
      sessionExclusionDuration: isSet(object.sessionExclusionDuration)
        ? sessionExclusionDurationFromJSON(object.sessionExclusionDuration)
        : 0,
      sessionExclusionCriteria: isSet(object.sessionExclusionCriteria)
        ? SessionSegmentCriteria.fromJSON(object.sessionExclusionCriteria)
        : undefined,
    };
  },

  toJSON(message: SessionSegmentExclusion): unknown {
    const obj: any = {};
    if (message.sessionExclusionDuration !== 0) {
      obj.sessionExclusionDuration = sessionExclusionDurationToJSON(message.sessionExclusionDuration);
    }
    if (message.sessionExclusionCriteria !== undefined) {
      obj.sessionExclusionCriteria = SessionSegmentCriteria.toJSON(message.sessionExclusionCriteria);
    }
    return obj;
  },

  create(base?: DeepPartial<SessionSegmentExclusion>): SessionSegmentExclusion {
    return SessionSegmentExclusion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SessionSegmentExclusion>): SessionSegmentExclusion {
    const message = createBaseSessionSegmentExclusion();
    message.sessionExclusionDuration = object.sessionExclusionDuration ?? 0;
    message.sessionExclusionCriteria =
      (object.sessionExclusionCriteria !== undefined && object.sessionExclusionCriteria !== null)
        ? SessionSegmentCriteria.fromPartial(object.sessionExclusionCriteria)
        : undefined;
    return message;
  },
};

function createBaseEventSegment(): EventSegment {
  return { eventInclusionCriteria: undefined, exclusion: undefined };
}

export const EventSegment: MessageFns<EventSegment> = {
  encode(message: EventSegment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventInclusionCriteria !== undefined) {
      EventSegmentCriteria.encode(message.eventInclusionCriteria, writer.uint32(10).fork()).join();
    }
    if (message.exclusion !== undefined) {
      EventSegmentExclusion.encode(message.exclusion, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventSegment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventSegment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventInclusionCriteria = EventSegmentCriteria.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.exclusion = EventSegmentExclusion.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventSegment {
    return {
      eventInclusionCriteria: isSet(object.eventInclusionCriteria)
        ? EventSegmentCriteria.fromJSON(object.eventInclusionCriteria)
        : undefined,
      exclusion: isSet(object.exclusion) ? EventSegmentExclusion.fromJSON(object.exclusion) : undefined,
    };
  },

  toJSON(message: EventSegment): unknown {
    const obj: any = {};
    if (message.eventInclusionCriteria !== undefined) {
      obj.eventInclusionCriteria = EventSegmentCriteria.toJSON(message.eventInclusionCriteria);
    }
    if (message.exclusion !== undefined) {
      obj.exclusion = EventSegmentExclusion.toJSON(message.exclusion);
    }
    return obj;
  },

  create(base?: DeepPartial<EventSegment>): EventSegment {
    return EventSegment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventSegment>): EventSegment {
    const message = createBaseEventSegment();
    message.eventInclusionCriteria =
      (object.eventInclusionCriteria !== undefined && object.eventInclusionCriteria !== null)
        ? EventSegmentCriteria.fromPartial(object.eventInclusionCriteria)
        : undefined;
    message.exclusion = (object.exclusion !== undefined && object.exclusion !== null)
      ? EventSegmentExclusion.fromPartial(object.exclusion)
      : undefined;
    return message;
  },
};

function createBaseEventSegmentCriteria(): EventSegmentCriteria {
  return { andConditionGroups: [] };
}

export const EventSegmentCriteria: MessageFns<EventSegmentCriteria> = {
  encode(message: EventSegmentCriteria, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.andConditionGroups) {
      EventSegmentConditionGroup.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventSegmentCriteria {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventSegmentCriteria();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.andConditionGroups.push(EventSegmentConditionGroup.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventSegmentCriteria {
    return {
      andConditionGroups: globalThis.Array.isArray(object?.andConditionGroups)
        ? object.andConditionGroups.map((e: any) => EventSegmentConditionGroup.fromJSON(e))
        : [],
    };
  },

  toJSON(message: EventSegmentCriteria): unknown {
    const obj: any = {};
    if (message.andConditionGroups?.length) {
      obj.andConditionGroups = message.andConditionGroups.map((e) => EventSegmentConditionGroup.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<EventSegmentCriteria>): EventSegmentCriteria {
    return EventSegmentCriteria.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventSegmentCriteria>): EventSegmentCriteria {
    const message = createBaseEventSegmentCriteria();
    message.andConditionGroups = object.andConditionGroups?.map((e) => EventSegmentConditionGroup.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEventSegmentConditionGroup(): EventSegmentConditionGroup {
  return { conditionScoping: 0, segmentFilterExpression: undefined };
}

export const EventSegmentConditionGroup: MessageFns<EventSegmentConditionGroup> = {
  encode(message: EventSegmentConditionGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.conditionScoping !== 0) {
      writer.uint32(8).int32(message.conditionScoping);
    }
    if (message.segmentFilterExpression !== undefined) {
      SegmentFilterExpression.encode(message.segmentFilterExpression, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventSegmentConditionGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventSegmentConditionGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.conditionScoping = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.segmentFilterExpression = SegmentFilterExpression.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventSegmentConditionGroup {
    return {
      conditionScoping: isSet(object.conditionScoping) ? eventCriteriaScopingFromJSON(object.conditionScoping) : 0,
      segmentFilterExpression: isSet(object.segmentFilterExpression)
        ? SegmentFilterExpression.fromJSON(object.segmentFilterExpression)
        : undefined,
    };
  },

  toJSON(message: EventSegmentConditionGroup): unknown {
    const obj: any = {};
    if (message.conditionScoping !== 0) {
      obj.conditionScoping = eventCriteriaScopingToJSON(message.conditionScoping);
    }
    if (message.segmentFilterExpression !== undefined) {
      obj.segmentFilterExpression = SegmentFilterExpression.toJSON(message.segmentFilterExpression);
    }
    return obj;
  },

  create(base?: DeepPartial<EventSegmentConditionGroup>): EventSegmentConditionGroup {
    return EventSegmentConditionGroup.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventSegmentConditionGroup>): EventSegmentConditionGroup {
    const message = createBaseEventSegmentConditionGroup();
    message.conditionScoping = object.conditionScoping ?? 0;
    message.segmentFilterExpression =
      (object.segmentFilterExpression !== undefined && object.segmentFilterExpression !== null)
        ? SegmentFilterExpression.fromPartial(object.segmentFilterExpression)
        : undefined;
    return message;
  },
};

function createBaseEventSegmentExclusion(): EventSegmentExclusion {
  return { eventExclusionDuration: 0, eventExclusionCriteria: undefined };
}

export const EventSegmentExclusion: MessageFns<EventSegmentExclusion> = {
  encode(message: EventSegmentExclusion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventExclusionDuration !== 0) {
      writer.uint32(8).int32(message.eventExclusionDuration);
    }
    if (message.eventExclusionCriteria !== undefined) {
      EventSegmentCriteria.encode(message.eventExclusionCriteria, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventSegmentExclusion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventSegmentExclusion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.eventExclusionDuration = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.eventExclusionCriteria = EventSegmentCriteria.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventSegmentExclusion {
    return {
      eventExclusionDuration: isSet(object.eventExclusionDuration)
        ? eventExclusionDurationFromJSON(object.eventExclusionDuration)
        : 0,
      eventExclusionCriteria: isSet(object.eventExclusionCriteria)
        ? EventSegmentCriteria.fromJSON(object.eventExclusionCriteria)
        : undefined,
    };
  },

  toJSON(message: EventSegmentExclusion): unknown {
    const obj: any = {};
    if (message.eventExclusionDuration !== 0) {
      obj.eventExclusionDuration = eventExclusionDurationToJSON(message.eventExclusionDuration);
    }
    if (message.eventExclusionCriteria !== undefined) {
      obj.eventExclusionCriteria = EventSegmentCriteria.toJSON(message.eventExclusionCriteria);
    }
    return obj;
  },

  create(base?: DeepPartial<EventSegmentExclusion>): EventSegmentExclusion {
    return EventSegmentExclusion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventSegmentExclusion>): EventSegmentExclusion {
    const message = createBaseEventSegmentExclusion();
    message.eventExclusionDuration = object.eventExclusionDuration ?? 0;
    message.eventExclusionCriteria =
      (object.eventExclusionCriteria !== undefined && object.eventExclusionCriteria !== null)
        ? EventSegmentCriteria.fromPartial(object.eventExclusionCriteria)
        : undefined;
    return message;
  },
};

function createBaseSegment(): Segment {
  return { name: "", userSegment: undefined, sessionSegment: undefined, eventSegment: undefined };
}

export const Segment: MessageFns<Segment> = {
  encode(message: Segment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.userSegment !== undefined) {
      UserSegment.encode(message.userSegment, writer.uint32(18).fork()).join();
    }
    if (message.sessionSegment !== undefined) {
      SessionSegment.encode(message.sessionSegment, writer.uint32(26).fork()).join();
    }
    if (message.eventSegment !== undefined) {
      EventSegment.encode(message.eventSegment, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Segment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSegment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userSegment = UserSegment.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sessionSegment = SessionSegment.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.eventSegment = EventSegment.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Segment {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      userSegment: isSet(object.userSegment) ? UserSegment.fromJSON(object.userSegment) : undefined,
      sessionSegment: isSet(object.sessionSegment) ? SessionSegment.fromJSON(object.sessionSegment) : undefined,
      eventSegment: isSet(object.eventSegment) ? EventSegment.fromJSON(object.eventSegment) : undefined,
    };
  },

  toJSON(message: Segment): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.userSegment !== undefined) {
      obj.userSegment = UserSegment.toJSON(message.userSegment);
    }
    if (message.sessionSegment !== undefined) {
      obj.sessionSegment = SessionSegment.toJSON(message.sessionSegment);
    }
    if (message.eventSegment !== undefined) {
      obj.eventSegment = EventSegment.toJSON(message.eventSegment);
    }
    return obj;
  },

  create(base?: DeepPartial<Segment>): Segment {
    return Segment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Segment>): Segment {
    const message = createBaseSegment();
    message.name = object.name ?? "";
    message.userSegment = (object.userSegment !== undefined && object.userSegment !== null)
      ? UserSegment.fromPartial(object.userSegment)
      : undefined;
    message.sessionSegment = (object.sessionSegment !== undefined && object.sessionSegment !== null)
      ? SessionSegment.fromPartial(object.sessionSegment)
      : undefined;
    message.eventSegment = (object.eventSegment !== undefined && object.eventSegment !== null)
      ? EventSegment.fromPartial(object.eventSegment)
      : undefined;
    return message;
  },
};

function createBaseSegmentFilterExpression(): SegmentFilterExpression {
  return {
    andGroup: undefined,
    orGroup: undefined,
    notExpression: undefined,
    segmentFilter: undefined,
    segmentEventFilter: undefined,
  };
}

export const SegmentFilterExpression: MessageFns<SegmentFilterExpression> = {
  encode(message: SegmentFilterExpression, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.andGroup !== undefined) {
      SegmentFilterExpressionList.encode(message.andGroup, writer.uint32(10).fork()).join();
    }
    if (message.orGroup !== undefined) {
      SegmentFilterExpressionList.encode(message.orGroup, writer.uint32(18).fork()).join();
    }
    if (message.notExpression !== undefined) {
      SegmentFilterExpression.encode(message.notExpression, writer.uint32(26).fork()).join();
    }
    if (message.segmentFilter !== undefined) {
      SegmentFilter.encode(message.segmentFilter, writer.uint32(34).fork()).join();
    }
    if (message.segmentEventFilter !== undefined) {
      SegmentEventFilter.encode(message.segmentEventFilter, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SegmentFilterExpression {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSegmentFilterExpression();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.andGroup = SegmentFilterExpressionList.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.orGroup = SegmentFilterExpressionList.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.notExpression = SegmentFilterExpression.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.segmentFilter = SegmentFilter.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.segmentEventFilter = SegmentEventFilter.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SegmentFilterExpression {
    return {
      andGroup: isSet(object.andGroup) ? SegmentFilterExpressionList.fromJSON(object.andGroup) : undefined,
      orGroup: isSet(object.orGroup) ? SegmentFilterExpressionList.fromJSON(object.orGroup) : undefined,
      notExpression: isSet(object.notExpression) ? SegmentFilterExpression.fromJSON(object.notExpression) : undefined,
      segmentFilter: isSet(object.segmentFilter) ? SegmentFilter.fromJSON(object.segmentFilter) : undefined,
      segmentEventFilter: isSet(object.segmentEventFilter)
        ? SegmentEventFilter.fromJSON(object.segmentEventFilter)
        : undefined,
    };
  },

  toJSON(message: SegmentFilterExpression): unknown {
    const obj: any = {};
    if (message.andGroup !== undefined) {
      obj.andGroup = SegmentFilterExpressionList.toJSON(message.andGroup);
    }
    if (message.orGroup !== undefined) {
      obj.orGroup = SegmentFilterExpressionList.toJSON(message.orGroup);
    }
    if (message.notExpression !== undefined) {
      obj.notExpression = SegmentFilterExpression.toJSON(message.notExpression);
    }
    if (message.segmentFilter !== undefined) {
      obj.segmentFilter = SegmentFilter.toJSON(message.segmentFilter);
    }
    if (message.segmentEventFilter !== undefined) {
      obj.segmentEventFilter = SegmentEventFilter.toJSON(message.segmentEventFilter);
    }
    return obj;
  },

  create(base?: DeepPartial<SegmentFilterExpression>): SegmentFilterExpression {
    return SegmentFilterExpression.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SegmentFilterExpression>): SegmentFilterExpression {
    const message = createBaseSegmentFilterExpression();
    message.andGroup = (object.andGroup !== undefined && object.andGroup !== null)
      ? SegmentFilterExpressionList.fromPartial(object.andGroup)
      : undefined;
    message.orGroup = (object.orGroup !== undefined && object.orGroup !== null)
      ? SegmentFilterExpressionList.fromPartial(object.orGroup)
      : undefined;
    message.notExpression = (object.notExpression !== undefined && object.notExpression !== null)
      ? SegmentFilterExpression.fromPartial(object.notExpression)
      : undefined;
    message.segmentFilter = (object.segmentFilter !== undefined && object.segmentFilter !== null)
      ? SegmentFilter.fromPartial(object.segmentFilter)
      : undefined;
    message.segmentEventFilter = (object.segmentEventFilter !== undefined && object.segmentEventFilter !== null)
      ? SegmentEventFilter.fromPartial(object.segmentEventFilter)
      : undefined;
    return message;
  },
};

function createBaseSegmentFilterExpressionList(): SegmentFilterExpressionList {
  return { expressions: [] };
}

export const SegmentFilterExpressionList: MessageFns<SegmentFilterExpressionList> = {
  encode(message: SegmentFilterExpressionList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.expressions) {
      SegmentFilterExpression.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SegmentFilterExpressionList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSegmentFilterExpressionList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.expressions.push(SegmentFilterExpression.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SegmentFilterExpressionList {
    return {
      expressions: globalThis.Array.isArray(object?.expressions)
        ? object.expressions.map((e: any) => SegmentFilterExpression.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SegmentFilterExpressionList): unknown {
    const obj: any = {};
    if (message.expressions?.length) {
      obj.expressions = message.expressions.map((e) => SegmentFilterExpression.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SegmentFilterExpressionList>): SegmentFilterExpressionList {
    return SegmentFilterExpressionList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SegmentFilterExpressionList>): SegmentFilterExpressionList {
    const message = createBaseSegmentFilterExpressionList();
    message.expressions = object.expressions?.map((e) => SegmentFilterExpression.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSegmentFilter(): SegmentFilter {
  return {
    fieldName: "",
    stringFilter: undefined,
    inListFilter: undefined,
    numericFilter: undefined,
    betweenFilter: undefined,
    filterScoping: undefined,
  };
}

export const SegmentFilter: MessageFns<SegmentFilter> = {
  encode(message: SegmentFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fieldName !== "") {
      writer.uint32(10).string(message.fieldName);
    }
    if (message.stringFilter !== undefined) {
      StringFilter.encode(message.stringFilter, writer.uint32(34).fork()).join();
    }
    if (message.inListFilter !== undefined) {
      InListFilter.encode(message.inListFilter, writer.uint32(42).fork()).join();
    }
    if (message.numericFilter !== undefined) {
      NumericFilter.encode(message.numericFilter, writer.uint32(50).fork()).join();
    }
    if (message.betweenFilter !== undefined) {
      BetweenFilter.encode(message.betweenFilter, writer.uint32(58).fork()).join();
    }
    if (message.filterScoping !== undefined) {
      SegmentFilterScoping.encode(message.filterScoping, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SegmentFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSegmentFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fieldName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.stringFilter = StringFilter.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.inListFilter = InListFilter.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.numericFilter = NumericFilter.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.betweenFilter = BetweenFilter.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.filterScoping = SegmentFilterScoping.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SegmentFilter {
    return {
      fieldName: isSet(object.fieldName) ? globalThis.String(object.fieldName) : "",
      stringFilter: isSet(object.stringFilter) ? StringFilter.fromJSON(object.stringFilter) : undefined,
      inListFilter: isSet(object.inListFilter) ? InListFilter.fromJSON(object.inListFilter) : undefined,
      numericFilter: isSet(object.numericFilter) ? NumericFilter.fromJSON(object.numericFilter) : undefined,
      betweenFilter: isSet(object.betweenFilter) ? BetweenFilter.fromJSON(object.betweenFilter) : undefined,
      filterScoping: isSet(object.filterScoping) ? SegmentFilterScoping.fromJSON(object.filterScoping) : undefined,
    };
  },

  toJSON(message: SegmentFilter): unknown {
    const obj: any = {};
    if (message.fieldName !== "") {
      obj.fieldName = message.fieldName;
    }
    if (message.stringFilter !== undefined) {
      obj.stringFilter = StringFilter.toJSON(message.stringFilter);
    }
    if (message.inListFilter !== undefined) {
      obj.inListFilter = InListFilter.toJSON(message.inListFilter);
    }
    if (message.numericFilter !== undefined) {
      obj.numericFilter = NumericFilter.toJSON(message.numericFilter);
    }
    if (message.betweenFilter !== undefined) {
      obj.betweenFilter = BetweenFilter.toJSON(message.betweenFilter);
    }
    if (message.filterScoping !== undefined) {
      obj.filterScoping = SegmentFilterScoping.toJSON(message.filterScoping);
    }
    return obj;
  },

  create(base?: DeepPartial<SegmentFilter>): SegmentFilter {
    return SegmentFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SegmentFilter>): SegmentFilter {
    const message = createBaseSegmentFilter();
    message.fieldName = object.fieldName ?? "";
    message.stringFilter = (object.stringFilter !== undefined && object.stringFilter !== null)
      ? StringFilter.fromPartial(object.stringFilter)
      : undefined;
    message.inListFilter = (object.inListFilter !== undefined && object.inListFilter !== null)
      ? InListFilter.fromPartial(object.inListFilter)
      : undefined;
    message.numericFilter = (object.numericFilter !== undefined && object.numericFilter !== null)
      ? NumericFilter.fromPartial(object.numericFilter)
      : undefined;
    message.betweenFilter = (object.betweenFilter !== undefined && object.betweenFilter !== null)
      ? BetweenFilter.fromPartial(object.betweenFilter)
      : undefined;
    message.filterScoping = (object.filterScoping !== undefined && object.filterScoping !== null)
      ? SegmentFilterScoping.fromPartial(object.filterScoping)
      : undefined;
    return message;
  },
};

function createBaseSegmentFilterScoping(): SegmentFilterScoping {
  return { atAnyPointInTime: undefined };
}

export const SegmentFilterScoping: MessageFns<SegmentFilterScoping> = {
  encode(message: SegmentFilterScoping, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.atAnyPointInTime !== undefined) {
      writer.uint32(8).bool(message.atAnyPointInTime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SegmentFilterScoping {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSegmentFilterScoping();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.atAnyPointInTime = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SegmentFilterScoping {
    return {
      atAnyPointInTime: isSet(object.atAnyPointInTime) ? globalThis.Boolean(object.atAnyPointInTime) : undefined,
    };
  },

  toJSON(message: SegmentFilterScoping): unknown {
    const obj: any = {};
    if (message.atAnyPointInTime !== undefined) {
      obj.atAnyPointInTime = message.atAnyPointInTime;
    }
    return obj;
  },

  create(base?: DeepPartial<SegmentFilterScoping>): SegmentFilterScoping {
    return SegmentFilterScoping.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SegmentFilterScoping>): SegmentFilterScoping {
    const message = createBaseSegmentFilterScoping();
    message.atAnyPointInTime = object.atAnyPointInTime ?? undefined;
    return message;
  },
};

function createBaseSegmentEventFilter(): SegmentEventFilter {
  return { eventName: undefined, segmentParameterFilterExpression: undefined };
}

export const SegmentEventFilter: MessageFns<SegmentEventFilter> = {
  encode(message: SegmentEventFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventName !== undefined) {
      writer.uint32(10).string(message.eventName);
    }
    if (message.segmentParameterFilterExpression !== undefined) {
      SegmentParameterFilterExpression.encode(message.segmentParameterFilterExpression, writer.uint32(18).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SegmentEventFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSegmentEventFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.segmentParameterFilterExpression = SegmentParameterFilterExpression.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SegmentEventFilter {
    return {
      eventName: isSet(object.eventName) ? globalThis.String(object.eventName) : undefined,
      segmentParameterFilterExpression: isSet(object.segmentParameterFilterExpression)
        ? SegmentParameterFilterExpression.fromJSON(object.segmentParameterFilterExpression)
        : undefined,
    };
  },

  toJSON(message: SegmentEventFilter): unknown {
    const obj: any = {};
    if (message.eventName !== undefined) {
      obj.eventName = message.eventName;
    }
    if (message.segmentParameterFilterExpression !== undefined) {
      obj.segmentParameterFilterExpression = SegmentParameterFilterExpression.toJSON(
        message.segmentParameterFilterExpression,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<SegmentEventFilter>): SegmentEventFilter {
    return SegmentEventFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SegmentEventFilter>): SegmentEventFilter {
    const message = createBaseSegmentEventFilter();
    message.eventName = object.eventName ?? undefined;
    message.segmentParameterFilterExpression =
      (object.segmentParameterFilterExpression !== undefined && object.segmentParameterFilterExpression !== null)
        ? SegmentParameterFilterExpression.fromPartial(object.segmentParameterFilterExpression)
        : undefined;
    return message;
  },
};

function createBaseSegmentParameterFilterExpression(): SegmentParameterFilterExpression {
  return { andGroup: undefined, orGroup: undefined, notExpression: undefined, segmentParameterFilter: undefined };
}

export const SegmentParameterFilterExpression: MessageFns<SegmentParameterFilterExpression> = {
  encode(message: SegmentParameterFilterExpression, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.andGroup !== undefined) {
      SegmentParameterFilterExpressionList.encode(message.andGroup, writer.uint32(10).fork()).join();
    }
    if (message.orGroup !== undefined) {
      SegmentParameterFilterExpressionList.encode(message.orGroup, writer.uint32(18).fork()).join();
    }
    if (message.notExpression !== undefined) {
      SegmentParameterFilterExpression.encode(message.notExpression, writer.uint32(26).fork()).join();
    }
    if (message.segmentParameterFilter !== undefined) {
      SegmentParameterFilter.encode(message.segmentParameterFilter, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SegmentParameterFilterExpression {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSegmentParameterFilterExpression();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.andGroup = SegmentParameterFilterExpressionList.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.orGroup = SegmentParameterFilterExpressionList.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.notExpression = SegmentParameterFilterExpression.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.segmentParameterFilter = SegmentParameterFilter.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SegmentParameterFilterExpression {
    return {
      andGroup: isSet(object.andGroup) ? SegmentParameterFilterExpressionList.fromJSON(object.andGroup) : undefined,
      orGroup: isSet(object.orGroup) ? SegmentParameterFilterExpressionList.fromJSON(object.orGroup) : undefined,
      notExpression: isSet(object.notExpression)
        ? SegmentParameterFilterExpression.fromJSON(object.notExpression)
        : undefined,
      segmentParameterFilter: isSet(object.segmentParameterFilter)
        ? SegmentParameterFilter.fromJSON(object.segmentParameterFilter)
        : undefined,
    };
  },

  toJSON(message: SegmentParameterFilterExpression): unknown {
    const obj: any = {};
    if (message.andGroup !== undefined) {
      obj.andGroup = SegmentParameterFilterExpressionList.toJSON(message.andGroup);
    }
    if (message.orGroup !== undefined) {
      obj.orGroup = SegmentParameterFilterExpressionList.toJSON(message.orGroup);
    }
    if (message.notExpression !== undefined) {
      obj.notExpression = SegmentParameterFilterExpression.toJSON(message.notExpression);
    }
    if (message.segmentParameterFilter !== undefined) {
      obj.segmentParameterFilter = SegmentParameterFilter.toJSON(message.segmentParameterFilter);
    }
    return obj;
  },

  create(base?: DeepPartial<SegmentParameterFilterExpression>): SegmentParameterFilterExpression {
    return SegmentParameterFilterExpression.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SegmentParameterFilterExpression>): SegmentParameterFilterExpression {
    const message = createBaseSegmentParameterFilterExpression();
    message.andGroup = (object.andGroup !== undefined && object.andGroup !== null)
      ? SegmentParameterFilterExpressionList.fromPartial(object.andGroup)
      : undefined;
    message.orGroup = (object.orGroup !== undefined && object.orGroup !== null)
      ? SegmentParameterFilterExpressionList.fromPartial(object.orGroup)
      : undefined;
    message.notExpression = (object.notExpression !== undefined && object.notExpression !== null)
      ? SegmentParameterFilterExpression.fromPartial(object.notExpression)
      : undefined;
    message.segmentParameterFilter =
      (object.segmentParameterFilter !== undefined && object.segmentParameterFilter !== null)
        ? SegmentParameterFilter.fromPartial(object.segmentParameterFilter)
        : undefined;
    return message;
  },
};

function createBaseSegmentParameterFilterExpressionList(): SegmentParameterFilterExpressionList {
  return { expressions: [] };
}

export const SegmentParameterFilterExpressionList: MessageFns<SegmentParameterFilterExpressionList> = {
  encode(message: SegmentParameterFilterExpressionList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.expressions) {
      SegmentParameterFilterExpression.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SegmentParameterFilterExpressionList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSegmentParameterFilterExpressionList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.expressions.push(SegmentParameterFilterExpression.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SegmentParameterFilterExpressionList {
    return {
      expressions: globalThis.Array.isArray(object?.expressions)
        ? object.expressions.map((e: any) => SegmentParameterFilterExpression.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SegmentParameterFilterExpressionList): unknown {
    const obj: any = {};
    if (message.expressions?.length) {
      obj.expressions = message.expressions.map((e) => SegmentParameterFilterExpression.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SegmentParameterFilterExpressionList>): SegmentParameterFilterExpressionList {
    return SegmentParameterFilterExpressionList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SegmentParameterFilterExpressionList>): SegmentParameterFilterExpressionList {
    const message = createBaseSegmentParameterFilterExpressionList();
    message.expressions = object.expressions?.map((e) => SegmentParameterFilterExpression.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSegmentParameterFilter(): SegmentParameterFilter {
  return {
    eventParameterName: undefined,
    itemParameterName: undefined,
    stringFilter: undefined,
    inListFilter: undefined,
    numericFilter: undefined,
    betweenFilter: undefined,
    filterScoping: undefined,
  };
}

export const SegmentParameterFilter: MessageFns<SegmentParameterFilter> = {
  encode(message: SegmentParameterFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventParameterName !== undefined) {
      writer.uint32(10).string(message.eventParameterName);
    }
    if (message.itemParameterName !== undefined) {
      writer.uint32(18).string(message.itemParameterName);
    }
    if (message.stringFilter !== undefined) {
      StringFilter.encode(message.stringFilter, writer.uint32(34).fork()).join();
    }
    if (message.inListFilter !== undefined) {
      InListFilter.encode(message.inListFilter, writer.uint32(42).fork()).join();
    }
    if (message.numericFilter !== undefined) {
      NumericFilter.encode(message.numericFilter, writer.uint32(50).fork()).join();
    }
    if (message.betweenFilter !== undefined) {
      BetweenFilter.encode(message.betweenFilter, writer.uint32(58).fork()).join();
    }
    if (message.filterScoping !== undefined) {
      SegmentParameterFilterScoping.encode(message.filterScoping, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SegmentParameterFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSegmentParameterFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventParameterName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.itemParameterName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.stringFilter = StringFilter.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.inListFilter = InListFilter.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.numericFilter = NumericFilter.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.betweenFilter = BetweenFilter.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.filterScoping = SegmentParameterFilterScoping.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SegmentParameterFilter {
    return {
      eventParameterName: isSet(object.eventParameterName) ? globalThis.String(object.eventParameterName) : undefined,
      itemParameterName: isSet(object.itemParameterName) ? globalThis.String(object.itemParameterName) : undefined,
      stringFilter: isSet(object.stringFilter) ? StringFilter.fromJSON(object.stringFilter) : undefined,
      inListFilter: isSet(object.inListFilter) ? InListFilter.fromJSON(object.inListFilter) : undefined,
      numericFilter: isSet(object.numericFilter) ? NumericFilter.fromJSON(object.numericFilter) : undefined,
      betweenFilter: isSet(object.betweenFilter) ? BetweenFilter.fromJSON(object.betweenFilter) : undefined,
      filterScoping: isSet(object.filterScoping)
        ? SegmentParameterFilterScoping.fromJSON(object.filterScoping)
        : undefined,
    };
  },

  toJSON(message: SegmentParameterFilter): unknown {
    const obj: any = {};
    if (message.eventParameterName !== undefined) {
      obj.eventParameterName = message.eventParameterName;
    }
    if (message.itemParameterName !== undefined) {
      obj.itemParameterName = message.itemParameterName;
    }
    if (message.stringFilter !== undefined) {
      obj.stringFilter = StringFilter.toJSON(message.stringFilter);
    }
    if (message.inListFilter !== undefined) {
      obj.inListFilter = InListFilter.toJSON(message.inListFilter);
    }
    if (message.numericFilter !== undefined) {
      obj.numericFilter = NumericFilter.toJSON(message.numericFilter);
    }
    if (message.betweenFilter !== undefined) {
      obj.betweenFilter = BetweenFilter.toJSON(message.betweenFilter);
    }
    if (message.filterScoping !== undefined) {
      obj.filterScoping = SegmentParameterFilterScoping.toJSON(message.filterScoping);
    }
    return obj;
  },

  create(base?: DeepPartial<SegmentParameterFilter>): SegmentParameterFilter {
    return SegmentParameterFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SegmentParameterFilter>): SegmentParameterFilter {
    const message = createBaseSegmentParameterFilter();
    message.eventParameterName = object.eventParameterName ?? undefined;
    message.itemParameterName = object.itemParameterName ?? undefined;
    message.stringFilter = (object.stringFilter !== undefined && object.stringFilter !== null)
      ? StringFilter.fromPartial(object.stringFilter)
      : undefined;
    message.inListFilter = (object.inListFilter !== undefined && object.inListFilter !== null)
      ? InListFilter.fromPartial(object.inListFilter)
      : undefined;
    message.numericFilter = (object.numericFilter !== undefined && object.numericFilter !== null)
      ? NumericFilter.fromPartial(object.numericFilter)
      : undefined;
    message.betweenFilter = (object.betweenFilter !== undefined && object.betweenFilter !== null)
      ? BetweenFilter.fromPartial(object.betweenFilter)
      : undefined;
    message.filterScoping = (object.filterScoping !== undefined && object.filterScoping !== null)
      ? SegmentParameterFilterScoping.fromPartial(object.filterScoping)
      : undefined;
    return message;
  },
};

function createBaseSegmentParameterFilterScoping(): SegmentParameterFilterScoping {
  return { inAnyNDayPeriod: undefined };
}

export const SegmentParameterFilterScoping: MessageFns<SegmentParameterFilterScoping> = {
  encode(message: SegmentParameterFilterScoping, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inAnyNDayPeriod !== undefined) {
      writer.uint32(8).int64(message.inAnyNDayPeriod.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SegmentParameterFilterScoping {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSegmentParameterFilterScoping();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.inAnyNDayPeriod = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SegmentParameterFilterScoping {
    return { inAnyNDayPeriod: isSet(object.inAnyNDayPeriod) ? Long.fromValue(object.inAnyNDayPeriod) : undefined };
  },

  toJSON(message: SegmentParameterFilterScoping): unknown {
    const obj: any = {};
    if (message.inAnyNDayPeriod !== undefined) {
      obj.inAnyNDayPeriod = (message.inAnyNDayPeriod || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<SegmentParameterFilterScoping>): SegmentParameterFilterScoping {
    return SegmentParameterFilterScoping.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SegmentParameterFilterScoping>): SegmentParameterFilterScoping {
    const message = createBaseSegmentParameterFilterScoping();
    message.inAnyNDayPeriod = (object.inAnyNDayPeriod !== undefined && object.inAnyNDayPeriod !== null)
      ? Long.fromValue(object.inAnyNDayPeriod)
      : undefined;
    return message;
  },
};

function createBaseFunnelFilterExpression(): FunnelFilterExpression {
  return {
    andGroup: undefined,
    orGroup: undefined,
    notExpression: undefined,
    funnelFieldFilter: undefined,
    funnelEventFilter: undefined,
  };
}

export const FunnelFilterExpression: MessageFns<FunnelFilterExpression> = {
  encode(message: FunnelFilterExpression, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.andGroup !== undefined) {
      FunnelFilterExpressionList.encode(message.andGroup, writer.uint32(10).fork()).join();
    }
    if (message.orGroup !== undefined) {
      FunnelFilterExpressionList.encode(message.orGroup, writer.uint32(18).fork()).join();
    }
    if (message.notExpression !== undefined) {
      FunnelFilterExpression.encode(message.notExpression, writer.uint32(26).fork()).join();
    }
    if (message.funnelFieldFilter !== undefined) {
      FunnelFieldFilter.encode(message.funnelFieldFilter, writer.uint32(34).fork()).join();
    }
    if (message.funnelEventFilter !== undefined) {
      FunnelEventFilter.encode(message.funnelEventFilter, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunnelFilterExpression {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunnelFilterExpression();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.andGroup = FunnelFilterExpressionList.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.orGroup = FunnelFilterExpressionList.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.notExpression = FunnelFilterExpression.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.funnelFieldFilter = FunnelFieldFilter.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.funnelEventFilter = FunnelEventFilter.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunnelFilterExpression {
    return {
      andGroup: isSet(object.andGroup) ? FunnelFilterExpressionList.fromJSON(object.andGroup) : undefined,
      orGroup: isSet(object.orGroup) ? FunnelFilterExpressionList.fromJSON(object.orGroup) : undefined,
      notExpression: isSet(object.notExpression) ? FunnelFilterExpression.fromJSON(object.notExpression) : undefined,
      funnelFieldFilter: isSet(object.funnelFieldFilter)
        ? FunnelFieldFilter.fromJSON(object.funnelFieldFilter)
        : undefined,
      funnelEventFilter: isSet(object.funnelEventFilter)
        ? FunnelEventFilter.fromJSON(object.funnelEventFilter)
        : undefined,
    };
  },

  toJSON(message: FunnelFilterExpression): unknown {
    const obj: any = {};
    if (message.andGroup !== undefined) {
      obj.andGroup = FunnelFilterExpressionList.toJSON(message.andGroup);
    }
    if (message.orGroup !== undefined) {
      obj.orGroup = FunnelFilterExpressionList.toJSON(message.orGroup);
    }
    if (message.notExpression !== undefined) {
      obj.notExpression = FunnelFilterExpression.toJSON(message.notExpression);
    }
    if (message.funnelFieldFilter !== undefined) {
      obj.funnelFieldFilter = FunnelFieldFilter.toJSON(message.funnelFieldFilter);
    }
    if (message.funnelEventFilter !== undefined) {
      obj.funnelEventFilter = FunnelEventFilter.toJSON(message.funnelEventFilter);
    }
    return obj;
  },

  create(base?: DeepPartial<FunnelFilterExpression>): FunnelFilterExpression {
    return FunnelFilterExpression.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FunnelFilterExpression>): FunnelFilterExpression {
    const message = createBaseFunnelFilterExpression();
    message.andGroup = (object.andGroup !== undefined && object.andGroup !== null)
      ? FunnelFilterExpressionList.fromPartial(object.andGroup)
      : undefined;
    message.orGroup = (object.orGroup !== undefined && object.orGroup !== null)
      ? FunnelFilterExpressionList.fromPartial(object.orGroup)
      : undefined;
    message.notExpression = (object.notExpression !== undefined && object.notExpression !== null)
      ? FunnelFilterExpression.fromPartial(object.notExpression)
      : undefined;
    message.funnelFieldFilter = (object.funnelFieldFilter !== undefined && object.funnelFieldFilter !== null)
      ? FunnelFieldFilter.fromPartial(object.funnelFieldFilter)
      : undefined;
    message.funnelEventFilter = (object.funnelEventFilter !== undefined && object.funnelEventFilter !== null)
      ? FunnelEventFilter.fromPartial(object.funnelEventFilter)
      : undefined;
    return message;
  },
};

function createBaseFunnelFilterExpressionList(): FunnelFilterExpressionList {
  return { expressions: [] };
}

export const FunnelFilterExpressionList: MessageFns<FunnelFilterExpressionList> = {
  encode(message: FunnelFilterExpressionList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.expressions) {
      FunnelFilterExpression.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunnelFilterExpressionList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunnelFilterExpressionList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.expressions.push(FunnelFilterExpression.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunnelFilterExpressionList {
    return {
      expressions: globalThis.Array.isArray(object?.expressions)
        ? object.expressions.map((e: any) => FunnelFilterExpression.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FunnelFilterExpressionList): unknown {
    const obj: any = {};
    if (message.expressions?.length) {
      obj.expressions = message.expressions.map((e) => FunnelFilterExpression.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<FunnelFilterExpressionList>): FunnelFilterExpressionList {
    return FunnelFilterExpressionList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FunnelFilterExpressionList>): FunnelFilterExpressionList {
    const message = createBaseFunnelFilterExpressionList();
    message.expressions = object.expressions?.map((e) => FunnelFilterExpression.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFunnelFieldFilter(): FunnelFieldFilter {
  return {
    fieldName: "",
    stringFilter: undefined,
    inListFilter: undefined,
    numericFilter: undefined,
    betweenFilter: undefined,
  };
}

export const FunnelFieldFilter: MessageFns<FunnelFieldFilter> = {
  encode(message: FunnelFieldFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fieldName !== "") {
      writer.uint32(10).string(message.fieldName);
    }
    if (message.stringFilter !== undefined) {
      StringFilter.encode(message.stringFilter, writer.uint32(34).fork()).join();
    }
    if (message.inListFilter !== undefined) {
      InListFilter.encode(message.inListFilter, writer.uint32(42).fork()).join();
    }
    if (message.numericFilter !== undefined) {
      NumericFilter.encode(message.numericFilter, writer.uint32(50).fork()).join();
    }
    if (message.betweenFilter !== undefined) {
      BetweenFilter.encode(message.betweenFilter, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunnelFieldFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunnelFieldFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fieldName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.stringFilter = StringFilter.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.inListFilter = InListFilter.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.numericFilter = NumericFilter.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.betweenFilter = BetweenFilter.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunnelFieldFilter {
    return {
      fieldName: isSet(object.fieldName) ? globalThis.String(object.fieldName) : "",
      stringFilter: isSet(object.stringFilter) ? StringFilter.fromJSON(object.stringFilter) : undefined,
      inListFilter: isSet(object.inListFilter) ? InListFilter.fromJSON(object.inListFilter) : undefined,
      numericFilter: isSet(object.numericFilter) ? NumericFilter.fromJSON(object.numericFilter) : undefined,
      betweenFilter: isSet(object.betweenFilter) ? BetweenFilter.fromJSON(object.betweenFilter) : undefined,
    };
  },

  toJSON(message: FunnelFieldFilter): unknown {
    const obj: any = {};
    if (message.fieldName !== "") {
      obj.fieldName = message.fieldName;
    }
    if (message.stringFilter !== undefined) {
      obj.stringFilter = StringFilter.toJSON(message.stringFilter);
    }
    if (message.inListFilter !== undefined) {
      obj.inListFilter = InListFilter.toJSON(message.inListFilter);
    }
    if (message.numericFilter !== undefined) {
      obj.numericFilter = NumericFilter.toJSON(message.numericFilter);
    }
    if (message.betweenFilter !== undefined) {
      obj.betweenFilter = BetweenFilter.toJSON(message.betweenFilter);
    }
    return obj;
  },

  create(base?: DeepPartial<FunnelFieldFilter>): FunnelFieldFilter {
    return FunnelFieldFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FunnelFieldFilter>): FunnelFieldFilter {
    const message = createBaseFunnelFieldFilter();
    message.fieldName = object.fieldName ?? "";
    message.stringFilter = (object.stringFilter !== undefined && object.stringFilter !== null)
      ? StringFilter.fromPartial(object.stringFilter)
      : undefined;
    message.inListFilter = (object.inListFilter !== undefined && object.inListFilter !== null)
      ? InListFilter.fromPartial(object.inListFilter)
      : undefined;
    message.numericFilter = (object.numericFilter !== undefined && object.numericFilter !== null)
      ? NumericFilter.fromPartial(object.numericFilter)
      : undefined;
    message.betweenFilter = (object.betweenFilter !== undefined && object.betweenFilter !== null)
      ? BetweenFilter.fromPartial(object.betweenFilter)
      : undefined;
    return message;
  },
};

function createBaseFunnelEventFilter(): FunnelEventFilter {
  return { eventName: undefined, funnelParameterFilterExpression: undefined };
}

export const FunnelEventFilter: MessageFns<FunnelEventFilter> = {
  encode(message: FunnelEventFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventName !== undefined) {
      writer.uint32(10).string(message.eventName);
    }
    if (message.funnelParameterFilterExpression !== undefined) {
      FunnelParameterFilterExpression.encode(message.funnelParameterFilterExpression, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunnelEventFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunnelEventFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.funnelParameterFilterExpression = FunnelParameterFilterExpression.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunnelEventFilter {
    return {
      eventName: isSet(object.eventName) ? globalThis.String(object.eventName) : undefined,
      funnelParameterFilterExpression: isSet(object.funnelParameterFilterExpression)
        ? FunnelParameterFilterExpression.fromJSON(object.funnelParameterFilterExpression)
        : undefined,
    };
  },

  toJSON(message: FunnelEventFilter): unknown {
    const obj: any = {};
    if (message.eventName !== undefined) {
      obj.eventName = message.eventName;
    }
    if (message.funnelParameterFilterExpression !== undefined) {
      obj.funnelParameterFilterExpression = FunnelParameterFilterExpression.toJSON(
        message.funnelParameterFilterExpression,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<FunnelEventFilter>): FunnelEventFilter {
    return FunnelEventFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FunnelEventFilter>): FunnelEventFilter {
    const message = createBaseFunnelEventFilter();
    message.eventName = object.eventName ?? undefined;
    message.funnelParameterFilterExpression =
      (object.funnelParameterFilterExpression !== undefined && object.funnelParameterFilterExpression !== null)
        ? FunnelParameterFilterExpression.fromPartial(object.funnelParameterFilterExpression)
        : undefined;
    return message;
  },
};

function createBaseFunnelParameterFilterExpression(): FunnelParameterFilterExpression {
  return { andGroup: undefined, orGroup: undefined, notExpression: undefined, funnelParameterFilter: undefined };
}

export const FunnelParameterFilterExpression: MessageFns<FunnelParameterFilterExpression> = {
  encode(message: FunnelParameterFilterExpression, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.andGroup !== undefined) {
      FunnelParameterFilterExpressionList.encode(message.andGroup, writer.uint32(10).fork()).join();
    }
    if (message.orGroup !== undefined) {
      FunnelParameterFilterExpressionList.encode(message.orGroup, writer.uint32(18).fork()).join();
    }
    if (message.notExpression !== undefined) {
      FunnelParameterFilterExpression.encode(message.notExpression, writer.uint32(26).fork()).join();
    }
    if (message.funnelParameterFilter !== undefined) {
      FunnelParameterFilter.encode(message.funnelParameterFilter, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunnelParameterFilterExpression {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunnelParameterFilterExpression();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.andGroup = FunnelParameterFilterExpressionList.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.orGroup = FunnelParameterFilterExpressionList.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.notExpression = FunnelParameterFilterExpression.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.funnelParameterFilter = FunnelParameterFilter.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunnelParameterFilterExpression {
    return {
      andGroup: isSet(object.andGroup) ? FunnelParameterFilterExpressionList.fromJSON(object.andGroup) : undefined,
      orGroup: isSet(object.orGroup) ? FunnelParameterFilterExpressionList.fromJSON(object.orGroup) : undefined,
      notExpression: isSet(object.notExpression)
        ? FunnelParameterFilterExpression.fromJSON(object.notExpression)
        : undefined,
      funnelParameterFilter: isSet(object.funnelParameterFilter)
        ? FunnelParameterFilter.fromJSON(object.funnelParameterFilter)
        : undefined,
    };
  },

  toJSON(message: FunnelParameterFilterExpression): unknown {
    const obj: any = {};
    if (message.andGroup !== undefined) {
      obj.andGroup = FunnelParameterFilterExpressionList.toJSON(message.andGroup);
    }
    if (message.orGroup !== undefined) {
      obj.orGroup = FunnelParameterFilterExpressionList.toJSON(message.orGroup);
    }
    if (message.notExpression !== undefined) {
      obj.notExpression = FunnelParameterFilterExpression.toJSON(message.notExpression);
    }
    if (message.funnelParameterFilter !== undefined) {
      obj.funnelParameterFilter = FunnelParameterFilter.toJSON(message.funnelParameterFilter);
    }
    return obj;
  },

  create(base?: DeepPartial<FunnelParameterFilterExpression>): FunnelParameterFilterExpression {
    return FunnelParameterFilterExpression.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FunnelParameterFilterExpression>): FunnelParameterFilterExpression {
    const message = createBaseFunnelParameterFilterExpression();
    message.andGroup = (object.andGroup !== undefined && object.andGroup !== null)
      ? FunnelParameterFilterExpressionList.fromPartial(object.andGroup)
      : undefined;
    message.orGroup = (object.orGroup !== undefined && object.orGroup !== null)
      ? FunnelParameterFilterExpressionList.fromPartial(object.orGroup)
      : undefined;
    message.notExpression = (object.notExpression !== undefined && object.notExpression !== null)
      ? FunnelParameterFilterExpression.fromPartial(object.notExpression)
      : undefined;
    message.funnelParameterFilter =
      (object.funnelParameterFilter !== undefined && object.funnelParameterFilter !== null)
        ? FunnelParameterFilter.fromPartial(object.funnelParameterFilter)
        : undefined;
    return message;
  },
};

function createBaseFunnelParameterFilterExpressionList(): FunnelParameterFilterExpressionList {
  return { expressions: [] };
}

export const FunnelParameterFilterExpressionList: MessageFns<FunnelParameterFilterExpressionList> = {
  encode(message: FunnelParameterFilterExpressionList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.expressions) {
      FunnelParameterFilterExpression.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunnelParameterFilterExpressionList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunnelParameterFilterExpressionList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.expressions.push(FunnelParameterFilterExpression.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunnelParameterFilterExpressionList {
    return {
      expressions: globalThis.Array.isArray(object?.expressions)
        ? object.expressions.map((e: any) => FunnelParameterFilterExpression.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FunnelParameterFilterExpressionList): unknown {
    const obj: any = {};
    if (message.expressions?.length) {
      obj.expressions = message.expressions.map((e) => FunnelParameterFilterExpression.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<FunnelParameterFilterExpressionList>): FunnelParameterFilterExpressionList {
    return FunnelParameterFilterExpressionList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FunnelParameterFilterExpressionList>): FunnelParameterFilterExpressionList {
    const message = createBaseFunnelParameterFilterExpressionList();
    message.expressions = object.expressions?.map((e) => FunnelParameterFilterExpression.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFunnelParameterFilter(): FunnelParameterFilter {
  return {
    eventParameterName: undefined,
    itemParameterName: undefined,
    stringFilter: undefined,
    inListFilter: undefined,
    numericFilter: undefined,
    betweenFilter: undefined,
  };
}

export const FunnelParameterFilter: MessageFns<FunnelParameterFilter> = {
  encode(message: FunnelParameterFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventParameterName !== undefined) {
      writer.uint32(10).string(message.eventParameterName);
    }
    if (message.itemParameterName !== undefined) {
      writer.uint32(18).string(message.itemParameterName);
    }
    if (message.stringFilter !== undefined) {
      StringFilter.encode(message.stringFilter, writer.uint32(34).fork()).join();
    }
    if (message.inListFilter !== undefined) {
      InListFilter.encode(message.inListFilter, writer.uint32(42).fork()).join();
    }
    if (message.numericFilter !== undefined) {
      NumericFilter.encode(message.numericFilter, writer.uint32(50).fork()).join();
    }
    if (message.betweenFilter !== undefined) {
      BetweenFilter.encode(message.betweenFilter, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunnelParameterFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunnelParameterFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventParameterName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.itemParameterName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.stringFilter = StringFilter.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.inListFilter = InListFilter.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.numericFilter = NumericFilter.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.betweenFilter = BetweenFilter.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunnelParameterFilter {
    return {
      eventParameterName: isSet(object.eventParameterName) ? globalThis.String(object.eventParameterName) : undefined,
      itemParameterName: isSet(object.itemParameterName) ? globalThis.String(object.itemParameterName) : undefined,
      stringFilter: isSet(object.stringFilter) ? StringFilter.fromJSON(object.stringFilter) : undefined,
      inListFilter: isSet(object.inListFilter) ? InListFilter.fromJSON(object.inListFilter) : undefined,
      numericFilter: isSet(object.numericFilter) ? NumericFilter.fromJSON(object.numericFilter) : undefined,
      betweenFilter: isSet(object.betweenFilter) ? BetweenFilter.fromJSON(object.betweenFilter) : undefined,
    };
  },

  toJSON(message: FunnelParameterFilter): unknown {
    const obj: any = {};
    if (message.eventParameterName !== undefined) {
      obj.eventParameterName = message.eventParameterName;
    }
    if (message.itemParameterName !== undefined) {
      obj.itemParameterName = message.itemParameterName;
    }
    if (message.stringFilter !== undefined) {
      obj.stringFilter = StringFilter.toJSON(message.stringFilter);
    }
    if (message.inListFilter !== undefined) {
      obj.inListFilter = InListFilter.toJSON(message.inListFilter);
    }
    if (message.numericFilter !== undefined) {
      obj.numericFilter = NumericFilter.toJSON(message.numericFilter);
    }
    if (message.betweenFilter !== undefined) {
      obj.betweenFilter = BetweenFilter.toJSON(message.betweenFilter);
    }
    return obj;
  },

  create(base?: DeepPartial<FunnelParameterFilter>): FunnelParameterFilter {
    return FunnelParameterFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FunnelParameterFilter>): FunnelParameterFilter {
    const message = createBaseFunnelParameterFilter();
    message.eventParameterName = object.eventParameterName ?? undefined;
    message.itemParameterName = object.itemParameterName ?? undefined;
    message.stringFilter = (object.stringFilter !== undefined && object.stringFilter !== null)
      ? StringFilter.fromPartial(object.stringFilter)
      : undefined;
    message.inListFilter = (object.inListFilter !== undefined && object.inListFilter !== null)
      ? InListFilter.fromPartial(object.inListFilter)
      : undefined;
    message.numericFilter = (object.numericFilter !== undefined && object.numericFilter !== null)
      ? NumericFilter.fromPartial(object.numericFilter)
      : undefined;
    message.betweenFilter = (object.betweenFilter !== undefined && object.betweenFilter !== null)
      ? BetweenFilter.fromPartial(object.betweenFilter)
      : undefined;
    return message;
  },
};

function createBaseFunnelResponseMetadata(): FunnelResponseMetadata {
  return { samplingMetadatas: [] };
}

export const FunnelResponseMetadata: MessageFns<FunnelResponseMetadata> = {
  encode(message: FunnelResponseMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.samplingMetadatas) {
      SamplingMetadata.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunnelResponseMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunnelResponseMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.samplingMetadatas.push(SamplingMetadata.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunnelResponseMetadata {
    return {
      samplingMetadatas: globalThis.Array.isArray(object?.samplingMetadatas)
        ? object.samplingMetadatas.map((e: any) => SamplingMetadata.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FunnelResponseMetadata): unknown {
    const obj: any = {};
    if (message.samplingMetadatas?.length) {
      obj.samplingMetadatas = message.samplingMetadatas.map((e) => SamplingMetadata.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<FunnelResponseMetadata>): FunnelResponseMetadata {
    return FunnelResponseMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FunnelResponseMetadata>): FunnelResponseMetadata {
    const message = createBaseFunnelResponseMetadata();
    message.samplingMetadatas = object.samplingMetadatas?.map((e) => SamplingMetadata.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSamplingMetadata(): SamplingMetadata {
  return { samplesReadCount: Long.ZERO, samplingSpaceSize: Long.ZERO };
}

export const SamplingMetadata: MessageFns<SamplingMetadata> = {
  encode(message: SamplingMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.samplesReadCount.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.samplesReadCount.toString());
    }
    if (!message.samplingSpaceSize.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.samplingSpaceSize.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SamplingMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSamplingMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.samplesReadCount = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.samplingSpaceSize = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SamplingMetadata {
    return {
      samplesReadCount: isSet(object.samplesReadCount) ? Long.fromValue(object.samplesReadCount) : Long.ZERO,
      samplingSpaceSize: isSet(object.samplingSpaceSize) ? Long.fromValue(object.samplingSpaceSize) : Long.ZERO,
    };
  },

  toJSON(message: SamplingMetadata): unknown {
    const obj: any = {};
    if (!message.samplesReadCount.equals(Long.ZERO)) {
      obj.samplesReadCount = (message.samplesReadCount || Long.ZERO).toString();
    }
    if (!message.samplingSpaceSize.equals(Long.ZERO)) {
      obj.samplingSpaceSize = (message.samplingSpaceSize || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<SamplingMetadata>): SamplingMetadata {
    return SamplingMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SamplingMetadata>): SamplingMetadata {
    const message = createBaseSamplingMetadata();
    message.samplesReadCount = (object.samplesReadCount !== undefined && object.samplesReadCount !== null)
      ? Long.fromValue(object.samplesReadCount)
      : Long.ZERO;
    message.samplingSpaceSize = (object.samplingSpaceSize !== undefined && object.samplingSpaceSize !== null)
      ? Long.fromValue(object.samplingSpaceSize)
      : Long.ZERO;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
