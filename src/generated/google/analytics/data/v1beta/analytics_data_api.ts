// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/analytics/data/v1beta/analytics_data_api.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../longrunning/operations.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import {
  CohortSpec,
  Comparison,
  ComparisonMetadata,
  Compatibility,
  compatibilityFromJSON,
  compatibilityToJSON,
  DateRange,
  Dimension,
  DimensionCompatibility,
  DimensionHeader,
  DimensionMetadata,
  FilterExpression,
  Metric,
  MetricAggregation,
  metricAggregationFromJSON,
  metricAggregationToJSON,
  MetricCompatibility,
  MetricHeader,
  MetricMetadata,
  MinuteRange,
  OrderBy,
  Pivot,
  PivotHeader,
  PropertyQuota,
  ResponseMetaData,
  Row,
} from "./data.js";

export const protobufPackage = "google.analytics.data.v1beta";

/**
 * The request for compatibility information for a report's dimensions and
 * metrics. Check compatibility provides a preview of the compatibility of a
 * report; fields shared with the `runReport` request should be the same values
 * as in your `runReport` request.
 */
export interface CheckCompatibilityRequest {
  /**
   * A Google Analytics GA4 property identifier whose events are tracked. To
   * learn more, see [where to find your Property
   * ID](https://developers.google.com/analytics/devguides/reporting/data/v1/property-id).
   * `property` should be the same value as in your `runReport` request.
   *
   * Example: properties/1234
   */
  property: string;
  /**
   * The dimensions in this report. `dimensions` should be the same value as in
   * your `runReport` request.
   */
  dimensions: Dimension[];
  /**
   * The metrics in this report. `metrics` should be the same value as in your
   * `runReport` request.
   */
  metrics: Metric[];
  /**
   * The filter clause of dimensions. `dimensionFilter` should be the same value
   * as in your `runReport` request.
   */
  dimensionFilter:
    | FilterExpression
    | undefined;
  /**
   * The filter clause of metrics. `metricFilter` should be the same value as in
   * your `runReport` request
   */
  metricFilter:
    | FilterExpression
    | undefined;
  /**
   * Filters the dimensions and metrics in the response to just this
   * compatibility. Commonly used as `”compatibilityFilter”: “COMPATIBLE”`
   * to only return compatible dimensions & metrics.
   */
  compatibilityFilter: Compatibility;
}

/** The compatibility response with the compatibility of each dimension & metric. */
export interface CheckCompatibilityResponse {
  /** The compatibility of each dimension. */
  dimensionCompatibilities: DimensionCompatibility[];
  /** The compatibility of each metric. */
  metricCompatibilities: MetricCompatibility[];
}

/**
 * The dimensions, metrics and comparisons currently accepted in reporting
 * methods.
 */
export interface Metadata {
  /** Resource name of this metadata. */
  name: string;
  /** The dimension descriptions. */
  dimensions: DimensionMetadata[];
  /** The metric descriptions. */
  metrics: MetricMetadata[];
  /** The comparison descriptions. */
  comparisons: ComparisonMetadata[];
}

/** The request to generate a report. */
export interface RunReportRequest {
  /**
   * A Google Analytics GA4 property identifier whose events are tracked.
   * Specified in the URL path and not the body. To learn more, see [where to
   * find your Property
   * ID](https://developers.google.com/analytics/devguides/reporting/data/v1/property-id).
   * Within a batch request, this property should either be unspecified or
   * consistent with the batch-level property.
   *
   * Example: properties/1234
   */
  property: string;
  /** The dimensions requested and displayed. */
  dimensions: Dimension[];
  /** The metrics requested and displayed. */
  metrics: Metric[];
  /**
   * Date ranges of data to read. If multiple date ranges are requested, each
   * response row will contain a zero based date range index. If two date
   * ranges overlap, the event data for the overlapping days is included in the
   * response rows for both date ranges. In a cohort request, this `dateRanges`
   * must be unspecified.
   */
  dateRanges: DateRange[];
  /**
   * Dimension filters let you ask for only specific dimension values in
   * the report. To learn more, see [Fundamentals of Dimension
   * Filters](https://developers.google.com/analytics/devguides/reporting/data/v1/basics#dimension_filters)
   * for examples. Metrics cannot be used in this filter.
   */
  dimensionFilter:
    | FilterExpression
    | undefined;
  /**
   * The filter clause of metrics. Applied after aggregating the report's rows,
   * similar to SQL having-clause. Dimensions cannot be used in this filter.
   */
  metricFilter:
    | FilterExpression
    | undefined;
  /**
   * The row count of the start row. The first row is counted as row 0.
   *
   * When paging, the first request does not specify offset; or equivalently,
   * sets offset to 0; the first request returns the first `limit` of rows. The
   * second request sets offset to the `limit` of the first request; the second
   * request returns the second `limit` of rows.
   *
   * To learn more about this pagination parameter, see
   * [Pagination](https://developers.google.com/analytics/devguides/reporting/data/v1/basics#pagination).
   */
  offset: Long;
  /**
   * The number of rows to return. If unspecified, 10,000 rows are returned. The
   * API returns a maximum of 250,000 rows per request, no matter how many you
   * ask for. `limit` must be positive.
   *
   * The API can also return fewer rows than the requested `limit`, if there
   * aren't as many dimension values as the `limit`. For instance, there are
   * fewer than 300 possible values for the dimension `country`, so when
   * reporting on only `country`, you can't get more than 300 rows, even if you
   * set `limit` to a higher value.
   *
   * To learn more about this pagination parameter, see
   * [Pagination](https://developers.google.com/analytics/devguides/reporting/data/v1/basics#pagination).
   */
  limit: Long;
  /**
   * Aggregation of metrics. Aggregated metric values will be shown in rows
   * where the dimension_values are set to "RESERVED_(MetricAggregation)".
   */
  metricAggregations: MetricAggregation[];
  /** Specifies how rows are ordered in the response. */
  orderBys: OrderBy[];
  /**
   * A currency code in ISO4217 format, such as "AED", "USD", "JPY".
   * If the field is empty, the report uses the property's default currency.
   */
  currencyCode: string;
  /**
   * Cohort group associated with this request. If there is a cohort group
   * in the request the 'cohort' dimension must be present.
   */
  cohortSpec:
    | CohortSpec
    | undefined;
  /**
   * If false or unspecified, each row with all metrics equal to 0 will not be
   * returned. If true, these rows will be returned if they are not separately
   * removed by a filter.
   *
   * Regardless of this `keep_empty_rows` setting, only data recorded by the
   * Google Analytics (GA4) property can be displayed in a report.
   *
   * For example if a property never logs a `purchase` event, then a query for
   * the `eventName` dimension and  `eventCount` metric will not have a row
   * eventName: "purchase" and eventCount: 0.
   */
  keepEmptyRows: boolean;
  /**
   * Toggles whether to return the current state of this Analytics Property's
   * quota. Quota is returned in [PropertyQuota](#PropertyQuota).
   */
  returnPropertyQuota: boolean;
  /**
   * Optional. The configuration of comparisons requested and displayed. The
   * request only requires a comparisons field in order to receive a comparison
   * column in the response.
   */
  comparisons: Comparison[];
}

/** The response report table corresponding to a request. */
export interface RunReportResponse {
  /**
   * Describes dimension columns. The number of DimensionHeaders and ordering of
   * DimensionHeaders matches the dimensions present in rows.
   */
  dimensionHeaders: DimensionHeader[];
  /**
   * Describes metric columns. The number of MetricHeaders and ordering of
   * MetricHeaders matches the metrics present in rows.
   */
  metricHeaders: MetricHeader[];
  /** Rows of dimension value combinations and metric values in the report. */
  rows: Row[];
  /** If requested, the totaled values of metrics. */
  totals: Row[];
  /** If requested, the maximum values of metrics. */
  maximums: Row[];
  /** If requested, the minimum values of metrics. */
  minimums: Row[];
  /**
   * The total number of rows in the query result. `rowCount` is independent of
   * the number of rows returned in the response, the `limit` request
   * parameter, and the `offset` request parameter. For example if a query
   * returns 175 rows and includes `limit` of 50 in the API request, the
   * response will contain `rowCount` of 175 but only 50 rows.
   *
   * To learn more about this pagination parameter, see
   * [Pagination](https://developers.google.com/analytics/devguides/reporting/data/v1/basics#pagination).
   */
  rowCount: number;
  /** Metadata for the report. */
  metadata:
    | ResponseMetaData
    | undefined;
  /** This Analytics Property's quota state including this request. */
  propertyQuota:
    | PropertyQuota
    | undefined;
  /**
   * Identifies what kind of resource this message is. This `kind` is always the
   * fixed string "analyticsData#runReport". Useful to distinguish between
   * response types in JSON.
   */
  kind: string;
}

/** The request to generate a pivot report. */
export interface RunPivotReportRequest {
  /**
   * A Google Analytics GA4 property identifier whose events are tracked.
   * Specified in the URL path and not the body. To learn more, see [where to
   * find your Property
   * ID](https://developers.google.com/analytics/devguides/reporting/data/v1/property-id).
   * Within a batch request, this property should either be unspecified or
   * consistent with the batch-level property.
   *
   * Example: properties/1234
   */
  property: string;
  /**
   * The dimensions requested. All defined dimensions must be used by one of the
   * following: dimension_expression, dimension_filter, pivots, order_bys.
   */
  dimensions: Dimension[];
  /**
   * The metrics requested, at least one metric needs to be specified. All
   * defined metrics must be used by one of the following: metric_expression,
   * metric_filter, order_bys.
   */
  metrics: Metric[];
  /**
   * The date range to retrieve event data for the report. If multiple date
   * ranges are specified, event data from each date range is used in the
   * report. A special dimension with field name "dateRange" can be included in
   * a Pivot's field names; if included, the report compares between date
   * ranges. In a cohort request, this `dateRanges` must be unspecified.
   */
  dateRanges: DateRange[];
  /**
   * Describes the visual format of the report's dimensions in columns or rows.
   * The union of the fieldNames (dimension names) in all pivots must be a
   * subset of dimension names defined in Dimensions. No two pivots can share a
   * dimension. A dimension is only visible if it appears in a pivot.
   */
  pivots: Pivot[];
  /**
   * The filter clause of dimensions. Dimensions must be requested to be used in
   * this filter. Metrics cannot be used in this filter.
   */
  dimensionFilter:
    | FilterExpression
    | undefined;
  /**
   * The filter clause of metrics. Applied at post aggregation phase, similar to
   * SQL having-clause. Metrics must be requested to be used in this filter.
   * Dimensions cannot be used in this filter.
   */
  metricFilter:
    | FilterExpression
    | undefined;
  /**
   * A currency code in ISO4217 format, such as "AED", "USD", "JPY".
   * If the field is empty, the report uses the property's default currency.
   */
  currencyCode: string;
  /**
   * Cohort group associated with this request. If there is a cohort group
   * in the request the 'cohort' dimension must be present.
   */
  cohortSpec:
    | CohortSpec
    | undefined;
  /**
   * If false or unspecified, each row with all metrics equal to 0 will not be
   * returned. If true, these rows will be returned if they are not separately
   * removed by a filter.
   *
   * Regardless of this `keep_empty_rows` setting, only data recorded by the
   * Google Analytics (GA4) property can be displayed in a report.
   *
   * For example if a property never logs a `purchase` event, then a query for
   * the `eventName` dimension and  `eventCount` metric will not have a row
   * eventName: "purchase" and eventCount: 0.
   */
  keepEmptyRows: boolean;
  /**
   * Toggles whether to return the current state of this Analytics Property's
   * quota. Quota is returned in [PropertyQuota](#PropertyQuota).
   */
  returnPropertyQuota: boolean;
  /**
   * Optional. The configuration of comparisons requested and displayed. The
   * request requires both a comparisons field and a comparisons dimension to
   * receive a comparison column in the response.
   */
  comparisons: Comparison[];
}

/** The response pivot report table corresponding to a pivot request. */
export interface RunPivotReportResponse {
  /**
   * Summarizes the columns and rows created by a pivot. Each pivot in the
   * request produces one header in the response. If we have a request like
   * this:
   *
   *     "pivots": [{
   *       "fieldNames": ["country",
   *         "city"]
   *     },
   *     {
   *       "fieldNames": "eventName"
   *     }]
   *
   * We will have the following `pivotHeaders` in the response:
   *
   *     "pivotHeaders" : [{
   *       "dimensionHeaders": [{
   *         "dimensionValues": [
   *            { "value": "United Kingdom" },
   *            { "value": "London" }
   *          ]
   *       },
   *       {
   *         "dimensionValues": [
   *         { "value": "Japan" },
   *         { "value": "Osaka" }
   *         ]
   *       }]
   *     },
   *     {
   *       "dimensionHeaders": [{
   *         "dimensionValues": [{ "value": "session_start" }]
   *       },
   *       {
   *         "dimensionValues": [{ "value": "scroll" }]
   *       }]
   *     }]
   */
  pivotHeaders: PivotHeader[];
  /**
   * Describes dimension columns. The number of DimensionHeaders and ordering of
   * DimensionHeaders matches the dimensions present in rows.
   */
  dimensionHeaders: DimensionHeader[];
  /**
   * Describes metric columns. The number of MetricHeaders and ordering of
   * MetricHeaders matches the metrics present in rows.
   */
  metricHeaders: MetricHeader[];
  /** Rows of dimension value combinations and metric values in the report. */
  rows: Row[];
  /**
   * Aggregation of metric values. Can be totals, minimums, or maximums. The
   * returned aggregations are controlled by the metric_aggregations in the
   * pivot. The type of aggregation returned in each row is shown by the
   * dimension_values which are set to "RESERVED_<MetricAggregation>".
   */
  aggregates: Row[];
  /** Metadata for the report. */
  metadata:
    | ResponseMetaData
    | undefined;
  /** This Analytics Property's quota state including this request. */
  propertyQuota:
    | PropertyQuota
    | undefined;
  /**
   * Identifies what kind of resource this message is. This `kind` is always the
   * fixed string "analyticsData#runPivotReport". Useful to distinguish between
   * response types in JSON.
   */
  kind: string;
}

/** The batch request containing multiple report requests. */
export interface BatchRunReportsRequest {
  /**
   * A Google Analytics GA4 property identifier whose events are tracked.
   * Specified in the URL path and not the body. To learn more, see [where to
   * find your Property
   * ID](https://developers.google.com/analytics/devguides/reporting/data/v1/property-id).
   * This property must be specified for the batch. The property within
   * RunReportRequest may either be unspecified or consistent with this
   * property.
   *
   * Example: properties/1234
   */
  property: string;
  /**
   * Individual requests. Each request has a separate report response. Each
   * batch request is allowed up to 5 requests.
   */
  requests: RunReportRequest[];
}

/** The batch response containing multiple reports. */
export interface BatchRunReportsResponse {
  /** Individual responses. Each response has a separate report request. */
  reports: RunReportResponse[];
  /**
   * Identifies what kind of resource this message is. This `kind` is always the
   * fixed string "analyticsData#batchRunReports". Useful to distinguish between
   * response types in JSON.
   */
  kind: string;
}

/** The batch request containing multiple pivot report requests. */
export interface BatchRunPivotReportsRequest {
  /**
   * A Google Analytics GA4 property identifier whose events are tracked.
   * Specified in the URL path and not the body. To learn more, see [where to
   * find your Property
   * ID](https://developers.google.com/analytics/devguides/reporting/data/v1/property-id).
   * This property must be specified for the batch. The property within
   * RunPivotReportRequest may either be unspecified or consistent with this
   * property.
   *
   * Example: properties/1234
   */
  property: string;
  /**
   * Individual requests. Each request has a separate pivot report response.
   * Each batch request is allowed up to 5 requests.
   */
  requests: RunPivotReportRequest[];
}

/** The batch response containing multiple pivot reports. */
export interface BatchRunPivotReportsResponse {
  /** Individual responses. Each response has a separate pivot report request. */
  pivotReports: RunPivotReportResponse[];
  /**
   * Identifies what kind of resource this message is. This `kind` is always the
   * fixed string "analyticsData#batchRunPivotReports". Useful to distinguish
   * between response types in JSON.
   */
  kind: string;
}

/** Request for a property's dimension and metric metadata. */
export interface GetMetadataRequest {
  /**
   * Required. The resource name of the metadata to retrieve. This name field is
   * specified in the URL path and not URL parameters. Property is a numeric
   * Google Analytics GA4 Property identifier. To learn more, see [where to find
   * your Property
   * ID](https://developers.google.com/analytics/devguides/reporting/data/v1/property-id).
   *
   * Example: properties/1234/metadata
   *
   * Set the Property ID to 0 for dimensions and metrics common to all
   * properties. In this special mode, this method will not return custom
   * dimensions and metrics.
   */
  name: string;
}

/** The request to generate a realtime report. */
export interface RunRealtimeReportRequest {
  /**
   * A Google Analytics GA4 property identifier whose events are tracked.
   * Specified in the URL path and not the body. To learn more, see [where to
   * find your Property
   * ID](https://developers.google.com/analytics/devguides/reporting/data/v1/property-id).
   *
   * Example: properties/1234
   */
  property: string;
  /** The dimensions requested and displayed. */
  dimensions: Dimension[];
  /** The metrics requested and displayed. */
  metrics: Metric[];
  /** The filter clause of dimensions. Metrics cannot be used in this filter. */
  dimensionFilter:
    | FilterExpression
    | undefined;
  /**
   * The filter clause of metrics. Applied at post aggregation phase, similar to
   * SQL having-clause. Dimensions cannot be used in this filter.
   */
  metricFilter:
    | FilterExpression
    | undefined;
  /**
   * The number of rows to return. If unspecified, 10,000 rows are returned. The
   * API returns a maximum of 250,000 rows per request, no matter how many you
   * ask for. `limit` must be positive.
   *
   * The API can also return fewer rows than the requested `limit`, if there
   * aren't as many dimension values as the `limit`. For instance, there are
   * fewer than 300 possible values for the dimension `country`, so when
   * reporting on only `country`, you can't get more than 300 rows, even if you
   * set `limit` to a higher value.
   */
  limit: Long;
  /**
   * Aggregation of metrics. Aggregated metric values will be shown in rows
   * where the dimension_values are set to "RESERVED_(MetricAggregation)".
   */
  metricAggregations: MetricAggregation[];
  /** Specifies how rows are ordered in the response. */
  orderBys: OrderBy[];
  /**
   * Toggles whether to return the current state of this Analytics Property's
   * Realtime quota. Quota is returned in [PropertyQuota](#PropertyQuota).
   */
  returnPropertyQuota: boolean;
  /**
   * The minute ranges of event data to read. If unspecified, one minute range
   * for the last 30 minutes will be used. If multiple minute ranges are
   * requested, each response row will contain a zero based minute range index.
   * If two minute ranges overlap, the event data for the overlapping minutes is
   * included in the response rows for both minute ranges.
   */
  minuteRanges: MinuteRange[];
}

/** The response realtime report table corresponding to a request. */
export interface RunRealtimeReportResponse {
  /**
   * Describes dimension columns. The number of DimensionHeaders and ordering of
   * DimensionHeaders matches the dimensions present in rows.
   */
  dimensionHeaders: DimensionHeader[];
  /**
   * Describes metric columns. The number of MetricHeaders and ordering of
   * MetricHeaders matches the metrics present in rows.
   */
  metricHeaders: MetricHeader[];
  /** Rows of dimension value combinations and metric values in the report. */
  rows: Row[];
  /** If requested, the totaled values of metrics. */
  totals: Row[];
  /** If requested, the maximum values of metrics. */
  maximums: Row[];
  /** If requested, the minimum values of metrics. */
  minimums: Row[];
  /**
   * The total number of rows in the query result. `rowCount` is independent of
   * the number of rows returned in the response and the `limit` request
   * parameter. For example if a query returns 175 rows and includes `limit`
   * of 50 in the API request, the response will contain `rowCount` of 175 but
   * only 50 rows.
   */
  rowCount: number;
  /** This Analytics Property's Realtime quota state including this request. */
  propertyQuota:
    | PropertyQuota
    | undefined;
  /**
   * Identifies what kind of resource this message is. This `kind` is always the
   * fixed string "analyticsData#runRealtimeReport". Useful to distinguish
   * between response types in JSON.
   */
  kind: string;
}

/**
 * A request to retrieve configuration metadata about a specific audience
 * export.
 */
export interface GetAudienceExportRequest {
  /**
   * Required. The audience export resource name.
   * Format: `properties/{property}/audienceExports/{audience_export}`
   */
  name: string;
}

/** A request to list all audience exports for a property. */
export interface ListAudienceExportsRequest {
  /**
   * Required. All audience exports for this property will be listed in the
   * response. Format: `properties/{property}`
   */
  parent: string;
  /**
   * Optional. The maximum number of audience exports to return. The service may
   * return fewer than this value. If unspecified, at most 200 audience exports
   * will be returned. The maximum value is 1000 (higher values will be coerced
   * to the maximum).
   */
  pageSize: number;
  /**
   * Optional. A page token, received from a previous `ListAudienceExports`
   * call. Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListAudienceExports`
   * must match the call that provided the page token.
   */
  pageToken: string;
}

/** A list of all audience exports for a property. */
export interface ListAudienceExportsResponse {
  /** Each audience export for a property. */
  audienceExports: AudienceExport[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken?: string | undefined;
}

/** A request to create a new audience export. */
export interface CreateAudienceExportRequest {
  /**
   * Required. The parent resource where this audience export will be created.
   * Format: `properties/{property}`
   */
  parent: string;
  /** Required. The audience export to create. */
  audienceExport: AudienceExport | undefined;
}

/**
 * An audience export is a list of users in an audience at the time of the
 * list's creation. One audience may have multiple audience exports created for
 * different days.
 */
export interface AudienceExport {
  /**
   * Output only. Identifier. The audience export resource name assigned during
   * creation. This resource name identifies this `AudienceExport`.
   *
   * Format: `properties/{property}/audienceExports/{audience_export}`
   */
  name: string;
  /**
   * Required. The audience resource name. This resource name identifies the
   * audience being listed and is shared between the Analytics Data & Admin
   * APIs.
   *
   * Format: `properties/{property}/audiences/{audience}`
   */
  audience: string;
  /**
   * Output only. The descriptive display name for this audience. For example,
   * "Purchasers".
   */
  audienceDisplayName: string;
  /** Required. The dimensions requested and displayed in the query response. */
  dimensions: AudienceDimension[];
  /** Output only. The current state for this AudienceExport. */
  state?:
    | AudienceExport_State
    | undefined;
  /**
   * Output only. The time when CreateAudienceExport was called and the
   * AudienceExport began the `CREATING` state.
   */
  beginCreatingTime?:
    | Date
    | undefined;
  /**
   * Output only. The total quota tokens charged during creation of the
   * AudienceExport. Because this token count is based on activity from the
   * `CREATING` state, this tokens charged will be fixed once an AudienceExport
   * enters the `ACTIVE` or `FAILED` states.
   */
  creationQuotaTokensCharged: number;
  /** Output only. The total number of rows in the AudienceExport result. */
  rowCount?:
    | number
    | undefined;
  /**
   * Output only. Error message is populated when an audience export fails
   * during creation. A common reason for such a failure is quota exhaustion.
   */
  errorMessage?:
    | string
    | undefined;
  /**
   * Output only. The percentage completed for this audience export ranging
   * between 0 to 100.
   */
  percentageCompleted?: number | undefined;
}

/** The AudienceExport currently exists in this state. */
export enum AudienceExport_State {
  /** STATE_UNSPECIFIED - Unspecified state will never be used. */
  STATE_UNSPECIFIED = 0,
  /**
   * CREATING - The AudienceExport is currently creating and will be available in the
   * future. Creating occurs immediately after the CreateAudienceExport call.
   */
  CREATING = 1,
  /**
   * ACTIVE - The AudienceExport is fully created and ready for querying. An
   * AudienceExport is updated to active asynchronously from a request; this
   * occurs some time (for example 15 minutes) after the initial create call.
   */
  ACTIVE = 2,
  /**
   * FAILED - The AudienceExport failed to be created. It is possible that
   * re-requesting this audience export will succeed.
   */
  FAILED = 3,
  UNRECOGNIZED = -1,
}

export function audienceExport_StateFromJSON(object: any): AudienceExport_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return AudienceExport_State.STATE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return AudienceExport_State.CREATING;
    case 2:
    case "ACTIVE":
      return AudienceExport_State.ACTIVE;
    case 3:
    case "FAILED":
      return AudienceExport_State.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AudienceExport_State.UNRECOGNIZED;
  }
}

export function audienceExport_StateToJSON(object: AudienceExport_State): string {
  switch (object) {
    case AudienceExport_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case AudienceExport_State.CREATING:
      return "CREATING";
    case AudienceExport_State.ACTIVE:
      return "ACTIVE";
    case AudienceExport_State.FAILED:
      return "FAILED";
    case AudienceExport_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** This metadata is currently blank. */
export interface AudienceExportMetadata {
}

/** A request to list users in an audience export. */
export interface QueryAudienceExportRequest {
  /**
   * Required. The name of the audience export to retrieve users from.
   * Format: `properties/{property}/audienceExports/{audience_export}`
   */
  name: string;
  /**
   * Optional. The row count of the start row. The first row is counted as row
   * 0.
   *
   * When paging, the first request does not specify offset; or equivalently,
   * sets offset to 0; the first request returns the first `limit` of rows. The
   * second request sets offset to the `limit` of the first request; the second
   * request returns the second `limit` of rows.
   *
   * To learn more about this pagination parameter, see
   * [Pagination](https://developers.google.com/analytics/devguides/reporting/data/v1/basics#pagination).
   */
  offset: Long;
  /**
   * Optional. The number of rows to return. If unspecified, 10,000 rows are
   * returned. The API returns a maximum of 250,000 rows per request, no matter
   * how many you ask for. `limit` must be positive.
   *
   * The API can also return fewer rows than the requested `limit`, if there
   * aren't as many dimension values as the `limit`.
   *
   * To learn more about this pagination parameter, see
   * [Pagination](https://developers.google.com/analytics/devguides/reporting/data/v1/basics#pagination).
   */
  limit: Long;
}

/** A list of users in an audience export. */
export interface QueryAudienceExportResponse {
  /**
   * Configuration data about AudienceExport being queried. Returned to help
   * interpret the audience rows in this response. For example, the dimensions
   * in this AudienceExport correspond to the columns in the AudienceRows.
   */
  audienceExport?:
    | AudienceExport
    | undefined;
  /**
   * Rows for each user in an audience export. The number of rows in this
   * response will be less than or equal to request's page size.
   */
  audienceRows: AudienceRow[];
  /**
   * The total number of rows in the AudienceExport result. `rowCount` is
   * independent of the number of rows returned in the response, the `limit`
   * request parameter, and the `offset` request parameter. For example if a
   * query returns 175 rows and includes `limit` of 50 in the API request, the
   * response will contain `rowCount` of 175 but only 50 rows.
   *
   * To learn more about this pagination parameter, see
   * [Pagination](https://developers.google.com/analytics/devguides/reporting/data/v1/basics#pagination).
   */
  rowCount?: number | undefined;
}

/** Dimension value attributes for the audience user row. */
export interface AudienceRow {
  /**
   * Each dimension value attribute for an audience user. One dimension value
   * will be added for each dimension column requested.
   */
  dimensionValues: AudienceDimensionValue[];
}

/**
 * An audience dimension is a user attribute. Specific user attributed are
 * requested and then later returned in the `QueryAudienceExportResponse`.
 */
export interface AudienceDimension {
  /**
   * Optional. The API name of the dimension. See the [API
   * Dimensions](https://developers.google.com/analytics/devguides/reporting/data/v1/audience-list-api-schema#dimensions)
   * for the list of dimension names.
   */
  dimensionName: string;
}

/** The value of a dimension. */
export interface AudienceDimensionValue {
  /** Value as a string if the dimension type is a string. */
  value?: string | undefined;
}

function createBaseCheckCompatibilityRequest(): CheckCompatibilityRequest {
  return {
    property: "",
    dimensions: [],
    metrics: [],
    dimensionFilter: undefined,
    metricFilter: undefined,
    compatibilityFilter: 0,
  };
}

export const CheckCompatibilityRequest: MessageFns<CheckCompatibilityRequest> = {
  encode(message: CheckCompatibilityRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.property !== "") {
      writer.uint32(10).string(message.property);
    }
    for (const v of message.dimensions) {
      Dimension.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.metrics) {
      Metric.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.dimensionFilter !== undefined) {
      FilterExpression.encode(message.dimensionFilter, writer.uint32(34).fork()).join();
    }
    if (message.metricFilter !== undefined) {
      FilterExpression.encode(message.metricFilter, writer.uint32(42).fork()).join();
    }
    if (message.compatibilityFilter !== 0) {
      writer.uint32(48).int32(message.compatibilityFilter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckCompatibilityRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckCompatibilityRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.property = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dimensions.push(Dimension.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.metrics.push(Metric.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.dimensionFilter = FilterExpression.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.metricFilter = FilterExpression.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.compatibilityFilter = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckCompatibilityRequest {
    return {
      property: isSet(object.property) ? globalThis.String(object.property) : "",
      dimensions: globalThis.Array.isArray(object?.dimensions)
        ? object.dimensions.map((e: any) => Dimension.fromJSON(e))
        : [],
      metrics: globalThis.Array.isArray(object?.metrics) ? object.metrics.map((e: any) => Metric.fromJSON(e)) : [],
      dimensionFilter: isSet(object.dimensionFilter) ? FilterExpression.fromJSON(object.dimensionFilter) : undefined,
      metricFilter: isSet(object.metricFilter) ? FilterExpression.fromJSON(object.metricFilter) : undefined,
      compatibilityFilter: isSet(object.compatibilityFilter) ? compatibilityFromJSON(object.compatibilityFilter) : 0,
    };
  },

  toJSON(message: CheckCompatibilityRequest): unknown {
    const obj: any = {};
    if (message.property !== "") {
      obj.property = message.property;
    }
    if (message.dimensions?.length) {
      obj.dimensions = message.dimensions.map((e) => Dimension.toJSON(e));
    }
    if (message.metrics?.length) {
      obj.metrics = message.metrics.map((e) => Metric.toJSON(e));
    }
    if (message.dimensionFilter !== undefined) {
      obj.dimensionFilter = FilterExpression.toJSON(message.dimensionFilter);
    }
    if (message.metricFilter !== undefined) {
      obj.metricFilter = FilterExpression.toJSON(message.metricFilter);
    }
    if (message.compatibilityFilter !== 0) {
      obj.compatibilityFilter = compatibilityToJSON(message.compatibilityFilter);
    }
    return obj;
  },

  create(base?: DeepPartial<CheckCompatibilityRequest>): CheckCompatibilityRequest {
    return CheckCompatibilityRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CheckCompatibilityRequest>): CheckCompatibilityRequest {
    const message = createBaseCheckCompatibilityRequest();
    message.property = object.property ?? "";
    message.dimensions = object.dimensions?.map((e) => Dimension.fromPartial(e)) || [];
    message.metrics = object.metrics?.map((e) => Metric.fromPartial(e)) || [];
    message.dimensionFilter = (object.dimensionFilter !== undefined && object.dimensionFilter !== null)
      ? FilterExpression.fromPartial(object.dimensionFilter)
      : undefined;
    message.metricFilter = (object.metricFilter !== undefined && object.metricFilter !== null)
      ? FilterExpression.fromPartial(object.metricFilter)
      : undefined;
    message.compatibilityFilter = object.compatibilityFilter ?? 0;
    return message;
  },
};

function createBaseCheckCompatibilityResponse(): CheckCompatibilityResponse {
  return { dimensionCompatibilities: [], metricCompatibilities: [] };
}

export const CheckCompatibilityResponse: MessageFns<CheckCompatibilityResponse> = {
  encode(message: CheckCompatibilityResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.dimensionCompatibilities) {
      DimensionCompatibility.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.metricCompatibilities) {
      MetricCompatibility.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckCompatibilityResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckCompatibilityResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dimensionCompatibilities.push(DimensionCompatibility.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.metricCompatibilities.push(MetricCompatibility.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckCompatibilityResponse {
    return {
      dimensionCompatibilities: globalThis.Array.isArray(object?.dimensionCompatibilities)
        ? object.dimensionCompatibilities.map((e: any) => DimensionCompatibility.fromJSON(e))
        : [],
      metricCompatibilities: globalThis.Array.isArray(object?.metricCompatibilities)
        ? object.metricCompatibilities.map((e: any) => MetricCompatibility.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CheckCompatibilityResponse): unknown {
    const obj: any = {};
    if (message.dimensionCompatibilities?.length) {
      obj.dimensionCompatibilities = message.dimensionCompatibilities.map((e) => DimensionCompatibility.toJSON(e));
    }
    if (message.metricCompatibilities?.length) {
      obj.metricCompatibilities = message.metricCompatibilities.map((e) => MetricCompatibility.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CheckCompatibilityResponse>): CheckCompatibilityResponse {
    return CheckCompatibilityResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CheckCompatibilityResponse>): CheckCompatibilityResponse {
    const message = createBaseCheckCompatibilityResponse();
    message.dimensionCompatibilities =
      object.dimensionCompatibilities?.map((e) => DimensionCompatibility.fromPartial(e)) || [];
    message.metricCompatibilities = object.metricCompatibilities?.map((e) => MetricCompatibility.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMetadata(): Metadata {
  return { name: "", dimensions: [], metrics: [], comparisons: [] };
}

export const Metadata: MessageFns<Metadata> = {
  encode(message: Metadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    for (const v of message.dimensions) {
      DimensionMetadata.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.metrics) {
      MetricMetadata.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.comparisons) {
      ComparisonMetadata.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Metadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dimensions.push(DimensionMetadata.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.metrics.push(MetricMetadata.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.comparisons.push(ComparisonMetadata.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Metadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      dimensions: globalThis.Array.isArray(object?.dimensions)
        ? object.dimensions.map((e: any) => DimensionMetadata.fromJSON(e))
        : [],
      metrics: globalThis.Array.isArray(object?.metrics)
        ? object.metrics.map((e: any) => MetricMetadata.fromJSON(e))
        : [],
      comparisons: globalThis.Array.isArray(object?.comparisons)
        ? object.comparisons.map((e: any) => ComparisonMetadata.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Metadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.dimensions?.length) {
      obj.dimensions = message.dimensions.map((e) => DimensionMetadata.toJSON(e));
    }
    if (message.metrics?.length) {
      obj.metrics = message.metrics.map((e) => MetricMetadata.toJSON(e));
    }
    if (message.comparisons?.length) {
      obj.comparisons = message.comparisons.map((e) => ComparisonMetadata.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Metadata>): Metadata {
    return Metadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Metadata>): Metadata {
    const message = createBaseMetadata();
    message.name = object.name ?? "";
    message.dimensions = object.dimensions?.map((e) => DimensionMetadata.fromPartial(e)) || [];
    message.metrics = object.metrics?.map((e) => MetricMetadata.fromPartial(e)) || [];
    message.comparisons = object.comparisons?.map((e) => ComparisonMetadata.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRunReportRequest(): RunReportRequest {
  return {
    property: "",
    dimensions: [],
    metrics: [],
    dateRanges: [],
    dimensionFilter: undefined,
    metricFilter: undefined,
    offset: Long.ZERO,
    limit: Long.ZERO,
    metricAggregations: [],
    orderBys: [],
    currencyCode: "",
    cohortSpec: undefined,
    keepEmptyRows: false,
    returnPropertyQuota: false,
    comparisons: [],
  };
}

export const RunReportRequest: MessageFns<RunReportRequest> = {
  encode(message: RunReportRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.property !== "") {
      writer.uint32(10).string(message.property);
    }
    for (const v of message.dimensions) {
      Dimension.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.metrics) {
      Metric.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.dateRanges) {
      DateRange.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.dimensionFilter !== undefined) {
      FilterExpression.encode(message.dimensionFilter, writer.uint32(42).fork()).join();
    }
    if (message.metricFilter !== undefined) {
      FilterExpression.encode(message.metricFilter, writer.uint32(50).fork()).join();
    }
    if (!message.offset.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.offset.toString());
    }
    if (!message.limit.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.limit.toString());
    }
    writer.uint32(74).fork();
    for (const v of message.metricAggregations) {
      writer.int32(v);
    }
    writer.join();
    for (const v of message.orderBys) {
      OrderBy.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.currencyCode !== "") {
      writer.uint32(90).string(message.currencyCode);
    }
    if (message.cohortSpec !== undefined) {
      CohortSpec.encode(message.cohortSpec, writer.uint32(98).fork()).join();
    }
    if (message.keepEmptyRows !== false) {
      writer.uint32(104).bool(message.keepEmptyRows);
    }
    if (message.returnPropertyQuota !== false) {
      writer.uint32(112).bool(message.returnPropertyQuota);
    }
    for (const v of message.comparisons) {
      Comparison.encode(v!, writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunReportRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunReportRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.property = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dimensions.push(Dimension.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.metrics.push(Metric.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.dateRanges.push(DateRange.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.dimensionFilter = FilterExpression.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.metricFilter = FilterExpression.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.offset = Long.fromString(reader.int64().toString());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.limit = Long.fromString(reader.int64().toString());
          continue;
        case 9:
          if (tag === 72) {
            message.metricAggregations.push(reader.int32() as any);

            continue;
          }

          if (tag === 74) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.metricAggregations.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.orderBys.push(OrderBy.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.currencyCode = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.cohortSpec = CohortSpec.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.keepEmptyRows = reader.bool();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.returnPropertyQuota = reader.bool();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.comparisons.push(Comparison.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunReportRequest {
    return {
      property: isSet(object.property) ? globalThis.String(object.property) : "",
      dimensions: globalThis.Array.isArray(object?.dimensions)
        ? object.dimensions.map((e: any) => Dimension.fromJSON(e))
        : [],
      metrics: globalThis.Array.isArray(object?.metrics) ? object.metrics.map((e: any) => Metric.fromJSON(e)) : [],
      dateRanges: globalThis.Array.isArray(object?.dateRanges)
        ? object.dateRanges.map((e: any) => DateRange.fromJSON(e))
        : [],
      dimensionFilter: isSet(object.dimensionFilter) ? FilterExpression.fromJSON(object.dimensionFilter) : undefined,
      metricFilter: isSet(object.metricFilter) ? FilterExpression.fromJSON(object.metricFilter) : undefined,
      offset: isSet(object.offset) ? Long.fromValue(object.offset) : Long.ZERO,
      limit: isSet(object.limit) ? Long.fromValue(object.limit) : Long.ZERO,
      metricAggregations: globalThis.Array.isArray(object?.metricAggregations)
        ? object.metricAggregations.map((e: any) => metricAggregationFromJSON(e))
        : [],
      orderBys: globalThis.Array.isArray(object?.orderBys) ? object.orderBys.map((e: any) => OrderBy.fromJSON(e)) : [],
      currencyCode: isSet(object.currencyCode) ? globalThis.String(object.currencyCode) : "",
      cohortSpec: isSet(object.cohortSpec) ? CohortSpec.fromJSON(object.cohortSpec) : undefined,
      keepEmptyRows: isSet(object.keepEmptyRows) ? globalThis.Boolean(object.keepEmptyRows) : false,
      returnPropertyQuota: isSet(object.returnPropertyQuota) ? globalThis.Boolean(object.returnPropertyQuota) : false,
      comparisons: globalThis.Array.isArray(object?.comparisons)
        ? object.comparisons.map((e: any) => Comparison.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RunReportRequest): unknown {
    const obj: any = {};
    if (message.property !== "") {
      obj.property = message.property;
    }
    if (message.dimensions?.length) {
      obj.dimensions = message.dimensions.map((e) => Dimension.toJSON(e));
    }
    if (message.metrics?.length) {
      obj.metrics = message.metrics.map((e) => Metric.toJSON(e));
    }
    if (message.dateRanges?.length) {
      obj.dateRanges = message.dateRanges.map((e) => DateRange.toJSON(e));
    }
    if (message.dimensionFilter !== undefined) {
      obj.dimensionFilter = FilterExpression.toJSON(message.dimensionFilter);
    }
    if (message.metricFilter !== undefined) {
      obj.metricFilter = FilterExpression.toJSON(message.metricFilter);
    }
    if (!message.offset.equals(Long.ZERO)) {
      obj.offset = (message.offset || Long.ZERO).toString();
    }
    if (!message.limit.equals(Long.ZERO)) {
      obj.limit = (message.limit || Long.ZERO).toString();
    }
    if (message.metricAggregations?.length) {
      obj.metricAggregations = message.metricAggregations.map((e) => metricAggregationToJSON(e));
    }
    if (message.orderBys?.length) {
      obj.orderBys = message.orderBys.map((e) => OrderBy.toJSON(e));
    }
    if (message.currencyCode !== "") {
      obj.currencyCode = message.currencyCode;
    }
    if (message.cohortSpec !== undefined) {
      obj.cohortSpec = CohortSpec.toJSON(message.cohortSpec);
    }
    if (message.keepEmptyRows !== false) {
      obj.keepEmptyRows = message.keepEmptyRows;
    }
    if (message.returnPropertyQuota !== false) {
      obj.returnPropertyQuota = message.returnPropertyQuota;
    }
    if (message.comparisons?.length) {
      obj.comparisons = message.comparisons.map((e) => Comparison.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RunReportRequest>): RunReportRequest {
    return RunReportRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunReportRequest>): RunReportRequest {
    const message = createBaseRunReportRequest();
    message.property = object.property ?? "";
    message.dimensions = object.dimensions?.map((e) => Dimension.fromPartial(e)) || [];
    message.metrics = object.metrics?.map((e) => Metric.fromPartial(e)) || [];
    message.dateRanges = object.dateRanges?.map((e) => DateRange.fromPartial(e)) || [];
    message.dimensionFilter = (object.dimensionFilter !== undefined && object.dimensionFilter !== null)
      ? FilterExpression.fromPartial(object.dimensionFilter)
      : undefined;
    message.metricFilter = (object.metricFilter !== undefined && object.metricFilter !== null)
      ? FilterExpression.fromPartial(object.metricFilter)
      : undefined;
    message.offset = (object.offset !== undefined && object.offset !== null)
      ? Long.fromValue(object.offset)
      : Long.ZERO;
    message.limit = (object.limit !== undefined && object.limit !== null) ? Long.fromValue(object.limit) : Long.ZERO;
    message.metricAggregations = object.metricAggregations?.map((e) => e) || [];
    message.orderBys = object.orderBys?.map((e) => OrderBy.fromPartial(e)) || [];
    message.currencyCode = object.currencyCode ?? "";
    message.cohortSpec = (object.cohortSpec !== undefined && object.cohortSpec !== null)
      ? CohortSpec.fromPartial(object.cohortSpec)
      : undefined;
    message.keepEmptyRows = object.keepEmptyRows ?? false;
    message.returnPropertyQuota = object.returnPropertyQuota ?? false;
    message.comparisons = object.comparisons?.map((e) => Comparison.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRunReportResponse(): RunReportResponse {
  return {
    dimensionHeaders: [],
    metricHeaders: [],
    rows: [],
    totals: [],
    maximums: [],
    minimums: [],
    rowCount: 0,
    metadata: undefined,
    propertyQuota: undefined,
    kind: "",
  };
}

export const RunReportResponse: MessageFns<RunReportResponse> = {
  encode(message: RunReportResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.dimensionHeaders) {
      DimensionHeader.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.metricHeaders) {
      MetricHeader.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.rows) {
      Row.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.totals) {
      Row.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.maximums) {
      Row.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.minimums) {
      Row.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.rowCount !== 0) {
      writer.uint32(56).int32(message.rowCount);
    }
    if (message.metadata !== undefined) {
      ResponseMetaData.encode(message.metadata, writer.uint32(66).fork()).join();
    }
    if (message.propertyQuota !== undefined) {
      PropertyQuota.encode(message.propertyQuota, writer.uint32(74).fork()).join();
    }
    if (message.kind !== "") {
      writer.uint32(82).string(message.kind);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunReportResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunReportResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dimensionHeaders.push(DimensionHeader.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.metricHeaders.push(MetricHeader.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.rows.push(Row.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.totals.push(Row.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.maximums.push(Row.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.minimums.push(Row.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.rowCount = reader.int32();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.metadata = ResponseMetaData.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.propertyQuota = PropertyQuota.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.kind = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunReportResponse {
    return {
      dimensionHeaders: globalThis.Array.isArray(object?.dimensionHeaders)
        ? object.dimensionHeaders.map((e: any) => DimensionHeader.fromJSON(e))
        : [],
      metricHeaders: globalThis.Array.isArray(object?.metricHeaders)
        ? object.metricHeaders.map((e: any) => MetricHeader.fromJSON(e))
        : [],
      rows: globalThis.Array.isArray(object?.rows) ? object.rows.map((e: any) => Row.fromJSON(e)) : [],
      totals: globalThis.Array.isArray(object?.totals) ? object.totals.map((e: any) => Row.fromJSON(e)) : [],
      maximums: globalThis.Array.isArray(object?.maximums) ? object.maximums.map((e: any) => Row.fromJSON(e)) : [],
      minimums: globalThis.Array.isArray(object?.minimums) ? object.minimums.map((e: any) => Row.fromJSON(e)) : [],
      rowCount: isSet(object.rowCount) ? globalThis.Number(object.rowCount) : 0,
      metadata: isSet(object.metadata) ? ResponseMetaData.fromJSON(object.metadata) : undefined,
      propertyQuota: isSet(object.propertyQuota) ? PropertyQuota.fromJSON(object.propertyQuota) : undefined,
      kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
    };
  },

  toJSON(message: RunReportResponse): unknown {
    const obj: any = {};
    if (message.dimensionHeaders?.length) {
      obj.dimensionHeaders = message.dimensionHeaders.map((e) => DimensionHeader.toJSON(e));
    }
    if (message.metricHeaders?.length) {
      obj.metricHeaders = message.metricHeaders.map((e) => MetricHeader.toJSON(e));
    }
    if (message.rows?.length) {
      obj.rows = message.rows.map((e) => Row.toJSON(e));
    }
    if (message.totals?.length) {
      obj.totals = message.totals.map((e) => Row.toJSON(e));
    }
    if (message.maximums?.length) {
      obj.maximums = message.maximums.map((e) => Row.toJSON(e));
    }
    if (message.minimums?.length) {
      obj.minimums = message.minimums.map((e) => Row.toJSON(e));
    }
    if (message.rowCount !== 0) {
      obj.rowCount = Math.round(message.rowCount);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetaData.toJSON(message.metadata);
    }
    if (message.propertyQuota !== undefined) {
      obj.propertyQuota = PropertyQuota.toJSON(message.propertyQuota);
    }
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    return obj;
  },

  create(base?: DeepPartial<RunReportResponse>): RunReportResponse {
    return RunReportResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunReportResponse>): RunReportResponse {
    const message = createBaseRunReportResponse();
    message.dimensionHeaders = object.dimensionHeaders?.map((e) => DimensionHeader.fromPartial(e)) || [];
    message.metricHeaders = object.metricHeaders?.map((e) => MetricHeader.fromPartial(e)) || [];
    message.rows = object.rows?.map((e) => Row.fromPartial(e)) || [];
    message.totals = object.totals?.map((e) => Row.fromPartial(e)) || [];
    message.maximums = object.maximums?.map((e) => Row.fromPartial(e)) || [];
    message.minimums = object.minimums?.map((e) => Row.fromPartial(e)) || [];
    message.rowCount = object.rowCount ?? 0;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetaData.fromPartial(object.metadata)
      : undefined;
    message.propertyQuota = (object.propertyQuota !== undefined && object.propertyQuota !== null)
      ? PropertyQuota.fromPartial(object.propertyQuota)
      : undefined;
    message.kind = object.kind ?? "";
    return message;
  },
};

function createBaseRunPivotReportRequest(): RunPivotReportRequest {
  return {
    property: "",
    dimensions: [],
    metrics: [],
    dateRanges: [],
    pivots: [],
    dimensionFilter: undefined,
    metricFilter: undefined,
    currencyCode: "",
    cohortSpec: undefined,
    keepEmptyRows: false,
    returnPropertyQuota: false,
    comparisons: [],
  };
}

export const RunPivotReportRequest: MessageFns<RunPivotReportRequest> = {
  encode(message: RunPivotReportRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.property !== "") {
      writer.uint32(10).string(message.property);
    }
    for (const v of message.dimensions) {
      Dimension.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.metrics) {
      Metric.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.dateRanges) {
      DateRange.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.pivots) {
      Pivot.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.dimensionFilter !== undefined) {
      FilterExpression.encode(message.dimensionFilter, writer.uint32(50).fork()).join();
    }
    if (message.metricFilter !== undefined) {
      FilterExpression.encode(message.metricFilter, writer.uint32(58).fork()).join();
    }
    if (message.currencyCode !== "") {
      writer.uint32(66).string(message.currencyCode);
    }
    if (message.cohortSpec !== undefined) {
      CohortSpec.encode(message.cohortSpec, writer.uint32(74).fork()).join();
    }
    if (message.keepEmptyRows !== false) {
      writer.uint32(80).bool(message.keepEmptyRows);
    }
    if (message.returnPropertyQuota !== false) {
      writer.uint32(88).bool(message.returnPropertyQuota);
    }
    for (const v of message.comparisons) {
      Comparison.encode(v!, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunPivotReportRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunPivotReportRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.property = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dimensions.push(Dimension.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.metrics.push(Metric.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.dateRanges.push(DateRange.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.pivots.push(Pivot.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.dimensionFilter = FilterExpression.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.metricFilter = FilterExpression.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.currencyCode = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.cohortSpec = CohortSpec.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.keepEmptyRows = reader.bool();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.returnPropertyQuota = reader.bool();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.comparisons.push(Comparison.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunPivotReportRequest {
    return {
      property: isSet(object.property) ? globalThis.String(object.property) : "",
      dimensions: globalThis.Array.isArray(object?.dimensions)
        ? object.dimensions.map((e: any) => Dimension.fromJSON(e))
        : [],
      metrics: globalThis.Array.isArray(object?.metrics) ? object.metrics.map((e: any) => Metric.fromJSON(e)) : [],
      dateRanges: globalThis.Array.isArray(object?.dateRanges)
        ? object.dateRanges.map((e: any) => DateRange.fromJSON(e))
        : [],
      pivots: globalThis.Array.isArray(object?.pivots) ? object.pivots.map((e: any) => Pivot.fromJSON(e)) : [],
      dimensionFilter: isSet(object.dimensionFilter) ? FilterExpression.fromJSON(object.dimensionFilter) : undefined,
      metricFilter: isSet(object.metricFilter) ? FilterExpression.fromJSON(object.metricFilter) : undefined,
      currencyCode: isSet(object.currencyCode) ? globalThis.String(object.currencyCode) : "",
      cohortSpec: isSet(object.cohortSpec) ? CohortSpec.fromJSON(object.cohortSpec) : undefined,
      keepEmptyRows: isSet(object.keepEmptyRows) ? globalThis.Boolean(object.keepEmptyRows) : false,
      returnPropertyQuota: isSet(object.returnPropertyQuota) ? globalThis.Boolean(object.returnPropertyQuota) : false,
      comparisons: globalThis.Array.isArray(object?.comparisons)
        ? object.comparisons.map((e: any) => Comparison.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RunPivotReportRequest): unknown {
    const obj: any = {};
    if (message.property !== "") {
      obj.property = message.property;
    }
    if (message.dimensions?.length) {
      obj.dimensions = message.dimensions.map((e) => Dimension.toJSON(e));
    }
    if (message.metrics?.length) {
      obj.metrics = message.metrics.map((e) => Metric.toJSON(e));
    }
    if (message.dateRanges?.length) {
      obj.dateRanges = message.dateRanges.map((e) => DateRange.toJSON(e));
    }
    if (message.pivots?.length) {
      obj.pivots = message.pivots.map((e) => Pivot.toJSON(e));
    }
    if (message.dimensionFilter !== undefined) {
      obj.dimensionFilter = FilterExpression.toJSON(message.dimensionFilter);
    }
    if (message.metricFilter !== undefined) {
      obj.metricFilter = FilterExpression.toJSON(message.metricFilter);
    }
    if (message.currencyCode !== "") {
      obj.currencyCode = message.currencyCode;
    }
    if (message.cohortSpec !== undefined) {
      obj.cohortSpec = CohortSpec.toJSON(message.cohortSpec);
    }
    if (message.keepEmptyRows !== false) {
      obj.keepEmptyRows = message.keepEmptyRows;
    }
    if (message.returnPropertyQuota !== false) {
      obj.returnPropertyQuota = message.returnPropertyQuota;
    }
    if (message.comparisons?.length) {
      obj.comparisons = message.comparisons.map((e) => Comparison.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RunPivotReportRequest>): RunPivotReportRequest {
    return RunPivotReportRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunPivotReportRequest>): RunPivotReportRequest {
    const message = createBaseRunPivotReportRequest();
    message.property = object.property ?? "";
    message.dimensions = object.dimensions?.map((e) => Dimension.fromPartial(e)) || [];
    message.metrics = object.metrics?.map((e) => Metric.fromPartial(e)) || [];
    message.dateRanges = object.dateRanges?.map((e) => DateRange.fromPartial(e)) || [];
    message.pivots = object.pivots?.map((e) => Pivot.fromPartial(e)) || [];
    message.dimensionFilter = (object.dimensionFilter !== undefined && object.dimensionFilter !== null)
      ? FilterExpression.fromPartial(object.dimensionFilter)
      : undefined;
    message.metricFilter = (object.metricFilter !== undefined && object.metricFilter !== null)
      ? FilterExpression.fromPartial(object.metricFilter)
      : undefined;
    message.currencyCode = object.currencyCode ?? "";
    message.cohortSpec = (object.cohortSpec !== undefined && object.cohortSpec !== null)
      ? CohortSpec.fromPartial(object.cohortSpec)
      : undefined;
    message.keepEmptyRows = object.keepEmptyRows ?? false;
    message.returnPropertyQuota = object.returnPropertyQuota ?? false;
    message.comparisons = object.comparisons?.map((e) => Comparison.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRunPivotReportResponse(): RunPivotReportResponse {
  return {
    pivotHeaders: [],
    dimensionHeaders: [],
    metricHeaders: [],
    rows: [],
    aggregates: [],
    metadata: undefined,
    propertyQuota: undefined,
    kind: "",
  };
}

export const RunPivotReportResponse: MessageFns<RunPivotReportResponse> = {
  encode(message: RunPivotReportResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.pivotHeaders) {
      PivotHeader.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.dimensionHeaders) {
      DimensionHeader.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.metricHeaders) {
      MetricHeader.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.rows) {
      Row.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.aggregates) {
      Row.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetaData.encode(message.metadata, writer.uint32(50).fork()).join();
    }
    if (message.propertyQuota !== undefined) {
      PropertyQuota.encode(message.propertyQuota, writer.uint32(58).fork()).join();
    }
    if (message.kind !== "") {
      writer.uint32(66).string(message.kind);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunPivotReportResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunPivotReportResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pivotHeaders.push(PivotHeader.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dimensionHeaders.push(DimensionHeader.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.metricHeaders.push(MetricHeader.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.rows.push(Row.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.aggregates.push(Row.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.metadata = ResponseMetaData.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.propertyQuota = PropertyQuota.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.kind = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunPivotReportResponse {
    return {
      pivotHeaders: globalThis.Array.isArray(object?.pivotHeaders)
        ? object.pivotHeaders.map((e: any) => PivotHeader.fromJSON(e))
        : [],
      dimensionHeaders: globalThis.Array.isArray(object?.dimensionHeaders)
        ? object.dimensionHeaders.map((e: any) => DimensionHeader.fromJSON(e))
        : [],
      metricHeaders: globalThis.Array.isArray(object?.metricHeaders)
        ? object.metricHeaders.map((e: any) => MetricHeader.fromJSON(e))
        : [],
      rows: globalThis.Array.isArray(object?.rows) ? object.rows.map((e: any) => Row.fromJSON(e)) : [],
      aggregates: globalThis.Array.isArray(object?.aggregates)
        ? object.aggregates.map((e: any) => Row.fromJSON(e))
        : [],
      metadata: isSet(object.metadata) ? ResponseMetaData.fromJSON(object.metadata) : undefined,
      propertyQuota: isSet(object.propertyQuota) ? PropertyQuota.fromJSON(object.propertyQuota) : undefined,
      kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
    };
  },

  toJSON(message: RunPivotReportResponse): unknown {
    const obj: any = {};
    if (message.pivotHeaders?.length) {
      obj.pivotHeaders = message.pivotHeaders.map((e) => PivotHeader.toJSON(e));
    }
    if (message.dimensionHeaders?.length) {
      obj.dimensionHeaders = message.dimensionHeaders.map((e) => DimensionHeader.toJSON(e));
    }
    if (message.metricHeaders?.length) {
      obj.metricHeaders = message.metricHeaders.map((e) => MetricHeader.toJSON(e));
    }
    if (message.rows?.length) {
      obj.rows = message.rows.map((e) => Row.toJSON(e));
    }
    if (message.aggregates?.length) {
      obj.aggregates = message.aggregates.map((e) => Row.toJSON(e));
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetaData.toJSON(message.metadata);
    }
    if (message.propertyQuota !== undefined) {
      obj.propertyQuota = PropertyQuota.toJSON(message.propertyQuota);
    }
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    return obj;
  },

  create(base?: DeepPartial<RunPivotReportResponse>): RunPivotReportResponse {
    return RunPivotReportResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunPivotReportResponse>): RunPivotReportResponse {
    const message = createBaseRunPivotReportResponse();
    message.pivotHeaders = object.pivotHeaders?.map((e) => PivotHeader.fromPartial(e)) || [];
    message.dimensionHeaders = object.dimensionHeaders?.map((e) => DimensionHeader.fromPartial(e)) || [];
    message.metricHeaders = object.metricHeaders?.map((e) => MetricHeader.fromPartial(e)) || [];
    message.rows = object.rows?.map((e) => Row.fromPartial(e)) || [];
    message.aggregates = object.aggregates?.map((e) => Row.fromPartial(e)) || [];
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetaData.fromPartial(object.metadata)
      : undefined;
    message.propertyQuota = (object.propertyQuota !== undefined && object.propertyQuota !== null)
      ? PropertyQuota.fromPartial(object.propertyQuota)
      : undefined;
    message.kind = object.kind ?? "";
    return message;
  },
};

function createBaseBatchRunReportsRequest(): BatchRunReportsRequest {
  return { property: "", requests: [] };
}

export const BatchRunReportsRequest: MessageFns<BatchRunReportsRequest> = {
  encode(message: BatchRunReportsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.property !== "") {
      writer.uint32(10).string(message.property);
    }
    for (const v of message.requests) {
      RunReportRequest.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchRunReportsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchRunReportsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.property = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requests.push(RunReportRequest.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchRunReportsRequest {
    return {
      property: isSet(object.property) ? globalThis.String(object.property) : "",
      requests: globalThis.Array.isArray(object?.requests)
        ? object.requests.map((e: any) => RunReportRequest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchRunReportsRequest): unknown {
    const obj: any = {};
    if (message.property !== "") {
      obj.property = message.property;
    }
    if (message.requests?.length) {
      obj.requests = message.requests.map((e) => RunReportRequest.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchRunReportsRequest>): BatchRunReportsRequest {
    return BatchRunReportsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchRunReportsRequest>): BatchRunReportsRequest {
    const message = createBaseBatchRunReportsRequest();
    message.property = object.property ?? "";
    message.requests = object.requests?.map((e) => RunReportRequest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBatchRunReportsResponse(): BatchRunReportsResponse {
  return { reports: [], kind: "" };
}

export const BatchRunReportsResponse: MessageFns<BatchRunReportsResponse> = {
  encode(message: BatchRunReportsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.reports) {
      RunReportResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.kind !== "") {
      writer.uint32(18).string(message.kind);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchRunReportsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchRunReportsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.reports.push(RunReportResponse.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.kind = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchRunReportsResponse {
    return {
      reports: globalThis.Array.isArray(object?.reports)
        ? object.reports.map((e: any) => RunReportResponse.fromJSON(e))
        : [],
      kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
    };
  },

  toJSON(message: BatchRunReportsResponse): unknown {
    const obj: any = {};
    if (message.reports?.length) {
      obj.reports = message.reports.map((e) => RunReportResponse.toJSON(e));
    }
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    return obj;
  },

  create(base?: DeepPartial<BatchRunReportsResponse>): BatchRunReportsResponse {
    return BatchRunReportsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchRunReportsResponse>): BatchRunReportsResponse {
    const message = createBaseBatchRunReportsResponse();
    message.reports = object.reports?.map((e) => RunReportResponse.fromPartial(e)) || [];
    message.kind = object.kind ?? "";
    return message;
  },
};

function createBaseBatchRunPivotReportsRequest(): BatchRunPivotReportsRequest {
  return { property: "", requests: [] };
}

export const BatchRunPivotReportsRequest: MessageFns<BatchRunPivotReportsRequest> = {
  encode(message: BatchRunPivotReportsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.property !== "") {
      writer.uint32(10).string(message.property);
    }
    for (const v of message.requests) {
      RunPivotReportRequest.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchRunPivotReportsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchRunPivotReportsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.property = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requests.push(RunPivotReportRequest.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchRunPivotReportsRequest {
    return {
      property: isSet(object.property) ? globalThis.String(object.property) : "",
      requests: globalThis.Array.isArray(object?.requests)
        ? object.requests.map((e: any) => RunPivotReportRequest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchRunPivotReportsRequest): unknown {
    const obj: any = {};
    if (message.property !== "") {
      obj.property = message.property;
    }
    if (message.requests?.length) {
      obj.requests = message.requests.map((e) => RunPivotReportRequest.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchRunPivotReportsRequest>): BatchRunPivotReportsRequest {
    return BatchRunPivotReportsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchRunPivotReportsRequest>): BatchRunPivotReportsRequest {
    const message = createBaseBatchRunPivotReportsRequest();
    message.property = object.property ?? "";
    message.requests = object.requests?.map((e) => RunPivotReportRequest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBatchRunPivotReportsResponse(): BatchRunPivotReportsResponse {
  return { pivotReports: [], kind: "" };
}

export const BatchRunPivotReportsResponse: MessageFns<BatchRunPivotReportsResponse> = {
  encode(message: BatchRunPivotReportsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.pivotReports) {
      RunPivotReportResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.kind !== "") {
      writer.uint32(18).string(message.kind);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchRunPivotReportsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchRunPivotReportsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pivotReports.push(RunPivotReportResponse.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.kind = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchRunPivotReportsResponse {
    return {
      pivotReports: globalThis.Array.isArray(object?.pivotReports)
        ? object.pivotReports.map((e: any) => RunPivotReportResponse.fromJSON(e))
        : [],
      kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
    };
  },

  toJSON(message: BatchRunPivotReportsResponse): unknown {
    const obj: any = {};
    if (message.pivotReports?.length) {
      obj.pivotReports = message.pivotReports.map((e) => RunPivotReportResponse.toJSON(e));
    }
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    return obj;
  },

  create(base?: DeepPartial<BatchRunPivotReportsResponse>): BatchRunPivotReportsResponse {
    return BatchRunPivotReportsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchRunPivotReportsResponse>): BatchRunPivotReportsResponse {
    const message = createBaseBatchRunPivotReportsResponse();
    message.pivotReports = object.pivotReports?.map((e) => RunPivotReportResponse.fromPartial(e)) || [];
    message.kind = object.kind ?? "";
    return message;
  },
};

function createBaseGetMetadataRequest(): GetMetadataRequest {
  return { name: "" };
}

export const GetMetadataRequest: MessageFns<GetMetadataRequest> = {
  encode(message: GetMetadataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMetadataRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMetadataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMetadataRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetMetadataRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetMetadataRequest>): GetMetadataRequest {
    return GetMetadataRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetMetadataRequest>): GetMetadataRequest {
    const message = createBaseGetMetadataRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseRunRealtimeReportRequest(): RunRealtimeReportRequest {
  return {
    property: "",
    dimensions: [],
    metrics: [],
    dimensionFilter: undefined,
    metricFilter: undefined,
    limit: Long.ZERO,
    metricAggregations: [],
    orderBys: [],
    returnPropertyQuota: false,
    minuteRanges: [],
  };
}

export const RunRealtimeReportRequest: MessageFns<RunRealtimeReportRequest> = {
  encode(message: RunRealtimeReportRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.property !== "") {
      writer.uint32(10).string(message.property);
    }
    for (const v of message.dimensions) {
      Dimension.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.metrics) {
      Metric.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.dimensionFilter !== undefined) {
      FilterExpression.encode(message.dimensionFilter, writer.uint32(34).fork()).join();
    }
    if (message.metricFilter !== undefined) {
      FilterExpression.encode(message.metricFilter, writer.uint32(42).fork()).join();
    }
    if (!message.limit.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.limit.toString());
    }
    writer.uint32(58).fork();
    for (const v of message.metricAggregations) {
      writer.int32(v);
    }
    writer.join();
    for (const v of message.orderBys) {
      OrderBy.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.returnPropertyQuota !== false) {
      writer.uint32(72).bool(message.returnPropertyQuota);
    }
    for (const v of message.minuteRanges) {
      MinuteRange.encode(v!, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunRealtimeReportRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunRealtimeReportRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.property = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dimensions.push(Dimension.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.metrics.push(Metric.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.dimensionFilter = FilterExpression.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.metricFilter = FilterExpression.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.limit = Long.fromString(reader.int64().toString());
          continue;
        case 7:
          if (tag === 56) {
            message.metricAggregations.push(reader.int32() as any);

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.metricAggregations.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.orderBys.push(OrderBy.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.returnPropertyQuota = reader.bool();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.minuteRanges.push(MinuteRange.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunRealtimeReportRequest {
    return {
      property: isSet(object.property) ? globalThis.String(object.property) : "",
      dimensions: globalThis.Array.isArray(object?.dimensions)
        ? object.dimensions.map((e: any) => Dimension.fromJSON(e))
        : [],
      metrics: globalThis.Array.isArray(object?.metrics) ? object.metrics.map((e: any) => Metric.fromJSON(e)) : [],
      dimensionFilter: isSet(object.dimensionFilter) ? FilterExpression.fromJSON(object.dimensionFilter) : undefined,
      metricFilter: isSet(object.metricFilter) ? FilterExpression.fromJSON(object.metricFilter) : undefined,
      limit: isSet(object.limit) ? Long.fromValue(object.limit) : Long.ZERO,
      metricAggregations: globalThis.Array.isArray(object?.metricAggregations)
        ? object.metricAggregations.map((e: any) => metricAggregationFromJSON(e))
        : [],
      orderBys: globalThis.Array.isArray(object?.orderBys) ? object.orderBys.map((e: any) => OrderBy.fromJSON(e)) : [],
      returnPropertyQuota: isSet(object.returnPropertyQuota) ? globalThis.Boolean(object.returnPropertyQuota) : false,
      minuteRanges: globalThis.Array.isArray(object?.minuteRanges)
        ? object.minuteRanges.map((e: any) => MinuteRange.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RunRealtimeReportRequest): unknown {
    const obj: any = {};
    if (message.property !== "") {
      obj.property = message.property;
    }
    if (message.dimensions?.length) {
      obj.dimensions = message.dimensions.map((e) => Dimension.toJSON(e));
    }
    if (message.metrics?.length) {
      obj.metrics = message.metrics.map((e) => Metric.toJSON(e));
    }
    if (message.dimensionFilter !== undefined) {
      obj.dimensionFilter = FilterExpression.toJSON(message.dimensionFilter);
    }
    if (message.metricFilter !== undefined) {
      obj.metricFilter = FilterExpression.toJSON(message.metricFilter);
    }
    if (!message.limit.equals(Long.ZERO)) {
      obj.limit = (message.limit || Long.ZERO).toString();
    }
    if (message.metricAggregations?.length) {
      obj.metricAggregations = message.metricAggregations.map((e) => metricAggregationToJSON(e));
    }
    if (message.orderBys?.length) {
      obj.orderBys = message.orderBys.map((e) => OrderBy.toJSON(e));
    }
    if (message.returnPropertyQuota !== false) {
      obj.returnPropertyQuota = message.returnPropertyQuota;
    }
    if (message.minuteRanges?.length) {
      obj.minuteRanges = message.minuteRanges.map((e) => MinuteRange.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RunRealtimeReportRequest>): RunRealtimeReportRequest {
    return RunRealtimeReportRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunRealtimeReportRequest>): RunRealtimeReportRequest {
    const message = createBaseRunRealtimeReportRequest();
    message.property = object.property ?? "";
    message.dimensions = object.dimensions?.map((e) => Dimension.fromPartial(e)) || [];
    message.metrics = object.metrics?.map((e) => Metric.fromPartial(e)) || [];
    message.dimensionFilter = (object.dimensionFilter !== undefined && object.dimensionFilter !== null)
      ? FilterExpression.fromPartial(object.dimensionFilter)
      : undefined;
    message.metricFilter = (object.metricFilter !== undefined && object.metricFilter !== null)
      ? FilterExpression.fromPartial(object.metricFilter)
      : undefined;
    message.limit = (object.limit !== undefined && object.limit !== null) ? Long.fromValue(object.limit) : Long.ZERO;
    message.metricAggregations = object.metricAggregations?.map((e) => e) || [];
    message.orderBys = object.orderBys?.map((e) => OrderBy.fromPartial(e)) || [];
    message.returnPropertyQuota = object.returnPropertyQuota ?? false;
    message.minuteRanges = object.minuteRanges?.map((e) => MinuteRange.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRunRealtimeReportResponse(): RunRealtimeReportResponse {
  return {
    dimensionHeaders: [],
    metricHeaders: [],
    rows: [],
    totals: [],
    maximums: [],
    minimums: [],
    rowCount: 0,
    propertyQuota: undefined,
    kind: "",
  };
}

export const RunRealtimeReportResponse: MessageFns<RunRealtimeReportResponse> = {
  encode(message: RunRealtimeReportResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.dimensionHeaders) {
      DimensionHeader.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.metricHeaders) {
      MetricHeader.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.rows) {
      Row.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.totals) {
      Row.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.maximums) {
      Row.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.minimums) {
      Row.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.rowCount !== 0) {
      writer.uint32(56).int32(message.rowCount);
    }
    if (message.propertyQuota !== undefined) {
      PropertyQuota.encode(message.propertyQuota, writer.uint32(66).fork()).join();
    }
    if (message.kind !== "") {
      writer.uint32(74).string(message.kind);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunRealtimeReportResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunRealtimeReportResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dimensionHeaders.push(DimensionHeader.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.metricHeaders.push(MetricHeader.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.rows.push(Row.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.totals.push(Row.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.maximums.push(Row.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.minimums.push(Row.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.rowCount = reader.int32();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.propertyQuota = PropertyQuota.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.kind = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunRealtimeReportResponse {
    return {
      dimensionHeaders: globalThis.Array.isArray(object?.dimensionHeaders)
        ? object.dimensionHeaders.map((e: any) => DimensionHeader.fromJSON(e))
        : [],
      metricHeaders: globalThis.Array.isArray(object?.metricHeaders)
        ? object.metricHeaders.map((e: any) => MetricHeader.fromJSON(e))
        : [],
      rows: globalThis.Array.isArray(object?.rows) ? object.rows.map((e: any) => Row.fromJSON(e)) : [],
      totals: globalThis.Array.isArray(object?.totals) ? object.totals.map((e: any) => Row.fromJSON(e)) : [],
      maximums: globalThis.Array.isArray(object?.maximums) ? object.maximums.map((e: any) => Row.fromJSON(e)) : [],
      minimums: globalThis.Array.isArray(object?.minimums) ? object.minimums.map((e: any) => Row.fromJSON(e)) : [],
      rowCount: isSet(object.rowCount) ? globalThis.Number(object.rowCount) : 0,
      propertyQuota: isSet(object.propertyQuota) ? PropertyQuota.fromJSON(object.propertyQuota) : undefined,
      kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
    };
  },

  toJSON(message: RunRealtimeReportResponse): unknown {
    const obj: any = {};
    if (message.dimensionHeaders?.length) {
      obj.dimensionHeaders = message.dimensionHeaders.map((e) => DimensionHeader.toJSON(e));
    }
    if (message.metricHeaders?.length) {
      obj.metricHeaders = message.metricHeaders.map((e) => MetricHeader.toJSON(e));
    }
    if (message.rows?.length) {
      obj.rows = message.rows.map((e) => Row.toJSON(e));
    }
    if (message.totals?.length) {
      obj.totals = message.totals.map((e) => Row.toJSON(e));
    }
    if (message.maximums?.length) {
      obj.maximums = message.maximums.map((e) => Row.toJSON(e));
    }
    if (message.minimums?.length) {
      obj.minimums = message.minimums.map((e) => Row.toJSON(e));
    }
    if (message.rowCount !== 0) {
      obj.rowCount = Math.round(message.rowCount);
    }
    if (message.propertyQuota !== undefined) {
      obj.propertyQuota = PropertyQuota.toJSON(message.propertyQuota);
    }
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    return obj;
  },

  create(base?: DeepPartial<RunRealtimeReportResponse>): RunRealtimeReportResponse {
    return RunRealtimeReportResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunRealtimeReportResponse>): RunRealtimeReportResponse {
    const message = createBaseRunRealtimeReportResponse();
    message.dimensionHeaders = object.dimensionHeaders?.map((e) => DimensionHeader.fromPartial(e)) || [];
    message.metricHeaders = object.metricHeaders?.map((e) => MetricHeader.fromPartial(e)) || [];
    message.rows = object.rows?.map((e) => Row.fromPartial(e)) || [];
    message.totals = object.totals?.map((e) => Row.fromPartial(e)) || [];
    message.maximums = object.maximums?.map((e) => Row.fromPartial(e)) || [];
    message.minimums = object.minimums?.map((e) => Row.fromPartial(e)) || [];
    message.rowCount = object.rowCount ?? 0;
    message.propertyQuota = (object.propertyQuota !== undefined && object.propertyQuota !== null)
      ? PropertyQuota.fromPartial(object.propertyQuota)
      : undefined;
    message.kind = object.kind ?? "";
    return message;
  },
};

function createBaseGetAudienceExportRequest(): GetAudienceExportRequest {
  return { name: "" };
}

export const GetAudienceExportRequest: MessageFns<GetAudienceExportRequest> = {
  encode(message: GetAudienceExportRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAudienceExportRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAudienceExportRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAudienceExportRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetAudienceExportRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetAudienceExportRequest>): GetAudienceExportRequest {
    return GetAudienceExportRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAudienceExportRequest>): GetAudienceExportRequest {
    const message = createBaseGetAudienceExportRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListAudienceExportsRequest(): ListAudienceExportsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListAudienceExportsRequest: MessageFns<ListAudienceExportsRequest> = {
  encode(message: ListAudienceExportsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAudienceExportsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAudienceExportsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAudienceExportsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListAudienceExportsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAudienceExportsRequest>): ListAudienceExportsRequest {
    return ListAudienceExportsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAudienceExportsRequest>): ListAudienceExportsRequest {
    const message = createBaseListAudienceExportsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListAudienceExportsResponse(): ListAudienceExportsResponse {
  return { audienceExports: [], nextPageToken: undefined };
}

export const ListAudienceExportsResponse: MessageFns<ListAudienceExportsResponse> = {
  encode(message: ListAudienceExportsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.audienceExports) {
      AudienceExport.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== undefined) {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAudienceExportsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAudienceExportsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.audienceExports.push(AudienceExport.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAudienceExportsResponse {
    return {
      audienceExports: globalThis.Array.isArray(object?.audienceExports)
        ? object.audienceExports.map((e: any) => AudienceExport.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : undefined,
    };
  },

  toJSON(message: ListAudienceExportsResponse): unknown {
    const obj: any = {};
    if (message.audienceExports?.length) {
      obj.audienceExports = message.audienceExports.map((e) => AudienceExport.toJSON(e));
    }
    if (message.nextPageToken !== undefined) {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAudienceExportsResponse>): ListAudienceExportsResponse {
    return ListAudienceExportsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAudienceExportsResponse>): ListAudienceExportsResponse {
    const message = createBaseListAudienceExportsResponse();
    message.audienceExports = object.audienceExports?.map((e) => AudienceExport.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? undefined;
    return message;
  },
};

function createBaseCreateAudienceExportRequest(): CreateAudienceExportRequest {
  return { parent: "", audienceExport: undefined };
}

export const CreateAudienceExportRequest: MessageFns<CreateAudienceExportRequest> = {
  encode(message: CreateAudienceExportRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.audienceExport !== undefined) {
      AudienceExport.encode(message.audienceExport, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateAudienceExportRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateAudienceExportRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.audienceExport = AudienceExport.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateAudienceExportRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      audienceExport: isSet(object.audienceExport) ? AudienceExport.fromJSON(object.audienceExport) : undefined,
    };
  },

  toJSON(message: CreateAudienceExportRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.audienceExport !== undefined) {
      obj.audienceExport = AudienceExport.toJSON(message.audienceExport);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateAudienceExportRequest>): CreateAudienceExportRequest {
    return CreateAudienceExportRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateAudienceExportRequest>): CreateAudienceExportRequest {
    const message = createBaseCreateAudienceExportRequest();
    message.parent = object.parent ?? "";
    message.audienceExport = (object.audienceExport !== undefined && object.audienceExport !== null)
      ? AudienceExport.fromPartial(object.audienceExport)
      : undefined;
    return message;
  },
};

function createBaseAudienceExport(): AudienceExport {
  return {
    name: "",
    audience: "",
    audienceDisplayName: "",
    dimensions: [],
    state: undefined,
    beginCreatingTime: undefined,
    creationQuotaTokensCharged: 0,
    rowCount: undefined,
    errorMessage: undefined,
    percentageCompleted: undefined,
  };
}

export const AudienceExport: MessageFns<AudienceExport> = {
  encode(message: AudienceExport, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.audience !== "") {
      writer.uint32(18).string(message.audience);
    }
    if (message.audienceDisplayName !== "") {
      writer.uint32(26).string(message.audienceDisplayName);
    }
    for (const v of message.dimensions) {
      AudienceDimension.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.state !== undefined) {
      writer.uint32(40).int32(message.state);
    }
    if (message.beginCreatingTime !== undefined) {
      Timestamp.encode(toTimestamp(message.beginCreatingTime), writer.uint32(50).fork()).join();
    }
    if (message.creationQuotaTokensCharged !== 0) {
      writer.uint32(56).int32(message.creationQuotaTokensCharged);
    }
    if (message.rowCount !== undefined) {
      writer.uint32(64).int32(message.rowCount);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(74).string(message.errorMessage);
    }
    if (message.percentageCompleted !== undefined) {
      writer.uint32(81).double(message.percentageCompleted);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudienceExport {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudienceExport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.audience = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.audienceDisplayName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.dimensions.push(AudienceDimension.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.beginCreatingTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.creationQuotaTokensCharged = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.rowCount = reader.int32();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 10:
          if (tag !== 81) {
            break;
          }

          message.percentageCompleted = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudienceExport {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      audience: isSet(object.audience) ? globalThis.String(object.audience) : "",
      audienceDisplayName: isSet(object.audienceDisplayName) ? globalThis.String(object.audienceDisplayName) : "",
      dimensions: globalThis.Array.isArray(object?.dimensions)
        ? object.dimensions.map((e: any) => AudienceDimension.fromJSON(e))
        : [],
      state: isSet(object.state) ? audienceExport_StateFromJSON(object.state) : undefined,
      beginCreatingTime: isSet(object.beginCreatingTime) ? fromJsonTimestamp(object.beginCreatingTime) : undefined,
      creationQuotaTokensCharged: isSet(object.creationQuotaTokensCharged)
        ? globalThis.Number(object.creationQuotaTokensCharged)
        : 0,
      rowCount: isSet(object.rowCount) ? globalThis.Number(object.rowCount) : undefined,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : undefined,
      percentageCompleted: isSet(object.percentageCompleted)
        ? globalThis.Number(object.percentageCompleted)
        : undefined,
    };
  },

  toJSON(message: AudienceExport): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.audience !== "") {
      obj.audience = message.audience;
    }
    if (message.audienceDisplayName !== "") {
      obj.audienceDisplayName = message.audienceDisplayName;
    }
    if (message.dimensions?.length) {
      obj.dimensions = message.dimensions.map((e) => AudienceDimension.toJSON(e));
    }
    if (message.state !== undefined) {
      obj.state = audienceExport_StateToJSON(message.state);
    }
    if (message.beginCreatingTime !== undefined) {
      obj.beginCreatingTime = message.beginCreatingTime.toISOString();
    }
    if (message.creationQuotaTokensCharged !== 0) {
      obj.creationQuotaTokensCharged = Math.round(message.creationQuotaTokensCharged);
    }
    if (message.rowCount !== undefined) {
      obj.rowCount = Math.round(message.rowCount);
    }
    if (message.errorMessage !== undefined) {
      obj.errorMessage = message.errorMessage;
    }
    if (message.percentageCompleted !== undefined) {
      obj.percentageCompleted = message.percentageCompleted;
    }
    return obj;
  },

  create(base?: DeepPartial<AudienceExport>): AudienceExport {
    return AudienceExport.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AudienceExport>): AudienceExport {
    const message = createBaseAudienceExport();
    message.name = object.name ?? "";
    message.audience = object.audience ?? "";
    message.audienceDisplayName = object.audienceDisplayName ?? "";
    message.dimensions = object.dimensions?.map((e) => AudienceDimension.fromPartial(e)) || [];
    message.state = object.state ?? undefined;
    message.beginCreatingTime = object.beginCreatingTime ?? undefined;
    message.creationQuotaTokensCharged = object.creationQuotaTokensCharged ?? 0;
    message.rowCount = object.rowCount ?? undefined;
    message.errorMessage = object.errorMessage ?? undefined;
    message.percentageCompleted = object.percentageCompleted ?? undefined;
    return message;
  },
};

function createBaseAudienceExportMetadata(): AudienceExportMetadata {
  return {};
}

export const AudienceExportMetadata: MessageFns<AudienceExportMetadata> = {
  encode(_: AudienceExportMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudienceExportMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudienceExportMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AudienceExportMetadata {
    return {};
  },

  toJSON(_: AudienceExportMetadata): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<AudienceExportMetadata>): AudienceExportMetadata {
    return AudienceExportMetadata.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<AudienceExportMetadata>): AudienceExportMetadata {
    const message = createBaseAudienceExportMetadata();
    return message;
  },
};

function createBaseQueryAudienceExportRequest(): QueryAudienceExportRequest {
  return { name: "", offset: Long.ZERO, limit: Long.ZERO };
}

export const QueryAudienceExportRequest: MessageFns<QueryAudienceExportRequest> = {
  encode(message: QueryAudienceExportRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (!message.offset.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.offset.toString());
    }
    if (!message.limit.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.limit.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAudienceExportRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAudienceExportRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.offset = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.limit = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAudienceExportRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      offset: isSet(object.offset) ? Long.fromValue(object.offset) : Long.ZERO,
      limit: isSet(object.limit) ? Long.fromValue(object.limit) : Long.ZERO,
    };
  },

  toJSON(message: QueryAudienceExportRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (!message.offset.equals(Long.ZERO)) {
      obj.offset = (message.offset || Long.ZERO).toString();
    }
    if (!message.limit.equals(Long.ZERO)) {
      obj.limit = (message.limit || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<QueryAudienceExportRequest>): QueryAudienceExportRequest {
    return QueryAudienceExportRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryAudienceExportRequest>): QueryAudienceExportRequest {
    const message = createBaseQueryAudienceExportRequest();
    message.name = object.name ?? "";
    message.offset = (object.offset !== undefined && object.offset !== null)
      ? Long.fromValue(object.offset)
      : Long.ZERO;
    message.limit = (object.limit !== undefined && object.limit !== null) ? Long.fromValue(object.limit) : Long.ZERO;
    return message;
  },
};

function createBaseQueryAudienceExportResponse(): QueryAudienceExportResponse {
  return { audienceExport: undefined, audienceRows: [], rowCount: undefined };
}

export const QueryAudienceExportResponse: MessageFns<QueryAudienceExportResponse> = {
  encode(message: QueryAudienceExportResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.audienceExport !== undefined) {
      AudienceExport.encode(message.audienceExport, writer.uint32(10).fork()).join();
    }
    for (const v of message.audienceRows) {
      AudienceRow.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.rowCount !== undefined) {
      writer.uint32(24).int32(message.rowCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAudienceExportResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAudienceExportResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.audienceExport = AudienceExport.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.audienceRows.push(AudienceRow.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.rowCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAudienceExportResponse {
    return {
      audienceExport: isSet(object.audienceExport) ? AudienceExport.fromJSON(object.audienceExport) : undefined,
      audienceRows: globalThis.Array.isArray(object?.audienceRows)
        ? object.audienceRows.map((e: any) => AudienceRow.fromJSON(e))
        : [],
      rowCount: isSet(object.rowCount) ? globalThis.Number(object.rowCount) : undefined,
    };
  },

  toJSON(message: QueryAudienceExportResponse): unknown {
    const obj: any = {};
    if (message.audienceExport !== undefined) {
      obj.audienceExport = AudienceExport.toJSON(message.audienceExport);
    }
    if (message.audienceRows?.length) {
      obj.audienceRows = message.audienceRows.map((e) => AudienceRow.toJSON(e));
    }
    if (message.rowCount !== undefined) {
      obj.rowCount = Math.round(message.rowCount);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryAudienceExportResponse>): QueryAudienceExportResponse {
    return QueryAudienceExportResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryAudienceExportResponse>): QueryAudienceExportResponse {
    const message = createBaseQueryAudienceExportResponse();
    message.audienceExport = (object.audienceExport !== undefined && object.audienceExport !== null)
      ? AudienceExport.fromPartial(object.audienceExport)
      : undefined;
    message.audienceRows = object.audienceRows?.map((e) => AudienceRow.fromPartial(e)) || [];
    message.rowCount = object.rowCount ?? undefined;
    return message;
  },
};

function createBaseAudienceRow(): AudienceRow {
  return { dimensionValues: [] };
}

export const AudienceRow: MessageFns<AudienceRow> = {
  encode(message: AudienceRow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.dimensionValues) {
      AudienceDimensionValue.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudienceRow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudienceRow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dimensionValues.push(AudienceDimensionValue.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudienceRow {
    return {
      dimensionValues: globalThis.Array.isArray(object?.dimensionValues)
        ? object.dimensionValues.map((e: any) => AudienceDimensionValue.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AudienceRow): unknown {
    const obj: any = {};
    if (message.dimensionValues?.length) {
      obj.dimensionValues = message.dimensionValues.map((e) => AudienceDimensionValue.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AudienceRow>): AudienceRow {
    return AudienceRow.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AudienceRow>): AudienceRow {
    const message = createBaseAudienceRow();
    message.dimensionValues = object.dimensionValues?.map((e) => AudienceDimensionValue.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAudienceDimension(): AudienceDimension {
  return { dimensionName: "" };
}

export const AudienceDimension: MessageFns<AudienceDimension> = {
  encode(message: AudienceDimension, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dimensionName !== "") {
      writer.uint32(10).string(message.dimensionName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudienceDimension {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudienceDimension();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dimensionName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudienceDimension {
    return { dimensionName: isSet(object.dimensionName) ? globalThis.String(object.dimensionName) : "" };
  },

  toJSON(message: AudienceDimension): unknown {
    const obj: any = {};
    if (message.dimensionName !== "") {
      obj.dimensionName = message.dimensionName;
    }
    return obj;
  },

  create(base?: DeepPartial<AudienceDimension>): AudienceDimension {
    return AudienceDimension.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AudienceDimension>): AudienceDimension {
    const message = createBaseAudienceDimension();
    message.dimensionName = object.dimensionName ?? "";
    return message;
  },
};

function createBaseAudienceDimensionValue(): AudienceDimensionValue {
  return { value: undefined };
}

export const AudienceDimensionValue: MessageFns<AudienceDimensionValue> = {
  encode(message: AudienceDimensionValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== undefined) {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudienceDimensionValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudienceDimensionValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudienceDimensionValue {
    return { value: isSet(object.value) ? globalThis.String(object.value) : undefined };
  },

  toJSON(message: AudienceDimensionValue): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<AudienceDimensionValue>): AudienceDimensionValue {
    return AudienceDimensionValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AudienceDimensionValue>): AudienceDimensionValue {
    const message = createBaseAudienceDimensionValue();
    message.value = object.value ?? undefined;
    return message;
  },
};

/** Google Analytics reporting data service. */
export type BetaAnalyticsDataDefinition = typeof BetaAnalyticsDataDefinition;
export const BetaAnalyticsDataDefinition = {
  name: "BetaAnalyticsData",
  fullName: "google.analytics.data.v1beta.BetaAnalyticsData",
  methods: {
    /**
     * Returns a customized report of your Google Analytics event data. Reports
     * contain statistics derived from data collected by the Google Analytics
     * tracking code. The data returned from the API is as a table with columns
     * for the requested dimensions and metrics. Metrics are individual
     * measurements of user activity on your property, such as active users or
     * event count. Dimensions break down metrics across some common criteria,
     * such as country or event name.
     *
     * For a guide to constructing requests & understanding responses, see
     * [Creating a
     * Report](https://developers.google.com/analytics/devguides/reporting/data/v1/basics).
     */
    runReport: {
      name: "RunReport",
      requestType: RunReportRequest,
      requestStream: false,
      responseType: RunReportResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              46,
              58,
              1,
              42,
              34,
              41,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              112,
              114,
              111,
              112,
              101,
              114,
              116,
              121,
              61,
              112,
              114,
              111,
              112,
              101,
              114,
              116,
              105,
              101,
              115,
              47,
              42,
              125,
              58,
              114,
              117,
              110,
              82,
              101,
              112,
              111,
              114,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * Returns a customized pivot report of your Google Analytics event data.
     * Pivot reports are more advanced and expressive formats than regular
     * reports. In a pivot report, dimensions are only visible if they are
     * included in a pivot. Multiple pivots can be specified to further dissect
     * your data.
     */
    runPivotReport: {
      name: "RunPivotReport",
      requestType: RunPivotReportRequest,
      requestStream: false,
      responseType: RunPivotReportResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              51,
              58,
              1,
              42,
              34,
              46,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              112,
              114,
              111,
              112,
              101,
              114,
              116,
              121,
              61,
              112,
              114,
              111,
              112,
              101,
              114,
              116,
              105,
              101,
              115,
              47,
              42,
              125,
              58,
              114,
              117,
              110,
              80,
              105,
              118,
              111,
              116,
              82,
              101,
              112,
              111,
              114,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * Returns multiple reports in a batch. All reports must be for the same
     * GA4 Property.
     */
    batchRunReports: {
      name: "BatchRunReports",
      requestType: BatchRunReportsRequest,
      requestStream: false,
      responseType: BatchRunReportsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              52,
              58,
              1,
              42,
              34,
              47,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              112,
              114,
              111,
              112,
              101,
              114,
              116,
              121,
              61,
              112,
              114,
              111,
              112,
              101,
              114,
              116,
              105,
              101,
              115,
              47,
              42,
              125,
              58,
              98,
              97,
              116,
              99,
              104,
              82,
              117,
              110,
              82,
              101,
              112,
              111,
              114,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Returns multiple pivot reports in a batch. All reports must be for the same
     * GA4 Property.
     */
    batchRunPivotReports: {
      name: "BatchRunPivotReports",
      requestType: BatchRunPivotReportsRequest,
      requestStream: false,
      responseType: BatchRunPivotReportsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              57,
              58,
              1,
              42,
              34,
              52,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              112,
              114,
              111,
              112,
              101,
              114,
              116,
              121,
              61,
              112,
              114,
              111,
              112,
              101,
              114,
              116,
              105,
              101,
              115,
              47,
              42,
              125,
              58,
              98,
              97,
              116,
              99,
              104,
              82,
              117,
              110,
              80,
              105,
              118,
              111,
              116,
              82,
              101,
              112,
              111,
              114,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Returns metadata for dimensions and metrics available in reporting methods.
     * Used to explore the dimensions and metrics. In this method, a Google
     * Analytics GA4 Property Identifier is specified in the request, and
     * the metadata response includes Custom dimensions and metrics as well as
     * Universal metadata.
     *
     * For example if a custom metric with parameter name `levels_unlocked` is
     * registered to a property, the Metadata response will contain
     * `customEvent:levels_unlocked`. Universal metadata are dimensions and
     * metrics applicable to any property such as `country` and `totalUsers`.
     */
    getMetadata: {
      name: "GetMetadata",
      requestType: GetMetadataRequest,
      requestStream: false,
      responseType: Metadata,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              38,
              18,
              36,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              112,
              101,
              114,
              116,
              105,
              101,
              115,
              47,
              42,
              47,
              109,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Returns a customized report of realtime event data for your property.
     * Events appear in realtime reports seconds after they have been sent to
     * the Google Analytics. Realtime reports show events and usage data for the
     * periods of time ranging from the present moment to 30 minutes ago (up to
     * 60 minutes for Google Analytics 360 properties).
     *
     * For a guide to constructing realtime requests & understanding responses,
     * see [Creating a Realtime
     * Report](https://developers.google.com/analytics/devguides/reporting/data/v1/realtime-basics).
     */
    runRealtimeReport: {
      name: "RunRealtimeReport",
      requestType: RunRealtimeReportRequest,
      requestStream: false,
      responseType: RunRealtimeReportResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              54,
              58,
              1,
              42,
              34,
              49,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              112,
              114,
              111,
              112,
              101,
              114,
              116,
              121,
              61,
              112,
              114,
              111,
              112,
              101,
              114,
              116,
              105,
              101,
              115,
              47,
              42,
              125,
              58,
              114,
              117,
              110,
              82,
              101,
              97,
              108,
              116,
              105,
              109,
              101,
              82,
              101,
              112,
              111,
              114,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * This compatibility method lists dimensions and metrics that can be added to
     * a report request and maintain compatibility. This method fails if the
     * request's dimensions and metrics are incompatible.
     *
     * In Google Analytics, reports fail if they request incompatible dimensions
     * and/or metrics; in that case, you will need to remove dimensions and/or
     * metrics from the incompatible report until the report is compatible.
     *
     * The Realtime and Core reports have different compatibility rules. This
     * method checks compatibility for Core reports.
     */
    checkCompatibility: {
      name: "CheckCompatibility",
      requestType: CheckCompatibilityRequest,
      requestStream: false,
      responseType: CheckCompatibilityResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              55,
              58,
              1,
              42,
              34,
              50,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              112,
              114,
              111,
              112,
              101,
              114,
              116,
              121,
              61,
              112,
              114,
              111,
              112,
              101,
              114,
              116,
              105,
              101,
              115,
              47,
              42,
              125,
              58,
              99,
              104,
              101,
              99,
              107,
              67,
              111,
              109,
              112,
              97,
              116,
              105,
              98,
              105,
              108,
              105,
              116,
              121,
            ]),
          ],
        },
      },
    },
    /**
     * Creates an audience export for later retrieval. This method quickly returns
     * the audience export's resource name and initiates a long running
     * asynchronous request to form an audience export. To export the users in an
     * audience export, first create the audience export through this method and
     * then send the audience resource name to the `QueryAudienceExport` method.
     *
     * See [Creating an Audience
     * Export](https://developers.google.com/analytics/devguides/reporting/data/v1/audience-list-basics)
     * for an introduction to Audience Exports with examples.
     *
     * An audience export is a snapshot of the users currently in the audience at
     * the time of audience export creation. Creating audience exports for one
     * audience on different days will return different results as users enter and
     * exit the audience.
     *
     * Audiences in Google Analytics 4 allow you to segment your users in the ways
     * that are important to your business. To learn more, see
     * https://support.google.com/analytics/answer/9267572. Audience exports
     * contain the users in each audience.
     *
     * Audience Export APIs have some methods at alpha and other methods at beta
     * stability. The intention is to advance methods to beta stability after some
     * feedback and adoption. To give your feedback on this API, complete the
     * [Google Analytics Audience Export API
     * Feedback](https://forms.gle/EeA5u5LW6PEggtCEA) form.
     */
    createAudienceExport: {
      name: "CreateAudienceExport",
      requestType: CreateAudienceExportRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              40,
              10,
              14,
              65,
              117,
              100,
              105,
              101,
              110,
              99,
              101,
              69,
              120,
              112,
              111,
              114,
              116,
              18,
              22,
              65,
              117,
              100,
              105,
              101,
              110,
              99,
              101,
              69,
              120,
              112,
              111,
              114,
              116,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              22,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              97,
              117,
              100,
              105,
              101,
              110,
              99,
              101,
              95,
              101,
              120,
              112,
              111,
              114,
              116,
            ]),
          ],
          578365826: [
            Buffer.from([
              64,
              58,
              15,
              97,
              117,
              100,
              105,
              101,
              110,
              99,
              101,
              95,
              101,
              120,
              112,
              111,
              114,
              116,
              34,
              45,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              112,
              101,
              114,
              116,
              105,
              101,
              115,
              47,
              42,
              125,
              47,
              97,
              117,
              100,
              105,
              101,
              110,
              99,
              101,
              69,
              120,
              112,
              111,
              114,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Retrieves an audience export of users. After creating an audience, the
     * users are not immediately available for exporting. First, a request to
     * `CreateAudienceExport` is necessary to create an audience export of users,
     * and then second, this method is used to retrieve the users in the audience
     * export.
     *
     * See [Creating an Audience
     * Export](https://developers.google.com/analytics/devguides/reporting/data/v1/audience-list-basics)
     * for an introduction to Audience Exports with examples.
     *
     * Audiences in Google Analytics 4 allow you to segment your users in the ways
     * that are important to your business. To learn more, see
     * https://support.google.com/analytics/answer/9267572.
     *
     * Audience Export APIs have some methods at alpha and other methods at beta
     * stability. The intention is to advance methods to beta stability after some
     * feedback and adoption. To give your feedback on this API, complete the
     * [Google Analytics Audience Export API
     * Feedback](https://forms.gle/EeA5u5LW6PEggtCEA) form.
     */
    queryAudienceExport: {
      name: "QueryAudienceExport",
      requestType: QueryAudienceExportRequest,
      requestStream: false,
      responseType: QueryAudienceExportResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              56,
              58,
              1,
              42,
              34,
              51,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              112,
              101,
              114,
              116,
              105,
              101,
              115,
              47,
              42,
              47,
              97,
              117,
              100,
              105,
              101,
              110,
              99,
              101,
              69,
              120,
              112,
              111,
              114,
              116,
              115,
              47,
              42,
              125,
              58,
              113,
              117,
              101,
              114,
              121,
            ]),
          ],
        },
      },
    },
    /**
     * Gets configuration metadata about a specific audience export. This method
     * can be used to understand an audience export after it has been created.
     *
     * See [Creating an Audience
     * Export](https://developers.google.com/analytics/devguides/reporting/data/v1/audience-list-basics)
     * for an introduction to Audience Exports with examples.
     *
     * Audience Export APIs have some methods at alpha and other methods at beta
     * stability. The intention is to advance methods to beta stability after some
     * feedback and adoption. To give your feedback on this API, complete the
     * [Google Analytics Audience Export API
     * Feedback](https://forms.gle/EeA5u5LW6PEggtCEA) form.
     */
    getAudienceExport: {
      name: "GetAudienceExport",
      requestType: GetAudienceExportRequest,
      requestStream: false,
      responseType: AudienceExport,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              47,
              18,
              45,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              112,
              101,
              114,
              116,
              105,
              101,
              115,
              47,
              42,
              47,
              97,
              117,
              100,
              105,
              101,
              110,
              99,
              101,
              69,
              120,
              112,
              111,
              114,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Lists all audience exports for a property. This method can be used for you
     * to find and reuse existing audience exports rather than creating
     * unnecessary new audience exports. The same audience can have multiple
     * audience exports that represent the export of users that were in an
     * audience on different days.
     *
     * See [Creating an Audience
     * Export](https://developers.google.com/analytics/devguides/reporting/data/v1/audience-list-basics)
     * for an introduction to Audience Exports with examples.
     *
     * Audience Export APIs have some methods at alpha and other methods at beta
     * stability. The intention is to advance methods to beta stability after some
     * feedback and adoption. To give your feedback on this API, complete the
     * [Google Analytics Audience Export API
     * Feedback](https://forms.gle/EeA5u5LW6PEggtCEA) form.
     */
    listAudienceExports: {
      name: "ListAudienceExports",
      requestType: ListAudienceExportsRequest,
      requestStream: false,
      responseType: ListAudienceExportsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              47,
              18,
              45,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              112,
              101,
              114,
              116,
              105,
              101,
              115,
              47,
              42,
              125,
              47,
              97,
              117,
              100,
              105,
              101,
              110,
              99,
              101,
              69,
              120,
              112,
              111,
              114,
              116,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface BetaAnalyticsDataServiceImplementation<CallContextExt = {}> {
  /**
   * Returns a customized report of your Google Analytics event data. Reports
   * contain statistics derived from data collected by the Google Analytics
   * tracking code. The data returned from the API is as a table with columns
   * for the requested dimensions and metrics. Metrics are individual
   * measurements of user activity on your property, such as active users or
   * event count. Dimensions break down metrics across some common criteria,
   * such as country or event name.
   *
   * For a guide to constructing requests & understanding responses, see
   * [Creating a
   * Report](https://developers.google.com/analytics/devguides/reporting/data/v1/basics).
   */
  runReport(request: RunReportRequest, context: CallContext & CallContextExt): Promise<DeepPartial<RunReportResponse>>;
  /**
   * Returns a customized pivot report of your Google Analytics event data.
   * Pivot reports are more advanced and expressive formats than regular
   * reports. In a pivot report, dimensions are only visible if they are
   * included in a pivot. Multiple pivots can be specified to further dissect
   * your data.
   */
  runPivotReport(
    request: RunPivotReportRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<RunPivotReportResponse>>;
  /**
   * Returns multiple reports in a batch. All reports must be for the same
   * GA4 Property.
   */
  batchRunReports(
    request: BatchRunReportsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<BatchRunReportsResponse>>;
  /**
   * Returns multiple pivot reports in a batch. All reports must be for the same
   * GA4 Property.
   */
  batchRunPivotReports(
    request: BatchRunPivotReportsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<BatchRunPivotReportsResponse>>;
  /**
   * Returns metadata for dimensions and metrics available in reporting methods.
   * Used to explore the dimensions and metrics. In this method, a Google
   * Analytics GA4 Property Identifier is specified in the request, and
   * the metadata response includes Custom dimensions and metrics as well as
   * Universal metadata.
   *
   * For example if a custom metric with parameter name `levels_unlocked` is
   * registered to a property, the Metadata response will contain
   * `customEvent:levels_unlocked`. Universal metadata are dimensions and
   * metrics applicable to any property such as `country` and `totalUsers`.
   */
  getMetadata(request: GetMetadataRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Metadata>>;
  /**
   * Returns a customized report of realtime event data for your property.
   * Events appear in realtime reports seconds after they have been sent to
   * the Google Analytics. Realtime reports show events and usage data for the
   * periods of time ranging from the present moment to 30 minutes ago (up to
   * 60 minutes for Google Analytics 360 properties).
   *
   * For a guide to constructing realtime requests & understanding responses,
   * see [Creating a Realtime
   * Report](https://developers.google.com/analytics/devguides/reporting/data/v1/realtime-basics).
   */
  runRealtimeReport(
    request: RunRealtimeReportRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<RunRealtimeReportResponse>>;
  /**
   * This compatibility method lists dimensions and metrics that can be added to
   * a report request and maintain compatibility. This method fails if the
   * request's dimensions and metrics are incompatible.
   *
   * In Google Analytics, reports fail if they request incompatible dimensions
   * and/or metrics; in that case, you will need to remove dimensions and/or
   * metrics from the incompatible report until the report is compatible.
   *
   * The Realtime and Core reports have different compatibility rules. This
   * method checks compatibility for Core reports.
   */
  checkCompatibility(
    request: CheckCompatibilityRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CheckCompatibilityResponse>>;
  /**
   * Creates an audience export for later retrieval. This method quickly returns
   * the audience export's resource name and initiates a long running
   * asynchronous request to form an audience export. To export the users in an
   * audience export, first create the audience export through this method and
   * then send the audience resource name to the `QueryAudienceExport` method.
   *
   * See [Creating an Audience
   * Export](https://developers.google.com/analytics/devguides/reporting/data/v1/audience-list-basics)
   * for an introduction to Audience Exports with examples.
   *
   * An audience export is a snapshot of the users currently in the audience at
   * the time of audience export creation. Creating audience exports for one
   * audience on different days will return different results as users enter and
   * exit the audience.
   *
   * Audiences in Google Analytics 4 allow you to segment your users in the ways
   * that are important to your business. To learn more, see
   * https://support.google.com/analytics/answer/9267572. Audience exports
   * contain the users in each audience.
   *
   * Audience Export APIs have some methods at alpha and other methods at beta
   * stability. The intention is to advance methods to beta stability after some
   * feedback and adoption. To give your feedback on this API, complete the
   * [Google Analytics Audience Export API
   * Feedback](https://forms.gle/EeA5u5LW6PEggtCEA) form.
   */
  createAudienceExport(
    request: CreateAudienceExportRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Retrieves an audience export of users. After creating an audience, the
   * users are not immediately available for exporting. First, a request to
   * `CreateAudienceExport` is necessary to create an audience export of users,
   * and then second, this method is used to retrieve the users in the audience
   * export.
   *
   * See [Creating an Audience
   * Export](https://developers.google.com/analytics/devguides/reporting/data/v1/audience-list-basics)
   * for an introduction to Audience Exports with examples.
   *
   * Audiences in Google Analytics 4 allow you to segment your users in the ways
   * that are important to your business. To learn more, see
   * https://support.google.com/analytics/answer/9267572.
   *
   * Audience Export APIs have some methods at alpha and other methods at beta
   * stability. The intention is to advance methods to beta stability after some
   * feedback and adoption. To give your feedback on this API, complete the
   * [Google Analytics Audience Export API
   * Feedback](https://forms.gle/EeA5u5LW6PEggtCEA) form.
   */
  queryAudienceExport(
    request: QueryAudienceExportRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<QueryAudienceExportResponse>>;
  /**
   * Gets configuration metadata about a specific audience export. This method
   * can be used to understand an audience export after it has been created.
   *
   * See [Creating an Audience
   * Export](https://developers.google.com/analytics/devguides/reporting/data/v1/audience-list-basics)
   * for an introduction to Audience Exports with examples.
   *
   * Audience Export APIs have some methods at alpha and other methods at beta
   * stability. The intention is to advance methods to beta stability after some
   * feedback and adoption. To give your feedback on this API, complete the
   * [Google Analytics Audience Export API
   * Feedback](https://forms.gle/EeA5u5LW6PEggtCEA) form.
   */
  getAudienceExport(
    request: GetAudienceExportRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<AudienceExport>>;
  /**
   * Lists all audience exports for a property. This method can be used for you
   * to find and reuse existing audience exports rather than creating
   * unnecessary new audience exports. The same audience can have multiple
   * audience exports that represent the export of users that were in an
   * audience on different days.
   *
   * See [Creating an Audience
   * Export](https://developers.google.com/analytics/devguides/reporting/data/v1/audience-list-basics)
   * for an introduction to Audience Exports with examples.
   *
   * Audience Export APIs have some methods at alpha and other methods at beta
   * stability. The intention is to advance methods to beta stability after some
   * feedback and adoption. To give your feedback on this API, complete the
   * [Google Analytics Audience Export API
   * Feedback](https://forms.gle/EeA5u5LW6PEggtCEA) form.
   */
  listAudienceExports(
    request: ListAudienceExportsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListAudienceExportsResponse>>;
}

export interface BetaAnalyticsDataClient<CallOptionsExt = {}> {
  /**
   * Returns a customized report of your Google Analytics event data. Reports
   * contain statistics derived from data collected by the Google Analytics
   * tracking code. The data returned from the API is as a table with columns
   * for the requested dimensions and metrics. Metrics are individual
   * measurements of user activity on your property, such as active users or
   * event count. Dimensions break down metrics across some common criteria,
   * such as country or event name.
   *
   * For a guide to constructing requests & understanding responses, see
   * [Creating a
   * Report](https://developers.google.com/analytics/devguides/reporting/data/v1/basics).
   */
  runReport(request: DeepPartial<RunReportRequest>, options?: CallOptions & CallOptionsExt): Promise<RunReportResponse>;
  /**
   * Returns a customized pivot report of your Google Analytics event data.
   * Pivot reports are more advanced and expressive formats than regular
   * reports. In a pivot report, dimensions are only visible if they are
   * included in a pivot. Multiple pivots can be specified to further dissect
   * your data.
   */
  runPivotReport(
    request: DeepPartial<RunPivotReportRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<RunPivotReportResponse>;
  /**
   * Returns multiple reports in a batch. All reports must be for the same
   * GA4 Property.
   */
  batchRunReports(
    request: DeepPartial<BatchRunReportsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<BatchRunReportsResponse>;
  /**
   * Returns multiple pivot reports in a batch. All reports must be for the same
   * GA4 Property.
   */
  batchRunPivotReports(
    request: DeepPartial<BatchRunPivotReportsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<BatchRunPivotReportsResponse>;
  /**
   * Returns metadata for dimensions and metrics available in reporting methods.
   * Used to explore the dimensions and metrics. In this method, a Google
   * Analytics GA4 Property Identifier is specified in the request, and
   * the metadata response includes Custom dimensions and metrics as well as
   * Universal metadata.
   *
   * For example if a custom metric with parameter name `levels_unlocked` is
   * registered to a property, the Metadata response will contain
   * `customEvent:levels_unlocked`. Universal metadata are dimensions and
   * metrics applicable to any property such as `country` and `totalUsers`.
   */
  getMetadata(request: DeepPartial<GetMetadataRequest>, options?: CallOptions & CallOptionsExt): Promise<Metadata>;
  /**
   * Returns a customized report of realtime event data for your property.
   * Events appear in realtime reports seconds after they have been sent to
   * the Google Analytics. Realtime reports show events and usage data for the
   * periods of time ranging from the present moment to 30 minutes ago (up to
   * 60 minutes for Google Analytics 360 properties).
   *
   * For a guide to constructing realtime requests & understanding responses,
   * see [Creating a Realtime
   * Report](https://developers.google.com/analytics/devguides/reporting/data/v1/realtime-basics).
   */
  runRealtimeReport(
    request: DeepPartial<RunRealtimeReportRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<RunRealtimeReportResponse>;
  /**
   * This compatibility method lists dimensions and metrics that can be added to
   * a report request and maintain compatibility. This method fails if the
   * request's dimensions and metrics are incompatible.
   *
   * In Google Analytics, reports fail if they request incompatible dimensions
   * and/or metrics; in that case, you will need to remove dimensions and/or
   * metrics from the incompatible report until the report is compatible.
   *
   * The Realtime and Core reports have different compatibility rules. This
   * method checks compatibility for Core reports.
   */
  checkCompatibility(
    request: DeepPartial<CheckCompatibilityRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CheckCompatibilityResponse>;
  /**
   * Creates an audience export for later retrieval. This method quickly returns
   * the audience export's resource name and initiates a long running
   * asynchronous request to form an audience export. To export the users in an
   * audience export, first create the audience export through this method and
   * then send the audience resource name to the `QueryAudienceExport` method.
   *
   * See [Creating an Audience
   * Export](https://developers.google.com/analytics/devguides/reporting/data/v1/audience-list-basics)
   * for an introduction to Audience Exports with examples.
   *
   * An audience export is a snapshot of the users currently in the audience at
   * the time of audience export creation. Creating audience exports for one
   * audience on different days will return different results as users enter and
   * exit the audience.
   *
   * Audiences in Google Analytics 4 allow you to segment your users in the ways
   * that are important to your business. To learn more, see
   * https://support.google.com/analytics/answer/9267572. Audience exports
   * contain the users in each audience.
   *
   * Audience Export APIs have some methods at alpha and other methods at beta
   * stability. The intention is to advance methods to beta stability after some
   * feedback and adoption. To give your feedback on this API, complete the
   * [Google Analytics Audience Export API
   * Feedback](https://forms.gle/EeA5u5LW6PEggtCEA) form.
   */
  createAudienceExport(
    request: DeepPartial<CreateAudienceExportRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Retrieves an audience export of users. After creating an audience, the
   * users are not immediately available for exporting. First, a request to
   * `CreateAudienceExport` is necessary to create an audience export of users,
   * and then second, this method is used to retrieve the users in the audience
   * export.
   *
   * See [Creating an Audience
   * Export](https://developers.google.com/analytics/devguides/reporting/data/v1/audience-list-basics)
   * for an introduction to Audience Exports with examples.
   *
   * Audiences in Google Analytics 4 allow you to segment your users in the ways
   * that are important to your business. To learn more, see
   * https://support.google.com/analytics/answer/9267572.
   *
   * Audience Export APIs have some methods at alpha and other methods at beta
   * stability. The intention is to advance methods to beta stability after some
   * feedback and adoption. To give your feedback on this API, complete the
   * [Google Analytics Audience Export API
   * Feedback](https://forms.gle/EeA5u5LW6PEggtCEA) form.
   */
  queryAudienceExport(
    request: DeepPartial<QueryAudienceExportRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<QueryAudienceExportResponse>;
  /**
   * Gets configuration metadata about a specific audience export. This method
   * can be used to understand an audience export after it has been created.
   *
   * See [Creating an Audience
   * Export](https://developers.google.com/analytics/devguides/reporting/data/v1/audience-list-basics)
   * for an introduction to Audience Exports with examples.
   *
   * Audience Export APIs have some methods at alpha and other methods at beta
   * stability. The intention is to advance methods to beta stability after some
   * feedback and adoption. To give your feedback on this API, complete the
   * [Google Analytics Audience Export API
   * Feedback](https://forms.gle/EeA5u5LW6PEggtCEA) form.
   */
  getAudienceExport(
    request: DeepPartial<GetAudienceExportRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AudienceExport>;
  /**
   * Lists all audience exports for a property. This method can be used for you
   * to find and reuse existing audience exports rather than creating
   * unnecessary new audience exports. The same audience can have multiple
   * audience exports that represent the export of users that were in an
   * audience on different days.
   *
   * See [Creating an Audience
   * Export](https://developers.google.com/analytics/devguides/reporting/data/v1/audience-list-basics)
   * for an introduction to Audience Exports with examples.
   *
   * Audience Export APIs have some methods at alpha and other methods at beta
   * stability. The intention is to advance methods to beta stability after some
   * feedback and adoption. To give your feedback on this API, complete the
   * [Google Analytics Audience Export API
   * Feedback](https://forms.gle/EeA5u5LW6PEggtCEA) form.
   */
  listAudienceExports(
    request: DeepPartial<ListAudienceExportsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListAudienceExportsResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
