// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/analytics/admin/v1beta/resources.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { BoolValue } from "../../../protobuf/wrappers.js";

export const protobufPackage = "google.analytics.admin.v1beta";

/** The category selected for this property, used for industry benchmarking. */
export enum IndustryCategory {
  /** INDUSTRY_CATEGORY_UNSPECIFIED - Industry category unspecified */
  INDUSTRY_CATEGORY_UNSPECIFIED = 0,
  /** AUTOMOTIVE - Automotive */
  AUTOMOTIVE = 1,
  /** BUSINESS_AND_INDUSTRIAL_MARKETS - Business and industrial markets */
  BUSINESS_AND_INDUSTRIAL_MARKETS = 2,
  /** FINANCE - Finance */
  FINANCE = 3,
  /** HEALTHCARE - Healthcare */
  HEALTHCARE = 4,
  /** TECHNOLOGY - Technology */
  TECHNOLOGY = 5,
  /** TRAVEL - Travel */
  TRAVEL = 6,
  /** OTHER - Other */
  OTHER = 7,
  /** ARTS_AND_ENTERTAINMENT - Arts and entertainment */
  ARTS_AND_ENTERTAINMENT = 8,
  /** BEAUTY_AND_FITNESS - Beauty and fitness */
  BEAUTY_AND_FITNESS = 9,
  /** BOOKS_AND_LITERATURE - Books and literature */
  BOOKS_AND_LITERATURE = 10,
  /** FOOD_AND_DRINK - Food and drink */
  FOOD_AND_DRINK = 11,
  /** GAMES - Games */
  GAMES = 12,
  /** HOBBIES_AND_LEISURE - Hobbies and leisure */
  HOBBIES_AND_LEISURE = 13,
  /** HOME_AND_GARDEN - Home and garden */
  HOME_AND_GARDEN = 14,
  /** INTERNET_AND_TELECOM - Internet and telecom */
  INTERNET_AND_TELECOM = 15,
  /** LAW_AND_GOVERNMENT - Law and government */
  LAW_AND_GOVERNMENT = 16,
  /** NEWS - News */
  NEWS = 17,
  /** ONLINE_COMMUNITIES - Online communities */
  ONLINE_COMMUNITIES = 18,
  /** PEOPLE_AND_SOCIETY - People and society */
  PEOPLE_AND_SOCIETY = 19,
  /** PETS_AND_ANIMALS - Pets and animals */
  PETS_AND_ANIMALS = 20,
  /** REAL_ESTATE - Real estate */
  REAL_ESTATE = 21,
  /** REFERENCE - Reference */
  REFERENCE = 22,
  /** SCIENCE - Science */
  SCIENCE = 23,
  /** SPORTS - Sports */
  SPORTS = 24,
  /** JOBS_AND_EDUCATION - Jobs and education */
  JOBS_AND_EDUCATION = 25,
  /** SHOPPING - Shopping */
  SHOPPING = 26,
  UNRECOGNIZED = -1,
}

export function industryCategoryFromJSON(object: any): IndustryCategory {
  switch (object) {
    case 0:
    case "INDUSTRY_CATEGORY_UNSPECIFIED":
      return IndustryCategory.INDUSTRY_CATEGORY_UNSPECIFIED;
    case 1:
    case "AUTOMOTIVE":
      return IndustryCategory.AUTOMOTIVE;
    case 2:
    case "BUSINESS_AND_INDUSTRIAL_MARKETS":
      return IndustryCategory.BUSINESS_AND_INDUSTRIAL_MARKETS;
    case 3:
    case "FINANCE":
      return IndustryCategory.FINANCE;
    case 4:
    case "HEALTHCARE":
      return IndustryCategory.HEALTHCARE;
    case 5:
    case "TECHNOLOGY":
      return IndustryCategory.TECHNOLOGY;
    case 6:
    case "TRAVEL":
      return IndustryCategory.TRAVEL;
    case 7:
    case "OTHER":
      return IndustryCategory.OTHER;
    case 8:
    case "ARTS_AND_ENTERTAINMENT":
      return IndustryCategory.ARTS_AND_ENTERTAINMENT;
    case 9:
    case "BEAUTY_AND_FITNESS":
      return IndustryCategory.BEAUTY_AND_FITNESS;
    case 10:
    case "BOOKS_AND_LITERATURE":
      return IndustryCategory.BOOKS_AND_LITERATURE;
    case 11:
    case "FOOD_AND_DRINK":
      return IndustryCategory.FOOD_AND_DRINK;
    case 12:
    case "GAMES":
      return IndustryCategory.GAMES;
    case 13:
    case "HOBBIES_AND_LEISURE":
      return IndustryCategory.HOBBIES_AND_LEISURE;
    case 14:
    case "HOME_AND_GARDEN":
      return IndustryCategory.HOME_AND_GARDEN;
    case 15:
    case "INTERNET_AND_TELECOM":
      return IndustryCategory.INTERNET_AND_TELECOM;
    case 16:
    case "LAW_AND_GOVERNMENT":
      return IndustryCategory.LAW_AND_GOVERNMENT;
    case 17:
    case "NEWS":
      return IndustryCategory.NEWS;
    case 18:
    case "ONLINE_COMMUNITIES":
      return IndustryCategory.ONLINE_COMMUNITIES;
    case 19:
    case "PEOPLE_AND_SOCIETY":
      return IndustryCategory.PEOPLE_AND_SOCIETY;
    case 20:
    case "PETS_AND_ANIMALS":
      return IndustryCategory.PETS_AND_ANIMALS;
    case 21:
    case "REAL_ESTATE":
      return IndustryCategory.REAL_ESTATE;
    case 22:
    case "REFERENCE":
      return IndustryCategory.REFERENCE;
    case 23:
    case "SCIENCE":
      return IndustryCategory.SCIENCE;
    case 24:
    case "SPORTS":
      return IndustryCategory.SPORTS;
    case 25:
    case "JOBS_AND_EDUCATION":
      return IndustryCategory.JOBS_AND_EDUCATION;
    case 26:
    case "SHOPPING":
      return IndustryCategory.SHOPPING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return IndustryCategory.UNRECOGNIZED;
  }
}

export function industryCategoryToJSON(object: IndustryCategory): string {
  switch (object) {
    case IndustryCategory.INDUSTRY_CATEGORY_UNSPECIFIED:
      return "INDUSTRY_CATEGORY_UNSPECIFIED";
    case IndustryCategory.AUTOMOTIVE:
      return "AUTOMOTIVE";
    case IndustryCategory.BUSINESS_AND_INDUSTRIAL_MARKETS:
      return "BUSINESS_AND_INDUSTRIAL_MARKETS";
    case IndustryCategory.FINANCE:
      return "FINANCE";
    case IndustryCategory.HEALTHCARE:
      return "HEALTHCARE";
    case IndustryCategory.TECHNOLOGY:
      return "TECHNOLOGY";
    case IndustryCategory.TRAVEL:
      return "TRAVEL";
    case IndustryCategory.OTHER:
      return "OTHER";
    case IndustryCategory.ARTS_AND_ENTERTAINMENT:
      return "ARTS_AND_ENTERTAINMENT";
    case IndustryCategory.BEAUTY_AND_FITNESS:
      return "BEAUTY_AND_FITNESS";
    case IndustryCategory.BOOKS_AND_LITERATURE:
      return "BOOKS_AND_LITERATURE";
    case IndustryCategory.FOOD_AND_DRINK:
      return "FOOD_AND_DRINK";
    case IndustryCategory.GAMES:
      return "GAMES";
    case IndustryCategory.HOBBIES_AND_LEISURE:
      return "HOBBIES_AND_LEISURE";
    case IndustryCategory.HOME_AND_GARDEN:
      return "HOME_AND_GARDEN";
    case IndustryCategory.INTERNET_AND_TELECOM:
      return "INTERNET_AND_TELECOM";
    case IndustryCategory.LAW_AND_GOVERNMENT:
      return "LAW_AND_GOVERNMENT";
    case IndustryCategory.NEWS:
      return "NEWS";
    case IndustryCategory.ONLINE_COMMUNITIES:
      return "ONLINE_COMMUNITIES";
    case IndustryCategory.PEOPLE_AND_SOCIETY:
      return "PEOPLE_AND_SOCIETY";
    case IndustryCategory.PETS_AND_ANIMALS:
      return "PETS_AND_ANIMALS";
    case IndustryCategory.REAL_ESTATE:
      return "REAL_ESTATE";
    case IndustryCategory.REFERENCE:
      return "REFERENCE";
    case IndustryCategory.SCIENCE:
      return "SCIENCE";
    case IndustryCategory.SPORTS:
      return "SPORTS";
    case IndustryCategory.JOBS_AND_EDUCATION:
      return "JOBS_AND_EDUCATION";
    case IndustryCategory.SHOPPING:
      return "SHOPPING";
    case IndustryCategory.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Various levels of service for Google Analytics. */
export enum ServiceLevel {
  /** SERVICE_LEVEL_UNSPECIFIED - Service level not specified or invalid. */
  SERVICE_LEVEL_UNSPECIFIED = 0,
  /** GOOGLE_ANALYTICS_STANDARD - The standard version of Google Analytics. */
  GOOGLE_ANALYTICS_STANDARD = 1,
  /** GOOGLE_ANALYTICS_360 - The paid, premium version of Google Analytics. */
  GOOGLE_ANALYTICS_360 = 2,
  UNRECOGNIZED = -1,
}

export function serviceLevelFromJSON(object: any): ServiceLevel {
  switch (object) {
    case 0:
    case "SERVICE_LEVEL_UNSPECIFIED":
      return ServiceLevel.SERVICE_LEVEL_UNSPECIFIED;
    case 1:
    case "GOOGLE_ANALYTICS_STANDARD":
      return ServiceLevel.GOOGLE_ANALYTICS_STANDARD;
    case 2:
    case "GOOGLE_ANALYTICS_360":
      return ServiceLevel.GOOGLE_ANALYTICS_360;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ServiceLevel.UNRECOGNIZED;
  }
}

export function serviceLevelToJSON(object: ServiceLevel): string {
  switch (object) {
    case ServiceLevel.SERVICE_LEVEL_UNSPECIFIED:
      return "SERVICE_LEVEL_UNSPECIFIED";
    case ServiceLevel.GOOGLE_ANALYTICS_STANDARD:
      return "GOOGLE_ANALYTICS_STANDARD";
    case ServiceLevel.GOOGLE_ANALYTICS_360:
      return "GOOGLE_ANALYTICS_360";
    case ServiceLevel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Different kinds of actors that can make changes to Google Analytics
 * resources.
 */
export enum ActorType {
  /** ACTOR_TYPE_UNSPECIFIED - Unknown or unspecified actor type. */
  ACTOR_TYPE_UNSPECIFIED = 0,
  /** USER - Changes made by the user specified in actor_email. */
  USER = 1,
  /** SYSTEM - Changes made by the Google Analytics system. */
  SYSTEM = 2,
  /** SUPPORT - Changes made by Google Analytics support team staff. */
  SUPPORT = 3,
  UNRECOGNIZED = -1,
}

export function actorTypeFromJSON(object: any): ActorType {
  switch (object) {
    case 0:
    case "ACTOR_TYPE_UNSPECIFIED":
      return ActorType.ACTOR_TYPE_UNSPECIFIED;
    case 1:
    case "USER":
      return ActorType.USER;
    case 2:
    case "SYSTEM":
      return ActorType.SYSTEM;
    case 3:
    case "SUPPORT":
      return ActorType.SUPPORT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ActorType.UNRECOGNIZED;
  }
}

export function actorTypeToJSON(object: ActorType): string {
  switch (object) {
    case ActorType.ACTOR_TYPE_UNSPECIFIED:
      return "ACTOR_TYPE_UNSPECIFIED";
    case ActorType.USER:
      return "USER";
    case ActorType.SYSTEM:
      return "SYSTEM";
    case ActorType.SUPPORT:
      return "SUPPORT";
    case ActorType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Types of actions that may change a resource. */
export enum ActionType {
  /** ACTION_TYPE_UNSPECIFIED - Action type unknown or not specified. */
  ACTION_TYPE_UNSPECIFIED = 0,
  /** CREATED - Resource was created in this change. */
  CREATED = 1,
  /** UPDATED - Resource was updated in this change. */
  UPDATED = 2,
  /** DELETED - Resource was deleted in this change. */
  DELETED = 3,
  UNRECOGNIZED = -1,
}

export function actionTypeFromJSON(object: any): ActionType {
  switch (object) {
    case 0:
    case "ACTION_TYPE_UNSPECIFIED":
      return ActionType.ACTION_TYPE_UNSPECIFIED;
    case 1:
    case "CREATED":
      return ActionType.CREATED;
    case 2:
    case "UPDATED":
      return ActionType.UPDATED;
    case 3:
    case "DELETED":
      return ActionType.DELETED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ActionType.UNRECOGNIZED;
  }
}

export function actionTypeToJSON(object: ActionType): string {
  switch (object) {
    case ActionType.ACTION_TYPE_UNSPECIFIED:
      return "ACTION_TYPE_UNSPECIFIED";
    case ActionType.CREATED:
      return "CREATED";
    case ActionType.UPDATED:
      return "UPDATED";
    case ActionType.DELETED:
      return "DELETED";
    case ActionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Types of resources whose changes may be returned from change history. */
export enum ChangeHistoryResourceType {
  /** CHANGE_HISTORY_RESOURCE_TYPE_UNSPECIFIED - Resource type unknown or not specified. */
  CHANGE_HISTORY_RESOURCE_TYPE_UNSPECIFIED = 0,
  /** ACCOUNT - Account resource */
  ACCOUNT = 1,
  /** PROPERTY - Property resource */
  PROPERTY = 2,
  /** FIREBASE_LINK - FirebaseLink resource */
  FIREBASE_LINK = 6,
  /** GOOGLE_ADS_LINK - GoogleAdsLink resource */
  GOOGLE_ADS_LINK = 7,
  /** GOOGLE_SIGNALS_SETTINGS - GoogleSignalsSettings resource */
  GOOGLE_SIGNALS_SETTINGS = 8,
  /** CONVERSION_EVENT - ConversionEvent resource */
  CONVERSION_EVENT = 9,
  /** MEASUREMENT_PROTOCOL_SECRET - MeasurementProtocolSecret resource */
  MEASUREMENT_PROTOCOL_SECRET = 10,
  /** DATA_RETENTION_SETTINGS - DataRetentionSettings resource */
  DATA_RETENTION_SETTINGS = 13,
  /** DISPLAY_VIDEO_360_ADVERTISER_LINK - DisplayVideo360AdvertiserLink resource */
  DISPLAY_VIDEO_360_ADVERTISER_LINK = 14,
  /** DISPLAY_VIDEO_360_ADVERTISER_LINK_PROPOSAL - DisplayVideo360AdvertiserLinkProposal resource */
  DISPLAY_VIDEO_360_ADVERTISER_LINK_PROPOSAL = 15,
  /** DATA_STREAM - DataStream resource */
  DATA_STREAM = 18,
  /** ATTRIBUTION_SETTINGS - AttributionSettings resource */
  ATTRIBUTION_SETTINGS = 20,
  UNRECOGNIZED = -1,
}

export function changeHistoryResourceTypeFromJSON(object: any): ChangeHistoryResourceType {
  switch (object) {
    case 0:
    case "CHANGE_HISTORY_RESOURCE_TYPE_UNSPECIFIED":
      return ChangeHistoryResourceType.CHANGE_HISTORY_RESOURCE_TYPE_UNSPECIFIED;
    case 1:
    case "ACCOUNT":
      return ChangeHistoryResourceType.ACCOUNT;
    case 2:
    case "PROPERTY":
      return ChangeHistoryResourceType.PROPERTY;
    case 6:
    case "FIREBASE_LINK":
      return ChangeHistoryResourceType.FIREBASE_LINK;
    case 7:
    case "GOOGLE_ADS_LINK":
      return ChangeHistoryResourceType.GOOGLE_ADS_LINK;
    case 8:
    case "GOOGLE_SIGNALS_SETTINGS":
      return ChangeHistoryResourceType.GOOGLE_SIGNALS_SETTINGS;
    case 9:
    case "CONVERSION_EVENT":
      return ChangeHistoryResourceType.CONVERSION_EVENT;
    case 10:
    case "MEASUREMENT_PROTOCOL_SECRET":
      return ChangeHistoryResourceType.MEASUREMENT_PROTOCOL_SECRET;
    case 13:
    case "DATA_RETENTION_SETTINGS":
      return ChangeHistoryResourceType.DATA_RETENTION_SETTINGS;
    case 14:
    case "DISPLAY_VIDEO_360_ADVERTISER_LINK":
      return ChangeHistoryResourceType.DISPLAY_VIDEO_360_ADVERTISER_LINK;
    case 15:
    case "DISPLAY_VIDEO_360_ADVERTISER_LINK_PROPOSAL":
      return ChangeHistoryResourceType.DISPLAY_VIDEO_360_ADVERTISER_LINK_PROPOSAL;
    case 18:
    case "DATA_STREAM":
      return ChangeHistoryResourceType.DATA_STREAM;
    case 20:
    case "ATTRIBUTION_SETTINGS":
      return ChangeHistoryResourceType.ATTRIBUTION_SETTINGS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ChangeHistoryResourceType.UNRECOGNIZED;
  }
}

export function changeHistoryResourceTypeToJSON(object: ChangeHistoryResourceType): string {
  switch (object) {
    case ChangeHistoryResourceType.CHANGE_HISTORY_RESOURCE_TYPE_UNSPECIFIED:
      return "CHANGE_HISTORY_RESOURCE_TYPE_UNSPECIFIED";
    case ChangeHistoryResourceType.ACCOUNT:
      return "ACCOUNT";
    case ChangeHistoryResourceType.PROPERTY:
      return "PROPERTY";
    case ChangeHistoryResourceType.FIREBASE_LINK:
      return "FIREBASE_LINK";
    case ChangeHistoryResourceType.GOOGLE_ADS_LINK:
      return "GOOGLE_ADS_LINK";
    case ChangeHistoryResourceType.GOOGLE_SIGNALS_SETTINGS:
      return "GOOGLE_SIGNALS_SETTINGS";
    case ChangeHistoryResourceType.CONVERSION_EVENT:
      return "CONVERSION_EVENT";
    case ChangeHistoryResourceType.MEASUREMENT_PROTOCOL_SECRET:
      return "MEASUREMENT_PROTOCOL_SECRET";
    case ChangeHistoryResourceType.DATA_RETENTION_SETTINGS:
      return "DATA_RETENTION_SETTINGS";
    case ChangeHistoryResourceType.DISPLAY_VIDEO_360_ADVERTISER_LINK:
      return "DISPLAY_VIDEO_360_ADVERTISER_LINK";
    case ChangeHistoryResourceType.DISPLAY_VIDEO_360_ADVERTISER_LINK_PROPOSAL:
      return "DISPLAY_VIDEO_360_ADVERTISER_LINK_PROPOSAL";
    case ChangeHistoryResourceType.DATA_STREAM:
      return "DATA_STREAM";
    case ChangeHistoryResourceType.ATTRIBUTION_SETTINGS:
      return "ATTRIBUTION_SETTINGS";
    case ChangeHistoryResourceType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Types of Property resources. */
export enum PropertyType {
  /** PROPERTY_TYPE_UNSPECIFIED - Unknown or unspecified property type */
  PROPERTY_TYPE_UNSPECIFIED = 0,
  /** PROPERTY_TYPE_ORDINARY - Ordinary GA4 property */
  PROPERTY_TYPE_ORDINARY = 1,
  /** PROPERTY_TYPE_SUBPROPERTY - GA4 subproperty */
  PROPERTY_TYPE_SUBPROPERTY = 2,
  /** PROPERTY_TYPE_ROLLUP - GA4 rollup property */
  PROPERTY_TYPE_ROLLUP = 3,
  UNRECOGNIZED = -1,
}

export function propertyTypeFromJSON(object: any): PropertyType {
  switch (object) {
    case 0:
    case "PROPERTY_TYPE_UNSPECIFIED":
      return PropertyType.PROPERTY_TYPE_UNSPECIFIED;
    case 1:
    case "PROPERTY_TYPE_ORDINARY":
      return PropertyType.PROPERTY_TYPE_ORDINARY;
    case 2:
    case "PROPERTY_TYPE_SUBPROPERTY":
      return PropertyType.PROPERTY_TYPE_SUBPROPERTY;
    case 3:
    case "PROPERTY_TYPE_ROLLUP":
      return PropertyType.PROPERTY_TYPE_ROLLUP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PropertyType.UNRECOGNIZED;
  }
}

export function propertyTypeToJSON(object: PropertyType): string {
  switch (object) {
    case PropertyType.PROPERTY_TYPE_UNSPECIFIED:
      return "PROPERTY_TYPE_UNSPECIFIED";
    case PropertyType.PROPERTY_TYPE_ORDINARY:
      return "PROPERTY_TYPE_ORDINARY";
    case PropertyType.PROPERTY_TYPE_SUBPROPERTY:
      return "PROPERTY_TYPE_SUBPROPERTY";
    case PropertyType.PROPERTY_TYPE_ROLLUP:
      return "PROPERTY_TYPE_ROLLUP";
    case PropertyType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A resource message representing a Google Analytics account. */
export interface Account {
  /**
   * Output only. Resource name of this account.
   * Format: accounts/{account}
   * Example: "accounts/100"
   */
  name: string;
  /** Output only. Time when this account was originally created. */
  createTime:
    | Date
    | undefined;
  /** Output only. Time when account payload fields were last updated. */
  updateTime:
    | Date
    | undefined;
  /** Required. Human-readable display name for this account. */
  displayName: string;
  /** Country of business. Must be a Unicode CLDR region code. */
  regionCode: string;
  /**
   * Output only. Indicates whether this Account is soft-deleted or not. Deleted
   * accounts are excluded from List results unless specifically requested.
   */
  deleted: boolean;
  /**
   * Output only. The URI for a Google Marketing Platform organization resource.
   * Only set when this account is connected to a GMP organization.
   * Format: marketingplatformadmin.googleapis.com/organizations/{org_id}
   */
  gmpOrganization: string;
}

/** A resource message representing a Google Analytics GA4 property. */
export interface Property {
  /**
   * Output only. Resource name of this property.
   * Format: properties/{property_id}
   * Example: "properties/1000"
   */
  name: string;
  /**
   * Immutable. The property type for this Property resource. When creating a
   * property, if the type is "PROPERTY_TYPE_UNSPECIFIED", then
   * "ORDINARY_PROPERTY" will be implied.
   */
  propertyType: PropertyType;
  /** Output only. Time when the entity was originally created. */
  createTime:
    | Date
    | undefined;
  /** Output only. Time when entity payload fields were last updated. */
  updateTime:
    | Date
    | undefined;
  /**
   * Immutable. Resource name of this property's logical parent.
   *
   * Note: The Property-Moving UI can be used to change the parent.
   * Format: accounts/{account}, properties/{property}
   * Example: "accounts/100", "properties/101"
   */
  parent: string;
  /**
   * Required. Human-readable display name for this property.
   *
   * The max allowed display name length is 100 UTF-16 code units.
   */
  displayName: string;
  /**
   * Industry associated with this property
   * Example: AUTOMOTIVE, FOOD_AND_DRINK
   */
  industryCategory: IndustryCategory;
  /**
   * Required. Reporting Time Zone, used as the day boundary for reports,
   * regardless of where the data originates. If the time zone honors DST,
   * Analytics will automatically adjust for the changes.
   *
   * NOTE: Changing the time zone only affects data going forward, and is not
   * applied retroactively.
   *
   * Format: https://www.iana.org/time-zones
   * Example: "America/Los_Angeles"
   */
  timeZone: string;
  /**
   * The currency type used in reports involving monetary values.
   *
   * Format: https://en.wikipedia.org/wiki/ISO_4217
   * Examples: "USD", "EUR", "JPY"
   */
  currencyCode: string;
  /**
   * Output only. The Google Analytics service level that applies to this
   * property.
   */
  serviceLevel: ServiceLevel;
  /**
   * Output only. If set, the time at which this property was trashed. If not
   * set, then this property is not currently in the trash can.
   */
  deleteTime:
    | Date
    | undefined;
  /**
   * Output only. If set, the time at which this trashed property will be
   * permanently deleted. If not set, then this property is not currently in the
   * trash can and is not slated to be deleted.
   */
  expireTime:
    | Date
    | undefined;
  /**
   * Immutable. The resource name of the parent account
   * Format: accounts/{account_id}
   * Example: "accounts/123"
   */
  account: string;
}

/** A resource message representing a data stream. */
export interface DataStream {
  /**
   * Data specific to web streams. Must be populated if type is
   * WEB_DATA_STREAM.
   */
  webStreamData?:
    | DataStream_WebStreamData
    | undefined;
  /**
   * Data specific to Android app streams. Must be populated if type is
   * ANDROID_APP_DATA_STREAM.
   */
  androidAppStreamData?:
    | DataStream_AndroidAppStreamData
    | undefined;
  /**
   * Data specific to iOS app streams. Must be populated if type is
   * IOS_APP_DATA_STREAM.
   */
  iosAppStreamData?:
    | DataStream_IosAppStreamData
    | undefined;
  /**
   * Output only. Resource name of this Data Stream.
   * Format: properties/{property_id}/dataStreams/{stream_id}
   * Example: "properties/1000/dataStreams/2000"
   */
  name: string;
  /** Required. Immutable. The type of this DataStream resource. */
  type: DataStream_DataStreamType;
  /**
   * Human-readable display name for the Data Stream.
   *
   * Required for web data streams.
   *
   * The max allowed display name length is 255 UTF-16 code units.
   */
  displayName: string;
  /** Output only. Time when this stream was originally created. */
  createTime:
    | Date
    | undefined;
  /** Output only. Time when stream payload fields were last updated. */
  updateTime: Date | undefined;
}

/** The type of the data stream. */
export enum DataStream_DataStreamType {
  /** DATA_STREAM_TYPE_UNSPECIFIED - Type unknown or not specified. */
  DATA_STREAM_TYPE_UNSPECIFIED = 0,
  /** WEB_DATA_STREAM - Web data stream. */
  WEB_DATA_STREAM = 1,
  /** ANDROID_APP_DATA_STREAM - Android app data stream. */
  ANDROID_APP_DATA_STREAM = 2,
  /** IOS_APP_DATA_STREAM - iOS app data stream. */
  IOS_APP_DATA_STREAM = 3,
  UNRECOGNIZED = -1,
}

export function dataStream_DataStreamTypeFromJSON(object: any): DataStream_DataStreamType {
  switch (object) {
    case 0:
    case "DATA_STREAM_TYPE_UNSPECIFIED":
      return DataStream_DataStreamType.DATA_STREAM_TYPE_UNSPECIFIED;
    case 1:
    case "WEB_DATA_STREAM":
      return DataStream_DataStreamType.WEB_DATA_STREAM;
    case 2:
    case "ANDROID_APP_DATA_STREAM":
      return DataStream_DataStreamType.ANDROID_APP_DATA_STREAM;
    case 3:
    case "IOS_APP_DATA_STREAM":
      return DataStream_DataStreamType.IOS_APP_DATA_STREAM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DataStream_DataStreamType.UNRECOGNIZED;
  }
}

export function dataStream_DataStreamTypeToJSON(object: DataStream_DataStreamType): string {
  switch (object) {
    case DataStream_DataStreamType.DATA_STREAM_TYPE_UNSPECIFIED:
      return "DATA_STREAM_TYPE_UNSPECIFIED";
    case DataStream_DataStreamType.WEB_DATA_STREAM:
      return "WEB_DATA_STREAM";
    case DataStream_DataStreamType.ANDROID_APP_DATA_STREAM:
      return "ANDROID_APP_DATA_STREAM";
    case DataStream_DataStreamType.IOS_APP_DATA_STREAM:
      return "IOS_APP_DATA_STREAM";
    case DataStream_DataStreamType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Data specific to web streams. */
export interface DataStream_WebStreamData {
  /**
   * Output only. Analytics Measurement ID.
   *
   * Example: "G-1A2BCD345E"
   */
  measurementId: string;
  /**
   * Output only. ID of the corresponding web app in Firebase, if any.
   * This ID can change if the web app is deleted and recreated.
   */
  firebaseAppId: string;
  /**
   * Domain name of the web app being measured, or empty.
   * Example: "http://www.google.com", "https://www.google.com"
   */
  defaultUri: string;
}

/** Data specific to Android app streams. */
export interface DataStream_AndroidAppStreamData {
  /**
   * Output only. ID of the corresponding Android app in Firebase, if any.
   * This ID can change if the Android app is deleted and recreated.
   */
  firebaseAppId: string;
  /**
   * Immutable. The package name for the app being measured.
   * Example: "com.example.myandroidapp"
   */
  packageName: string;
}

/** Data specific to iOS app streams. */
export interface DataStream_IosAppStreamData {
  /**
   * Output only. ID of the corresponding iOS app in Firebase, if any.
   * This ID can change if the iOS app is deleted and recreated.
   */
  firebaseAppId: string;
  /**
   * Required. Immutable. The Apple App Store Bundle ID for the app
   * Example: "com.example.myiosapp"
   */
  bundleId: string;
}

/** A link between a GA4 property and a Firebase project. */
export interface FirebaseLink {
  /** Output only. Example format: properties/1234/firebaseLinks/5678 */
  name: string;
  /**
   * Immutable. Firebase project resource name. When creating a FirebaseLink,
   * you may provide this resource name using either a project number or project
   * ID. Once this resource has been created, returned FirebaseLinks will always
   * have a project_name that contains a project number.
   *
   * Format: 'projects/{project number}'
   * Example: 'projects/1234'
   */
  project: string;
  /** Output only. Time when this FirebaseLink was originally created. */
  createTime: Date | undefined;
}

/** A link between a GA4 property and a Google Ads account. */
export interface GoogleAdsLink {
  /**
   * Output only. Format:
   * properties/{propertyId}/googleAdsLinks/{googleAdsLinkId}
   *
   * Note: googleAdsLinkId is not the Google Ads customer ID.
   */
  name: string;
  /** Immutable. Google Ads customer ID. */
  customerId: string;
  /** Output only. If true, this link is for a Google Ads manager account. */
  canManageClients: boolean;
  /**
   * Enable personalized advertising features with this integration.
   * Automatically publish my Google Analytics audience lists and Google
   * Analytics remarketing events/parameters to the linked Google Ads account.
   * If this field is not set on create/update, it will be defaulted to true.
   */
  adsPersonalizationEnabled:
    | boolean
    | undefined;
  /** Output only. Time when this link was originally created. */
  createTime:
    | Date
    | undefined;
  /** Output only. Time when this link was last updated. */
  updateTime:
    | Date
    | undefined;
  /**
   * Output only. Email address of the user that created the link.
   * An empty string will be returned if the email address can't be retrieved.
   */
  creatorEmailAddress: string;
}

/**
 * A resource message representing data sharing settings of a Google Analytics
 * account.
 */
export interface DataSharingSettings {
  /**
   * Output only. Resource name.
   * Format: accounts/{account}/dataSharingSettings
   * Example: "accounts/1000/dataSharingSettings"
   */
  name: string;
  /**
   * Allows Google support to access the data in order to help troubleshoot
   * issues.
   */
  sharingWithGoogleSupportEnabled: boolean;
  /**
   * Allows Google sales teams that are assigned to the customer to access the
   * data in order to suggest configuration changes to improve results.
   * Sales team restrictions still apply when enabled.
   */
  sharingWithGoogleAssignedSalesEnabled: boolean;
  /**
   * Allows any of Google sales to access the data in order to suggest
   * configuration changes to improve results.
   */
  sharingWithGoogleAnySalesEnabled: boolean;
  /** Allows Google to use the data to improve other Google products or services. */
  sharingWithGoogleProductsEnabled: boolean;
  /** Allows Google to share the data anonymously in aggregate form with others. */
  sharingWithOthersEnabled: boolean;
}

/**
 * A virtual resource representing an overview of an account and
 * all its child GA4 properties.
 */
export interface AccountSummary {
  /**
   * Resource name for this account summary.
   * Format: accountSummaries/{account_id}
   * Example: "accountSummaries/1000"
   */
  name: string;
  /**
   * Resource name of account referred to by this account summary
   * Format: accounts/{account_id}
   * Example: "accounts/1000"
   */
  account: string;
  /** Display name for the account referred to in this account summary. */
  displayName: string;
  /** List of summaries for child accounts of this account. */
  propertySummaries: PropertySummary[];
}

/** A virtual resource representing metadata for a GA4 property. */
export interface PropertySummary {
  /**
   * Resource name of property referred to by this property summary
   * Format: properties/{property_id}
   * Example: "properties/1000"
   */
  property: string;
  /** Display name for the property referred to in this property summary. */
  displayName: string;
  /** The property's property type. */
  propertyType: PropertyType;
  /**
   * Resource name of this property's logical parent.
   *
   * Note: The Property-Moving UI can be used to change the parent.
   * Format: accounts/{account}, properties/{property}
   * Example: "accounts/100", "properties/200"
   */
  parent: string;
}

/** A secret value used for sending hits to Measurement Protocol. */
export interface MeasurementProtocolSecret {
  /**
   * Output only. Resource name of this secret. This secret may be a child of
   * any type of stream. Format:
   * properties/{property}/dataStreams/{dataStream}/measurementProtocolSecrets/{measurementProtocolSecret}
   */
  name: string;
  /** Required. Human-readable display name for this secret. */
  displayName: string;
  /**
   * Output only. The measurement protocol secret value. Pass this value to the
   * api_secret field of the Measurement Protocol API when sending hits to this
   * secret's parent property.
   */
  secretValue: string;
}

/**
 * A set of changes within a Google Analytics account or its child properties
 * that resulted from the same cause. Common causes would be updates made in the
 * Google Analytics UI, changes from customer support, or automatic Google
 * Analytics system changes.
 */
export interface ChangeHistoryEvent {
  /** ID of this change history event. This ID is unique across Google Analytics. */
  id: string;
  /** Time when change was made. */
  changeTime:
    | Date
    | undefined;
  /** The type of actor that made this change. */
  actorType: ActorType;
  /**
   * Email address of the Google account that made the change. This will be a
   * valid email address if the actor field is set to USER, and empty otherwise.
   * Google accounts that have been deleted will cause an error.
   */
  userActorEmail: string;
  /**
   * If true, then the list of changes returned was filtered, and does not
   * represent all changes that occurred in this event.
   */
  changesFiltered: boolean;
  /**
   * A list of changes made in this change history event that fit the filters
   * specified in SearchChangeHistoryEventsRequest.
   */
  changes: ChangeHistoryChange[];
}

/** A description of a change to a single Google Analytics resource. */
export interface ChangeHistoryChange {
  /** Resource name of the resource whose changes are described by this entry. */
  resource: string;
  /** The type of action that changed this resource. */
  action: ActionType;
  /**
   * Resource contents from before the change was made. If this resource was
   * created in this change, this field will be missing.
   */
  resourceBeforeChange:
    | ChangeHistoryChange_ChangeHistoryResource
    | undefined;
  /**
   * Resource contents from after the change was made. If this resource was
   * deleted in this change, this field will be missing.
   */
  resourceAfterChange: ChangeHistoryChange_ChangeHistoryResource | undefined;
}

/**
 * A snapshot of a resource as before or after the result of a change in
 * change history.
 */
export interface ChangeHistoryChange_ChangeHistoryResource {
  /** A snapshot of an Account resource in change history. */
  account?:
    | Account
    | undefined;
  /** A snapshot of a Property resource in change history. */
  property?:
    | Property
    | undefined;
  /** A snapshot of a FirebaseLink resource in change history. */
  firebaseLink?:
    | FirebaseLink
    | undefined;
  /** A snapshot of a GoogleAdsLink resource in change history. */
  googleAdsLink?:
    | GoogleAdsLink
    | undefined;
  /** A snapshot of a ConversionEvent resource in change history. */
  conversionEvent?:
    | ConversionEvent
    | undefined;
  /** A snapshot of a MeasurementProtocolSecret resource in change history. */
  measurementProtocolSecret?:
    | MeasurementProtocolSecret
    | undefined;
  /** A snapshot of a data retention settings resource in change history. */
  dataRetentionSettings?:
    | DataRetentionSettings
    | undefined;
  /** A snapshot of a DataStream resource in change history. */
  dataStream?: DataStream | undefined;
}

/** A conversion event in a Google Analytics property. */
export interface ConversionEvent {
  /**
   * Output only. Resource name of this conversion event.
   * Format: properties/{property}/conversionEvents/{conversion_event}
   */
  name: string;
  /**
   * Immutable. The event name for this conversion event.
   * Examples: 'click', 'purchase'
   */
  eventName: string;
  /** Output only. Time when this conversion event was created in the property. */
  createTime:
    | Date
    | undefined;
  /**
   * Output only. If set, this event can currently be deleted with
   * DeleteConversionEvent.
   */
  deletable: boolean;
  /**
   * Output only. If set to true, this conversion event refers to a custom
   * event.  If set to false, this conversion event refers to a default event in
   * GA. Default events typically have special meaning in GA. Default events are
   * usually created for you by the GA system, but in some cases can be created
   * by property admins. Custom events count towards the maximum number of
   * custom conversion events that may be created per property.
   */
  custom: boolean;
  /**
   * Optional. The method by which conversions will be counted across multiple
   * events within a session. If this value is not provided, it will be set to
   * `ONCE_PER_EVENT`.
   */
  countingMethod: ConversionEvent_ConversionCountingMethod;
  /** Optional. Defines a default value/currency for a conversion event. */
  defaultConversionValue?: ConversionEvent_DefaultConversionValue | undefined;
}

/**
 * The method by which conversions will be counted across multiple events
 * within a session.
 */
export enum ConversionEvent_ConversionCountingMethod {
  /** CONVERSION_COUNTING_METHOD_UNSPECIFIED - Counting method not specified. */
  CONVERSION_COUNTING_METHOD_UNSPECIFIED = 0,
  /** ONCE_PER_EVENT - Each Event instance is considered a Conversion. */
  ONCE_PER_EVENT = 1,
  /**
   * ONCE_PER_SESSION - An Event instance is considered a Conversion at most once per session per
   * user.
   */
  ONCE_PER_SESSION = 2,
  UNRECOGNIZED = -1,
}

export function conversionEvent_ConversionCountingMethodFromJSON(
  object: any,
): ConversionEvent_ConversionCountingMethod {
  switch (object) {
    case 0:
    case "CONVERSION_COUNTING_METHOD_UNSPECIFIED":
      return ConversionEvent_ConversionCountingMethod.CONVERSION_COUNTING_METHOD_UNSPECIFIED;
    case 1:
    case "ONCE_PER_EVENT":
      return ConversionEvent_ConversionCountingMethod.ONCE_PER_EVENT;
    case 2:
    case "ONCE_PER_SESSION":
      return ConversionEvent_ConversionCountingMethod.ONCE_PER_SESSION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ConversionEvent_ConversionCountingMethod.UNRECOGNIZED;
  }
}

export function conversionEvent_ConversionCountingMethodToJSON(
  object: ConversionEvent_ConversionCountingMethod,
): string {
  switch (object) {
    case ConversionEvent_ConversionCountingMethod.CONVERSION_COUNTING_METHOD_UNSPECIFIED:
      return "CONVERSION_COUNTING_METHOD_UNSPECIFIED";
    case ConversionEvent_ConversionCountingMethod.ONCE_PER_EVENT:
      return "ONCE_PER_EVENT";
    case ConversionEvent_ConversionCountingMethod.ONCE_PER_SESSION:
      return "ONCE_PER_SESSION";
    case ConversionEvent_ConversionCountingMethod.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Defines a default value/currency for a conversion event. Both value and
 * currency must be provided.
 */
export interface ConversionEvent_DefaultConversionValue {
  /**
   * This value will be used to populate the value for all conversions
   * of the specified event_name where the event "value" parameter is unset.
   */
  value?:
    | number
    | undefined;
  /**
   * When a conversion event for this event_name has no set currency,
   * this currency will be applied as the default. Must be in ISO 4217
   * currency code format. See https://en.wikipedia.org/wiki/ISO_4217 for
   * more information.
   */
  currencyCode?: string | undefined;
}

/** A key event in a Google Analytics property. */
export interface KeyEvent {
  /**
   * Output only. Resource name of this key event.
   * Format: properties/{property}/keyEvents/{key_event}
   */
  name: string;
  /**
   * Immutable. The event name for this key event.
   * Examples: 'click', 'purchase'
   */
  eventName: string;
  /** Output only. Time when this key event was created in the property. */
  createTime:
    | Date
    | undefined;
  /** Output only. If set to true, this event can be deleted. */
  deletable: boolean;
  /**
   * Output only. If set to true, this key event refers to a custom event.  If
   * set to false, this key event refers to a default event in GA. Default
   * events typically have special meaning in GA. Default events are usually
   * created for you by the GA system, but in some cases can be created by
   * property admins. Custom events count towards the maximum number of
   * custom key events that may be created per property.
   */
  custom: boolean;
  /**
   * Required. The method by which Key Events will be counted across multiple
   * events within a session.
   */
  countingMethod: KeyEvent_CountingMethod;
  /** Optional. Defines a default value/currency for a key event. */
  defaultValue: KeyEvent_DefaultValue | undefined;
}

/**
 * The method by which Key Events will be counted across multiple events
 * within a session.
 */
export enum KeyEvent_CountingMethod {
  /** COUNTING_METHOD_UNSPECIFIED - Counting method not specified. */
  COUNTING_METHOD_UNSPECIFIED = 0,
  /** ONCE_PER_EVENT - Each Event instance is considered a Key Event. */
  ONCE_PER_EVENT = 1,
  /**
   * ONCE_PER_SESSION - An Event instance is considered a Key Event at most once per session per
   * user.
   */
  ONCE_PER_SESSION = 2,
  UNRECOGNIZED = -1,
}

export function keyEvent_CountingMethodFromJSON(object: any): KeyEvent_CountingMethod {
  switch (object) {
    case 0:
    case "COUNTING_METHOD_UNSPECIFIED":
      return KeyEvent_CountingMethod.COUNTING_METHOD_UNSPECIFIED;
    case 1:
    case "ONCE_PER_EVENT":
      return KeyEvent_CountingMethod.ONCE_PER_EVENT;
    case 2:
    case "ONCE_PER_SESSION":
      return KeyEvent_CountingMethod.ONCE_PER_SESSION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return KeyEvent_CountingMethod.UNRECOGNIZED;
  }
}

export function keyEvent_CountingMethodToJSON(object: KeyEvent_CountingMethod): string {
  switch (object) {
    case KeyEvent_CountingMethod.COUNTING_METHOD_UNSPECIFIED:
      return "COUNTING_METHOD_UNSPECIFIED";
    case KeyEvent_CountingMethod.ONCE_PER_EVENT:
      return "ONCE_PER_EVENT";
    case KeyEvent_CountingMethod.ONCE_PER_SESSION:
      return "ONCE_PER_SESSION";
    case KeyEvent_CountingMethod.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Defines a default value/currency for a key event. */
export interface KeyEvent_DefaultValue {
  /**
   * Required. This will be used to populate the "value" parameter for all
   * occurrences of this Key Event (specified by event_name) where that
   * parameter is unset.
   */
  numericValue: number;
  /**
   * Required. When an occurrence of this Key Event (specified by event_name)
   * has no set currency this currency will be applied as the default. Must be
   * in ISO 4217 currency code format.
   *
   * See https://en.wikipedia.org/wiki/ISO_4217 for more information.
   */
  currencyCode: string;
}

/** A definition for a CustomDimension. */
export interface CustomDimension {
  /**
   * Output only. Resource name for this CustomDimension resource.
   * Format: properties/{property}/customDimensions/{customDimension}
   */
  name: string;
  /**
   * Required. Immutable. Tagging parameter name for this custom dimension.
   *
   * If this is a user-scoped dimension, then this is the user property name.
   * If this is an event-scoped dimension, then this is the event parameter
   * name.
   *
   * If this is an item-scoped dimension, then this is the parameter
   * name found in the eCommerce items array.
   *
   * May only contain alphanumeric and underscore characters, starting with a
   * letter. Max length of 24 characters for user-scoped dimensions, 40
   * characters for event-scoped dimensions.
   */
  parameterName: string;
  /**
   * Required. Display name for this custom dimension as shown in the Analytics
   * UI. Max length of 82 characters, alphanumeric plus space and underscore
   * starting with a letter. Legacy system-generated display names may contain
   * square brackets, but updates to this field will never permit square
   * brackets.
   */
  displayName: string;
  /**
   * Optional. Description for this custom dimension. Max length of 150
   * characters.
   */
  description: string;
  /** Required. Immutable. The scope of this dimension. */
  scope: CustomDimension_DimensionScope;
  /**
   * Optional. If set to true, sets this dimension as NPA and excludes it from
   * ads personalization.
   *
   * This is currently only supported by user-scoped custom dimensions.
   */
  disallowAdsPersonalization: boolean;
}

/** Valid values for the scope of this dimension. */
export enum CustomDimension_DimensionScope {
  /** DIMENSION_SCOPE_UNSPECIFIED - Scope unknown or not specified. */
  DIMENSION_SCOPE_UNSPECIFIED = 0,
  /** EVENT - Dimension scoped to an event. */
  EVENT = 1,
  /** USER - Dimension scoped to a user. */
  USER = 2,
  /** ITEM - Dimension scoped to eCommerce items */
  ITEM = 3,
  UNRECOGNIZED = -1,
}

export function customDimension_DimensionScopeFromJSON(object: any): CustomDimension_DimensionScope {
  switch (object) {
    case 0:
    case "DIMENSION_SCOPE_UNSPECIFIED":
      return CustomDimension_DimensionScope.DIMENSION_SCOPE_UNSPECIFIED;
    case 1:
    case "EVENT":
      return CustomDimension_DimensionScope.EVENT;
    case 2:
    case "USER":
      return CustomDimension_DimensionScope.USER;
    case 3:
    case "ITEM":
      return CustomDimension_DimensionScope.ITEM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CustomDimension_DimensionScope.UNRECOGNIZED;
  }
}

export function customDimension_DimensionScopeToJSON(object: CustomDimension_DimensionScope): string {
  switch (object) {
    case CustomDimension_DimensionScope.DIMENSION_SCOPE_UNSPECIFIED:
      return "DIMENSION_SCOPE_UNSPECIFIED";
    case CustomDimension_DimensionScope.EVENT:
      return "EVENT";
    case CustomDimension_DimensionScope.USER:
      return "USER";
    case CustomDimension_DimensionScope.ITEM:
      return "ITEM";
    case CustomDimension_DimensionScope.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A definition for a custom metric. */
export interface CustomMetric {
  /**
   * Output only. Resource name for this CustomMetric resource.
   * Format: properties/{property}/customMetrics/{customMetric}
   */
  name: string;
  /**
   * Required. Immutable. Tagging name for this custom metric.
   *
   * If this is an event-scoped metric, then this is the event parameter
   * name.
   *
   * May only contain alphanumeric and underscore charactes, starting with a
   * letter. Max length of 40 characters for event-scoped metrics.
   */
  parameterName: string;
  /**
   * Required. Display name for this custom metric as shown in the Analytics UI.
   * Max length of 82 characters, alphanumeric plus space and underscore
   * starting with a letter. Legacy system-generated display names may contain
   * square brackets, but updates to this field will never permit square
   * brackets.
   */
  displayName: string;
  /**
   * Optional. Description for this custom dimension.
   * Max length of 150 characters.
   */
  description: string;
  /** Required. The type for the custom metric's value. */
  measurementUnit: CustomMetric_MeasurementUnit;
  /** Required. Immutable. The scope of this custom metric. */
  scope: CustomMetric_MetricScope;
  /**
   * Optional. Types of restricted data that this metric may contain. Required
   * for metrics with CURRENCY measurement unit. Must be empty for metrics with
   * a non-CURRENCY measurement unit.
   */
  restrictedMetricType: CustomMetric_RestrictedMetricType[];
}

/**
 * Possible types of representing the custom metric's value.
 *
 * Currency representation may change in the future, requiring a breaking API
 * change.
 */
export enum CustomMetric_MeasurementUnit {
  /** MEASUREMENT_UNIT_UNSPECIFIED - MeasurementUnit unspecified or missing. */
  MEASUREMENT_UNIT_UNSPECIFIED = 0,
  /** STANDARD - This metric uses default units. */
  STANDARD = 1,
  /** CURRENCY - This metric measures a currency. */
  CURRENCY = 2,
  /** FEET - This metric measures feet. */
  FEET = 3,
  /** METERS - This metric measures meters. */
  METERS = 4,
  /** KILOMETERS - This metric measures kilometers. */
  KILOMETERS = 5,
  /** MILES - This metric measures miles. */
  MILES = 6,
  /** MILLISECONDS - This metric measures milliseconds. */
  MILLISECONDS = 7,
  /** SECONDS - This metric measures seconds. */
  SECONDS = 8,
  /** MINUTES - This metric measures minutes. */
  MINUTES = 9,
  /** HOURS - This metric measures hours. */
  HOURS = 10,
  UNRECOGNIZED = -1,
}

export function customMetric_MeasurementUnitFromJSON(object: any): CustomMetric_MeasurementUnit {
  switch (object) {
    case 0:
    case "MEASUREMENT_UNIT_UNSPECIFIED":
      return CustomMetric_MeasurementUnit.MEASUREMENT_UNIT_UNSPECIFIED;
    case 1:
    case "STANDARD":
      return CustomMetric_MeasurementUnit.STANDARD;
    case 2:
    case "CURRENCY":
      return CustomMetric_MeasurementUnit.CURRENCY;
    case 3:
    case "FEET":
      return CustomMetric_MeasurementUnit.FEET;
    case 4:
    case "METERS":
      return CustomMetric_MeasurementUnit.METERS;
    case 5:
    case "KILOMETERS":
      return CustomMetric_MeasurementUnit.KILOMETERS;
    case 6:
    case "MILES":
      return CustomMetric_MeasurementUnit.MILES;
    case 7:
    case "MILLISECONDS":
      return CustomMetric_MeasurementUnit.MILLISECONDS;
    case 8:
    case "SECONDS":
      return CustomMetric_MeasurementUnit.SECONDS;
    case 9:
    case "MINUTES":
      return CustomMetric_MeasurementUnit.MINUTES;
    case 10:
    case "HOURS":
      return CustomMetric_MeasurementUnit.HOURS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CustomMetric_MeasurementUnit.UNRECOGNIZED;
  }
}

export function customMetric_MeasurementUnitToJSON(object: CustomMetric_MeasurementUnit): string {
  switch (object) {
    case CustomMetric_MeasurementUnit.MEASUREMENT_UNIT_UNSPECIFIED:
      return "MEASUREMENT_UNIT_UNSPECIFIED";
    case CustomMetric_MeasurementUnit.STANDARD:
      return "STANDARD";
    case CustomMetric_MeasurementUnit.CURRENCY:
      return "CURRENCY";
    case CustomMetric_MeasurementUnit.FEET:
      return "FEET";
    case CustomMetric_MeasurementUnit.METERS:
      return "METERS";
    case CustomMetric_MeasurementUnit.KILOMETERS:
      return "KILOMETERS";
    case CustomMetric_MeasurementUnit.MILES:
      return "MILES";
    case CustomMetric_MeasurementUnit.MILLISECONDS:
      return "MILLISECONDS";
    case CustomMetric_MeasurementUnit.SECONDS:
      return "SECONDS";
    case CustomMetric_MeasurementUnit.MINUTES:
      return "MINUTES";
    case CustomMetric_MeasurementUnit.HOURS:
      return "HOURS";
    case CustomMetric_MeasurementUnit.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The scope of this metric. */
export enum CustomMetric_MetricScope {
  /** METRIC_SCOPE_UNSPECIFIED - Scope unknown or not specified. */
  METRIC_SCOPE_UNSPECIFIED = 0,
  /** EVENT - Metric scoped to an event. */
  EVENT = 1,
  UNRECOGNIZED = -1,
}

export function customMetric_MetricScopeFromJSON(object: any): CustomMetric_MetricScope {
  switch (object) {
    case 0:
    case "METRIC_SCOPE_UNSPECIFIED":
      return CustomMetric_MetricScope.METRIC_SCOPE_UNSPECIFIED;
    case 1:
    case "EVENT":
      return CustomMetric_MetricScope.EVENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CustomMetric_MetricScope.UNRECOGNIZED;
  }
}

export function customMetric_MetricScopeToJSON(object: CustomMetric_MetricScope): string {
  switch (object) {
    case CustomMetric_MetricScope.METRIC_SCOPE_UNSPECIFIED:
      return "METRIC_SCOPE_UNSPECIFIED";
    case CustomMetric_MetricScope.EVENT:
      return "EVENT";
    case CustomMetric_MetricScope.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Labels that mark the data in this custom metric as data that should be
 * restricted to specific users.
 */
export enum CustomMetric_RestrictedMetricType {
  /** RESTRICTED_METRIC_TYPE_UNSPECIFIED - Type unknown or unspecified. */
  RESTRICTED_METRIC_TYPE_UNSPECIFIED = 0,
  /** COST_DATA - Metric reports cost data. */
  COST_DATA = 1,
  /** REVENUE_DATA - Metric reports revenue data. */
  REVENUE_DATA = 2,
  UNRECOGNIZED = -1,
}

export function customMetric_RestrictedMetricTypeFromJSON(object: any): CustomMetric_RestrictedMetricType {
  switch (object) {
    case 0:
    case "RESTRICTED_METRIC_TYPE_UNSPECIFIED":
      return CustomMetric_RestrictedMetricType.RESTRICTED_METRIC_TYPE_UNSPECIFIED;
    case 1:
    case "COST_DATA":
      return CustomMetric_RestrictedMetricType.COST_DATA;
    case 2:
    case "REVENUE_DATA":
      return CustomMetric_RestrictedMetricType.REVENUE_DATA;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CustomMetric_RestrictedMetricType.UNRECOGNIZED;
  }
}

export function customMetric_RestrictedMetricTypeToJSON(object: CustomMetric_RestrictedMetricType): string {
  switch (object) {
    case CustomMetric_RestrictedMetricType.RESTRICTED_METRIC_TYPE_UNSPECIFIED:
      return "RESTRICTED_METRIC_TYPE_UNSPECIFIED";
    case CustomMetric_RestrictedMetricType.COST_DATA:
      return "COST_DATA";
    case CustomMetric_RestrictedMetricType.REVENUE_DATA:
      return "REVENUE_DATA";
    case CustomMetric_RestrictedMetricType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Settings values for data retention. This is a singleton resource. */
export interface DataRetentionSettings {
  /**
   * Output only. Resource name for this DataRetentionSetting resource.
   * Format: properties/{property}/dataRetentionSettings
   */
  name: string;
  /** The length of time that event-level data is retained. */
  eventDataRetention: DataRetentionSettings_RetentionDuration;
  /**
   * If true, reset the retention period for the user identifier with every
   * event from that user.
   */
  resetUserDataOnNewActivity: boolean;
}

/** Valid values for the data retention duration. */
export enum DataRetentionSettings_RetentionDuration {
  /** RETENTION_DURATION_UNSPECIFIED - Data retention time duration is not specified. */
  RETENTION_DURATION_UNSPECIFIED = 0,
  /** TWO_MONTHS - The data retention time duration is 2 months. */
  TWO_MONTHS = 1,
  /** FOURTEEN_MONTHS - The data retention time duration is 14 months. */
  FOURTEEN_MONTHS = 3,
  /**
   * TWENTY_SIX_MONTHS - The data retention time duration is 26 months.
   * Available to 360 properties only.
   */
  TWENTY_SIX_MONTHS = 4,
  /**
   * THIRTY_EIGHT_MONTHS - The data retention time duration is 38 months.
   * Available to 360 properties only.
   */
  THIRTY_EIGHT_MONTHS = 5,
  /**
   * FIFTY_MONTHS - The data retention time duration is 50 months.
   * Available to 360 properties only.
   */
  FIFTY_MONTHS = 6,
  UNRECOGNIZED = -1,
}

export function dataRetentionSettings_RetentionDurationFromJSON(object: any): DataRetentionSettings_RetentionDuration {
  switch (object) {
    case 0:
    case "RETENTION_DURATION_UNSPECIFIED":
      return DataRetentionSettings_RetentionDuration.RETENTION_DURATION_UNSPECIFIED;
    case 1:
    case "TWO_MONTHS":
      return DataRetentionSettings_RetentionDuration.TWO_MONTHS;
    case 3:
    case "FOURTEEN_MONTHS":
      return DataRetentionSettings_RetentionDuration.FOURTEEN_MONTHS;
    case 4:
    case "TWENTY_SIX_MONTHS":
      return DataRetentionSettings_RetentionDuration.TWENTY_SIX_MONTHS;
    case 5:
    case "THIRTY_EIGHT_MONTHS":
      return DataRetentionSettings_RetentionDuration.THIRTY_EIGHT_MONTHS;
    case 6:
    case "FIFTY_MONTHS":
      return DataRetentionSettings_RetentionDuration.FIFTY_MONTHS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DataRetentionSettings_RetentionDuration.UNRECOGNIZED;
  }
}

export function dataRetentionSettings_RetentionDurationToJSON(object: DataRetentionSettings_RetentionDuration): string {
  switch (object) {
    case DataRetentionSettings_RetentionDuration.RETENTION_DURATION_UNSPECIFIED:
      return "RETENTION_DURATION_UNSPECIFIED";
    case DataRetentionSettings_RetentionDuration.TWO_MONTHS:
      return "TWO_MONTHS";
    case DataRetentionSettings_RetentionDuration.FOURTEEN_MONTHS:
      return "FOURTEEN_MONTHS";
    case DataRetentionSettings_RetentionDuration.TWENTY_SIX_MONTHS:
      return "TWENTY_SIX_MONTHS";
    case DataRetentionSettings_RetentionDuration.THIRTY_EIGHT_MONTHS:
      return "THIRTY_EIGHT_MONTHS";
    case DataRetentionSettings_RetentionDuration.FIFTY_MONTHS:
      return "FIFTY_MONTHS";
    case DataRetentionSettings_RetentionDuration.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseAccount(): Account {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    displayName: "",
    regionCode: "",
    deleted: false,
    gmpOrganization: "",
  };
}

export const Account: MessageFns<Account> = {
  encode(message: Account, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    if (message.displayName !== "") {
      writer.uint32(34).string(message.displayName);
    }
    if (message.regionCode !== "") {
      writer.uint32(42).string(message.regionCode);
    }
    if (message.deleted !== false) {
      writer.uint32(48).bool(message.deleted);
    }
    if (message.gmpOrganization !== "") {
      writer.uint32(58).string(message.gmpOrganization);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Account {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.regionCode = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.deleted = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.gmpOrganization = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Account {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      regionCode: isSet(object.regionCode) ? globalThis.String(object.regionCode) : "",
      deleted: isSet(object.deleted) ? globalThis.Boolean(object.deleted) : false,
      gmpOrganization: isSet(object.gmpOrganization) ? globalThis.String(object.gmpOrganization) : "",
    };
  },

  toJSON(message: Account): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.regionCode !== "") {
      obj.regionCode = message.regionCode;
    }
    if (message.deleted !== false) {
      obj.deleted = message.deleted;
    }
    if (message.gmpOrganization !== "") {
      obj.gmpOrganization = message.gmpOrganization;
    }
    return obj;
  },

  create(base?: DeepPartial<Account>): Account {
    return Account.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Account>): Account {
    const message = createBaseAccount();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.displayName = object.displayName ?? "";
    message.regionCode = object.regionCode ?? "";
    message.deleted = object.deleted ?? false;
    message.gmpOrganization = object.gmpOrganization ?? "";
    return message;
  },
};

function createBaseProperty(): Property {
  return {
    name: "",
    propertyType: 0,
    createTime: undefined,
    updateTime: undefined,
    parent: "",
    displayName: "",
    industryCategory: 0,
    timeZone: "",
    currencyCode: "",
    serviceLevel: 0,
    deleteTime: undefined,
    expireTime: undefined,
    account: "",
  };
}

export const Property: MessageFns<Property> = {
  encode(message: Property, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.propertyType !== 0) {
      writer.uint32(112).int32(message.propertyType);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(34).fork()).join();
    }
    if (message.parent !== "") {
      writer.uint32(18).string(message.parent);
    }
    if (message.displayName !== "") {
      writer.uint32(42).string(message.displayName);
    }
    if (message.industryCategory !== 0) {
      writer.uint32(48).int32(message.industryCategory);
    }
    if (message.timeZone !== "") {
      writer.uint32(58).string(message.timeZone);
    }
    if (message.currencyCode !== "") {
      writer.uint32(66).string(message.currencyCode);
    }
    if (message.serviceLevel !== 0) {
      writer.uint32(80).int32(message.serviceLevel);
    }
    if (message.deleteTime !== undefined) {
      Timestamp.encode(toTimestamp(message.deleteTime), writer.uint32(90).fork()).join();
    }
    if (message.expireTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expireTime), writer.uint32(98).fork()).join();
    }
    if (message.account !== "") {
      writer.uint32(106).string(message.account);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Property {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProperty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.propertyType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.industryCategory = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.timeZone = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.currencyCode = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.serviceLevel = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.deleteTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.expireTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.account = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Property {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      propertyType: isSet(object.propertyType) ? propertyTypeFromJSON(object.propertyType) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      industryCategory: isSet(object.industryCategory) ? industryCategoryFromJSON(object.industryCategory) : 0,
      timeZone: isSet(object.timeZone) ? globalThis.String(object.timeZone) : "",
      currencyCode: isSet(object.currencyCode) ? globalThis.String(object.currencyCode) : "",
      serviceLevel: isSet(object.serviceLevel) ? serviceLevelFromJSON(object.serviceLevel) : 0,
      deleteTime: isSet(object.deleteTime) ? fromJsonTimestamp(object.deleteTime) : undefined,
      expireTime: isSet(object.expireTime) ? fromJsonTimestamp(object.expireTime) : undefined,
      account: isSet(object.account) ? globalThis.String(object.account) : "",
    };
  },

  toJSON(message: Property): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.propertyType !== 0) {
      obj.propertyType = propertyTypeToJSON(message.propertyType);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.industryCategory !== 0) {
      obj.industryCategory = industryCategoryToJSON(message.industryCategory);
    }
    if (message.timeZone !== "") {
      obj.timeZone = message.timeZone;
    }
    if (message.currencyCode !== "") {
      obj.currencyCode = message.currencyCode;
    }
    if (message.serviceLevel !== 0) {
      obj.serviceLevel = serviceLevelToJSON(message.serviceLevel);
    }
    if (message.deleteTime !== undefined) {
      obj.deleteTime = message.deleteTime.toISOString();
    }
    if (message.expireTime !== undefined) {
      obj.expireTime = message.expireTime.toISOString();
    }
    if (message.account !== "") {
      obj.account = message.account;
    }
    return obj;
  },

  create(base?: DeepPartial<Property>): Property {
    return Property.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Property>): Property {
    const message = createBaseProperty();
    message.name = object.name ?? "";
    message.propertyType = object.propertyType ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.parent = object.parent ?? "";
    message.displayName = object.displayName ?? "";
    message.industryCategory = object.industryCategory ?? 0;
    message.timeZone = object.timeZone ?? "";
    message.currencyCode = object.currencyCode ?? "";
    message.serviceLevel = object.serviceLevel ?? 0;
    message.deleteTime = object.deleteTime ?? undefined;
    message.expireTime = object.expireTime ?? undefined;
    message.account = object.account ?? "";
    return message;
  },
};

function createBaseDataStream(): DataStream {
  return {
    webStreamData: undefined,
    androidAppStreamData: undefined,
    iosAppStreamData: undefined,
    name: "",
    type: 0,
    displayName: "",
    createTime: undefined,
    updateTime: undefined,
  };
}

export const DataStream: MessageFns<DataStream> = {
  encode(message: DataStream, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.webStreamData !== undefined) {
      DataStream_WebStreamData.encode(message.webStreamData, writer.uint32(50).fork()).join();
    }
    if (message.androidAppStreamData !== undefined) {
      DataStream_AndroidAppStreamData.encode(message.androidAppStreamData, writer.uint32(58).fork()).join();
    }
    if (message.iosAppStreamData !== undefined) {
      DataStream_IosAppStreamData.encode(message.iosAppStreamData, writer.uint32(66).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(34).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataStream {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataStream();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6:
          if (tag !== 50) {
            break;
          }

          message.webStreamData = DataStream_WebStreamData.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.androidAppStreamData = DataStream_AndroidAppStreamData.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.iosAppStreamData = DataStream_IosAppStreamData.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataStream {
    return {
      webStreamData: isSet(object.webStreamData) ? DataStream_WebStreamData.fromJSON(object.webStreamData) : undefined,
      androidAppStreamData: isSet(object.androidAppStreamData)
        ? DataStream_AndroidAppStreamData.fromJSON(object.androidAppStreamData)
        : undefined,
      iosAppStreamData: isSet(object.iosAppStreamData)
        ? DataStream_IosAppStreamData.fromJSON(object.iosAppStreamData)
        : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? dataStream_DataStreamTypeFromJSON(object.type) : 0,
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: DataStream): unknown {
    const obj: any = {};
    if (message.webStreamData !== undefined) {
      obj.webStreamData = DataStream_WebStreamData.toJSON(message.webStreamData);
    }
    if (message.androidAppStreamData !== undefined) {
      obj.androidAppStreamData = DataStream_AndroidAppStreamData.toJSON(message.androidAppStreamData);
    }
    if (message.iosAppStreamData !== undefined) {
      obj.iosAppStreamData = DataStream_IosAppStreamData.toJSON(message.iosAppStreamData);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== 0) {
      obj.type = dataStream_DataStreamTypeToJSON(message.type);
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<DataStream>): DataStream {
    return DataStream.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataStream>): DataStream {
    const message = createBaseDataStream();
    message.webStreamData = (object.webStreamData !== undefined && object.webStreamData !== null)
      ? DataStream_WebStreamData.fromPartial(object.webStreamData)
      : undefined;
    message.androidAppStreamData = (object.androidAppStreamData !== undefined && object.androidAppStreamData !== null)
      ? DataStream_AndroidAppStreamData.fromPartial(object.androidAppStreamData)
      : undefined;
    message.iosAppStreamData = (object.iosAppStreamData !== undefined && object.iosAppStreamData !== null)
      ? DataStream_IosAppStreamData.fromPartial(object.iosAppStreamData)
      : undefined;
    message.name = object.name ?? "";
    message.type = object.type ?? 0;
    message.displayName = object.displayName ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

function createBaseDataStream_WebStreamData(): DataStream_WebStreamData {
  return { measurementId: "", firebaseAppId: "", defaultUri: "" };
}

export const DataStream_WebStreamData: MessageFns<DataStream_WebStreamData> = {
  encode(message: DataStream_WebStreamData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.measurementId !== "") {
      writer.uint32(10).string(message.measurementId);
    }
    if (message.firebaseAppId !== "") {
      writer.uint32(18).string(message.firebaseAppId);
    }
    if (message.defaultUri !== "") {
      writer.uint32(26).string(message.defaultUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataStream_WebStreamData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataStream_WebStreamData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.measurementId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.firebaseAppId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.defaultUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataStream_WebStreamData {
    return {
      measurementId: isSet(object.measurementId) ? globalThis.String(object.measurementId) : "",
      firebaseAppId: isSet(object.firebaseAppId) ? globalThis.String(object.firebaseAppId) : "",
      defaultUri: isSet(object.defaultUri) ? globalThis.String(object.defaultUri) : "",
    };
  },

  toJSON(message: DataStream_WebStreamData): unknown {
    const obj: any = {};
    if (message.measurementId !== "") {
      obj.measurementId = message.measurementId;
    }
    if (message.firebaseAppId !== "") {
      obj.firebaseAppId = message.firebaseAppId;
    }
    if (message.defaultUri !== "") {
      obj.defaultUri = message.defaultUri;
    }
    return obj;
  },

  create(base?: DeepPartial<DataStream_WebStreamData>): DataStream_WebStreamData {
    return DataStream_WebStreamData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataStream_WebStreamData>): DataStream_WebStreamData {
    const message = createBaseDataStream_WebStreamData();
    message.measurementId = object.measurementId ?? "";
    message.firebaseAppId = object.firebaseAppId ?? "";
    message.defaultUri = object.defaultUri ?? "";
    return message;
  },
};

function createBaseDataStream_AndroidAppStreamData(): DataStream_AndroidAppStreamData {
  return { firebaseAppId: "", packageName: "" };
}

export const DataStream_AndroidAppStreamData: MessageFns<DataStream_AndroidAppStreamData> = {
  encode(message: DataStream_AndroidAppStreamData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.firebaseAppId !== "") {
      writer.uint32(10).string(message.firebaseAppId);
    }
    if (message.packageName !== "") {
      writer.uint32(18).string(message.packageName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataStream_AndroidAppStreamData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataStream_AndroidAppStreamData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.firebaseAppId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.packageName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataStream_AndroidAppStreamData {
    return {
      firebaseAppId: isSet(object.firebaseAppId) ? globalThis.String(object.firebaseAppId) : "",
      packageName: isSet(object.packageName) ? globalThis.String(object.packageName) : "",
    };
  },

  toJSON(message: DataStream_AndroidAppStreamData): unknown {
    const obj: any = {};
    if (message.firebaseAppId !== "") {
      obj.firebaseAppId = message.firebaseAppId;
    }
    if (message.packageName !== "") {
      obj.packageName = message.packageName;
    }
    return obj;
  },

  create(base?: DeepPartial<DataStream_AndroidAppStreamData>): DataStream_AndroidAppStreamData {
    return DataStream_AndroidAppStreamData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataStream_AndroidAppStreamData>): DataStream_AndroidAppStreamData {
    const message = createBaseDataStream_AndroidAppStreamData();
    message.firebaseAppId = object.firebaseAppId ?? "";
    message.packageName = object.packageName ?? "";
    return message;
  },
};

function createBaseDataStream_IosAppStreamData(): DataStream_IosAppStreamData {
  return { firebaseAppId: "", bundleId: "" };
}

export const DataStream_IosAppStreamData: MessageFns<DataStream_IosAppStreamData> = {
  encode(message: DataStream_IosAppStreamData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.firebaseAppId !== "") {
      writer.uint32(10).string(message.firebaseAppId);
    }
    if (message.bundleId !== "") {
      writer.uint32(18).string(message.bundleId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataStream_IosAppStreamData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataStream_IosAppStreamData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.firebaseAppId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.bundleId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataStream_IosAppStreamData {
    return {
      firebaseAppId: isSet(object.firebaseAppId) ? globalThis.String(object.firebaseAppId) : "",
      bundleId: isSet(object.bundleId) ? globalThis.String(object.bundleId) : "",
    };
  },

  toJSON(message: DataStream_IosAppStreamData): unknown {
    const obj: any = {};
    if (message.firebaseAppId !== "") {
      obj.firebaseAppId = message.firebaseAppId;
    }
    if (message.bundleId !== "") {
      obj.bundleId = message.bundleId;
    }
    return obj;
  },

  create(base?: DeepPartial<DataStream_IosAppStreamData>): DataStream_IosAppStreamData {
    return DataStream_IosAppStreamData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataStream_IosAppStreamData>): DataStream_IosAppStreamData {
    const message = createBaseDataStream_IosAppStreamData();
    message.firebaseAppId = object.firebaseAppId ?? "";
    message.bundleId = object.bundleId ?? "";
    return message;
  },
};

function createBaseFirebaseLink(): FirebaseLink {
  return { name: "", project: "", createTime: undefined };
}

export const FirebaseLink: MessageFns<FirebaseLink> = {
  encode(message: FirebaseLink, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.project !== "") {
      writer.uint32(18).string(message.project);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FirebaseLink {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFirebaseLink();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.project = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FirebaseLink {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      project: isSet(object.project) ? globalThis.String(object.project) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
    };
  },

  toJSON(message: FirebaseLink): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.project !== "") {
      obj.project = message.project;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<FirebaseLink>): FirebaseLink {
    return FirebaseLink.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FirebaseLink>): FirebaseLink {
    const message = createBaseFirebaseLink();
    message.name = object.name ?? "";
    message.project = object.project ?? "";
    message.createTime = object.createTime ?? undefined;
    return message;
  },
};

function createBaseGoogleAdsLink(): GoogleAdsLink {
  return {
    name: "",
    customerId: "",
    canManageClients: false,
    adsPersonalizationEnabled: undefined,
    createTime: undefined,
    updateTime: undefined,
    creatorEmailAddress: "",
  };
}

export const GoogleAdsLink: MessageFns<GoogleAdsLink> = {
  encode(message: GoogleAdsLink, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.customerId !== "") {
      writer.uint32(26).string(message.customerId);
    }
    if (message.canManageClients !== false) {
      writer.uint32(32).bool(message.canManageClients);
    }
    if (message.adsPersonalizationEnabled !== undefined) {
      BoolValue.encode({ value: message.adsPersonalizationEnabled! }, writer.uint32(42).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(58).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(66).fork()).join();
    }
    if (message.creatorEmailAddress !== "") {
      writer.uint32(74).string(message.creatorEmailAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GoogleAdsLink {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGoogleAdsLink();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.canManageClients = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.adsPersonalizationEnabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.creatorEmailAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GoogleAdsLink {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : "",
      canManageClients: isSet(object.canManageClients) ? globalThis.Boolean(object.canManageClients) : false,
      adsPersonalizationEnabled: isSet(object.adsPersonalizationEnabled)
        ? Boolean(object.adsPersonalizationEnabled)
        : undefined,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      creatorEmailAddress: isSet(object.creatorEmailAddress) ? globalThis.String(object.creatorEmailAddress) : "",
    };
  },

  toJSON(message: GoogleAdsLink): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.canManageClients !== false) {
      obj.canManageClients = message.canManageClients;
    }
    if (message.adsPersonalizationEnabled !== undefined) {
      obj.adsPersonalizationEnabled = message.adsPersonalizationEnabled;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.creatorEmailAddress !== "") {
      obj.creatorEmailAddress = message.creatorEmailAddress;
    }
    return obj;
  },

  create(base?: DeepPartial<GoogleAdsLink>): GoogleAdsLink {
    return GoogleAdsLink.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GoogleAdsLink>): GoogleAdsLink {
    const message = createBaseGoogleAdsLink();
    message.name = object.name ?? "";
    message.customerId = object.customerId ?? "";
    message.canManageClients = object.canManageClients ?? false;
    message.adsPersonalizationEnabled = object.adsPersonalizationEnabled ?? undefined;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.creatorEmailAddress = object.creatorEmailAddress ?? "";
    return message;
  },
};

function createBaseDataSharingSettings(): DataSharingSettings {
  return {
    name: "",
    sharingWithGoogleSupportEnabled: false,
    sharingWithGoogleAssignedSalesEnabled: false,
    sharingWithGoogleAnySalesEnabled: false,
    sharingWithGoogleProductsEnabled: false,
    sharingWithOthersEnabled: false,
  };
}

export const DataSharingSettings: MessageFns<DataSharingSettings> = {
  encode(message: DataSharingSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.sharingWithGoogleSupportEnabled !== false) {
      writer.uint32(16).bool(message.sharingWithGoogleSupportEnabled);
    }
    if (message.sharingWithGoogleAssignedSalesEnabled !== false) {
      writer.uint32(24).bool(message.sharingWithGoogleAssignedSalesEnabled);
    }
    if (message.sharingWithGoogleAnySalesEnabled !== false) {
      writer.uint32(32).bool(message.sharingWithGoogleAnySalesEnabled);
    }
    if (message.sharingWithGoogleProductsEnabled !== false) {
      writer.uint32(40).bool(message.sharingWithGoogleProductsEnabled);
    }
    if (message.sharingWithOthersEnabled !== false) {
      writer.uint32(48).bool(message.sharingWithOthersEnabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataSharingSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataSharingSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.sharingWithGoogleSupportEnabled = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.sharingWithGoogleAssignedSalesEnabled = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.sharingWithGoogleAnySalesEnabled = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.sharingWithGoogleProductsEnabled = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.sharingWithOthersEnabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataSharingSettings {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      sharingWithGoogleSupportEnabled: isSet(object.sharingWithGoogleSupportEnabled)
        ? globalThis.Boolean(object.sharingWithGoogleSupportEnabled)
        : false,
      sharingWithGoogleAssignedSalesEnabled: isSet(object.sharingWithGoogleAssignedSalesEnabled)
        ? globalThis.Boolean(object.sharingWithGoogleAssignedSalesEnabled)
        : false,
      sharingWithGoogleAnySalesEnabled: isSet(object.sharingWithGoogleAnySalesEnabled)
        ? globalThis.Boolean(object.sharingWithGoogleAnySalesEnabled)
        : false,
      sharingWithGoogleProductsEnabled: isSet(object.sharingWithGoogleProductsEnabled)
        ? globalThis.Boolean(object.sharingWithGoogleProductsEnabled)
        : false,
      sharingWithOthersEnabled: isSet(object.sharingWithOthersEnabled)
        ? globalThis.Boolean(object.sharingWithOthersEnabled)
        : false,
    };
  },

  toJSON(message: DataSharingSettings): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.sharingWithGoogleSupportEnabled !== false) {
      obj.sharingWithGoogleSupportEnabled = message.sharingWithGoogleSupportEnabled;
    }
    if (message.sharingWithGoogleAssignedSalesEnabled !== false) {
      obj.sharingWithGoogleAssignedSalesEnabled = message.sharingWithGoogleAssignedSalesEnabled;
    }
    if (message.sharingWithGoogleAnySalesEnabled !== false) {
      obj.sharingWithGoogleAnySalesEnabled = message.sharingWithGoogleAnySalesEnabled;
    }
    if (message.sharingWithGoogleProductsEnabled !== false) {
      obj.sharingWithGoogleProductsEnabled = message.sharingWithGoogleProductsEnabled;
    }
    if (message.sharingWithOthersEnabled !== false) {
      obj.sharingWithOthersEnabled = message.sharingWithOthersEnabled;
    }
    return obj;
  },

  create(base?: DeepPartial<DataSharingSettings>): DataSharingSettings {
    return DataSharingSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataSharingSettings>): DataSharingSettings {
    const message = createBaseDataSharingSettings();
    message.name = object.name ?? "";
    message.sharingWithGoogleSupportEnabled = object.sharingWithGoogleSupportEnabled ?? false;
    message.sharingWithGoogleAssignedSalesEnabled = object.sharingWithGoogleAssignedSalesEnabled ?? false;
    message.sharingWithGoogleAnySalesEnabled = object.sharingWithGoogleAnySalesEnabled ?? false;
    message.sharingWithGoogleProductsEnabled = object.sharingWithGoogleProductsEnabled ?? false;
    message.sharingWithOthersEnabled = object.sharingWithOthersEnabled ?? false;
    return message;
  },
};

function createBaseAccountSummary(): AccountSummary {
  return { name: "", account: "", displayName: "", propertySummaries: [] };
}

export const AccountSummary: MessageFns<AccountSummary> = {
  encode(message: AccountSummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.account !== "") {
      writer.uint32(18).string(message.account);
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    for (const v of message.propertySummaries) {
      PropertySummary.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountSummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.account = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.propertySummaries.push(PropertySummary.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountSummary {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      account: isSet(object.account) ? globalThis.String(object.account) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      propertySummaries: globalThis.Array.isArray(object?.propertySummaries)
        ? object.propertySummaries.map((e: any) => PropertySummary.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AccountSummary): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.account !== "") {
      obj.account = message.account;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.propertySummaries?.length) {
      obj.propertySummaries = message.propertySummaries.map((e) => PropertySummary.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AccountSummary>): AccountSummary {
    return AccountSummary.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccountSummary>): AccountSummary {
    const message = createBaseAccountSummary();
    message.name = object.name ?? "";
    message.account = object.account ?? "";
    message.displayName = object.displayName ?? "";
    message.propertySummaries = object.propertySummaries?.map((e) => PropertySummary.fromPartial(e)) || [];
    return message;
  },
};

function createBasePropertySummary(): PropertySummary {
  return { property: "", displayName: "", propertyType: 0, parent: "" };
}

export const PropertySummary: MessageFns<PropertySummary> = {
  encode(message: PropertySummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.property !== "") {
      writer.uint32(10).string(message.property);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.propertyType !== 0) {
      writer.uint32(24).int32(message.propertyType);
    }
    if (message.parent !== "") {
      writer.uint32(34).string(message.parent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PropertySummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePropertySummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.property = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.propertyType = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.parent = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PropertySummary {
    return {
      property: isSet(object.property) ? globalThis.String(object.property) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      propertyType: isSet(object.propertyType) ? propertyTypeFromJSON(object.propertyType) : 0,
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
    };
  },

  toJSON(message: PropertySummary): unknown {
    const obj: any = {};
    if (message.property !== "") {
      obj.property = message.property;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.propertyType !== 0) {
      obj.propertyType = propertyTypeToJSON(message.propertyType);
    }
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    return obj;
  },

  create(base?: DeepPartial<PropertySummary>): PropertySummary {
    return PropertySummary.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PropertySummary>): PropertySummary {
    const message = createBasePropertySummary();
    message.property = object.property ?? "";
    message.displayName = object.displayName ?? "";
    message.propertyType = object.propertyType ?? 0;
    message.parent = object.parent ?? "";
    return message;
  },
};

function createBaseMeasurementProtocolSecret(): MeasurementProtocolSecret {
  return { name: "", displayName: "", secretValue: "" };
}

export const MeasurementProtocolSecret: MessageFns<MeasurementProtocolSecret> = {
  encode(message: MeasurementProtocolSecret, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.secretValue !== "") {
      writer.uint32(26).string(message.secretValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MeasurementProtocolSecret {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMeasurementProtocolSecret();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.secretValue = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MeasurementProtocolSecret {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      secretValue: isSet(object.secretValue) ? globalThis.String(object.secretValue) : "",
    };
  },

  toJSON(message: MeasurementProtocolSecret): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.secretValue !== "") {
      obj.secretValue = message.secretValue;
    }
    return obj;
  },

  create(base?: DeepPartial<MeasurementProtocolSecret>): MeasurementProtocolSecret {
    return MeasurementProtocolSecret.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MeasurementProtocolSecret>): MeasurementProtocolSecret {
    const message = createBaseMeasurementProtocolSecret();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.secretValue = object.secretValue ?? "";
    return message;
  },
};

function createBaseChangeHistoryEvent(): ChangeHistoryEvent {
  return { id: "", changeTime: undefined, actorType: 0, userActorEmail: "", changesFiltered: false, changes: [] };
}

export const ChangeHistoryEvent: MessageFns<ChangeHistoryEvent> = {
  encode(message: ChangeHistoryEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.changeTime !== undefined) {
      Timestamp.encode(toTimestamp(message.changeTime), writer.uint32(18).fork()).join();
    }
    if (message.actorType !== 0) {
      writer.uint32(24).int32(message.actorType);
    }
    if (message.userActorEmail !== "") {
      writer.uint32(34).string(message.userActorEmail);
    }
    if (message.changesFiltered !== false) {
      writer.uint32(40).bool(message.changesFiltered);
    }
    for (const v of message.changes) {
      ChangeHistoryChange.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangeHistoryEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangeHistoryEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.changeTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.actorType = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.userActorEmail = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.changesFiltered = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.changes.push(ChangeHistoryChange.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangeHistoryEvent {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      changeTime: isSet(object.changeTime) ? fromJsonTimestamp(object.changeTime) : undefined,
      actorType: isSet(object.actorType) ? actorTypeFromJSON(object.actorType) : 0,
      userActorEmail: isSet(object.userActorEmail) ? globalThis.String(object.userActorEmail) : "",
      changesFiltered: isSet(object.changesFiltered) ? globalThis.Boolean(object.changesFiltered) : false,
      changes: globalThis.Array.isArray(object?.changes)
        ? object.changes.map((e: any) => ChangeHistoryChange.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ChangeHistoryEvent): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.changeTime !== undefined) {
      obj.changeTime = message.changeTime.toISOString();
    }
    if (message.actorType !== 0) {
      obj.actorType = actorTypeToJSON(message.actorType);
    }
    if (message.userActorEmail !== "") {
      obj.userActorEmail = message.userActorEmail;
    }
    if (message.changesFiltered !== false) {
      obj.changesFiltered = message.changesFiltered;
    }
    if (message.changes?.length) {
      obj.changes = message.changes.map((e) => ChangeHistoryChange.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ChangeHistoryEvent>): ChangeHistoryEvent {
    return ChangeHistoryEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChangeHistoryEvent>): ChangeHistoryEvent {
    const message = createBaseChangeHistoryEvent();
    message.id = object.id ?? "";
    message.changeTime = object.changeTime ?? undefined;
    message.actorType = object.actorType ?? 0;
    message.userActorEmail = object.userActorEmail ?? "";
    message.changesFiltered = object.changesFiltered ?? false;
    message.changes = object.changes?.map((e) => ChangeHistoryChange.fromPartial(e)) || [];
    return message;
  },
};

function createBaseChangeHistoryChange(): ChangeHistoryChange {
  return { resource: "", action: 0, resourceBeforeChange: undefined, resourceAfterChange: undefined };
}

export const ChangeHistoryChange: MessageFns<ChangeHistoryChange> = {
  encode(message: ChangeHistoryChange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resource !== "") {
      writer.uint32(10).string(message.resource);
    }
    if (message.action !== 0) {
      writer.uint32(16).int32(message.action);
    }
    if (message.resourceBeforeChange !== undefined) {
      ChangeHistoryChange_ChangeHistoryResource.encode(message.resourceBeforeChange, writer.uint32(26).fork()).join();
    }
    if (message.resourceAfterChange !== undefined) {
      ChangeHistoryChange_ChangeHistoryResource.encode(message.resourceAfterChange, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangeHistoryChange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangeHistoryChange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resource = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.resourceBeforeChange = ChangeHistoryChange_ChangeHistoryResource.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.resourceAfterChange = ChangeHistoryChange_ChangeHistoryResource.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangeHistoryChange {
    return {
      resource: isSet(object.resource) ? globalThis.String(object.resource) : "",
      action: isSet(object.action) ? actionTypeFromJSON(object.action) : 0,
      resourceBeforeChange: isSet(object.resourceBeforeChange)
        ? ChangeHistoryChange_ChangeHistoryResource.fromJSON(object.resourceBeforeChange)
        : undefined,
      resourceAfterChange: isSet(object.resourceAfterChange)
        ? ChangeHistoryChange_ChangeHistoryResource.fromJSON(object.resourceAfterChange)
        : undefined,
    };
  },

  toJSON(message: ChangeHistoryChange): unknown {
    const obj: any = {};
    if (message.resource !== "") {
      obj.resource = message.resource;
    }
    if (message.action !== 0) {
      obj.action = actionTypeToJSON(message.action);
    }
    if (message.resourceBeforeChange !== undefined) {
      obj.resourceBeforeChange = ChangeHistoryChange_ChangeHistoryResource.toJSON(message.resourceBeforeChange);
    }
    if (message.resourceAfterChange !== undefined) {
      obj.resourceAfterChange = ChangeHistoryChange_ChangeHistoryResource.toJSON(message.resourceAfterChange);
    }
    return obj;
  },

  create(base?: DeepPartial<ChangeHistoryChange>): ChangeHistoryChange {
    return ChangeHistoryChange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChangeHistoryChange>): ChangeHistoryChange {
    const message = createBaseChangeHistoryChange();
    message.resource = object.resource ?? "";
    message.action = object.action ?? 0;
    message.resourceBeforeChange = (object.resourceBeforeChange !== undefined && object.resourceBeforeChange !== null)
      ? ChangeHistoryChange_ChangeHistoryResource.fromPartial(object.resourceBeforeChange)
      : undefined;
    message.resourceAfterChange = (object.resourceAfterChange !== undefined && object.resourceAfterChange !== null)
      ? ChangeHistoryChange_ChangeHistoryResource.fromPartial(object.resourceAfterChange)
      : undefined;
    return message;
  },
};

function createBaseChangeHistoryChange_ChangeHistoryResource(): ChangeHistoryChange_ChangeHistoryResource {
  return {
    account: undefined,
    property: undefined,
    firebaseLink: undefined,
    googleAdsLink: undefined,
    conversionEvent: undefined,
    measurementProtocolSecret: undefined,
    dataRetentionSettings: undefined,
    dataStream: undefined,
  };
}

export const ChangeHistoryChange_ChangeHistoryResource: MessageFns<ChangeHistoryChange_ChangeHistoryResource> = {
  encode(message: ChangeHistoryChange_ChangeHistoryResource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.account !== undefined) {
      Account.encode(message.account, writer.uint32(10).fork()).join();
    }
    if (message.property !== undefined) {
      Property.encode(message.property, writer.uint32(18).fork()).join();
    }
    if (message.firebaseLink !== undefined) {
      FirebaseLink.encode(message.firebaseLink, writer.uint32(50).fork()).join();
    }
    if (message.googleAdsLink !== undefined) {
      GoogleAdsLink.encode(message.googleAdsLink, writer.uint32(58).fork()).join();
    }
    if (message.conversionEvent !== undefined) {
      ConversionEvent.encode(message.conversionEvent, writer.uint32(90).fork()).join();
    }
    if (message.measurementProtocolSecret !== undefined) {
      MeasurementProtocolSecret.encode(message.measurementProtocolSecret, writer.uint32(98).fork()).join();
    }
    if (message.dataRetentionSettings !== undefined) {
      DataRetentionSettings.encode(message.dataRetentionSettings, writer.uint32(122).fork()).join();
    }
    if (message.dataStream !== undefined) {
      DataStream.encode(message.dataStream, writer.uint32(146).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangeHistoryChange_ChangeHistoryResource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangeHistoryChange_ChangeHistoryResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.account = Account.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.property = Property.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.firebaseLink = FirebaseLink.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.googleAdsLink = GoogleAdsLink.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.conversionEvent = ConversionEvent.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.measurementProtocolSecret = MeasurementProtocolSecret.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.dataRetentionSettings = DataRetentionSettings.decode(reader, reader.uint32());
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.dataStream = DataStream.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangeHistoryChange_ChangeHistoryResource {
    return {
      account: isSet(object.account) ? Account.fromJSON(object.account) : undefined,
      property: isSet(object.property) ? Property.fromJSON(object.property) : undefined,
      firebaseLink: isSet(object.firebaseLink) ? FirebaseLink.fromJSON(object.firebaseLink) : undefined,
      googleAdsLink: isSet(object.googleAdsLink) ? GoogleAdsLink.fromJSON(object.googleAdsLink) : undefined,
      conversionEvent: isSet(object.conversionEvent) ? ConversionEvent.fromJSON(object.conversionEvent) : undefined,
      measurementProtocolSecret: isSet(object.measurementProtocolSecret)
        ? MeasurementProtocolSecret.fromJSON(object.measurementProtocolSecret)
        : undefined,
      dataRetentionSettings: isSet(object.dataRetentionSettings)
        ? DataRetentionSettings.fromJSON(object.dataRetentionSettings)
        : undefined,
      dataStream: isSet(object.dataStream) ? DataStream.fromJSON(object.dataStream) : undefined,
    };
  },

  toJSON(message: ChangeHistoryChange_ChangeHistoryResource): unknown {
    const obj: any = {};
    if (message.account !== undefined) {
      obj.account = Account.toJSON(message.account);
    }
    if (message.property !== undefined) {
      obj.property = Property.toJSON(message.property);
    }
    if (message.firebaseLink !== undefined) {
      obj.firebaseLink = FirebaseLink.toJSON(message.firebaseLink);
    }
    if (message.googleAdsLink !== undefined) {
      obj.googleAdsLink = GoogleAdsLink.toJSON(message.googleAdsLink);
    }
    if (message.conversionEvent !== undefined) {
      obj.conversionEvent = ConversionEvent.toJSON(message.conversionEvent);
    }
    if (message.measurementProtocolSecret !== undefined) {
      obj.measurementProtocolSecret = MeasurementProtocolSecret.toJSON(message.measurementProtocolSecret);
    }
    if (message.dataRetentionSettings !== undefined) {
      obj.dataRetentionSettings = DataRetentionSettings.toJSON(message.dataRetentionSettings);
    }
    if (message.dataStream !== undefined) {
      obj.dataStream = DataStream.toJSON(message.dataStream);
    }
    return obj;
  },

  create(base?: DeepPartial<ChangeHistoryChange_ChangeHistoryResource>): ChangeHistoryChange_ChangeHistoryResource {
    return ChangeHistoryChange_ChangeHistoryResource.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ChangeHistoryChange_ChangeHistoryResource>,
  ): ChangeHistoryChange_ChangeHistoryResource {
    const message = createBaseChangeHistoryChange_ChangeHistoryResource();
    message.account = (object.account !== undefined && object.account !== null)
      ? Account.fromPartial(object.account)
      : undefined;
    message.property = (object.property !== undefined && object.property !== null)
      ? Property.fromPartial(object.property)
      : undefined;
    message.firebaseLink = (object.firebaseLink !== undefined && object.firebaseLink !== null)
      ? FirebaseLink.fromPartial(object.firebaseLink)
      : undefined;
    message.googleAdsLink = (object.googleAdsLink !== undefined && object.googleAdsLink !== null)
      ? GoogleAdsLink.fromPartial(object.googleAdsLink)
      : undefined;
    message.conversionEvent = (object.conversionEvent !== undefined && object.conversionEvent !== null)
      ? ConversionEvent.fromPartial(object.conversionEvent)
      : undefined;
    message.measurementProtocolSecret =
      (object.measurementProtocolSecret !== undefined && object.measurementProtocolSecret !== null)
        ? MeasurementProtocolSecret.fromPartial(object.measurementProtocolSecret)
        : undefined;
    message.dataRetentionSettings =
      (object.dataRetentionSettings !== undefined && object.dataRetentionSettings !== null)
        ? DataRetentionSettings.fromPartial(object.dataRetentionSettings)
        : undefined;
    message.dataStream = (object.dataStream !== undefined && object.dataStream !== null)
      ? DataStream.fromPartial(object.dataStream)
      : undefined;
    return message;
  },
};

function createBaseConversionEvent(): ConversionEvent {
  return {
    name: "",
    eventName: "",
    createTime: undefined,
    deletable: false,
    custom: false,
    countingMethod: 0,
    defaultConversionValue: undefined,
  };
}

export const ConversionEvent: MessageFns<ConversionEvent> = {
  encode(message: ConversionEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.eventName !== "") {
      writer.uint32(18).string(message.eventName);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    if (message.deletable !== false) {
      writer.uint32(32).bool(message.deletable);
    }
    if (message.custom !== false) {
      writer.uint32(40).bool(message.custom);
    }
    if (message.countingMethod !== 0) {
      writer.uint32(48).int32(message.countingMethod);
    }
    if (message.defaultConversionValue !== undefined) {
      ConversionEvent_DefaultConversionValue.encode(message.defaultConversionValue, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConversionEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversionEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.eventName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.deletable = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.custom = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.countingMethod = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.defaultConversionValue = ConversionEvent_DefaultConversionValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConversionEvent {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      eventName: isSet(object.eventName) ? globalThis.String(object.eventName) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      deletable: isSet(object.deletable) ? globalThis.Boolean(object.deletable) : false,
      custom: isSet(object.custom) ? globalThis.Boolean(object.custom) : false,
      countingMethod: isSet(object.countingMethod)
        ? conversionEvent_ConversionCountingMethodFromJSON(object.countingMethod)
        : 0,
      defaultConversionValue: isSet(object.defaultConversionValue)
        ? ConversionEvent_DefaultConversionValue.fromJSON(object.defaultConversionValue)
        : undefined,
    };
  },

  toJSON(message: ConversionEvent): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.eventName !== "") {
      obj.eventName = message.eventName;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.deletable !== false) {
      obj.deletable = message.deletable;
    }
    if (message.custom !== false) {
      obj.custom = message.custom;
    }
    if (message.countingMethod !== 0) {
      obj.countingMethod = conversionEvent_ConversionCountingMethodToJSON(message.countingMethod);
    }
    if (message.defaultConversionValue !== undefined) {
      obj.defaultConversionValue = ConversionEvent_DefaultConversionValue.toJSON(message.defaultConversionValue);
    }
    return obj;
  },

  create(base?: DeepPartial<ConversionEvent>): ConversionEvent {
    return ConversionEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConversionEvent>): ConversionEvent {
    const message = createBaseConversionEvent();
    message.name = object.name ?? "";
    message.eventName = object.eventName ?? "";
    message.createTime = object.createTime ?? undefined;
    message.deletable = object.deletable ?? false;
    message.custom = object.custom ?? false;
    message.countingMethod = object.countingMethod ?? 0;
    message.defaultConversionValue =
      (object.defaultConversionValue !== undefined && object.defaultConversionValue !== null)
        ? ConversionEvent_DefaultConversionValue.fromPartial(object.defaultConversionValue)
        : undefined;
    return message;
  },
};

function createBaseConversionEvent_DefaultConversionValue(): ConversionEvent_DefaultConversionValue {
  return { value: undefined, currencyCode: undefined };
}

export const ConversionEvent_DefaultConversionValue: MessageFns<ConversionEvent_DefaultConversionValue> = {
  encode(message: ConversionEvent_DefaultConversionValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== undefined) {
      writer.uint32(9).double(message.value);
    }
    if (message.currencyCode !== undefined) {
      writer.uint32(18).string(message.currencyCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConversionEvent_DefaultConversionValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversionEvent_DefaultConversionValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.value = reader.double();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.currencyCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConversionEvent_DefaultConversionValue {
    return {
      value: isSet(object.value) ? globalThis.Number(object.value) : undefined,
      currencyCode: isSet(object.currencyCode) ? globalThis.String(object.currencyCode) : undefined,
    };
  },

  toJSON(message: ConversionEvent_DefaultConversionValue): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    if (message.currencyCode !== undefined) {
      obj.currencyCode = message.currencyCode;
    }
    return obj;
  },

  create(base?: DeepPartial<ConversionEvent_DefaultConversionValue>): ConversionEvent_DefaultConversionValue {
    return ConversionEvent_DefaultConversionValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConversionEvent_DefaultConversionValue>): ConversionEvent_DefaultConversionValue {
    const message = createBaseConversionEvent_DefaultConversionValue();
    message.value = object.value ?? undefined;
    message.currencyCode = object.currencyCode ?? undefined;
    return message;
  },
};

function createBaseKeyEvent(): KeyEvent {
  return {
    name: "",
    eventName: "",
    createTime: undefined,
    deletable: false,
    custom: false,
    countingMethod: 0,
    defaultValue: undefined,
  };
}

export const KeyEvent: MessageFns<KeyEvent> = {
  encode(message: KeyEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.eventName !== "") {
      writer.uint32(18).string(message.eventName);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    if (message.deletable !== false) {
      writer.uint32(32).bool(message.deletable);
    }
    if (message.custom !== false) {
      writer.uint32(40).bool(message.custom);
    }
    if (message.countingMethod !== 0) {
      writer.uint32(48).int32(message.countingMethod);
    }
    if (message.defaultValue !== undefined) {
      KeyEvent_DefaultValue.encode(message.defaultValue, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeyEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.eventName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.deletable = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.custom = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.countingMethod = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.defaultValue = KeyEvent_DefaultValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyEvent {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      eventName: isSet(object.eventName) ? globalThis.String(object.eventName) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      deletable: isSet(object.deletable) ? globalThis.Boolean(object.deletable) : false,
      custom: isSet(object.custom) ? globalThis.Boolean(object.custom) : false,
      countingMethod: isSet(object.countingMethod) ? keyEvent_CountingMethodFromJSON(object.countingMethod) : 0,
      defaultValue: isSet(object.defaultValue) ? KeyEvent_DefaultValue.fromJSON(object.defaultValue) : undefined,
    };
  },

  toJSON(message: KeyEvent): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.eventName !== "") {
      obj.eventName = message.eventName;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.deletable !== false) {
      obj.deletable = message.deletable;
    }
    if (message.custom !== false) {
      obj.custom = message.custom;
    }
    if (message.countingMethod !== 0) {
      obj.countingMethod = keyEvent_CountingMethodToJSON(message.countingMethod);
    }
    if (message.defaultValue !== undefined) {
      obj.defaultValue = KeyEvent_DefaultValue.toJSON(message.defaultValue);
    }
    return obj;
  },

  create(base?: DeepPartial<KeyEvent>): KeyEvent {
    return KeyEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KeyEvent>): KeyEvent {
    const message = createBaseKeyEvent();
    message.name = object.name ?? "";
    message.eventName = object.eventName ?? "";
    message.createTime = object.createTime ?? undefined;
    message.deletable = object.deletable ?? false;
    message.custom = object.custom ?? false;
    message.countingMethod = object.countingMethod ?? 0;
    message.defaultValue = (object.defaultValue !== undefined && object.defaultValue !== null)
      ? KeyEvent_DefaultValue.fromPartial(object.defaultValue)
      : undefined;
    return message;
  },
};

function createBaseKeyEvent_DefaultValue(): KeyEvent_DefaultValue {
  return { numericValue: 0, currencyCode: "" };
}

export const KeyEvent_DefaultValue: MessageFns<KeyEvent_DefaultValue> = {
  encode(message: KeyEvent_DefaultValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.numericValue !== 0) {
      writer.uint32(9).double(message.numericValue);
    }
    if (message.currencyCode !== "") {
      writer.uint32(18).string(message.currencyCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeyEvent_DefaultValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyEvent_DefaultValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.numericValue = reader.double();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.currencyCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyEvent_DefaultValue {
    return {
      numericValue: isSet(object.numericValue) ? globalThis.Number(object.numericValue) : 0,
      currencyCode: isSet(object.currencyCode) ? globalThis.String(object.currencyCode) : "",
    };
  },

  toJSON(message: KeyEvent_DefaultValue): unknown {
    const obj: any = {};
    if (message.numericValue !== 0) {
      obj.numericValue = message.numericValue;
    }
    if (message.currencyCode !== "") {
      obj.currencyCode = message.currencyCode;
    }
    return obj;
  },

  create(base?: DeepPartial<KeyEvent_DefaultValue>): KeyEvent_DefaultValue {
    return KeyEvent_DefaultValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KeyEvent_DefaultValue>): KeyEvent_DefaultValue {
    const message = createBaseKeyEvent_DefaultValue();
    message.numericValue = object.numericValue ?? 0;
    message.currencyCode = object.currencyCode ?? "";
    return message;
  },
};

function createBaseCustomDimension(): CustomDimension {
  return { name: "", parameterName: "", displayName: "", description: "", scope: 0, disallowAdsPersonalization: false };
}

export const CustomDimension: MessageFns<CustomDimension> = {
  encode(message: CustomDimension, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.parameterName !== "") {
      writer.uint32(18).string(message.parameterName);
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.scope !== 0) {
      writer.uint32(40).int32(message.scope);
    }
    if (message.disallowAdsPersonalization !== false) {
      writer.uint32(48).bool(message.disallowAdsPersonalization);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomDimension {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomDimension();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parameterName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.scope = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.disallowAdsPersonalization = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomDimension {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      parameterName: isSet(object.parameterName) ? globalThis.String(object.parameterName) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      scope: isSet(object.scope) ? customDimension_DimensionScopeFromJSON(object.scope) : 0,
      disallowAdsPersonalization: isSet(object.disallowAdsPersonalization)
        ? globalThis.Boolean(object.disallowAdsPersonalization)
        : false,
    };
  },

  toJSON(message: CustomDimension): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.parameterName !== "") {
      obj.parameterName = message.parameterName;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.scope !== 0) {
      obj.scope = customDimension_DimensionScopeToJSON(message.scope);
    }
    if (message.disallowAdsPersonalization !== false) {
      obj.disallowAdsPersonalization = message.disallowAdsPersonalization;
    }
    return obj;
  },

  create(base?: DeepPartial<CustomDimension>): CustomDimension {
    return CustomDimension.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CustomDimension>): CustomDimension {
    const message = createBaseCustomDimension();
    message.name = object.name ?? "";
    message.parameterName = object.parameterName ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.scope = object.scope ?? 0;
    message.disallowAdsPersonalization = object.disallowAdsPersonalization ?? false;
    return message;
  },
};

function createBaseCustomMetric(): CustomMetric {
  return {
    name: "",
    parameterName: "",
    displayName: "",
    description: "",
    measurementUnit: 0,
    scope: 0,
    restrictedMetricType: [],
  };
}

export const CustomMetric: MessageFns<CustomMetric> = {
  encode(message: CustomMetric, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.parameterName !== "") {
      writer.uint32(18).string(message.parameterName);
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.measurementUnit !== 0) {
      writer.uint32(40).int32(message.measurementUnit);
    }
    if (message.scope !== 0) {
      writer.uint32(48).int32(message.scope);
    }
    writer.uint32(66).fork();
    for (const v of message.restrictedMetricType) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomMetric {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomMetric();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parameterName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.measurementUnit = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.scope = reader.int32() as any;
          continue;
        case 8:
          if (tag === 64) {
            message.restrictedMetricType.push(reader.int32() as any);

            continue;
          }

          if (tag === 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.restrictedMetricType.push(reader.int32() as any);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomMetric {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      parameterName: isSet(object.parameterName) ? globalThis.String(object.parameterName) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      measurementUnit: isSet(object.measurementUnit) ? customMetric_MeasurementUnitFromJSON(object.measurementUnit) : 0,
      scope: isSet(object.scope) ? customMetric_MetricScopeFromJSON(object.scope) : 0,
      restrictedMetricType: globalThis.Array.isArray(object?.restrictedMetricType)
        ? object.restrictedMetricType.map((e: any) => customMetric_RestrictedMetricTypeFromJSON(e))
        : [],
    };
  },

  toJSON(message: CustomMetric): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.parameterName !== "") {
      obj.parameterName = message.parameterName;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.measurementUnit !== 0) {
      obj.measurementUnit = customMetric_MeasurementUnitToJSON(message.measurementUnit);
    }
    if (message.scope !== 0) {
      obj.scope = customMetric_MetricScopeToJSON(message.scope);
    }
    if (message.restrictedMetricType?.length) {
      obj.restrictedMetricType = message.restrictedMetricType.map((e) => customMetric_RestrictedMetricTypeToJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CustomMetric>): CustomMetric {
    return CustomMetric.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CustomMetric>): CustomMetric {
    const message = createBaseCustomMetric();
    message.name = object.name ?? "";
    message.parameterName = object.parameterName ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.measurementUnit = object.measurementUnit ?? 0;
    message.scope = object.scope ?? 0;
    message.restrictedMetricType = object.restrictedMetricType?.map((e) => e) || [];
    return message;
  },
};

function createBaseDataRetentionSettings(): DataRetentionSettings {
  return { name: "", eventDataRetention: 0, resetUserDataOnNewActivity: false };
}

export const DataRetentionSettings: MessageFns<DataRetentionSettings> = {
  encode(message: DataRetentionSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.eventDataRetention !== 0) {
      writer.uint32(16).int32(message.eventDataRetention);
    }
    if (message.resetUserDataOnNewActivity !== false) {
      writer.uint32(24).bool(message.resetUserDataOnNewActivity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataRetentionSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataRetentionSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.eventDataRetention = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.resetUserDataOnNewActivity = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataRetentionSettings {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      eventDataRetention: isSet(object.eventDataRetention)
        ? dataRetentionSettings_RetentionDurationFromJSON(object.eventDataRetention)
        : 0,
      resetUserDataOnNewActivity: isSet(object.resetUserDataOnNewActivity)
        ? globalThis.Boolean(object.resetUserDataOnNewActivity)
        : false,
    };
  },

  toJSON(message: DataRetentionSettings): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.eventDataRetention !== 0) {
      obj.eventDataRetention = dataRetentionSettings_RetentionDurationToJSON(message.eventDataRetention);
    }
    if (message.resetUserDataOnNewActivity !== false) {
      obj.resetUserDataOnNewActivity = message.resetUserDataOnNewActivity;
    }
    return obj;
  },

  create(base?: DeepPartial<DataRetentionSettings>): DataRetentionSettings {
    return DataRetentionSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataRetentionSettings>): DataRetentionSettings {
    const message = createBaseDataRetentionSettings();
    message.name = object.name ?? "";
    message.eventDataRetention = object.eventDataRetention ?? 0;
    message.resetUserDataOnNewActivity = object.resetUserDataOnNewActivity ?? false;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
