// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/actions/sdk/v2/interactionmodel/intent.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { ClassReference } from "./type/class_reference.js";

export const protobufPackage = "google.actions.sdk.v2.interactionmodel";

/**
 * Intents map open-ended user input to structured objects. Spoken
 * phrases are matched to intents with Google's Natural Language Understanding
 * (NLU). Intent matches can trigger events in your conversation design to
 * progress the user's conversation.
 * The intent name is specified in the name of the file.
 */
export interface Intent {
  /**
   * The list of parameters within the training phrases. All parameters must be
   * defined here to be used in the training phrase.
   */
  parameters: Intent_IntentParameter[];
  /**
   * Training phrases allow Googleâ€™s NLU to automatically match intents with
   * user input. The more unique phrases that are provided, the better chance
   * this intent will be matched.
   * The following is the format of training phrase part which are annotated.
   * Note that `auto` field is optional and the default behavior when `auto` is
   * not specified is equivalent to `auto=false`.
   * `($<paramName> '<sample text>' auto=<true or false>)`
   * `auto = true` means the part was auto annotated by NLU.
   * `auto = false` means the part was annotated by the user. This is the
   *     default when auto is not specified.
   * Example:
   * "Book a flight from ($source 'San Francisco' auto=false) to ($dest
   * 'Vancouver')"
   */
  trainingPhrases: string[];
}

/** Definition of a parameter which can be used inside training phrases. */
export interface Intent_IntentParameter {
  /**
   * Required. Unique name of the intent parameter. Can be used in conditions and
   * responses to reference intent parameters extracted by NLU with
   * $intent.params.[name].resolved
   */
  name: string;
  /**
   * Optional. Declares the data type of this parameter.
   * This should not be set for built-in intents.
   */
  type?:
    | ClassReference
    | undefined;
  /**
   * Optional. References to the sets of allowed entities for this intent parameter.
   * Only valid for parameters of a built-in intent. These
   * references point to entity sets in the 'custom/entitySets' directory.
   */
  entitySetReferences?: Intent_IntentParameter_EntitySetReferences | undefined;
}

/** Entity set references for an intent parameter. */
export interface Intent_IntentParameter_EntitySetReferences {
  /** Required. Entity set references for an intent parameter. */
  entitySetReferences: Intent_IntentParameter_EntitySetReferences_EntitySetReference[];
}

/** A reference to the set of allowed entities for this intent parameter. */
export interface Intent_IntentParameter_EntitySetReferences_EntitySetReference {
  /**
   * Required. Identifies the specific collection of entities to be considered for a
   * given parameter. The corresponding entity set definition should be
   * present in the custom/entitySets/ directory.
   */
  entitySet: string;
}

function createBaseIntent(): Intent {
  return { parameters: [], trainingPhrases: [] };
}

export const Intent: MessageFns<Intent> = {
  encode(message: Intent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.parameters) {
      Intent_IntentParameter.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.trainingPhrases) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Intent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parameters.push(Intent_IntentParameter.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.trainingPhrases.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Intent {
    return {
      parameters: globalThis.Array.isArray(object?.parameters)
        ? object.parameters.map((e: any) => Intent_IntentParameter.fromJSON(e))
        : [],
      trainingPhrases: globalThis.Array.isArray(object?.trainingPhrases)
        ? object.trainingPhrases.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Intent): unknown {
    const obj: any = {};
    if (message.parameters?.length) {
      obj.parameters = message.parameters.map((e) => Intent_IntentParameter.toJSON(e));
    }
    if (message.trainingPhrases?.length) {
      obj.trainingPhrases = message.trainingPhrases;
    }
    return obj;
  },

  create(base?: DeepPartial<Intent>): Intent {
    return Intent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Intent>): Intent {
    const message = createBaseIntent();
    message.parameters = object.parameters?.map((e) => Intent_IntentParameter.fromPartial(e)) || [];
    message.trainingPhrases = object.trainingPhrases?.map((e) => e) || [];
    return message;
  },
};

function createBaseIntent_IntentParameter(): Intent_IntentParameter {
  return { name: "", type: undefined, entitySetReferences: undefined };
}

export const Intent_IntentParameter: MessageFns<Intent_IntentParameter> = {
  encode(message: Intent_IntentParameter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== undefined) {
      ClassReference.encode(message.type, writer.uint32(18).fork()).join();
    }
    if (message.entitySetReferences !== undefined) {
      Intent_IntentParameter_EntitySetReferences.encode(message.entitySetReferences, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Intent_IntentParameter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntent_IntentParameter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = ClassReference.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.entitySetReferences = Intent_IntentParameter_EntitySetReferences.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Intent_IntentParameter {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? ClassReference.fromJSON(object.type) : undefined,
      entitySetReferences: isSet(object.entitySetReferences)
        ? Intent_IntentParameter_EntitySetReferences.fromJSON(object.entitySetReferences)
        : undefined,
    };
  },

  toJSON(message: Intent_IntentParameter): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== undefined) {
      obj.type = ClassReference.toJSON(message.type);
    }
    if (message.entitySetReferences !== undefined) {
      obj.entitySetReferences = Intent_IntentParameter_EntitySetReferences.toJSON(message.entitySetReferences);
    }
    return obj;
  },

  create(base?: DeepPartial<Intent_IntentParameter>): Intent_IntentParameter {
    return Intent_IntentParameter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Intent_IntentParameter>): Intent_IntentParameter {
    const message = createBaseIntent_IntentParameter();
    message.name = object.name ?? "";
    message.type = (object.type !== undefined && object.type !== null)
      ? ClassReference.fromPartial(object.type)
      : undefined;
    message.entitySetReferences = (object.entitySetReferences !== undefined && object.entitySetReferences !== null)
      ? Intent_IntentParameter_EntitySetReferences.fromPartial(object.entitySetReferences)
      : undefined;
    return message;
  },
};

function createBaseIntent_IntentParameter_EntitySetReferences(): Intent_IntentParameter_EntitySetReferences {
  return { entitySetReferences: [] };
}

export const Intent_IntentParameter_EntitySetReferences: MessageFns<Intent_IntentParameter_EntitySetReferences> = {
  encode(message: Intent_IntentParameter_EntitySetReferences, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entitySetReferences) {
      Intent_IntentParameter_EntitySetReferences_EntitySetReference.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Intent_IntentParameter_EntitySetReferences {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntent_IntentParameter_EntitySetReferences();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entitySetReferences.push(
            Intent_IntentParameter_EntitySetReferences_EntitySetReference.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Intent_IntentParameter_EntitySetReferences {
    return {
      entitySetReferences: globalThis.Array.isArray(object?.entitySetReferences)
        ? object.entitySetReferences.map((e: any) =>
          Intent_IntentParameter_EntitySetReferences_EntitySetReference.fromJSON(e)
        )
        : [],
    };
  },

  toJSON(message: Intent_IntentParameter_EntitySetReferences): unknown {
    const obj: any = {};
    if (message.entitySetReferences?.length) {
      obj.entitySetReferences = message.entitySetReferences.map((e) =>
        Intent_IntentParameter_EntitySetReferences_EntitySetReference.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<Intent_IntentParameter_EntitySetReferences>): Intent_IntentParameter_EntitySetReferences {
    return Intent_IntentParameter_EntitySetReferences.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<Intent_IntentParameter_EntitySetReferences>,
  ): Intent_IntentParameter_EntitySetReferences {
    const message = createBaseIntent_IntentParameter_EntitySetReferences();
    message.entitySetReferences =
      object.entitySetReferences?.map((e) =>
        Intent_IntentParameter_EntitySetReferences_EntitySetReference.fromPartial(e)
      ) || [];
    return message;
  },
};

function createBaseIntent_IntentParameter_EntitySetReferences_EntitySetReference(): Intent_IntentParameter_EntitySetReferences_EntitySetReference {
  return { entitySet: "" };
}

export const Intent_IntentParameter_EntitySetReferences_EntitySetReference: MessageFns<
  Intent_IntentParameter_EntitySetReferences_EntitySetReference
> = {
  encode(
    message: Intent_IntentParameter_EntitySetReferences_EntitySetReference,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.entitySet !== "") {
      writer.uint32(10).string(message.entitySet);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): Intent_IntentParameter_EntitySetReferences_EntitySetReference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntent_IntentParameter_EntitySetReferences_EntitySetReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entitySet = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Intent_IntentParameter_EntitySetReferences_EntitySetReference {
    return { entitySet: isSet(object.entitySet) ? globalThis.String(object.entitySet) : "" };
  },

  toJSON(message: Intent_IntentParameter_EntitySetReferences_EntitySetReference): unknown {
    const obj: any = {};
    if (message.entitySet !== "") {
      obj.entitySet = message.entitySet;
    }
    return obj;
  },

  create(
    base?: DeepPartial<Intent_IntentParameter_EntitySetReferences_EntitySetReference>,
  ): Intent_IntentParameter_EntitySetReferences_EntitySetReference {
    return Intent_IntentParameter_EntitySetReferences_EntitySetReference.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<Intent_IntentParameter_EntitySetReferences_EntitySetReference>,
  ): Intent_IntentParameter_EntitySetReferences_EntitySetReference {
    const message = createBaseIntent_IntentParameter_EntitySetReferences_EntitySetReference();
    message.entitySet = object.entitySet ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
