// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/actions/sdk/v2/interactionmodel/slot.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Value } from "../../../../protobuf/struct.js";
import { EventHandler } from "./event_handler.js";
import { ClassReference } from "./type/class_reference.js";

export const protobufPackage = "google.actions.sdk.v2.interactionmodel";

/**
 * Configuration for a slot. Slots are single units of data that can be filled
 * through natural language (ie. intent parameters), session parameters, and
 * other sources.
 */
export interface Slot {
  /** Required. Name of the slot. */
  name: string;
  /** Required. Declares the data type of this slot. */
  type:
    | ClassReference
    | undefined;
  /**
   * Optional. Indicates whether the slot is required to be filled before
   * advancing. Required slots that are not filled will trigger a customizable
   * prompt to the user.
   */
  required: boolean;
  /** Optional. Registers Prompts for different stages of slot filling. */
  promptSettings:
    | Slot_PromptSettings
    | undefined;
  /** Optional. Commit behavior associated with the slot. */
  commitBehavior:
    | Slot_CommitBehavior
    | undefined;
  /**
   * Optional. Additional configuration associated with the slot which is
   * used for filling the slot. The format of the config is specific to the
   * type of the slot. Resource references to user or session parameter can be
   * added to this config. This config is needed for filling slots related to
   * transactions and user engagement.
   *
   * Example:
   *  For a slot of type actions.type.CompletePurchaseValue, the following
   *  config proposes a digital good order with a reference to a client defined
   *  session parameter `userSelectedSkuId`:
   *
   *    {
   *      "@type": "type.googleapis.com/
   *                  google.actions.transactions.v3.CompletePurchaseValueSpec",
   *      "skuId": {
   *        "skuType": "SKU_TYPE_IN_APP",
   *        "id": "$session.params.userSelectedSkuId",
   *        "packageName": "com.example.company"
   *      }
   *    }
   */
  config:
    | any
    | undefined;
  /** Optional. Configuration to populate a default value for this slot. */
  defaultValue: Slot_DefaultValue | undefined;
}

/** A single place where slot prompts are defined. */
export interface Slot_PromptSettings {
  /** Prompt for the slot value itself. Example: "What size did you want?" */
  initialPrompt:
    | EventHandler
    | undefined;
  /**
   * Prompt to give when the user's input does not match the expected
   * value type for the slot for the first time. Example: "Sorry, I
   * didn't get that."
   */
  noMatchPrompt1:
    | EventHandler
    | undefined;
  /**
   * Prompt to give when the user's input does not match the expected
   * value type for the slot for the second time. Example: "Sorry, I
   * didn't get that."
   */
  noMatchPrompt2:
    | EventHandler
    | undefined;
  /**
   * Prompt to give when the user's input does not match the expected
   * value type for the slot for the last time. Example: "Sorry, I
   * didn't get that."
   */
  noMatchFinalPrompt:
    | EventHandler
    | undefined;
  /**
   * Prompt to give when the user does not provide an input for the first
   * time. Example: "Sorry, I didn't get that."
   */
  noInputPrompt1:
    | EventHandler
    | undefined;
  /**
   * Prompt to give when the user does not provide an input for the second
   * time. Example: "Sorry, I didn't get that."
   */
  noInputPrompt2:
    | EventHandler
    | undefined;
  /**
   * Prompt to give when the user does not provide an input for the last
   * time. Example: "Sorry, I didn't get that."
   */
  noInputFinalPrompt: EventHandler | undefined;
}

/**
 * Message describing the commit behavior associated with the slot after it
 * has been successfully filled.
 */
export interface Slot_CommitBehavior {
  /**
   * The session parameter to write the slot value after it is filled. Note
   * that nested paths are not currently supported. "$$" is used to write the
   * slot value to a session parameter with same name as the slot.
   * Eg: write_session_param = "fruit" corresponds to "$session.params.fruit".
   * write_session_param = "ticket" corresponds to "$session.params.ticket".
   */
  writeSessionParam: string;
}

/** Configuration to populate a default value for this slot. */
export interface Slot_DefaultValue {
  /**
   * Optional. The session parameter to be used to initialize the slot value, if it has
   * a non-empty value. The type of the value must match the type of the slot.
   * Note that nested paths are not currently supported.
   * Eg: `session_param = "fruit"` corresponds to `$session.params.fruit`.
   * `session_param = "ticket"` corresponds to `$session.params.ticket`.
   */
  sessionParam: string;
  /**
   * Optional. Constant default value for the slot. This will only be used if a value
   * for this slot was not populated through the `session_param`. The
   * type for this value must match the type of the slot.
   */
  constant: any | undefined;
}

function createBaseSlot(): Slot {
  return {
    name: "",
    type: undefined,
    required: false,
    promptSettings: undefined,
    commitBehavior: undefined,
    config: undefined,
    defaultValue: undefined,
  };
}

export const Slot: MessageFns<Slot> = {
  encode(message: Slot, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== undefined) {
      ClassReference.encode(message.type, writer.uint32(18).fork()).join();
    }
    if (message.required !== false) {
      writer.uint32(24).bool(message.required);
    }
    if (message.promptSettings !== undefined) {
      Slot_PromptSettings.encode(message.promptSettings, writer.uint32(34).fork()).join();
    }
    if (message.commitBehavior !== undefined) {
      Slot_CommitBehavior.encode(message.commitBehavior, writer.uint32(42).fork()).join();
    }
    if (message.config !== undefined) {
      Value.encode(Value.wrap(message.config), writer.uint32(50).fork()).join();
    }
    if (message.defaultValue !== undefined) {
      Slot_DefaultValue.encode(message.defaultValue, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Slot {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSlot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = ClassReference.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.required = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.promptSettings = Slot_PromptSettings.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.commitBehavior = Slot_CommitBehavior.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.config = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.defaultValue = Slot_DefaultValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Slot {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? ClassReference.fromJSON(object.type) : undefined,
      required: isSet(object.required) ? globalThis.Boolean(object.required) : false,
      promptSettings: isSet(object.promptSettings) ? Slot_PromptSettings.fromJSON(object.promptSettings) : undefined,
      commitBehavior: isSet(object.commitBehavior) ? Slot_CommitBehavior.fromJSON(object.commitBehavior) : undefined,
      config: isSet(object?.config) ? object.config : undefined,
      defaultValue: isSet(object.defaultValue) ? Slot_DefaultValue.fromJSON(object.defaultValue) : undefined,
    };
  },

  toJSON(message: Slot): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== undefined) {
      obj.type = ClassReference.toJSON(message.type);
    }
    if (message.required !== false) {
      obj.required = message.required;
    }
    if (message.promptSettings !== undefined) {
      obj.promptSettings = Slot_PromptSettings.toJSON(message.promptSettings);
    }
    if (message.commitBehavior !== undefined) {
      obj.commitBehavior = Slot_CommitBehavior.toJSON(message.commitBehavior);
    }
    if (message.config !== undefined) {
      obj.config = message.config;
    }
    if (message.defaultValue !== undefined) {
      obj.defaultValue = Slot_DefaultValue.toJSON(message.defaultValue);
    }
    return obj;
  },

  create(base?: DeepPartial<Slot>): Slot {
    return Slot.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Slot>): Slot {
    const message = createBaseSlot();
    message.name = object.name ?? "";
    message.type = (object.type !== undefined && object.type !== null)
      ? ClassReference.fromPartial(object.type)
      : undefined;
    message.required = object.required ?? false;
    message.promptSettings = (object.promptSettings !== undefined && object.promptSettings !== null)
      ? Slot_PromptSettings.fromPartial(object.promptSettings)
      : undefined;
    message.commitBehavior = (object.commitBehavior !== undefined && object.commitBehavior !== null)
      ? Slot_CommitBehavior.fromPartial(object.commitBehavior)
      : undefined;
    message.config = object.config ?? undefined;
    message.defaultValue = (object.defaultValue !== undefined && object.defaultValue !== null)
      ? Slot_DefaultValue.fromPartial(object.defaultValue)
      : undefined;
    return message;
  },
};

function createBaseSlot_PromptSettings(): Slot_PromptSettings {
  return {
    initialPrompt: undefined,
    noMatchPrompt1: undefined,
    noMatchPrompt2: undefined,
    noMatchFinalPrompt: undefined,
    noInputPrompt1: undefined,
    noInputPrompt2: undefined,
    noInputFinalPrompt: undefined,
  };
}

export const Slot_PromptSettings: MessageFns<Slot_PromptSettings> = {
  encode(message: Slot_PromptSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.initialPrompt !== undefined) {
      EventHandler.encode(message.initialPrompt, writer.uint32(10).fork()).join();
    }
    if (message.noMatchPrompt1 !== undefined) {
      EventHandler.encode(message.noMatchPrompt1, writer.uint32(18).fork()).join();
    }
    if (message.noMatchPrompt2 !== undefined) {
      EventHandler.encode(message.noMatchPrompt2, writer.uint32(26).fork()).join();
    }
    if (message.noMatchFinalPrompt !== undefined) {
      EventHandler.encode(message.noMatchFinalPrompt, writer.uint32(34).fork()).join();
    }
    if (message.noInputPrompt1 !== undefined) {
      EventHandler.encode(message.noInputPrompt1, writer.uint32(42).fork()).join();
    }
    if (message.noInputPrompt2 !== undefined) {
      EventHandler.encode(message.noInputPrompt2, writer.uint32(50).fork()).join();
    }
    if (message.noInputFinalPrompt !== undefined) {
      EventHandler.encode(message.noInputFinalPrompt, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Slot_PromptSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSlot_PromptSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.initialPrompt = EventHandler.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.noMatchPrompt1 = EventHandler.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.noMatchPrompt2 = EventHandler.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.noMatchFinalPrompt = EventHandler.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.noInputPrompt1 = EventHandler.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.noInputPrompt2 = EventHandler.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.noInputFinalPrompt = EventHandler.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Slot_PromptSettings {
    return {
      initialPrompt: isSet(object.initialPrompt) ? EventHandler.fromJSON(object.initialPrompt) : undefined,
      noMatchPrompt1: isSet(object.noMatchPrompt1) ? EventHandler.fromJSON(object.noMatchPrompt1) : undefined,
      noMatchPrompt2: isSet(object.noMatchPrompt2) ? EventHandler.fromJSON(object.noMatchPrompt2) : undefined,
      noMatchFinalPrompt: isSet(object.noMatchFinalPrompt)
        ? EventHandler.fromJSON(object.noMatchFinalPrompt)
        : undefined,
      noInputPrompt1: isSet(object.noInputPrompt1) ? EventHandler.fromJSON(object.noInputPrompt1) : undefined,
      noInputPrompt2: isSet(object.noInputPrompt2) ? EventHandler.fromJSON(object.noInputPrompt2) : undefined,
      noInputFinalPrompt: isSet(object.noInputFinalPrompt)
        ? EventHandler.fromJSON(object.noInputFinalPrompt)
        : undefined,
    };
  },

  toJSON(message: Slot_PromptSettings): unknown {
    const obj: any = {};
    if (message.initialPrompt !== undefined) {
      obj.initialPrompt = EventHandler.toJSON(message.initialPrompt);
    }
    if (message.noMatchPrompt1 !== undefined) {
      obj.noMatchPrompt1 = EventHandler.toJSON(message.noMatchPrompt1);
    }
    if (message.noMatchPrompt2 !== undefined) {
      obj.noMatchPrompt2 = EventHandler.toJSON(message.noMatchPrompt2);
    }
    if (message.noMatchFinalPrompt !== undefined) {
      obj.noMatchFinalPrompt = EventHandler.toJSON(message.noMatchFinalPrompt);
    }
    if (message.noInputPrompt1 !== undefined) {
      obj.noInputPrompt1 = EventHandler.toJSON(message.noInputPrompt1);
    }
    if (message.noInputPrompt2 !== undefined) {
      obj.noInputPrompt2 = EventHandler.toJSON(message.noInputPrompt2);
    }
    if (message.noInputFinalPrompt !== undefined) {
      obj.noInputFinalPrompt = EventHandler.toJSON(message.noInputFinalPrompt);
    }
    return obj;
  },

  create(base?: DeepPartial<Slot_PromptSettings>): Slot_PromptSettings {
    return Slot_PromptSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Slot_PromptSettings>): Slot_PromptSettings {
    const message = createBaseSlot_PromptSettings();
    message.initialPrompt = (object.initialPrompt !== undefined && object.initialPrompt !== null)
      ? EventHandler.fromPartial(object.initialPrompt)
      : undefined;
    message.noMatchPrompt1 = (object.noMatchPrompt1 !== undefined && object.noMatchPrompt1 !== null)
      ? EventHandler.fromPartial(object.noMatchPrompt1)
      : undefined;
    message.noMatchPrompt2 = (object.noMatchPrompt2 !== undefined && object.noMatchPrompt2 !== null)
      ? EventHandler.fromPartial(object.noMatchPrompt2)
      : undefined;
    message.noMatchFinalPrompt = (object.noMatchFinalPrompt !== undefined && object.noMatchFinalPrompt !== null)
      ? EventHandler.fromPartial(object.noMatchFinalPrompt)
      : undefined;
    message.noInputPrompt1 = (object.noInputPrompt1 !== undefined && object.noInputPrompt1 !== null)
      ? EventHandler.fromPartial(object.noInputPrompt1)
      : undefined;
    message.noInputPrompt2 = (object.noInputPrompt2 !== undefined && object.noInputPrompt2 !== null)
      ? EventHandler.fromPartial(object.noInputPrompt2)
      : undefined;
    message.noInputFinalPrompt = (object.noInputFinalPrompt !== undefined && object.noInputFinalPrompt !== null)
      ? EventHandler.fromPartial(object.noInputFinalPrompt)
      : undefined;
    return message;
  },
};

function createBaseSlot_CommitBehavior(): Slot_CommitBehavior {
  return { writeSessionParam: "" };
}

export const Slot_CommitBehavior: MessageFns<Slot_CommitBehavior> = {
  encode(message: Slot_CommitBehavior, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.writeSessionParam !== "") {
      writer.uint32(10).string(message.writeSessionParam);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Slot_CommitBehavior {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSlot_CommitBehavior();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.writeSessionParam = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Slot_CommitBehavior {
    return { writeSessionParam: isSet(object.writeSessionParam) ? globalThis.String(object.writeSessionParam) : "" };
  },

  toJSON(message: Slot_CommitBehavior): unknown {
    const obj: any = {};
    if (message.writeSessionParam !== "") {
      obj.writeSessionParam = message.writeSessionParam;
    }
    return obj;
  },

  create(base?: DeepPartial<Slot_CommitBehavior>): Slot_CommitBehavior {
    return Slot_CommitBehavior.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Slot_CommitBehavior>): Slot_CommitBehavior {
    const message = createBaseSlot_CommitBehavior();
    message.writeSessionParam = object.writeSessionParam ?? "";
    return message;
  },
};

function createBaseSlot_DefaultValue(): Slot_DefaultValue {
  return { sessionParam: "", constant: undefined };
}

export const Slot_DefaultValue: MessageFns<Slot_DefaultValue> = {
  encode(message: Slot_DefaultValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionParam !== "") {
      writer.uint32(10).string(message.sessionParam);
    }
    if (message.constant !== undefined) {
      Value.encode(Value.wrap(message.constant), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Slot_DefaultValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSlot_DefaultValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sessionParam = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.constant = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Slot_DefaultValue {
    return {
      sessionParam: isSet(object.sessionParam) ? globalThis.String(object.sessionParam) : "",
      constant: isSet(object?.constant) ? object.constant : undefined,
    };
  },

  toJSON(message: Slot_DefaultValue): unknown {
    const obj: any = {};
    if (message.sessionParam !== "") {
      obj.sessionParam = message.sessionParam;
    }
    if (message.constant !== undefined) {
      obj.constant = message.constant;
    }
    return obj;
  },

  create(base?: DeepPartial<Slot_DefaultValue>): Slot_DefaultValue {
    return Slot_DefaultValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Slot_DefaultValue>): Slot_DefaultValue {
    const message = createBaseSlot_DefaultValue();
    message.sessionParam = object.sessionParam ?? "";
    message.constant = object.constant ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
