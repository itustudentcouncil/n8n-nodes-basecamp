// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/api/cloudquotas/v1/resources.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Int64Value } from "../../../protobuf/wrappers.js";

export const protobufPackage = "google.api.cloudquotas.v1";

/** Enumerations of quota safety checks. */
export enum QuotaSafetyCheck {
  /** QUOTA_SAFETY_CHECK_UNSPECIFIED - Unspecified quota safety check. */
  QUOTA_SAFETY_CHECK_UNSPECIFIED = 0,
  /**
   * QUOTA_DECREASE_BELOW_USAGE - Validates that a quota mutation would not cause the consumer's effective
   * limit to be lower than the consumer's quota usage.
   */
  QUOTA_DECREASE_BELOW_USAGE = 1,
  /**
   * QUOTA_DECREASE_PERCENTAGE_TOO_HIGH - Validates that a quota mutation would not cause the consumer's effective
   * limit to decrease by more than 10 percent.
   */
  QUOTA_DECREASE_PERCENTAGE_TOO_HIGH = 2,
  UNRECOGNIZED = -1,
}

export function quotaSafetyCheckFromJSON(object: any): QuotaSafetyCheck {
  switch (object) {
    case 0:
    case "QUOTA_SAFETY_CHECK_UNSPECIFIED":
      return QuotaSafetyCheck.QUOTA_SAFETY_CHECK_UNSPECIFIED;
    case 1:
    case "QUOTA_DECREASE_BELOW_USAGE":
      return QuotaSafetyCheck.QUOTA_DECREASE_BELOW_USAGE;
    case 2:
    case "QUOTA_DECREASE_PERCENTAGE_TOO_HIGH":
      return QuotaSafetyCheck.QUOTA_DECREASE_PERCENTAGE_TOO_HIGH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return QuotaSafetyCheck.UNRECOGNIZED;
  }
}

export function quotaSafetyCheckToJSON(object: QuotaSafetyCheck): string {
  switch (object) {
    case QuotaSafetyCheck.QUOTA_SAFETY_CHECK_UNSPECIFIED:
      return "QUOTA_SAFETY_CHECK_UNSPECIFIED";
    case QuotaSafetyCheck.QUOTA_DECREASE_BELOW_USAGE:
      return "QUOTA_DECREASE_BELOW_USAGE";
    case QuotaSafetyCheck.QUOTA_DECREASE_PERCENTAGE_TOO_HIGH:
      return "QUOTA_DECREASE_PERCENTAGE_TOO_HIGH";
    case QuotaSafetyCheck.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * QuotaInfo represents information about a particular quota for a given
 * project, folder or organization.
 */
export interface QuotaInfo {
  /**
   * Resource name of this QuotaInfo.
   * The ID component following "locations/" must be "global".
   * Example:
   * `projects/123/locations/global/services/compute.googleapis.com/quotaInfos/CpusPerProjectPerRegion`
   */
  name: string;
  /**
   * The id of the quota, which is unquie within the service.
   * Example: `CpusPerProjectPerRegion`
   */
  quotaId: string;
  /**
   * The metric of the quota. It specifies the resources consumption the quota
   * is defined for.
   * Example: `compute.googleapis.com/cpus`
   */
  metric: string;
  /**
   * The name of the service in which the quota is defined.
   * Example: `compute.googleapis.com`
   */
  service: string;
  /**
   * Whether this is a precise quota. A precise quota is tracked with absolute
   * precision. In contrast, an imprecise quota is not tracked with precision.
   */
  isPrecise: boolean;
  /**
   * The reset time interval for the quota. Refresh interval applies to rate
   * quota only.
   * Example: "minute" for per minute, "day" for per day, or "10 seconds" for
   * every 10 seconds.
   */
  refreshInterval: string;
  /** The container type of the QuotaInfo. */
  containerType: QuotaInfo_ContainerType;
  /** The dimensions the quota is defined on. */
  dimensions: string[];
  /** The display name of the quota metric */
  metricDisplayName: string;
  /** The display name of the quota. */
  quotaDisplayName: string;
  /** The unit in which the metric value is reported, e.g., "MByte". */
  metricUnit: string;
  /** Whether it is eligible to request a higher quota value for this quota. */
  quotaIncreaseEligibility:
    | QuotaIncreaseEligibility
    | undefined;
  /** Whether the quota value is fixed or adjustable */
  isFixed: boolean;
  /**
   * The collection of dimensions info ordered by their dimensions from more
   * specific ones to less specific ones.
   */
  dimensionsInfos: DimensionsInfo[];
  /**
   * Whether the quota is a concurrent quota. Concurrent quotas are enforced
   * on the total number of concurrent operations in flight at any given time.
   */
  isConcurrent: boolean;
  /**
   * URI to the page where users can request more quota for the cloud
   * serviceâ€”for example,
   * https://console.cloud.google.com/iam-admin/quotas.
   */
  serviceRequestQuotaUri: string;
}

/** The enumeration of the types of a cloud resource container. */
export enum QuotaInfo_ContainerType {
  /** CONTAINER_TYPE_UNSPECIFIED - Unspecified container type. */
  CONTAINER_TYPE_UNSPECIFIED = 0,
  /** PROJECT - consumer project */
  PROJECT = 1,
  /** FOLDER - folder */
  FOLDER = 2,
  /** ORGANIZATION - organization */
  ORGANIZATION = 3,
  UNRECOGNIZED = -1,
}

export function quotaInfo_ContainerTypeFromJSON(object: any): QuotaInfo_ContainerType {
  switch (object) {
    case 0:
    case "CONTAINER_TYPE_UNSPECIFIED":
      return QuotaInfo_ContainerType.CONTAINER_TYPE_UNSPECIFIED;
    case 1:
    case "PROJECT":
      return QuotaInfo_ContainerType.PROJECT;
    case 2:
    case "FOLDER":
      return QuotaInfo_ContainerType.FOLDER;
    case 3:
    case "ORGANIZATION":
      return QuotaInfo_ContainerType.ORGANIZATION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return QuotaInfo_ContainerType.UNRECOGNIZED;
  }
}

export function quotaInfo_ContainerTypeToJSON(object: QuotaInfo_ContainerType): string {
  switch (object) {
    case QuotaInfo_ContainerType.CONTAINER_TYPE_UNSPECIFIED:
      return "CONTAINER_TYPE_UNSPECIFIED";
    case QuotaInfo_ContainerType.PROJECT:
      return "PROJECT";
    case QuotaInfo_ContainerType.FOLDER:
      return "FOLDER";
    case QuotaInfo_ContainerType.ORGANIZATION:
      return "ORGANIZATION";
    case QuotaInfo_ContainerType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Eligibility information regarding requesting increase adjustment of a quota. */
export interface QuotaIncreaseEligibility {
  /** Whether a higher quota value can be requested for the quota. */
  isEligible: boolean;
  /**
   * The reason of why it is ineligible to request increased value of the quota.
   * If the is_eligible field is true, it defaults to
   * INELIGIBILITY_REASON_UNSPECIFIED.
   */
  ineligibilityReason: QuotaIncreaseEligibility_IneligibilityReason;
}

/**
 * The enumeration of reasons when it is ineligible to request increase
 * adjustment.
 */
export enum QuotaIncreaseEligibility_IneligibilityReason {
  /** INELIGIBILITY_REASON_UNSPECIFIED - Default value when is_eligible is true. */
  INELIGIBILITY_REASON_UNSPECIFIED = 0,
  /** NO_VALID_BILLING_ACCOUNT - The container is not linked with a valid billing account. */
  NO_VALID_BILLING_ACCOUNT = 1,
  /** OTHER - Other reasons. */
  OTHER = 2,
  UNRECOGNIZED = -1,
}

export function quotaIncreaseEligibility_IneligibilityReasonFromJSON(
  object: any,
): QuotaIncreaseEligibility_IneligibilityReason {
  switch (object) {
    case 0:
    case "INELIGIBILITY_REASON_UNSPECIFIED":
      return QuotaIncreaseEligibility_IneligibilityReason.INELIGIBILITY_REASON_UNSPECIFIED;
    case 1:
    case "NO_VALID_BILLING_ACCOUNT":
      return QuotaIncreaseEligibility_IneligibilityReason.NO_VALID_BILLING_ACCOUNT;
    case 2:
    case "OTHER":
      return QuotaIncreaseEligibility_IneligibilityReason.OTHER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return QuotaIncreaseEligibility_IneligibilityReason.UNRECOGNIZED;
  }
}

export function quotaIncreaseEligibility_IneligibilityReasonToJSON(
  object: QuotaIncreaseEligibility_IneligibilityReason,
): string {
  switch (object) {
    case QuotaIncreaseEligibility_IneligibilityReason.INELIGIBILITY_REASON_UNSPECIFIED:
      return "INELIGIBILITY_REASON_UNSPECIFIED";
    case QuotaIncreaseEligibility_IneligibilityReason.NO_VALID_BILLING_ACCOUNT:
      return "NO_VALID_BILLING_ACCOUNT";
    case QuotaIncreaseEligibility_IneligibilityReason.OTHER:
      return "OTHER";
    case QuotaIncreaseEligibility_IneligibilityReason.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * QuotaPreference represents the preferred quota configuration specified for
 * a project, folder or organization. There is only one QuotaPreference
 * resource for a quota value targeting a unique set of dimensions.
 */
export interface QuotaPreference {
  /**
   * Required except in the CREATE requests.
   * The resource name of the quota preference.
   * The ID component following "locations/" must be "global".
   * Example:
   * `projects/123/locations/global/quotaPreferences/my-config-for-us-east1`
   */
  name: string;
  /**
   * Immutable. The dimensions that this quota preference applies to. The key of
   * the map entry is the name of a dimension, such as "region", "zone",
   * "network_id", and the value of the map entry is the dimension value.
   *
   * If a dimension is missing from the map of dimensions, the quota preference
   * applies to all the dimension values except for those that have other quota
   * preferences configured for the specific value.
   *
   * NOTE: QuotaPreferences can only be applied across all values of "user" and
   * "resource" dimension. Do not set values for "user" or "resource" in the
   * dimension map.
   *
   * Example: {"provider", "Foo Inc"} where "provider" is a service specific
   * dimension.
   */
  dimensions: { [key: string]: string };
  /** Required. Preferred quota configuration. */
  quotaConfig:
    | QuotaConfig
    | undefined;
  /**
   * Optional. The current etag of the quota preference. If an etag is provided
   * on update and does not match the current server's etag of the quota
   * preference, the request will be blocked and an ABORTED error will be
   * returned. See https://google.aip.dev/134#etags for more details on etags.
   */
  etag: string;
  /** Output only. Create time stamp */
  createTime:
    | Date
    | undefined;
  /** Output only. Update time stamp */
  updateTime:
    | Date
    | undefined;
  /** Required. The name of the service to which the quota preference is applied. */
  service: string;
  /**
   * Required. The id of the quota to which the quota preference is applied. A
   * quota name is unique in the service. Example: `CpusPerProjectPerRegion`
   */
  quotaId: string;
  /**
   * Output only. Is the quota preference pending Google Cloud approval and
   * fulfillment.
   */
  reconciling: boolean;
  /** The reason / justification for this quota preference. */
  justification: string;
  /**
   * Input only. An email address that can be used to contact the the user, in
   * case Google Cloud needs more information to make a decision before
   * additional quota can be granted.
   *
   * When requesting a quota increase, the email address is required.
   * When requesting a quota decrease, the email address is optional.
   * For example, the email address is optional when the
   * `QuotaConfig.preferred_value` is smaller than the
   * `QuotaDetails.reset_value`.
   */
  contactEmail: string;
}

export interface QuotaPreference_DimensionsEntry {
  key: string;
  value: string;
}

/** The preferred quota configuration. */
export interface QuotaConfig {
  /**
   * Required. The preferred value. Must be greater than or equal to -1. If set
   * to -1, it means the value is "unlimited".
   */
  preferredValue: Long;
  /** Output only. Optional details about the state of this quota preference. */
  stateDetail: string;
  /** Output only. Granted quota value. */
  grantedValue:
    | Long
    | undefined;
  /**
   * Output only. The trace id that the Google Cloud uses to provision the
   * requested quota. This trace id may be used by the client to contact Cloud
   * support to track the state of a quota preference request. The trace id is
   * only produced for increase requests and is unique for each request. The
   * quota decrease requests do not have a trace id.
   */
  traceId: string;
  /**
   * Optional. The annotations map for clients to store small amounts of
   * arbitrary data. Do not put PII or other sensitive information here. See
   * https://google.aip.dev/128#annotations
   */
  annotations: { [key: string]: string };
  /** Output only. The origin of the quota preference request. */
  requestOrigin: QuotaConfig_Origin;
}

/** The enumeration of the origins of quota preference requests. */
export enum QuotaConfig_Origin {
  /** ORIGIN_UNSPECIFIED - The unspecified value. */
  ORIGIN_UNSPECIFIED = 0,
  /** CLOUD_CONSOLE - Created through Cloud Console. */
  CLOUD_CONSOLE = 1,
  /** AUTO_ADJUSTER - Generated by automatic quota adjustment. */
  AUTO_ADJUSTER = 2,
  UNRECOGNIZED = -1,
}

export function quotaConfig_OriginFromJSON(object: any): QuotaConfig_Origin {
  switch (object) {
    case 0:
    case "ORIGIN_UNSPECIFIED":
      return QuotaConfig_Origin.ORIGIN_UNSPECIFIED;
    case 1:
    case "CLOUD_CONSOLE":
      return QuotaConfig_Origin.CLOUD_CONSOLE;
    case 2:
    case "AUTO_ADJUSTER":
      return QuotaConfig_Origin.AUTO_ADJUSTER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return QuotaConfig_Origin.UNRECOGNIZED;
  }
}

export function quotaConfig_OriginToJSON(object: QuotaConfig_Origin): string {
  switch (object) {
    case QuotaConfig_Origin.ORIGIN_UNSPECIFIED:
      return "ORIGIN_UNSPECIFIED";
    case QuotaConfig_Origin.CLOUD_CONSOLE:
      return "CLOUD_CONSOLE";
    case QuotaConfig_Origin.AUTO_ADJUSTER:
      return "AUTO_ADJUSTER";
    case QuotaConfig_Origin.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface QuotaConfig_AnnotationsEntry {
  key: string;
  value: string;
}

/**
 * The detailed quota information such as effective quota value for a
 * combination of dimensions.
 */
export interface DimensionsInfo {
  /**
   * The map of dimensions for this dimensions info. The key of a map entry
   * is "region", "zone" or the name of a service specific dimension, and the
   * value of a map entry is the value of the dimension.  If a dimension does
   * not appear in the map of dimensions, the dimensions info applies to all
   * the dimension values except for those that have another DimenisonInfo
   * instance configured for the specific value.
   * Example: {"provider" : "Foo Inc"} where "provider" is a service specific
   * dimension of a quota.
   */
  dimensions: { [key: string]: string };
  /** Quota details for the specified dimensions. */
  details:
    | QuotaDetails
    | undefined;
  /**
   * The applicable regions or zones of this dimensions info. The field will be
   * set to ['global'] for quotas that are not per region or per zone.
   * Otherwise, it will be set to the list of locations this dimension info is
   * applicable to.
   */
  applicableLocations: string[];
}

export interface DimensionsInfo_DimensionsEntry {
  key: string;
  value: string;
}

/** The quota details for a map of dimensions. */
export interface QuotaDetails {
  /** The value currently in effect and being enforced. */
  value: Long;
  /**
   * Rollout information of this quota.
   * This field is present only if the effective limit will change due to the
   * ongoing rollout of the service config.
   */
  rolloutInfo: RolloutInfo | undefined;
}

/** [Output only] Rollout information of a quota. */
export interface RolloutInfo {
  /** Whether there is an ongoing rollout for a quota or not. */
  ongoingRollout: boolean;
}

function createBaseQuotaInfo(): QuotaInfo {
  return {
    name: "",
    quotaId: "",
    metric: "",
    service: "",
    isPrecise: false,
    refreshInterval: "",
    containerType: 0,
    dimensions: [],
    metricDisplayName: "",
    quotaDisplayName: "",
    metricUnit: "",
    quotaIncreaseEligibility: undefined,
    isFixed: false,
    dimensionsInfos: [],
    isConcurrent: false,
    serviceRequestQuotaUri: "",
  };
}

export const QuotaInfo: MessageFns<QuotaInfo> = {
  encode(message: QuotaInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.quotaId !== "") {
      writer.uint32(18).string(message.quotaId);
    }
    if (message.metric !== "") {
      writer.uint32(26).string(message.metric);
    }
    if (message.service !== "") {
      writer.uint32(34).string(message.service);
    }
    if (message.isPrecise !== false) {
      writer.uint32(40).bool(message.isPrecise);
    }
    if (message.refreshInterval !== "") {
      writer.uint32(50).string(message.refreshInterval);
    }
    if (message.containerType !== 0) {
      writer.uint32(56).int32(message.containerType);
    }
    for (const v of message.dimensions) {
      writer.uint32(66).string(v!);
    }
    if (message.metricDisplayName !== "") {
      writer.uint32(74).string(message.metricDisplayName);
    }
    if (message.quotaDisplayName !== "") {
      writer.uint32(82).string(message.quotaDisplayName);
    }
    if (message.metricUnit !== "") {
      writer.uint32(90).string(message.metricUnit);
    }
    if (message.quotaIncreaseEligibility !== undefined) {
      QuotaIncreaseEligibility.encode(message.quotaIncreaseEligibility, writer.uint32(98).fork()).join();
    }
    if (message.isFixed !== false) {
      writer.uint32(104).bool(message.isFixed);
    }
    for (const v of message.dimensionsInfos) {
      DimensionsInfo.encode(v!, writer.uint32(114).fork()).join();
    }
    if (message.isConcurrent !== false) {
      writer.uint32(120).bool(message.isConcurrent);
    }
    if (message.serviceRequestQuotaUri !== "") {
      writer.uint32(138).string(message.serviceRequestQuotaUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuotaInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuotaInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.quotaId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.metric = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.service = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.isPrecise = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.refreshInterval = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.containerType = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.dimensions.push(reader.string());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.metricDisplayName = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.quotaDisplayName = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.metricUnit = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.quotaIncreaseEligibility = QuotaIncreaseEligibility.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.isFixed = reader.bool();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.dimensionsInfos.push(DimensionsInfo.decode(reader, reader.uint32()));
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.isConcurrent = reader.bool();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.serviceRequestQuotaUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuotaInfo {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      quotaId: isSet(object.quotaId) ? globalThis.String(object.quotaId) : "",
      metric: isSet(object.metric) ? globalThis.String(object.metric) : "",
      service: isSet(object.service) ? globalThis.String(object.service) : "",
      isPrecise: isSet(object.isPrecise) ? globalThis.Boolean(object.isPrecise) : false,
      refreshInterval: isSet(object.refreshInterval) ? globalThis.String(object.refreshInterval) : "",
      containerType: isSet(object.containerType) ? quotaInfo_ContainerTypeFromJSON(object.containerType) : 0,
      dimensions: globalThis.Array.isArray(object?.dimensions)
        ? object.dimensions.map((e: any) => globalThis.String(e))
        : [],
      metricDisplayName: isSet(object.metricDisplayName) ? globalThis.String(object.metricDisplayName) : "",
      quotaDisplayName: isSet(object.quotaDisplayName) ? globalThis.String(object.quotaDisplayName) : "",
      metricUnit: isSet(object.metricUnit) ? globalThis.String(object.metricUnit) : "",
      quotaIncreaseEligibility: isSet(object.quotaIncreaseEligibility)
        ? QuotaIncreaseEligibility.fromJSON(object.quotaIncreaseEligibility)
        : undefined,
      isFixed: isSet(object.isFixed) ? globalThis.Boolean(object.isFixed) : false,
      dimensionsInfos: globalThis.Array.isArray(object?.dimensionsInfos)
        ? object.dimensionsInfos.map((e: any) => DimensionsInfo.fromJSON(e))
        : [],
      isConcurrent: isSet(object.isConcurrent) ? globalThis.Boolean(object.isConcurrent) : false,
      serviceRequestQuotaUri: isSet(object.serviceRequestQuotaUri)
        ? globalThis.String(object.serviceRequestQuotaUri)
        : "",
    };
  },

  toJSON(message: QuotaInfo): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.quotaId !== "") {
      obj.quotaId = message.quotaId;
    }
    if (message.metric !== "") {
      obj.metric = message.metric;
    }
    if (message.service !== "") {
      obj.service = message.service;
    }
    if (message.isPrecise !== false) {
      obj.isPrecise = message.isPrecise;
    }
    if (message.refreshInterval !== "") {
      obj.refreshInterval = message.refreshInterval;
    }
    if (message.containerType !== 0) {
      obj.containerType = quotaInfo_ContainerTypeToJSON(message.containerType);
    }
    if (message.dimensions?.length) {
      obj.dimensions = message.dimensions;
    }
    if (message.metricDisplayName !== "") {
      obj.metricDisplayName = message.metricDisplayName;
    }
    if (message.quotaDisplayName !== "") {
      obj.quotaDisplayName = message.quotaDisplayName;
    }
    if (message.metricUnit !== "") {
      obj.metricUnit = message.metricUnit;
    }
    if (message.quotaIncreaseEligibility !== undefined) {
      obj.quotaIncreaseEligibility = QuotaIncreaseEligibility.toJSON(message.quotaIncreaseEligibility);
    }
    if (message.isFixed !== false) {
      obj.isFixed = message.isFixed;
    }
    if (message.dimensionsInfos?.length) {
      obj.dimensionsInfos = message.dimensionsInfos.map((e) => DimensionsInfo.toJSON(e));
    }
    if (message.isConcurrent !== false) {
      obj.isConcurrent = message.isConcurrent;
    }
    if (message.serviceRequestQuotaUri !== "") {
      obj.serviceRequestQuotaUri = message.serviceRequestQuotaUri;
    }
    return obj;
  },

  create(base?: DeepPartial<QuotaInfo>): QuotaInfo {
    return QuotaInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QuotaInfo>): QuotaInfo {
    const message = createBaseQuotaInfo();
    message.name = object.name ?? "";
    message.quotaId = object.quotaId ?? "";
    message.metric = object.metric ?? "";
    message.service = object.service ?? "";
    message.isPrecise = object.isPrecise ?? false;
    message.refreshInterval = object.refreshInterval ?? "";
    message.containerType = object.containerType ?? 0;
    message.dimensions = object.dimensions?.map((e) => e) || [];
    message.metricDisplayName = object.metricDisplayName ?? "";
    message.quotaDisplayName = object.quotaDisplayName ?? "";
    message.metricUnit = object.metricUnit ?? "";
    message.quotaIncreaseEligibility =
      (object.quotaIncreaseEligibility !== undefined && object.quotaIncreaseEligibility !== null)
        ? QuotaIncreaseEligibility.fromPartial(object.quotaIncreaseEligibility)
        : undefined;
    message.isFixed = object.isFixed ?? false;
    message.dimensionsInfos = object.dimensionsInfos?.map((e) => DimensionsInfo.fromPartial(e)) || [];
    message.isConcurrent = object.isConcurrent ?? false;
    message.serviceRequestQuotaUri = object.serviceRequestQuotaUri ?? "";
    return message;
  },
};

function createBaseQuotaIncreaseEligibility(): QuotaIncreaseEligibility {
  return { isEligible: false, ineligibilityReason: 0 };
}

export const QuotaIncreaseEligibility: MessageFns<QuotaIncreaseEligibility> = {
  encode(message: QuotaIncreaseEligibility, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isEligible !== false) {
      writer.uint32(8).bool(message.isEligible);
    }
    if (message.ineligibilityReason !== 0) {
      writer.uint32(16).int32(message.ineligibilityReason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuotaIncreaseEligibility {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuotaIncreaseEligibility();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.isEligible = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.ineligibilityReason = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuotaIncreaseEligibility {
    return {
      isEligible: isSet(object.isEligible) ? globalThis.Boolean(object.isEligible) : false,
      ineligibilityReason: isSet(object.ineligibilityReason)
        ? quotaIncreaseEligibility_IneligibilityReasonFromJSON(object.ineligibilityReason)
        : 0,
    };
  },

  toJSON(message: QuotaIncreaseEligibility): unknown {
    const obj: any = {};
    if (message.isEligible !== false) {
      obj.isEligible = message.isEligible;
    }
    if (message.ineligibilityReason !== 0) {
      obj.ineligibilityReason = quotaIncreaseEligibility_IneligibilityReasonToJSON(message.ineligibilityReason);
    }
    return obj;
  },

  create(base?: DeepPartial<QuotaIncreaseEligibility>): QuotaIncreaseEligibility {
    return QuotaIncreaseEligibility.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QuotaIncreaseEligibility>): QuotaIncreaseEligibility {
    const message = createBaseQuotaIncreaseEligibility();
    message.isEligible = object.isEligible ?? false;
    message.ineligibilityReason = object.ineligibilityReason ?? 0;
    return message;
  },
};

function createBaseQuotaPreference(): QuotaPreference {
  return {
    name: "",
    dimensions: {},
    quotaConfig: undefined,
    etag: "",
    createTime: undefined,
    updateTime: undefined,
    service: "",
    quotaId: "",
    reconciling: false,
    justification: "",
    contactEmail: "",
  };
}

export const QuotaPreference: MessageFns<QuotaPreference> = {
  encode(message: QuotaPreference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    Object.entries(message.dimensions).forEach(([key, value]) => {
      QuotaPreference_DimensionsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    if (message.quotaConfig !== undefined) {
      QuotaConfig.encode(message.quotaConfig, writer.uint32(26).fork()).join();
    }
    if (message.etag !== "") {
      writer.uint32(34).string(message.etag);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(42).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(50).fork()).join();
    }
    if (message.service !== "") {
      writer.uint32(58).string(message.service);
    }
    if (message.quotaId !== "") {
      writer.uint32(66).string(message.quotaId);
    }
    if (message.reconciling !== false) {
      writer.uint32(80).bool(message.reconciling);
    }
    if (message.justification !== "") {
      writer.uint32(90).string(message.justification);
    }
    if (message.contactEmail !== "") {
      writer.uint32(98).string(message.contactEmail);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuotaPreference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuotaPreference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = QuotaPreference_DimensionsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.dimensions[entry2.key] = entry2.value;
          }
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.quotaConfig = QuotaConfig.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.service = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.quotaId = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.reconciling = reader.bool();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.justification = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.contactEmail = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuotaPreference {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      dimensions: isObject(object.dimensions)
        ? Object.entries(object.dimensions).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      quotaConfig: isSet(object.quotaConfig) ? QuotaConfig.fromJSON(object.quotaConfig) : undefined,
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      service: isSet(object.service) ? globalThis.String(object.service) : "",
      quotaId: isSet(object.quotaId) ? globalThis.String(object.quotaId) : "",
      reconciling: isSet(object.reconciling) ? globalThis.Boolean(object.reconciling) : false,
      justification: isSet(object.justification) ? globalThis.String(object.justification) : "",
      contactEmail: isSet(object.contactEmail) ? globalThis.String(object.contactEmail) : "",
    };
  },

  toJSON(message: QuotaPreference): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.dimensions) {
      const entries = Object.entries(message.dimensions);
      if (entries.length > 0) {
        obj.dimensions = {};
        entries.forEach(([k, v]) => {
          obj.dimensions[k] = v;
        });
      }
    }
    if (message.quotaConfig !== undefined) {
      obj.quotaConfig = QuotaConfig.toJSON(message.quotaConfig);
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.service !== "") {
      obj.service = message.service;
    }
    if (message.quotaId !== "") {
      obj.quotaId = message.quotaId;
    }
    if (message.reconciling !== false) {
      obj.reconciling = message.reconciling;
    }
    if (message.justification !== "") {
      obj.justification = message.justification;
    }
    if (message.contactEmail !== "") {
      obj.contactEmail = message.contactEmail;
    }
    return obj;
  },

  create(base?: DeepPartial<QuotaPreference>): QuotaPreference {
    return QuotaPreference.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QuotaPreference>): QuotaPreference {
    const message = createBaseQuotaPreference();
    message.name = object.name ?? "";
    message.dimensions = Object.entries(object.dimensions ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.quotaConfig = (object.quotaConfig !== undefined && object.quotaConfig !== null)
      ? QuotaConfig.fromPartial(object.quotaConfig)
      : undefined;
    message.etag = object.etag ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.service = object.service ?? "";
    message.quotaId = object.quotaId ?? "";
    message.reconciling = object.reconciling ?? false;
    message.justification = object.justification ?? "";
    message.contactEmail = object.contactEmail ?? "";
    return message;
  },
};

function createBaseQuotaPreference_DimensionsEntry(): QuotaPreference_DimensionsEntry {
  return { key: "", value: "" };
}

export const QuotaPreference_DimensionsEntry: MessageFns<QuotaPreference_DimensionsEntry> = {
  encode(message: QuotaPreference_DimensionsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuotaPreference_DimensionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuotaPreference_DimensionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuotaPreference_DimensionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: QuotaPreference_DimensionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<QuotaPreference_DimensionsEntry>): QuotaPreference_DimensionsEntry {
    return QuotaPreference_DimensionsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QuotaPreference_DimensionsEntry>): QuotaPreference_DimensionsEntry {
    const message = createBaseQuotaPreference_DimensionsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseQuotaConfig(): QuotaConfig {
  return {
    preferredValue: Long.ZERO,
    stateDetail: "",
    grantedValue: undefined,
    traceId: "",
    annotations: {},
    requestOrigin: 0,
  };
}

export const QuotaConfig: MessageFns<QuotaConfig> = {
  encode(message: QuotaConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.preferredValue.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.preferredValue.toString());
    }
    if (message.stateDetail !== "") {
      writer.uint32(18).string(message.stateDetail);
    }
    if (message.grantedValue !== undefined) {
      Int64Value.encode({ value: message.grantedValue! }, writer.uint32(26).fork()).join();
    }
    if (message.traceId !== "") {
      writer.uint32(34).string(message.traceId);
    }
    Object.entries(message.annotations).forEach(([key, value]) => {
      QuotaConfig_AnnotationsEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    if (message.requestOrigin !== 0) {
      writer.uint32(48).int32(message.requestOrigin);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuotaConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuotaConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.preferredValue = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stateDetail = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.grantedValue = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.traceId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = QuotaConfig_AnnotationsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.annotations[entry5.key] = entry5.value;
          }
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.requestOrigin = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuotaConfig {
    return {
      preferredValue: isSet(object.preferredValue) ? Long.fromValue(object.preferredValue) : Long.ZERO,
      stateDetail: isSet(object.stateDetail) ? globalThis.String(object.stateDetail) : "",
      grantedValue: isSet(object.grantedValue) ? Long.fromValue(object.grantedValue) : undefined,
      traceId: isSet(object.traceId) ? globalThis.String(object.traceId) : "",
      annotations: isObject(object.annotations)
        ? Object.entries(object.annotations).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      requestOrigin: isSet(object.requestOrigin) ? quotaConfig_OriginFromJSON(object.requestOrigin) : 0,
    };
  },

  toJSON(message: QuotaConfig): unknown {
    const obj: any = {};
    if (!message.preferredValue.equals(Long.ZERO)) {
      obj.preferredValue = (message.preferredValue || Long.ZERO).toString();
    }
    if (message.stateDetail !== "") {
      obj.stateDetail = message.stateDetail;
    }
    if (message.grantedValue !== undefined) {
      obj.grantedValue = message.grantedValue;
    }
    if (message.traceId !== "") {
      obj.traceId = message.traceId;
    }
    if (message.annotations) {
      const entries = Object.entries(message.annotations);
      if (entries.length > 0) {
        obj.annotations = {};
        entries.forEach(([k, v]) => {
          obj.annotations[k] = v;
        });
      }
    }
    if (message.requestOrigin !== 0) {
      obj.requestOrigin = quotaConfig_OriginToJSON(message.requestOrigin);
    }
    return obj;
  },

  create(base?: DeepPartial<QuotaConfig>): QuotaConfig {
    return QuotaConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QuotaConfig>): QuotaConfig {
    const message = createBaseQuotaConfig();
    message.preferredValue = (object.preferredValue !== undefined && object.preferredValue !== null)
      ? Long.fromValue(object.preferredValue)
      : Long.ZERO;
    message.stateDetail = object.stateDetail ?? "";
    message.grantedValue = (object.grantedValue !== undefined && object.grantedValue !== null)
      ? Long.fromValue(object.grantedValue)
      : undefined;
    message.traceId = object.traceId ?? "";
    message.annotations = Object.entries(object.annotations ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.requestOrigin = object.requestOrigin ?? 0;
    return message;
  },
};

function createBaseQuotaConfig_AnnotationsEntry(): QuotaConfig_AnnotationsEntry {
  return { key: "", value: "" };
}

export const QuotaConfig_AnnotationsEntry: MessageFns<QuotaConfig_AnnotationsEntry> = {
  encode(message: QuotaConfig_AnnotationsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuotaConfig_AnnotationsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuotaConfig_AnnotationsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuotaConfig_AnnotationsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: QuotaConfig_AnnotationsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<QuotaConfig_AnnotationsEntry>): QuotaConfig_AnnotationsEntry {
    return QuotaConfig_AnnotationsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QuotaConfig_AnnotationsEntry>): QuotaConfig_AnnotationsEntry {
    const message = createBaseQuotaConfig_AnnotationsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseDimensionsInfo(): DimensionsInfo {
  return { dimensions: {}, details: undefined, applicableLocations: [] };
}

export const DimensionsInfo: MessageFns<DimensionsInfo> = {
  encode(message: DimensionsInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.dimensions).forEach(([key, value]) => {
      DimensionsInfo_DimensionsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    if (message.details !== undefined) {
      QuotaDetails.encode(message.details, writer.uint32(18).fork()).join();
    }
    for (const v of message.applicableLocations) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DimensionsInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDimensionsInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = DimensionsInfo_DimensionsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.dimensions[entry1.key] = entry1.value;
          }
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.details = QuotaDetails.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.applicableLocations.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DimensionsInfo {
    return {
      dimensions: isObject(object.dimensions)
        ? Object.entries(object.dimensions).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      details: isSet(object.details) ? QuotaDetails.fromJSON(object.details) : undefined,
      applicableLocations: globalThis.Array.isArray(object?.applicableLocations)
        ? object.applicableLocations.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: DimensionsInfo): unknown {
    const obj: any = {};
    if (message.dimensions) {
      const entries = Object.entries(message.dimensions);
      if (entries.length > 0) {
        obj.dimensions = {};
        entries.forEach(([k, v]) => {
          obj.dimensions[k] = v;
        });
      }
    }
    if (message.details !== undefined) {
      obj.details = QuotaDetails.toJSON(message.details);
    }
    if (message.applicableLocations?.length) {
      obj.applicableLocations = message.applicableLocations;
    }
    return obj;
  },

  create(base?: DeepPartial<DimensionsInfo>): DimensionsInfo {
    return DimensionsInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DimensionsInfo>): DimensionsInfo {
    const message = createBaseDimensionsInfo();
    message.dimensions = Object.entries(object.dimensions ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.details = (object.details !== undefined && object.details !== null)
      ? QuotaDetails.fromPartial(object.details)
      : undefined;
    message.applicableLocations = object.applicableLocations?.map((e) => e) || [];
    return message;
  },
};

function createBaseDimensionsInfo_DimensionsEntry(): DimensionsInfo_DimensionsEntry {
  return { key: "", value: "" };
}

export const DimensionsInfo_DimensionsEntry: MessageFns<DimensionsInfo_DimensionsEntry> = {
  encode(message: DimensionsInfo_DimensionsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DimensionsInfo_DimensionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDimensionsInfo_DimensionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DimensionsInfo_DimensionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: DimensionsInfo_DimensionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<DimensionsInfo_DimensionsEntry>): DimensionsInfo_DimensionsEntry {
    return DimensionsInfo_DimensionsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DimensionsInfo_DimensionsEntry>): DimensionsInfo_DimensionsEntry {
    const message = createBaseDimensionsInfo_DimensionsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseQuotaDetails(): QuotaDetails {
  return { value: Long.ZERO, rolloutInfo: undefined };
}

export const QuotaDetails: MessageFns<QuotaDetails> = {
  encode(message: QuotaDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.value.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.value.toString());
    }
    if (message.rolloutInfo !== undefined) {
      RolloutInfo.encode(message.rolloutInfo, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuotaDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuotaDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.value = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.rolloutInfo = RolloutInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuotaDetails {
    return {
      value: isSet(object.value) ? Long.fromValue(object.value) : Long.ZERO,
      rolloutInfo: isSet(object.rolloutInfo) ? RolloutInfo.fromJSON(object.rolloutInfo) : undefined,
    };
  },

  toJSON(message: QuotaDetails): unknown {
    const obj: any = {};
    if (!message.value.equals(Long.ZERO)) {
      obj.value = (message.value || Long.ZERO).toString();
    }
    if (message.rolloutInfo !== undefined) {
      obj.rolloutInfo = RolloutInfo.toJSON(message.rolloutInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<QuotaDetails>): QuotaDetails {
    return QuotaDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QuotaDetails>): QuotaDetails {
    const message = createBaseQuotaDetails();
    message.value = (object.value !== undefined && object.value !== null) ? Long.fromValue(object.value) : Long.ZERO;
    message.rolloutInfo = (object.rolloutInfo !== undefined && object.rolloutInfo !== null)
      ? RolloutInfo.fromPartial(object.rolloutInfo)
      : undefined;
    return message;
  },
};

function createBaseRolloutInfo(): RolloutInfo {
  return { ongoingRollout: false };
}

export const RolloutInfo: MessageFns<RolloutInfo> = {
  encode(message: RolloutInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ongoingRollout !== false) {
      writer.uint32(8).bool(message.ongoingRollout);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RolloutInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRolloutInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.ongoingRollout = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RolloutInfo {
    return { ongoingRollout: isSet(object.ongoingRollout) ? globalThis.Boolean(object.ongoingRollout) : false };
  },

  toJSON(message: RolloutInfo): unknown {
    const obj: any = {};
    if (message.ongoingRollout !== false) {
      obj.ongoingRollout = message.ongoingRollout;
    }
    return obj;
  },

  create(base?: DeepPartial<RolloutInfo>): RolloutInfo {
    return RolloutInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RolloutInfo>): RolloutInfo {
    const message = createBaseRolloutInfo();
    message.ongoingRollout = object.ongoingRollout ?? false;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
