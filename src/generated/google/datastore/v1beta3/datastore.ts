// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/datastore/v1beta3/datastore.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Entity, Key, PartitionId } from "./entity.js";
import { EntityResult, GqlQuery, Query, QueryResultBatch } from "./query.js";

export const protobufPackage = "google.datastore.v1beta3";

/**
 * The request for
 * [Datastore.Lookup][google.datastore.v1beta3.Datastore.Lookup].
 */
export interface LookupRequest {
  /** The ID of the project against which to make the request. */
  projectId: string;
  /** The options for this lookup request. */
  readOptions:
    | ReadOptions
    | undefined;
  /** Keys of entities to look up. */
  keys: Key[];
}

/**
 * The response for
 * [Datastore.Lookup][google.datastore.v1beta3.Datastore.Lookup].
 */
export interface LookupResponse {
  /**
   * Entities found as `ResultType.FULL` entities. The order of results in this
   * field is undefined and has no relation to the order of the keys in the
   * input.
   */
  found: EntityResult[];
  /**
   * Entities not found as `ResultType.KEY_ONLY` entities. The order of results
   * in this field is undefined and has no relation to the order of the keys
   * in the input.
   */
  missing: EntityResult[];
  /**
   * A list of keys that were not looked up due to resource constraints. The
   * order of results in this field is undefined and has no relation to the
   * order of the keys in the input.
   */
  deferred: Key[];
}

/**
 * The request for
 * [Datastore.RunQuery][google.datastore.v1beta3.Datastore.RunQuery].
 */
export interface RunQueryRequest {
  /** The ID of the project against which to make the request. */
  projectId: string;
  /**
   * Entities are partitioned into subsets, identified by a partition ID.
   * Queries are scoped to a single partition.
   * This partition ID is normalized with the standard default context
   * partition ID.
   */
  partitionId:
    | PartitionId
    | undefined;
  /** The options for this query. */
  readOptions:
    | ReadOptions
    | undefined;
  /** The query to run. */
  query?:
    | Query
    | undefined;
  /** The GQL query to run. */
  gqlQuery?: GqlQuery | undefined;
}

/**
 * The response for
 * [Datastore.RunQuery][google.datastore.v1beta3.Datastore.RunQuery].
 */
export interface RunQueryResponse {
  /** A batch of query results (always present). */
  batch:
    | QueryResultBatch
    | undefined;
  /** The parsed form of the `GqlQuery` from the request, if it was set. */
  query: Query | undefined;
}

/**
 * The request for
 * [Datastore.BeginTransaction][google.datastore.v1beta3.Datastore.BeginTransaction].
 */
export interface BeginTransactionRequest {
  /** The ID of the project against which to make the request. */
  projectId: string;
  /** Options for a new transaction. */
  transactionOptions: TransactionOptions | undefined;
}

/**
 * The response for
 * [Datastore.BeginTransaction][google.datastore.v1beta3.Datastore.BeginTransaction].
 */
export interface BeginTransactionResponse {
  /** The transaction identifier (always present). */
  transaction: Buffer;
}

/**
 * The request for
 * [Datastore.Rollback][google.datastore.v1beta3.Datastore.Rollback].
 */
export interface RollbackRequest {
  /** The ID of the project against which to make the request. */
  projectId: string;
  /**
   * The transaction identifier, returned by a call to
   * [Datastore.BeginTransaction][google.datastore.v1beta3.Datastore.BeginTransaction].
   */
  transaction: Buffer;
}

/**
 * The response for
 * [Datastore.Rollback][google.datastore.v1beta3.Datastore.Rollback]. (an empty
 * message).
 */
export interface RollbackResponse {
}

/**
 * The request for
 * [Datastore.Commit][google.datastore.v1beta3.Datastore.Commit].
 */
export interface CommitRequest {
  /** The ID of the project against which to make the request. */
  projectId: string;
  /** The type of commit to perform. Defaults to `TRANSACTIONAL`. */
  mode: CommitRequest_Mode;
  /**
   * The identifier of the transaction associated with the commit. A
   * transaction identifier is returned by a call to
   * [Datastore.BeginTransaction][google.datastore.v1beta3.Datastore.BeginTransaction].
   */
  transaction?:
    | Buffer
    | undefined;
  /**
   * The mutations to perform.
   *
   * When mode is `TRANSACTIONAL`, mutations affecting a single entity are
   * applied in order. The following sequences of mutations affecting a single
   * entity are not permitted in a single `Commit` request:
   *
   * - `insert` followed by `insert`
   * - `update` followed by `insert`
   * - `upsert` followed by `insert`
   * - `delete` followed by `update`
   *
   * When mode is `NON_TRANSACTIONAL`, no two mutations may affect a single
   * entity.
   */
  mutations: Mutation[];
}

/** The modes available for commits. */
export enum CommitRequest_Mode {
  /** MODE_UNSPECIFIED - Unspecified. This value must not be used. */
  MODE_UNSPECIFIED = 0,
  /**
   * TRANSACTIONAL - Transactional: The mutations are either all applied, or none are applied.
   * Learn about transactions
   * [here](https://cloud.google.com/datastore/docs/concepts/transactions).
   */
  TRANSACTIONAL = 1,
  /** NON_TRANSACTIONAL - Non-transactional: The mutations may not apply as all or none. */
  NON_TRANSACTIONAL = 2,
  UNRECOGNIZED = -1,
}

export function commitRequest_ModeFromJSON(object: any): CommitRequest_Mode {
  switch (object) {
    case 0:
    case "MODE_UNSPECIFIED":
      return CommitRequest_Mode.MODE_UNSPECIFIED;
    case 1:
    case "TRANSACTIONAL":
      return CommitRequest_Mode.TRANSACTIONAL;
    case 2:
    case "NON_TRANSACTIONAL":
      return CommitRequest_Mode.NON_TRANSACTIONAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CommitRequest_Mode.UNRECOGNIZED;
  }
}

export function commitRequest_ModeToJSON(object: CommitRequest_Mode): string {
  switch (object) {
    case CommitRequest_Mode.MODE_UNSPECIFIED:
      return "MODE_UNSPECIFIED";
    case CommitRequest_Mode.TRANSACTIONAL:
      return "TRANSACTIONAL";
    case CommitRequest_Mode.NON_TRANSACTIONAL:
      return "NON_TRANSACTIONAL";
    case CommitRequest_Mode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The response for
 * [Datastore.Commit][google.datastore.v1beta3.Datastore.Commit].
 */
export interface CommitResponse {
  /**
   * The result of performing the mutations.
   * The i-th mutation result corresponds to the i-th mutation in the request.
   */
  mutationResults: MutationResult[];
  /**
   * The number of index entries updated during the commit, or zero if none were
   * updated.
   */
  indexUpdates: number;
}

/**
 * The request for
 * [Datastore.AllocateIds][google.datastore.v1beta3.Datastore.AllocateIds].
 */
export interface AllocateIdsRequest {
  /** The ID of the project against which to make the request. */
  projectId: string;
  /**
   * A list of keys with incomplete key paths for which to allocate IDs.
   * No key may be reserved/read-only.
   */
  keys: Key[];
}

/**
 * The response for
 * [Datastore.AllocateIds][google.datastore.v1beta3.Datastore.AllocateIds].
 */
export interface AllocateIdsResponse {
  /**
   * The keys specified in the request (in the same order), each with
   * its key path completed with a newly allocated ID.
   */
  keys: Key[];
}

/**
 * The request for
 * [Datastore.ReserveIds][google.datastore.v1beta3.Datastore.ReserveIds].
 */
export interface ReserveIdsRequest {
  /** The ID of the project against which to make the request. */
  projectId: string;
  /** If not empty, the ID of the database against which to make the request. */
  databaseId: string;
  /**
   * A list of keys with complete key paths whose numeric IDs should not be
   * auto-allocated.
   */
  keys: Key[];
}

/**
 * The response for
 * [Datastore.ReserveIds][google.datastore.v1beta3.Datastore.ReserveIds].
 */
export interface ReserveIdsResponse {
}

/** A mutation to apply to an entity. */
export interface Mutation {
  /**
   * The entity to insert. The entity must not already exist.
   * The entity key's final path element may be incomplete.
   */
  insert?:
    | Entity
    | undefined;
  /**
   * The entity to update. The entity must already exist.
   * Must have a complete key path.
   */
  update?:
    | Entity
    | undefined;
  /**
   * The entity to upsert. The entity may or may not already exist.
   * The entity key's final path element may be incomplete.
   */
  upsert?:
    | Entity
    | undefined;
  /**
   * The key of the entity to delete. The entity may or may not already exist.
   * Must have a complete key path and must not be reserved/read-only.
   */
  delete?:
    | Key
    | undefined;
  /**
   * The version of the entity that this mutation is being applied to. If this
   * does not match the current version on the server, the mutation conflicts.
   */
  baseVersion?: Long | undefined;
}

/** The result of applying a mutation. */
export interface MutationResult {
  /**
   * The automatically allocated key.
   * Set only when the mutation allocated a key.
   */
  key:
    | Key
    | undefined;
  /**
   * The version of the entity on the server after processing the mutation. If
   * the mutation doesn't change anything on the server, then the version will
   * be the version of the current entity or, if no entity is present, a version
   * that is strictly greater than the version of any previous entity and less
   * than the version of any possible future entity.
   */
  version: Long;
  /**
   * Whether a conflict was detected for this mutation. Always false when a
   * conflict detection strategy field is not set in the mutation.
   */
  conflictDetected: boolean;
}

/** The options shared by read requests. */
export interface ReadOptions {
  /**
   * The non-transactional read consistency to use.
   * Cannot be set to `STRONG` for global queries.
   */
  readConsistency?:
    | ReadOptions_ReadConsistency
    | undefined;
  /**
   * The identifier of the transaction in which to read. A
   * transaction identifier is returned by a call to
   * [Datastore.BeginTransaction][google.datastore.v1beta3.Datastore.BeginTransaction].
   */
  transaction?: Buffer | undefined;
}

/** The possible values for read consistencies. */
export enum ReadOptions_ReadConsistency {
  /** READ_CONSISTENCY_UNSPECIFIED - Unspecified. This value must not be used. */
  READ_CONSISTENCY_UNSPECIFIED = 0,
  /** STRONG - Strong consistency. */
  STRONG = 1,
  /** EVENTUAL - Eventual consistency. */
  EVENTUAL = 2,
  UNRECOGNIZED = -1,
}

export function readOptions_ReadConsistencyFromJSON(object: any): ReadOptions_ReadConsistency {
  switch (object) {
    case 0:
    case "READ_CONSISTENCY_UNSPECIFIED":
      return ReadOptions_ReadConsistency.READ_CONSISTENCY_UNSPECIFIED;
    case 1:
    case "STRONG":
      return ReadOptions_ReadConsistency.STRONG;
    case 2:
    case "EVENTUAL":
      return ReadOptions_ReadConsistency.EVENTUAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ReadOptions_ReadConsistency.UNRECOGNIZED;
  }
}

export function readOptions_ReadConsistencyToJSON(object: ReadOptions_ReadConsistency): string {
  switch (object) {
    case ReadOptions_ReadConsistency.READ_CONSISTENCY_UNSPECIFIED:
      return "READ_CONSISTENCY_UNSPECIFIED";
    case ReadOptions_ReadConsistency.STRONG:
      return "STRONG";
    case ReadOptions_ReadConsistency.EVENTUAL:
      return "EVENTUAL";
    case ReadOptions_ReadConsistency.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Options for beginning a new transaction.
 *
 * Transactions can be created explicitly with calls to
 * [Datastore.BeginTransaction][google.datastore.v1beta3.Datastore.BeginTransaction]
 * or implicitly by setting
 * [ReadOptions.new_transaction][google.datastore.v1beta3.ReadOptions.new_transaction]
 * in read requests.
 */
export interface TransactionOptions {
  /** The transaction should allow both reads and writes. */
  readWrite?:
    | TransactionOptions_ReadWrite
    | undefined;
  /** The transaction should only allow reads. */
  readOnly?: TransactionOptions_ReadOnly | undefined;
}

/** Options specific to read / write transactions. */
export interface TransactionOptions_ReadWrite {
  /** The transaction identifier of the transaction being retried. */
  previousTransaction: Buffer;
}

/** Options specific to read-only transactions. */
export interface TransactionOptions_ReadOnly {
}

function createBaseLookupRequest(): LookupRequest {
  return { projectId: "", readOptions: undefined, keys: [] };
}

export const LookupRequest: MessageFns<LookupRequest> = {
  encode(message: LookupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(66).string(message.projectId);
    }
    if (message.readOptions !== undefined) {
      ReadOptions.encode(message.readOptions, writer.uint32(10).fork()).join();
    }
    for (const v of message.keys) {
      Key.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LookupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLookupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 8:
          if (tag !== 66) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.readOptions = ReadOptions.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.keys.push(Key.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LookupRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      readOptions: isSet(object.readOptions) ? ReadOptions.fromJSON(object.readOptions) : undefined,
      keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e: any) => Key.fromJSON(e)) : [],
    };
  },

  toJSON(message: LookupRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.readOptions !== undefined) {
      obj.readOptions = ReadOptions.toJSON(message.readOptions);
    }
    if (message.keys?.length) {
      obj.keys = message.keys.map((e) => Key.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<LookupRequest>): LookupRequest {
    return LookupRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LookupRequest>): LookupRequest {
    const message = createBaseLookupRequest();
    message.projectId = object.projectId ?? "";
    message.readOptions = (object.readOptions !== undefined && object.readOptions !== null)
      ? ReadOptions.fromPartial(object.readOptions)
      : undefined;
    message.keys = object.keys?.map((e) => Key.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLookupResponse(): LookupResponse {
  return { found: [], missing: [], deferred: [] };
}

export const LookupResponse: MessageFns<LookupResponse> = {
  encode(message: LookupResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.found) {
      EntityResult.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.missing) {
      EntityResult.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.deferred) {
      Key.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LookupResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLookupResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.found.push(EntityResult.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.missing.push(EntityResult.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.deferred.push(Key.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LookupResponse {
    return {
      found: globalThis.Array.isArray(object?.found) ? object.found.map((e: any) => EntityResult.fromJSON(e)) : [],
      missing: globalThis.Array.isArray(object?.missing)
        ? object.missing.map((e: any) => EntityResult.fromJSON(e))
        : [],
      deferred: globalThis.Array.isArray(object?.deferred) ? object.deferred.map((e: any) => Key.fromJSON(e)) : [],
    };
  },

  toJSON(message: LookupResponse): unknown {
    const obj: any = {};
    if (message.found?.length) {
      obj.found = message.found.map((e) => EntityResult.toJSON(e));
    }
    if (message.missing?.length) {
      obj.missing = message.missing.map((e) => EntityResult.toJSON(e));
    }
    if (message.deferred?.length) {
      obj.deferred = message.deferred.map((e) => Key.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<LookupResponse>): LookupResponse {
    return LookupResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LookupResponse>): LookupResponse {
    const message = createBaseLookupResponse();
    message.found = object.found?.map((e) => EntityResult.fromPartial(e)) || [];
    message.missing = object.missing?.map((e) => EntityResult.fromPartial(e)) || [];
    message.deferred = object.deferred?.map((e) => Key.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRunQueryRequest(): RunQueryRequest {
  return { projectId: "", partitionId: undefined, readOptions: undefined, query: undefined, gqlQuery: undefined };
}

export const RunQueryRequest: MessageFns<RunQueryRequest> = {
  encode(message: RunQueryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(66).string(message.projectId);
    }
    if (message.partitionId !== undefined) {
      PartitionId.encode(message.partitionId, writer.uint32(18).fork()).join();
    }
    if (message.readOptions !== undefined) {
      ReadOptions.encode(message.readOptions, writer.uint32(10).fork()).join();
    }
    if (message.query !== undefined) {
      Query.encode(message.query, writer.uint32(26).fork()).join();
    }
    if (message.gqlQuery !== undefined) {
      GqlQuery.encode(message.gqlQuery, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunQueryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunQueryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 8:
          if (tag !== 66) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.partitionId = PartitionId.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.readOptions = ReadOptions.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.query = Query.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.gqlQuery = GqlQuery.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunQueryRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      partitionId: isSet(object.partitionId) ? PartitionId.fromJSON(object.partitionId) : undefined,
      readOptions: isSet(object.readOptions) ? ReadOptions.fromJSON(object.readOptions) : undefined,
      query: isSet(object.query) ? Query.fromJSON(object.query) : undefined,
      gqlQuery: isSet(object.gqlQuery) ? GqlQuery.fromJSON(object.gqlQuery) : undefined,
    };
  },

  toJSON(message: RunQueryRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.partitionId !== undefined) {
      obj.partitionId = PartitionId.toJSON(message.partitionId);
    }
    if (message.readOptions !== undefined) {
      obj.readOptions = ReadOptions.toJSON(message.readOptions);
    }
    if (message.query !== undefined) {
      obj.query = Query.toJSON(message.query);
    }
    if (message.gqlQuery !== undefined) {
      obj.gqlQuery = GqlQuery.toJSON(message.gqlQuery);
    }
    return obj;
  },

  create(base?: DeepPartial<RunQueryRequest>): RunQueryRequest {
    return RunQueryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunQueryRequest>): RunQueryRequest {
    const message = createBaseRunQueryRequest();
    message.projectId = object.projectId ?? "";
    message.partitionId = (object.partitionId !== undefined && object.partitionId !== null)
      ? PartitionId.fromPartial(object.partitionId)
      : undefined;
    message.readOptions = (object.readOptions !== undefined && object.readOptions !== null)
      ? ReadOptions.fromPartial(object.readOptions)
      : undefined;
    message.query = (object.query !== undefined && object.query !== null) ? Query.fromPartial(object.query) : undefined;
    message.gqlQuery = (object.gqlQuery !== undefined && object.gqlQuery !== null)
      ? GqlQuery.fromPartial(object.gqlQuery)
      : undefined;
    return message;
  },
};

function createBaseRunQueryResponse(): RunQueryResponse {
  return { batch: undefined, query: undefined };
}

export const RunQueryResponse: MessageFns<RunQueryResponse> = {
  encode(message: RunQueryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.batch !== undefined) {
      QueryResultBatch.encode(message.batch, writer.uint32(10).fork()).join();
    }
    if (message.query !== undefined) {
      Query.encode(message.query, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunQueryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunQueryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.batch = QueryResultBatch.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.query = Query.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunQueryResponse {
    return {
      batch: isSet(object.batch) ? QueryResultBatch.fromJSON(object.batch) : undefined,
      query: isSet(object.query) ? Query.fromJSON(object.query) : undefined,
    };
  },

  toJSON(message: RunQueryResponse): unknown {
    const obj: any = {};
    if (message.batch !== undefined) {
      obj.batch = QueryResultBatch.toJSON(message.batch);
    }
    if (message.query !== undefined) {
      obj.query = Query.toJSON(message.query);
    }
    return obj;
  },

  create(base?: DeepPartial<RunQueryResponse>): RunQueryResponse {
    return RunQueryResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunQueryResponse>): RunQueryResponse {
    const message = createBaseRunQueryResponse();
    message.batch = (object.batch !== undefined && object.batch !== null)
      ? QueryResultBatch.fromPartial(object.batch)
      : undefined;
    message.query = (object.query !== undefined && object.query !== null) ? Query.fromPartial(object.query) : undefined;
    return message;
  },
};

function createBaseBeginTransactionRequest(): BeginTransactionRequest {
  return { projectId: "", transactionOptions: undefined };
}

export const BeginTransactionRequest: MessageFns<BeginTransactionRequest> = {
  encode(message: BeginTransactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(66).string(message.projectId);
    }
    if (message.transactionOptions !== undefined) {
      TransactionOptions.encode(message.transactionOptions, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BeginTransactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBeginTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 8:
          if (tag !== 66) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.transactionOptions = TransactionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BeginTransactionRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      transactionOptions: isSet(object.transactionOptions)
        ? TransactionOptions.fromJSON(object.transactionOptions)
        : undefined,
    };
  },

  toJSON(message: BeginTransactionRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.transactionOptions !== undefined) {
      obj.transactionOptions = TransactionOptions.toJSON(message.transactionOptions);
    }
    return obj;
  },

  create(base?: DeepPartial<BeginTransactionRequest>): BeginTransactionRequest {
    return BeginTransactionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BeginTransactionRequest>): BeginTransactionRequest {
    const message = createBaseBeginTransactionRequest();
    message.projectId = object.projectId ?? "";
    message.transactionOptions = (object.transactionOptions !== undefined && object.transactionOptions !== null)
      ? TransactionOptions.fromPartial(object.transactionOptions)
      : undefined;
    return message;
  },
};

function createBaseBeginTransactionResponse(): BeginTransactionResponse {
  return { transaction: Buffer.alloc(0) };
}

export const BeginTransactionResponse: MessageFns<BeginTransactionResponse> = {
  encode(message: BeginTransactionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transaction.length !== 0) {
      writer.uint32(10).bytes(message.transaction);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BeginTransactionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBeginTransactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transaction = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BeginTransactionResponse {
    return {
      transaction: isSet(object.transaction) ? Buffer.from(bytesFromBase64(object.transaction)) : Buffer.alloc(0),
    };
  },

  toJSON(message: BeginTransactionResponse): unknown {
    const obj: any = {};
    if (message.transaction.length !== 0) {
      obj.transaction = base64FromBytes(message.transaction);
    }
    return obj;
  },

  create(base?: DeepPartial<BeginTransactionResponse>): BeginTransactionResponse {
    return BeginTransactionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BeginTransactionResponse>): BeginTransactionResponse {
    const message = createBaseBeginTransactionResponse();
    message.transaction = object.transaction ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseRollbackRequest(): RollbackRequest {
  return { projectId: "", transaction: Buffer.alloc(0) };
}

export const RollbackRequest: MessageFns<RollbackRequest> = {
  encode(message: RollbackRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(66).string(message.projectId);
    }
    if (message.transaction.length !== 0) {
      writer.uint32(10).bytes(message.transaction);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RollbackRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRollbackRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 8:
          if (tag !== 66) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transaction = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RollbackRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      transaction: isSet(object.transaction) ? Buffer.from(bytesFromBase64(object.transaction)) : Buffer.alloc(0),
    };
  },

  toJSON(message: RollbackRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.transaction.length !== 0) {
      obj.transaction = base64FromBytes(message.transaction);
    }
    return obj;
  },

  create(base?: DeepPartial<RollbackRequest>): RollbackRequest {
    return RollbackRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RollbackRequest>): RollbackRequest {
    const message = createBaseRollbackRequest();
    message.projectId = object.projectId ?? "";
    message.transaction = object.transaction ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseRollbackResponse(): RollbackResponse {
  return {};
}

export const RollbackResponse: MessageFns<RollbackResponse> = {
  encode(_: RollbackResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RollbackResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRollbackResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RollbackResponse {
    return {};
  },

  toJSON(_: RollbackResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<RollbackResponse>): RollbackResponse {
    return RollbackResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<RollbackResponse>): RollbackResponse {
    const message = createBaseRollbackResponse();
    return message;
  },
};

function createBaseCommitRequest(): CommitRequest {
  return { projectId: "", mode: 0, transaction: undefined, mutations: [] };
}

export const CommitRequest: MessageFns<CommitRequest> = {
  encode(message: CommitRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(66).string(message.projectId);
    }
    if (message.mode !== 0) {
      writer.uint32(40).int32(message.mode);
    }
    if (message.transaction !== undefined) {
      writer.uint32(10).bytes(message.transaction);
    }
    for (const v of message.mutations) {
      Mutation.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommitRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommitRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 8:
          if (tag !== 66) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transaction = Buffer.from(reader.bytes());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.mutations.push(Mutation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommitRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      mode: isSet(object.mode) ? commitRequest_ModeFromJSON(object.mode) : 0,
      transaction: isSet(object.transaction) ? Buffer.from(bytesFromBase64(object.transaction)) : undefined,
      mutations: globalThis.Array.isArray(object?.mutations)
        ? object.mutations.map((e: any) => Mutation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CommitRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.mode !== 0) {
      obj.mode = commitRequest_ModeToJSON(message.mode);
    }
    if (message.transaction !== undefined) {
      obj.transaction = base64FromBytes(message.transaction);
    }
    if (message.mutations?.length) {
      obj.mutations = message.mutations.map((e) => Mutation.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CommitRequest>): CommitRequest {
    return CommitRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CommitRequest>): CommitRequest {
    const message = createBaseCommitRequest();
    message.projectId = object.projectId ?? "";
    message.mode = object.mode ?? 0;
    message.transaction = object.transaction ?? undefined;
    message.mutations = object.mutations?.map((e) => Mutation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCommitResponse(): CommitResponse {
  return { mutationResults: [], indexUpdates: 0 };
}

export const CommitResponse: MessageFns<CommitResponse> = {
  encode(message: CommitResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.mutationResults) {
      MutationResult.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.indexUpdates !== 0) {
      writer.uint32(32).int32(message.indexUpdates);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommitResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommitResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.mutationResults.push(MutationResult.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.indexUpdates = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommitResponse {
    return {
      mutationResults: globalThis.Array.isArray(object?.mutationResults)
        ? object.mutationResults.map((e: any) => MutationResult.fromJSON(e))
        : [],
      indexUpdates: isSet(object.indexUpdates) ? globalThis.Number(object.indexUpdates) : 0,
    };
  },

  toJSON(message: CommitResponse): unknown {
    const obj: any = {};
    if (message.mutationResults?.length) {
      obj.mutationResults = message.mutationResults.map((e) => MutationResult.toJSON(e));
    }
    if (message.indexUpdates !== 0) {
      obj.indexUpdates = Math.round(message.indexUpdates);
    }
    return obj;
  },

  create(base?: DeepPartial<CommitResponse>): CommitResponse {
    return CommitResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CommitResponse>): CommitResponse {
    const message = createBaseCommitResponse();
    message.mutationResults = object.mutationResults?.map((e) => MutationResult.fromPartial(e)) || [];
    message.indexUpdates = object.indexUpdates ?? 0;
    return message;
  },
};

function createBaseAllocateIdsRequest(): AllocateIdsRequest {
  return { projectId: "", keys: [] };
}

export const AllocateIdsRequest: MessageFns<AllocateIdsRequest> = {
  encode(message: AllocateIdsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(66).string(message.projectId);
    }
    for (const v of message.keys) {
      Key.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AllocateIdsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllocateIdsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 8:
          if (tag !== 66) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.keys.push(Key.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AllocateIdsRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e: any) => Key.fromJSON(e)) : [],
    };
  },

  toJSON(message: AllocateIdsRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.keys?.length) {
      obj.keys = message.keys.map((e) => Key.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AllocateIdsRequest>): AllocateIdsRequest {
    return AllocateIdsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AllocateIdsRequest>): AllocateIdsRequest {
    const message = createBaseAllocateIdsRequest();
    message.projectId = object.projectId ?? "";
    message.keys = object.keys?.map((e) => Key.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAllocateIdsResponse(): AllocateIdsResponse {
  return { keys: [] };
}

export const AllocateIdsResponse: MessageFns<AllocateIdsResponse> = {
  encode(message: AllocateIdsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.keys) {
      Key.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AllocateIdsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllocateIdsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.keys.push(Key.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AllocateIdsResponse {
    return { keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e: any) => Key.fromJSON(e)) : [] };
  },

  toJSON(message: AllocateIdsResponse): unknown {
    const obj: any = {};
    if (message.keys?.length) {
      obj.keys = message.keys.map((e) => Key.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AllocateIdsResponse>): AllocateIdsResponse {
    return AllocateIdsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AllocateIdsResponse>): AllocateIdsResponse {
    const message = createBaseAllocateIdsResponse();
    message.keys = object.keys?.map((e) => Key.fromPartial(e)) || [];
    return message;
  },
};

function createBaseReserveIdsRequest(): ReserveIdsRequest {
  return { projectId: "", databaseId: "", keys: [] };
}

export const ReserveIdsRequest: MessageFns<ReserveIdsRequest> = {
  encode(message: ReserveIdsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(66).string(message.projectId);
    }
    if (message.databaseId !== "") {
      writer.uint32(74).string(message.databaseId);
    }
    for (const v of message.keys) {
      Key.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReserveIdsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReserveIdsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 8:
          if (tag !== 66) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.databaseId = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.keys.push(Key.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReserveIdsRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      databaseId: isSet(object.databaseId) ? globalThis.String(object.databaseId) : "",
      keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e: any) => Key.fromJSON(e)) : [],
    };
  },

  toJSON(message: ReserveIdsRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.databaseId !== "") {
      obj.databaseId = message.databaseId;
    }
    if (message.keys?.length) {
      obj.keys = message.keys.map((e) => Key.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ReserveIdsRequest>): ReserveIdsRequest {
    return ReserveIdsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReserveIdsRequest>): ReserveIdsRequest {
    const message = createBaseReserveIdsRequest();
    message.projectId = object.projectId ?? "";
    message.databaseId = object.databaseId ?? "";
    message.keys = object.keys?.map((e) => Key.fromPartial(e)) || [];
    return message;
  },
};

function createBaseReserveIdsResponse(): ReserveIdsResponse {
  return {};
}

export const ReserveIdsResponse: MessageFns<ReserveIdsResponse> = {
  encode(_: ReserveIdsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReserveIdsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReserveIdsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ReserveIdsResponse {
    return {};
  },

  toJSON(_: ReserveIdsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<ReserveIdsResponse>): ReserveIdsResponse {
    return ReserveIdsResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ReserveIdsResponse>): ReserveIdsResponse {
    const message = createBaseReserveIdsResponse();
    return message;
  },
};

function createBaseMutation(): Mutation {
  return { insert: undefined, update: undefined, upsert: undefined, delete: undefined, baseVersion: undefined };
}

export const Mutation: MessageFns<Mutation> = {
  encode(message: Mutation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.insert !== undefined) {
      Entity.encode(message.insert, writer.uint32(34).fork()).join();
    }
    if (message.update !== undefined) {
      Entity.encode(message.update, writer.uint32(42).fork()).join();
    }
    if (message.upsert !== undefined) {
      Entity.encode(message.upsert, writer.uint32(50).fork()).join();
    }
    if (message.delete !== undefined) {
      Key.encode(message.delete, writer.uint32(58).fork()).join();
    }
    if (message.baseVersion !== undefined) {
      writer.uint32(64).int64(message.baseVersion.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Mutation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMutation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 34) {
            break;
          }

          message.insert = Entity.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.update = Entity.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.upsert = Entity.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.delete = Key.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.baseVersion = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Mutation {
    return {
      insert: isSet(object.insert) ? Entity.fromJSON(object.insert) : undefined,
      update: isSet(object.update) ? Entity.fromJSON(object.update) : undefined,
      upsert: isSet(object.upsert) ? Entity.fromJSON(object.upsert) : undefined,
      delete: isSet(object.delete) ? Key.fromJSON(object.delete) : undefined,
      baseVersion: isSet(object.baseVersion) ? Long.fromValue(object.baseVersion) : undefined,
    };
  },

  toJSON(message: Mutation): unknown {
    const obj: any = {};
    if (message.insert !== undefined) {
      obj.insert = Entity.toJSON(message.insert);
    }
    if (message.update !== undefined) {
      obj.update = Entity.toJSON(message.update);
    }
    if (message.upsert !== undefined) {
      obj.upsert = Entity.toJSON(message.upsert);
    }
    if (message.delete !== undefined) {
      obj.delete = Key.toJSON(message.delete);
    }
    if (message.baseVersion !== undefined) {
      obj.baseVersion = (message.baseVersion || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Mutation>): Mutation {
    return Mutation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Mutation>): Mutation {
    const message = createBaseMutation();
    message.insert = (object.insert !== undefined && object.insert !== null)
      ? Entity.fromPartial(object.insert)
      : undefined;
    message.update = (object.update !== undefined && object.update !== null)
      ? Entity.fromPartial(object.update)
      : undefined;
    message.upsert = (object.upsert !== undefined && object.upsert !== null)
      ? Entity.fromPartial(object.upsert)
      : undefined;
    message.delete = (object.delete !== undefined && object.delete !== null)
      ? Key.fromPartial(object.delete)
      : undefined;
    message.baseVersion = (object.baseVersion !== undefined && object.baseVersion !== null)
      ? Long.fromValue(object.baseVersion)
      : undefined;
    return message;
  },
};

function createBaseMutationResult(): MutationResult {
  return { key: undefined, version: Long.ZERO, conflictDetected: false };
}

export const MutationResult: MessageFns<MutationResult> = {
  encode(message: MutationResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== undefined) {
      Key.encode(message.key, writer.uint32(26).fork()).join();
    }
    if (!message.version.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.version.toString());
    }
    if (message.conflictDetected !== false) {
      writer.uint32(40).bool(message.conflictDetected);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MutationResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMutationResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.key = Key.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.version = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.conflictDetected = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MutationResult {
    return {
      key: isSet(object.key) ? Key.fromJSON(object.key) : undefined,
      version: isSet(object.version) ? Long.fromValue(object.version) : Long.ZERO,
      conflictDetected: isSet(object.conflictDetected) ? globalThis.Boolean(object.conflictDetected) : false,
    };
  },

  toJSON(message: MutationResult): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = Key.toJSON(message.key);
    }
    if (!message.version.equals(Long.ZERO)) {
      obj.version = (message.version || Long.ZERO).toString();
    }
    if (message.conflictDetected !== false) {
      obj.conflictDetected = message.conflictDetected;
    }
    return obj;
  },

  create(base?: DeepPartial<MutationResult>): MutationResult {
    return MutationResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MutationResult>): MutationResult {
    const message = createBaseMutationResult();
    message.key = (object.key !== undefined && object.key !== null) ? Key.fromPartial(object.key) : undefined;
    message.version = (object.version !== undefined && object.version !== null)
      ? Long.fromValue(object.version)
      : Long.ZERO;
    message.conflictDetected = object.conflictDetected ?? false;
    return message;
  },
};

function createBaseReadOptions(): ReadOptions {
  return { readConsistency: undefined, transaction: undefined };
}

export const ReadOptions: MessageFns<ReadOptions> = {
  encode(message: ReadOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.readConsistency !== undefined) {
      writer.uint32(8).int32(message.readConsistency);
    }
    if (message.transaction !== undefined) {
      writer.uint32(18).bytes(message.transaction);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReadOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.readConsistency = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transaction = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadOptions {
    return {
      readConsistency: isSet(object.readConsistency)
        ? readOptions_ReadConsistencyFromJSON(object.readConsistency)
        : undefined,
      transaction: isSet(object.transaction) ? Buffer.from(bytesFromBase64(object.transaction)) : undefined,
    };
  },

  toJSON(message: ReadOptions): unknown {
    const obj: any = {};
    if (message.readConsistency !== undefined) {
      obj.readConsistency = readOptions_ReadConsistencyToJSON(message.readConsistency);
    }
    if (message.transaction !== undefined) {
      obj.transaction = base64FromBytes(message.transaction);
    }
    return obj;
  },

  create(base?: DeepPartial<ReadOptions>): ReadOptions {
    return ReadOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReadOptions>): ReadOptions {
    const message = createBaseReadOptions();
    message.readConsistency = object.readConsistency ?? undefined;
    message.transaction = object.transaction ?? undefined;
    return message;
  },
};

function createBaseTransactionOptions(): TransactionOptions {
  return { readWrite: undefined, readOnly: undefined };
}

export const TransactionOptions: MessageFns<TransactionOptions> = {
  encode(message: TransactionOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.readWrite !== undefined) {
      TransactionOptions_ReadWrite.encode(message.readWrite, writer.uint32(10).fork()).join();
    }
    if (message.readOnly !== undefined) {
      TransactionOptions_ReadOnly.encode(message.readOnly, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.readWrite = TransactionOptions_ReadWrite.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.readOnly = TransactionOptions_ReadOnly.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionOptions {
    return {
      readWrite: isSet(object.readWrite) ? TransactionOptions_ReadWrite.fromJSON(object.readWrite) : undefined,
      readOnly: isSet(object.readOnly) ? TransactionOptions_ReadOnly.fromJSON(object.readOnly) : undefined,
    };
  },

  toJSON(message: TransactionOptions): unknown {
    const obj: any = {};
    if (message.readWrite !== undefined) {
      obj.readWrite = TransactionOptions_ReadWrite.toJSON(message.readWrite);
    }
    if (message.readOnly !== undefined) {
      obj.readOnly = TransactionOptions_ReadOnly.toJSON(message.readOnly);
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionOptions>): TransactionOptions {
    return TransactionOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionOptions>): TransactionOptions {
    const message = createBaseTransactionOptions();
    message.readWrite = (object.readWrite !== undefined && object.readWrite !== null)
      ? TransactionOptions_ReadWrite.fromPartial(object.readWrite)
      : undefined;
    message.readOnly = (object.readOnly !== undefined && object.readOnly !== null)
      ? TransactionOptions_ReadOnly.fromPartial(object.readOnly)
      : undefined;
    return message;
  },
};

function createBaseTransactionOptions_ReadWrite(): TransactionOptions_ReadWrite {
  return { previousTransaction: Buffer.alloc(0) };
}

export const TransactionOptions_ReadWrite: MessageFns<TransactionOptions_ReadWrite> = {
  encode(message: TransactionOptions_ReadWrite, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.previousTransaction.length !== 0) {
      writer.uint32(10).bytes(message.previousTransaction);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionOptions_ReadWrite {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionOptions_ReadWrite();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.previousTransaction = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionOptions_ReadWrite {
    return {
      previousTransaction: isSet(object.previousTransaction)
        ? Buffer.from(bytesFromBase64(object.previousTransaction))
        : Buffer.alloc(0),
    };
  },

  toJSON(message: TransactionOptions_ReadWrite): unknown {
    const obj: any = {};
    if (message.previousTransaction.length !== 0) {
      obj.previousTransaction = base64FromBytes(message.previousTransaction);
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionOptions_ReadWrite>): TransactionOptions_ReadWrite {
    return TransactionOptions_ReadWrite.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionOptions_ReadWrite>): TransactionOptions_ReadWrite {
    const message = createBaseTransactionOptions_ReadWrite();
    message.previousTransaction = object.previousTransaction ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseTransactionOptions_ReadOnly(): TransactionOptions_ReadOnly {
  return {};
}

export const TransactionOptions_ReadOnly: MessageFns<TransactionOptions_ReadOnly> = {
  encode(_: TransactionOptions_ReadOnly, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionOptions_ReadOnly {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionOptions_ReadOnly();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): TransactionOptions_ReadOnly {
    return {};
  },

  toJSON(_: TransactionOptions_ReadOnly): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<TransactionOptions_ReadOnly>): TransactionOptions_ReadOnly {
    return TransactionOptions_ReadOnly.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<TransactionOptions_ReadOnly>): TransactionOptions_ReadOnly {
    const message = createBaseTransactionOptions_ReadOnly();
    return message;
  },
};

/**
 * Each RPC normalizes the partition IDs of the keys in its input entities,
 * and always returns entities with keys with normalized partition IDs.
 * This applies to all keys and entities, including those in values, except keys
 * with both an empty path and an empty or unset partition ID. Normalization of
 * input keys sets the project ID (if not already set) to the project ID from
 * the request.
 */
export type DatastoreDefinition = typeof DatastoreDefinition;
export const DatastoreDefinition = {
  name: "Datastore",
  fullName: "google.datastore.v1beta3.Datastore",
  methods: {
    /** Looks up entities by key. */
    lookup: {
      name: "Lookup",
      requestType: LookupRequest,
      requestStream: false,
      responseType: LookupResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              42,
              58,
              1,
              42,
              34,
              37,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              51,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              125,
              58,
              108,
              111,
              111,
              107,
              117,
              112,
            ]),
          ],
        },
      },
    },
    /** Queries for entities. */
    runQuery: {
      name: "RunQuery",
      requestType: RunQueryRequest,
      requestStream: false,
      responseType: RunQueryResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              44,
              58,
              1,
              42,
              34,
              39,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              51,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              125,
              58,
              114,
              117,
              110,
              81,
              117,
              101,
              114,
              121,
            ]),
          ],
        },
      },
    },
    /** Begins a new transaction. */
    beginTransaction: {
      name: "BeginTransaction",
      requestType: BeginTransactionRequest,
      requestStream: false,
      responseType: BeginTransactionResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              52,
              58,
              1,
              42,
              34,
              47,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              51,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              125,
              58,
              98,
              101,
              103,
              105,
              110,
              84,
              114,
              97,
              110,
              115,
              97,
              99,
              116,
              105,
              111,
              110,
            ]),
          ],
        },
      },
    },
    /**
     * Commits a transaction, optionally creating, deleting or modifying some
     * entities.
     */
    commit: {
      name: "Commit",
      requestType: CommitRequest,
      requestStream: false,
      responseType: CommitResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              42,
              58,
              1,
              42,
              34,
              37,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              51,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              125,
              58,
              99,
              111,
              109,
              109,
              105,
              116,
            ]),
          ],
        },
      },
    },
    /** Rolls back a transaction. */
    rollback: {
      name: "Rollback",
      requestType: RollbackRequest,
      requestStream: false,
      responseType: RollbackResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              44,
              58,
              1,
              42,
              34,
              39,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              51,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              125,
              58,
              114,
              111,
              108,
              108,
              98,
              97,
              99,
              107,
            ]),
          ],
        },
      },
    },
    /**
     * Allocates IDs for the given keys, which is useful for referencing an entity
     * before it is inserted.
     */
    allocateIds: {
      name: "AllocateIds",
      requestType: AllocateIdsRequest,
      requestStream: false,
      responseType: AllocateIdsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              47,
              58,
              1,
              42,
              34,
              42,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              51,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              125,
              58,
              97,
              108,
              108,
              111,
              99,
              97,
              116,
              101,
              73,
              100,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Prevents the supplied keys' IDs from being auto-allocated by Cloud
     * Datastore.
     */
    reserveIds: {
      name: "ReserveIds",
      requestType: ReserveIdsRequest,
      requestStream: false,
      responseType: ReserveIdsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              46,
              58,
              1,
              42,
              34,
              41,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              51,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              125,
              58,
              114,
              101,
              115,
              101,
              114,
              118,
              101,
              73,
              100,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface DatastoreServiceImplementation<CallContextExt = {}> {
  /** Looks up entities by key. */
  lookup(request: LookupRequest, context: CallContext & CallContextExt): Promise<DeepPartial<LookupResponse>>;
  /** Queries for entities. */
  runQuery(request: RunQueryRequest, context: CallContext & CallContextExt): Promise<DeepPartial<RunQueryResponse>>;
  /** Begins a new transaction. */
  beginTransaction(
    request: BeginTransactionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<BeginTransactionResponse>>;
  /**
   * Commits a transaction, optionally creating, deleting or modifying some
   * entities.
   */
  commit(request: CommitRequest, context: CallContext & CallContextExt): Promise<DeepPartial<CommitResponse>>;
  /** Rolls back a transaction. */
  rollback(request: RollbackRequest, context: CallContext & CallContextExt): Promise<DeepPartial<RollbackResponse>>;
  /**
   * Allocates IDs for the given keys, which is useful for referencing an entity
   * before it is inserted.
   */
  allocateIds(
    request: AllocateIdsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<AllocateIdsResponse>>;
  /**
   * Prevents the supplied keys' IDs from being auto-allocated by Cloud
   * Datastore.
   */
  reserveIds(
    request: ReserveIdsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ReserveIdsResponse>>;
}

export interface DatastoreClient<CallOptionsExt = {}> {
  /** Looks up entities by key. */
  lookup(request: DeepPartial<LookupRequest>, options?: CallOptions & CallOptionsExt): Promise<LookupResponse>;
  /** Queries for entities. */
  runQuery(request: DeepPartial<RunQueryRequest>, options?: CallOptions & CallOptionsExt): Promise<RunQueryResponse>;
  /** Begins a new transaction. */
  beginTransaction(
    request: DeepPartial<BeginTransactionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<BeginTransactionResponse>;
  /**
   * Commits a transaction, optionally creating, deleting or modifying some
   * entities.
   */
  commit(request: DeepPartial<CommitRequest>, options?: CallOptions & CallOptionsExt): Promise<CommitResponse>;
  /** Rolls back a transaction. */
  rollback(request: DeepPartial<RollbackRequest>, options?: CallOptions & CallOptionsExt): Promise<RollbackResponse>;
  /**
   * Allocates IDs for the given keys, which is useful for referencing an entity
   * before it is inserted.
   */
  allocateIds(
    request: DeepPartial<AllocateIdsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AllocateIdsResponse>;
  /**
   * Prevents the supplied keys' IDs from being auto-allocated by Cloud
   * Datastore.
   */
  reserveIds(
    request: DeepPartial<ReserveIdsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ReserveIdsResponse>;
}

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
