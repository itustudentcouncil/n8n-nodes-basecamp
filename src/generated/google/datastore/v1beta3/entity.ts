// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/datastore/v1beta3/entity.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { NullValue, nullValueFromJSON, nullValueToJSON } from "../../protobuf/struct.js";
import { Timestamp } from "../../protobuf/timestamp.js";
import { LatLng } from "../../type/latlng.js";

export const protobufPackage = "google.datastore.v1beta3";

/**
 * A partition ID identifies a grouping of entities. The grouping is always
 * by project and namespace, however the namespace ID may be empty.
 *
 * A partition ID contains several dimensions:
 * project ID and namespace ID.
 *
 * Partition dimensions:
 *
 * - May be `""`.
 * - Must be valid UTF-8 bytes.
 * - Must have values that match regex `[A-Za-z\d\.\-_]{1,100}`
 * If the value of any dimension matches regex `__.*__`, the partition is
 * reserved/read-only.
 * A reserved/read-only partition ID is forbidden in certain documented
 * contexts.
 *
 * Foreign partition IDs (in which the project ID does
 * not match the context project ID ) are discouraged.
 * Reads and writes of foreign partition IDs may fail if the project is not in
 * an active state.
 */
export interface PartitionId {
  /** The ID of the project to which the entities belong. */
  projectId: string;
  /** If not empty, the ID of the namespace to which the entities belong. */
  namespaceId: string;
}

/**
 * A unique identifier for an entity.
 * If a key's partition ID or any of its path kinds or names are
 * reserved/read-only, the key is reserved/read-only.
 * A reserved/read-only key is forbidden in certain documented contexts.
 */
export interface Key {
  /**
   * Entities are partitioned into subsets, currently identified by a project
   * ID and namespace ID.
   * Queries are scoped to a single partition.
   */
  partitionId:
    | PartitionId
    | undefined;
  /**
   * The entity path.
   * An entity path consists of one or more elements composed of a kind and a
   * string or numerical identifier, which identify entities. The first
   * element identifies a _root entity_, the second element identifies
   * a _child_ of the root entity, the third element identifies a child of the
   * second entity, and so forth. The entities identified by all prefixes of
   * the path are called the element's _ancestors_.
   *
   * An entity path is always fully complete: *all* of the entity's ancestors
   * are required to be in the path along with the entity identifier itself.
   * The only exception is that in some documented cases, the identifier in the
   * last path element (for the entity) itself may be omitted. For example,
   * the last path element of the key of `Mutation.insert` may have no
   * identifier.
   *
   * A path can never be empty, and a path can have at most 100 elements.
   */
  path: Key_PathElement[];
}

/**
 * A (kind, ID/name) pair used to construct a key path.
 *
 * If either name or ID is set, the element is complete.
 * If neither is set, the element is incomplete.
 */
export interface Key_PathElement {
  /**
   * The kind of the entity.
   * A kind matching regex `__.*__` is reserved/read-only.
   * A kind must not contain more than 1500 bytes when UTF-8 encoded.
   * Cannot be `""`.
   */
  kind: string;
  /**
   * The auto-allocated ID of the entity.
   * Never equal to zero. Values less than zero are discouraged and may not
   * be supported in the future.
   */
  id?:
    | Long
    | undefined;
  /**
   * The name of the entity.
   * A name matching regex `__.*__` is reserved/read-only.
   * A name must not be more than 1500 bytes when UTF-8 encoded.
   * Cannot be `""`.
   */
  name?: string | undefined;
}

/** An array value. */
export interface ArrayValue {
  /**
   * Values in the array.
   * The order of this array may not be preserved if it contains a mix of
   * indexed and unindexed values.
   */
  values: Value[];
}

/**
 * A message that can hold any of the supported value types and associated
 * metadata.
 */
export interface Value {
  /** A null value. */
  nullValue?:
    | NullValue
    | undefined;
  /** A boolean value. */
  booleanValue?:
    | boolean
    | undefined;
  /** An integer value. */
  integerValue?:
    | Long
    | undefined;
  /** A double value. */
  doubleValue?:
    | number
    | undefined;
  /**
   * A timestamp value.
   * When stored in the Datastore, precise only to microseconds;
   * any additional precision is rounded down.
   */
  timestampValue?:
    | Date
    | undefined;
  /** A key value. */
  keyValue?:
    | Key
    | undefined;
  /**
   * A UTF-8 encoded string value.
   * When `exclude_from_indexes` is false (it is indexed), may have at most
   * 1500 bytes. Otherwise, may be set to at most 1,000,000 bytes.
   */
  stringValue?:
    | string
    | undefined;
  /**
   * A blob value.
   * May have at most 1,000,000 bytes.
   * When `exclude_from_indexes` is false, may have at most 1500 bytes.
   * In JSON requests, must be base64-encoded.
   */
  blobValue?:
    | Buffer
    | undefined;
  /** A geo point value representing a point on the surface of Earth. */
  geoPointValue?:
    | LatLng
    | undefined;
  /**
   * An entity value.
   *
   * - May have no key.
   * - May have a key with an incomplete key path.
   * - May have a reserved/read-only key.
   */
  entityValue?:
    | Entity
    | undefined;
  /**
   * An array value.
   * Cannot contain another array value.
   * A `Value` instance that sets field `array_value` must not set fields
   * `meaning` or `exclude_from_indexes`.
   */
  arrayValue?:
    | ArrayValue
    | undefined;
  /** The `meaning` field should only be populated for backwards compatibility. */
  meaning: number;
  /**
   * If the value should be excluded from all indexes including those defined
   * explicitly.
   */
  excludeFromIndexes: boolean;
}

/**
 * A Datastore data object.
 *
 * An entity is limited to 1 megabyte when stored. That _roughly_
 * corresponds to a limit of 1 megabyte for the serialized form of this
 * message.
 */
export interface Entity {
  /**
   * The entity's key.
   *
   * An entity must have a key, unless otherwise documented (for example,
   * an entity in `Value.entity_value` may have no key).
   * An entity's kind is its key path's last element's kind,
   * or null if it has no key.
   */
  key:
    | Key
    | undefined;
  /**
   * The entity's properties.
   * The map's keys are property names.
   * A property name matching regex `__.*__` is reserved.
   * A reserved property name is forbidden in certain documented contexts.
   * The name must not contain more than 500 characters.
   * The name cannot be `""`.
   */
  properties: { [key: string]: Value };
}

export interface Entity_PropertiesEntry {
  key: string;
  value: Value | undefined;
}

function createBasePartitionId(): PartitionId {
  return { projectId: "", namespaceId: "" };
}

export const PartitionId: MessageFns<PartitionId> = {
  encode(message: PartitionId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(18).string(message.projectId);
    }
    if (message.namespaceId !== "") {
      writer.uint32(34).string(message.namespaceId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PartitionId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePartitionId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.namespaceId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PartitionId {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      namespaceId: isSet(object.namespaceId) ? globalThis.String(object.namespaceId) : "",
    };
  },

  toJSON(message: PartitionId): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.namespaceId !== "") {
      obj.namespaceId = message.namespaceId;
    }
    return obj;
  },

  create(base?: DeepPartial<PartitionId>): PartitionId {
    return PartitionId.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PartitionId>): PartitionId {
    const message = createBasePartitionId();
    message.projectId = object.projectId ?? "";
    message.namespaceId = object.namespaceId ?? "";
    return message;
  },
};

function createBaseKey(): Key {
  return { partitionId: undefined, path: [] };
}

export const Key: MessageFns<Key> = {
  encode(message: Key, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.partitionId !== undefined) {
      PartitionId.encode(message.partitionId, writer.uint32(10).fork()).join();
    }
    for (const v of message.path) {
      Key_PathElement.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Key {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.partitionId = PartitionId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.path.push(Key_PathElement.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Key {
    return {
      partitionId: isSet(object.partitionId) ? PartitionId.fromJSON(object.partitionId) : undefined,
      path: globalThis.Array.isArray(object?.path) ? object.path.map((e: any) => Key_PathElement.fromJSON(e)) : [],
    };
  },

  toJSON(message: Key): unknown {
    const obj: any = {};
    if (message.partitionId !== undefined) {
      obj.partitionId = PartitionId.toJSON(message.partitionId);
    }
    if (message.path?.length) {
      obj.path = message.path.map((e) => Key_PathElement.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Key>): Key {
    return Key.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Key>): Key {
    const message = createBaseKey();
    message.partitionId = (object.partitionId !== undefined && object.partitionId !== null)
      ? PartitionId.fromPartial(object.partitionId)
      : undefined;
    message.path = object.path?.map((e) => Key_PathElement.fromPartial(e)) || [];
    return message;
  },
};

function createBaseKey_PathElement(): Key_PathElement {
  return { kind: "", id: undefined, name: undefined };
}

export const Key_PathElement: MessageFns<Key_PathElement> = {
  encode(message: Key_PathElement, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    if (message.id !== undefined) {
      writer.uint32(16).int64(message.id.toString());
    }
    if (message.name !== undefined) {
      writer.uint32(26).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Key_PathElement {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKey_PathElement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.kind = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.id = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Key_PathElement {
    return {
      kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
      id: isSet(object.id) ? Long.fromValue(object.id) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
    };
  },

  toJSON(message: Key_PathElement): unknown {
    const obj: any = {};
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.id !== undefined) {
      obj.id = (message.id || Long.ZERO).toString();
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<Key_PathElement>): Key_PathElement {
    return Key_PathElement.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Key_PathElement>): Key_PathElement {
    const message = createBaseKey_PathElement();
    message.kind = object.kind ?? "";
    message.id = (object.id !== undefined && object.id !== null) ? Long.fromValue(object.id) : undefined;
    message.name = object.name ?? undefined;
    return message;
  },
};

function createBaseArrayValue(): ArrayValue {
  return { values: [] };
}

export const ArrayValue: MessageFns<ArrayValue> = {
  encode(message: ArrayValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.values) {
      Value.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ArrayValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArrayValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.values.push(Value.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ArrayValue {
    return { values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => Value.fromJSON(e)) : [] };
  },

  toJSON(message: ArrayValue): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values.map((e) => Value.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ArrayValue>): ArrayValue {
    return ArrayValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ArrayValue>): ArrayValue {
    const message = createBaseArrayValue();
    message.values = object.values?.map((e) => Value.fromPartial(e)) || [];
    return message;
  },
};

function createBaseValue(): Value {
  return {
    nullValue: undefined,
    booleanValue: undefined,
    integerValue: undefined,
    doubleValue: undefined,
    timestampValue: undefined,
    keyValue: undefined,
    stringValue: undefined,
    blobValue: undefined,
    geoPointValue: undefined,
    entityValue: undefined,
    arrayValue: undefined,
    meaning: 0,
    excludeFromIndexes: false,
  };
}

export const Value: MessageFns<Value> = {
  encode(message: Value, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nullValue !== undefined) {
      writer.uint32(88).int32(message.nullValue);
    }
    if (message.booleanValue !== undefined) {
      writer.uint32(8).bool(message.booleanValue);
    }
    if (message.integerValue !== undefined) {
      writer.uint32(16).int64(message.integerValue.toString());
    }
    if (message.doubleValue !== undefined) {
      writer.uint32(25).double(message.doubleValue);
    }
    if (message.timestampValue !== undefined) {
      Timestamp.encode(toTimestamp(message.timestampValue), writer.uint32(82).fork()).join();
    }
    if (message.keyValue !== undefined) {
      Key.encode(message.keyValue, writer.uint32(42).fork()).join();
    }
    if (message.stringValue !== undefined) {
      writer.uint32(138).string(message.stringValue);
    }
    if (message.blobValue !== undefined) {
      writer.uint32(146).bytes(message.blobValue);
    }
    if (message.geoPointValue !== undefined) {
      LatLng.encode(message.geoPointValue, writer.uint32(66).fork()).join();
    }
    if (message.entityValue !== undefined) {
      Entity.encode(message.entityValue, writer.uint32(50).fork()).join();
    }
    if (message.arrayValue !== undefined) {
      ArrayValue.encode(message.arrayValue, writer.uint32(74).fork()).join();
    }
    if (message.meaning !== 0) {
      writer.uint32(112).int32(message.meaning);
    }
    if (message.excludeFromIndexes !== false) {
      writer.uint32(152).bool(message.excludeFromIndexes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Value {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 11:
          if (tag !== 88) {
            break;
          }

          message.nullValue = reader.int32() as any;
          continue;
        case 1:
          if (tag !== 8) {
            break;
          }

          message.booleanValue = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.integerValue = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.doubleValue = reader.double();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.timestampValue = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.keyValue = Key.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.stringValue = reader.string();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.blobValue = Buffer.from(reader.bytes());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.geoPointValue = LatLng.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.entityValue = Entity.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.arrayValue = ArrayValue.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.meaning = reader.int32();
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.excludeFromIndexes = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Value {
    return {
      nullValue: isSet(object.nullValue) ? nullValueFromJSON(object.nullValue) : undefined,
      booleanValue: isSet(object.booleanValue) ? globalThis.Boolean(object.booleanValue) : undefined,
      integerValue: isSet(object.integerValue) ? Long.fromValue(object.integerValue) : undefined,
      doubleValue: isSet(object.doubleValue) ? globalThis.Number(object.doubleValue) : undefined,
      timestampValue: isSet(object.timestampValue) ? fromJsonTimestamp(object.timestampValue) : undefined,
      keyValue: isSet(object.keyValue) ? Key.fromJSON(object.keyValue) : undefined,
      stringValue: isSet(object.stringValue) ? globalThis.String(object.stringValue) : undefined,
      blobValue: isSet(object.blobValue) ? Buffer.from(bytesFromBase64(object.blobValue)) : undefined,
      geoPointValue: isSet(object.geoPointValue) ? LatLng.fromJSON(object.geoPointValue) : undefined,
      entityValue: isSet(object.entityValue) ? Entity.fromJSON(object.entityValue) : undefined,
      arrayValue: isSet(object.arrayValue) ? ArrayValue.fromJSON(object.arrayValue) : undefined,
      meaning: isSet(object.meaning) ? globalThis.Number(object.meaning) : 0,
      excludeFromIndexes: isSet(object.excludeFromIndexes) ? globalThis.Boolean(object.excludeFromIndexes) : false,
    };
  },

  toJSON(message: Value): unknown {
    const obj: any = {};
    if (message.nullValue !== undefined) {
      obj.nullValue = nullValueToJSON(message.nullValue);
    }
    if (message.booleanValue !== undefined) {
      obj.booleanValue = message.booleanValue;
    }
    if (message.integerValue !== undefined) {
      obj.integerValue = (message.integerValue || Long.ZERO).toString();
    }
    if (message.doubleValue !== undefined) {
      obj.doubleValue = message.doubleValue;
    }
    if (message.timestampValue !== undefined) {
      obj.timestampValue = message.timestampValue.toISOString();
    }
    if (message.keyValue !== undefined) {
      obj.keyValue = Key.toJSON(message.keyValue);
    }
    if (message.stringValue !== undefined) {
      obj.stringValue = message.stringValue;
    }
    if (message.blobValue !== undefined) {
      obj.blobValue = base64FromBytes(message.blobValue);
    }
    if (message.geoPointValue !== undefined) {
      obj.geoPointValue = LatLng.toJSON(message.geoPointValue);
    }
    if (message.entityValue !== undefined) {
      obj.entityValue = Entity.toJSON(message.entityValue);
    }
    if (message.arrayValue !== undefined) {
      obj.arrayValue = ArrayValue.toJSON(message.arrayValue);
    }
    if (message.meaning !== 0) {
      obj.meaning = Math.round(message.meaning);
    }
    if (message.excludeFromIndexes !== false) {
      obj.excludeFromIndexes = message.excludeFromIndexes;
    }
    return obj;
  },

  create(base?: DeepPartial<Value>): Value {
    return Value.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Value>): Value {
    const message = createBaseValue();
    message.nullValue = object.nullValue ?? undefined;
    message.booleanValue = object.booleanValue ?? undefined;
    message.integerValue = (object.integerValue !== undefined && object.integerValue !== null)
      ? Long.fromValue(object.integerValue)
      : undefined;
    message.doubleValue = object.doubleValue ?? undefined;
    message.timestampValue = object.timestampValue ?? undefined;
    message.keyValue = (object.keyValue !== undefined && object.keyValue !== null)
      ? Key.fromPartial(object.keyValue)
      : undefined;
    message.stringValue = object.stringValue ?? undefined;
    message.blobValue = object.blobValue ?? undefined;
    message.geoPointValue = (object.geoPointValue !== undefined && object.geoPointValue !== null)
      ? LatLng.fromPartial(object.geoPointValue)
      : undefined;
    message.entityValue = (object.entityValue !== undefined && object.entityValue !== null)
      ? Entity.fromPartial(object.entityValue)
      : undefined;
    message.arrayValue = (object.arrayValue !== undefined && object.arrayValue !== null)
      ? ArrayValue.fromPartial(object.arrayValue)
      : undefined;
    message.meaning = object.meaning ?? 0;
    message.excludeFromIndexes = object.excludeFromIndexes ?? false;
    return message;
  },
};

function createBaseEntity(): Entity {
  return { key: undefined, properties: {} };
}

export const Entity: MessageFns<Entity> = {
  encode(message: Entity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== undefined) {
      Key.encode(message.key, writer.uint32(10).fork()).join();
    }
    Object.entries(message.properties).forEach(([key, value]) => {
      Entity_PropertiesEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Entity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = Key.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = Entity_PropertiesEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.properties[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Entity {
    return {
      key: isSet(object.key) ? Key.fromJSON(object.key) : undefined,
      properties: isObject(object.properties)
        ? Object.entries(object.properties).reduce<{ [key: string]: Value }>((acc, [key, value]) => {
          acc[key] = Value.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Entity): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = Key.toJSON(message.key);
    }
    if (message.properties) {
      const entries = Object.entries(message.properties);
      if (entries.length > 0) {
        obj.properties = {};
        entries.forEach(([k, v]) => {
          obj.properties[k] = Value.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<Entity>): Entity {
    return Entity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Entity>): Entity {
    const message = createBaseEntity();
    message.key = (object.key !== undefined && object.key !== null) ? Key.fromPartial(object.key) : undefined;
    message.properties = Object.entries(object.properties ?? {}).reduce<{ [key: string]: Value }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Value.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseEntity_PropertiesEntry(): Entity_PropertiesEntry {
  return { key: "", value: undefined };
}

export const Entity_PropertiesEntry: MessageFns<Entity_PropertiesEntry> = {
  encode(message: Entity_PropertiesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Value.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Entity_PropertiesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntity_PropertiesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Value.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Entity_PropertiesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Value.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Entity_PropertiesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Value.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<Entity_PropertiesEntry>): Entity_PropertiesEntry {
    return Entity_PropertiesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Entity_PropertiesEntry>): Entity_PropertiesEntry {
    const message = createBaseEntity_PropertiesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Value.fromPartial(object.value) : undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
