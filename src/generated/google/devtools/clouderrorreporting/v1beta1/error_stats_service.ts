// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/devtools/clouderrorreporting/v1beta1/error_stats_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Duration } from "../../../protobuf/duration.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { ErrorEvent, ErrorGroup, ServiceContext } from "./common.js";

export const protobufPackage = "google.devtools.clouderrorreporting.v1beta1";

/** Specifies how the time periods of error group counts are aligned. */
export enum TimedCountAlignment {
  /** ERROR_COUNT_ALIGNMENT_UNSPECIFIED - No alignment specified. */
  ERROR_COUNT_ALIGNMENT_UNSPECIFIED = 0,
  /**
   * ALIGNMENT_EQUAL_ROUNDED - The time periods shall be consecutive, have width equal to the
   * requested duration, and be aligned at the
   * [alignment_time]
   * [google.devtools.clouderrorreporting.v1beta1.ListGroupStatsRequest.alignment_time]
   * provided in the request.
   *
   * The [alignment_time]
   * [google.devtools.clouderrorreporting.v1beta1.ListGroupStatsRequest.alignment_time]
   * does not have to be inside the query period but even if it is outside, only
   * time periods are returned which overlap with the query period.
   *
   * A rounded alignment will typically result in a different size of the first
   * or the last time period.
   */
  ALIGNMENT_EQUAL_ROUNDED = 1,
  /**
   * ALIGNMENT_EQUAL_AT_END - The time periods shall be consecutive, have width equal to the
   * requested duration, and be aligned at the end of the requested time
   * period. This can result in a different size of the
   * first time period.
   */
  ALIGNMENT_EQUAL_AT_END = 2,
  UNRECOGNIZED = -1,
}

export function timedCountAlignmentFromJSON(object: any): TimedCountAlignment {
  switch (object) {
    case 0:
    case "ERROR_COUNT_ALIGNMENT_UNSPECIFIED":
      return TimedCountAlignment.ERROR_COUNT_ALIGNMENT_UNSPECIFIED;
    case 1:
    case "ALIGNMENT_EQUAL_ROUNDED":
      return TimedCountAlignment.ALIGNMENT_EQUAL_ROUNDED;
    case 2:
    case "ALIGNMENT_EQUAL_AT_END":
      return TimedCountAlignment.ALIGNMENT_EQUAL_AT_END;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TimedCountAlignment.UNRECOGNIZED;
  }
}

export function timedCountAlignmentToJSON(object: TimedCountAlignment): string {
  switch (object) {
    case TimedCountAlignment.ERROR_COUNT_ALIGNMENT_UNSPECIFIED:
      return "ERROR_COUNT_ALIGNMENT_UNSPECIFIED";
    case TimedCountAlignment.ALIGNMENT_EQUAL_ROUNDED:
      return "ALIGNMENT_EQUAL_ROUNDED";
    case TimedCountAlignment.ALIGNMENT_EQUAL_AT_END:
      return "ALIGNMENT_EQUAL_AT_END";
    case TimedCountAlignment.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A sorting order of error groups. */
export enum ErrorGroupOrder {
  /** GROUP_ORDER_UNSPECIFIED - No group order specified. */
  GROUP_ORDER_UNSPECIFIED = 0,
  /** COUNT_DESC - Total count of errors in the given time window in descending order. */
  COUNT_DESC = 1,
  /**
   * LAST_SEEN_DESC - Timestamp when the group was last seen in the given time window
   * in descending order.
   */
  LAST_SEEN_DESC = 2,
  /** CREATED_DESC - Timestamp when the group was created in descending order. */
  CREATED_DESC = 3,
  /** AFFECTED_USERS_DESC - Number of affected users in the given time window in descending order. */
  AFFECTED_USERS_DESC = 4,
  UNRECOGNIZED = -1,
}

export function errorGroupOrderFromJSON(object: any): ErrorGroupOrder {
  switch (object) {
    case 0:
    case "GROUP_ORDER_UNSPECIFIED":
      return ErrorGroupOrder.GROUP_ORDER_UNSPECIFIED;
    case 1:
    case "COUNT_DESC":
      return ErrorGroupOrder.COUNT_DESC;
    case 2:
    case "LAST_SEEN_DESC":
      return ErrorGroupOrder.LAST_SEEN_DESC;
    case 3:
    case "CREATED_DESC":
      return ErrorGroupOrder.CREATED_DESC;
    case 4:
    case "AFFECTED_USERS_DESC":
      return ErrorGroupOrder.AFFECTED_USERS_DESC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ErrorGroupOrder.UNRECOGNIZED;
  }
}

export function errorGroupOrderToJSON(object: ErrorGroupOrder): string {
  switch (object) {
    case ErrorGroupOrder.GROUP_ORDER_UNSPECIFIED:
      return "GROUP_ORDER_UNSPECIFIED";
    case ErrorGroupOrder.COUNT_DESC:
      return "COUNT_DESC";
    case ErrorGroupOrder.LAST_SEEN_DESC:
      return "LAST_SEEN_DESC";
    case ErrorGroupOrder.CREATED_DESC:
      return "CREATED_DESC";
    case ErrorGroupOrder.AFFECTED_USERS_DESC:
      return "AFFECTED_USERS_DESC";
    case ErrorGroupOrder.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Specifies a set of `ErrorGroupStats` to return. */
export interface ListGroupStatsRequest {
  /**
   * Required. The resource name of the Google Cloud Platform project. Written
   * as `projects/{projectID}` or `projects/{projectNumber}`, where
   * `{projectID}` and `{projectNumber}` can be found in the
   * [Google Cloud console](https://support.google.com/cloud/answer/6158840).
   * It may also include a location, such as
   * `projects/{projectID}/locations/{location}` where `{location}` is a cloud
   * region.
   *
   * Examples: `projects/my-project-123`, `projects/5551234`,
   * `projects/my-project-123/locations/us-central1`,
   * `projects/5551234/locations/us-central1`.
   *
   * For a list of supported locations, see [Supported
   * Regions](https://cloud.google.com/logging/docs/region-support). `global` is
   * the default when unspecified. Use `-` as a wildcard to request group stats
   * from all regions.
   */
  projectName: string;
  /**
   * Optional. List all [ErrorGroupStats]
   * [google.devtools.clouderrorreporting.v1beta1.ErrorGroupStats] with these
   * IDs. The `group_id` is a unique identifier for a particular error group.
   * The identifier is derived from key parts of the error-log content and is
   * treated as Service Data. For information about how Service Data
   * is handled, see [Google Cloud Privacy Notice]
   * (https://cloud.google.com/terms/cloud-privacy-notice).
   */
  groupId: string[];
  /**
   * Optional. List only [ErrorGroupStats]
   * [google.devtools.clouderrorreporting.v1beta1.ErrorGroupStats] which belong
   * to a service context that matches the filter. Data for all service contexts
   * is returned if this field is not specified.
   */
  serviceFilter:
    | ServiceContextFilter
    | undefined;
  /**
   * Optional. List data for the given time range.
   * If not set, a default time range is used. The field
   * [time_range_begin]
   * [google.devtools.clouderrorreporting.v1beta1.ListGroupStatsResponse.time_range_begin]
   * in the response will specify the beginning of this time range. Only
   * [ErrorGroupStats]
   * [google.devtools.clouderrorreporting.v1beta1.ErrorGroupStats] with a
   * non-zero count in the given time range are returned, unless the request
   * contains an explicit [group_id]
   * [google.devtools.clouderrorreporting.v1beta1.ListGroupStatsRequest.group_id]
   * list. If a [group_id]
   * [google.devtools.clouderrorreporting.v1beta1.ListGroupStatsRequest.group_id]
   * list is given, also [ErrorGroupStats]
   * [google.devtools.clouderrorreporting.v1beta1.ErrorGroupStats] with zero
   * occurrences are returned.
   */
  timeRange:
    | QueryTimeRange
    | undefined;
  /**
   * Optional. The preferred duration for a single returned [TimedCount]
   * [google.devtools.clouderrorreporting.v1beta1.TimedCount]. If not set, no
   * timed counts are returned.
   */
  timedCountDuration:
    | Duration
    | undefined;
  /**
   * Optional. The alignment of the timed counts to be returned.
   * Default is `ALIGNMENT_EQUAL_AT_END`.
   */
  alignment: TimedCountAlignment;
  /**
   * Optional. Time where the timed counts shall be aligned if rounded
   * alignment is chosen. Default is 00:00 UTC.
   */
  alignmentTime:
    | Date
    | undefined;
  /**
   * Optional. The sort order in which the results are returned.
   * Default is `COUNT_DESC`.
   */
  order: ErrorGroupOrder;
  /**
   * Optional. The maximum number of results to return per response.
   * Default is 20.
   */
  pageSize: number;
  /**
   * Optional. A [next_page_token]
   * [google.devtools.clouderrorreporting.v1beta1.ListGroupStatsResponse.next_page_token]
   * provided by a previous response. To view additional results, pass this
   * token along with the identical query parameters as the first request.
   */
  pageToken: string;
}

/** Contains a set of requested error group stats. */
export interface ListGroupStatsResponse {
  /** The error group stats which match the given request. */
  errorGroupStats: ErrorGroupStats[];
  /**
   * If non-empty, more results are available.
   * Pass this token, along with the same query parameters as the first
   * request, to view the next page of results.
   */
  nextPageToken: string;
  /**
   * The timestamp specifies the start time to which the request was restricted.
   * The start time is set based on the requested time range. It may be adjusted
   * to a later time if a project has exceeded the storage quota and older data
   * has been deleted.
   */
  timeRangeBegin: Date | undefined;
}

/**
 * Data extracted for a specific group based on certain filter criteria,
 * such as a given time period and/or service filter.
 */
export interface ErrorGroupStats {
  /** Group data that is independent of the filter criteria. */
  group:
    | ErrorGroup
    | undefined;
  /**
   * Approximate total number of events in the given group that match
   * the filter criteria.
   */
  count: Long;
  /**
   * Approximate number of affected users in the given group that
   * match the filter criteria.
   * Users are distinguished by data in the [ErrorContext]
   * [google.devtools.clouderrorreporting.v1beta1.ErrorContext] of the
   * individual error events, such as their login name or their remote
   * IP address in case of HTTP requests.
   * The number of affected users can be zero even if the number of
   * errors is non-zero if no data was provided from which the
   * affected user could be deduced.
   * Users are counted based on data in the request
   * context that was provided in the error report. If more users are
   * implicitly affected, such as due to a crash of the whole service,
   * this is not reflected here.
   */
  affectedUsersCount: Long;
  /**
   * Approximate number of occurrences over time.
   * Timed counts returned by ListGroups are guaranteed to be:
   *
   * - Inside the requested time interval
   * - Non-overlapping, and
   * - Ordered by ascending time.
   */
  timedCounts: TimedCount[];
  /**
   * Approximate first occurrence that was ever seen for this group
   * and which matches the given filter criteria, ignoring the
   * time_range that was specified in the request.
   */
  firstSeenTime:
    | Date
    | undefined;
  /**
   * Approximate last occurrence that was ever seen for this group and
   * which matches the given filter criteria, ignoring the time_range
   * that was specified in the request.
   */
  lastSeenTime:
    | Date
    | undefined;
  /**
   * Service contexts with a non-zero error count for the given filter
   * criteria. This list can be truncated if multiple services are affected.
   * Refer to `num_affected_services` for the total count.
   */
  affectedServices: ServiceContext[];
  /**
   * The total number of services with a non-zero error count for the given
   * filter criteria.
   */
  numAffectedServices: number;
  /**
   * An arbitrary event that is chosen as representative for the whole group.
   * The representative event is intended to be used as a quick preview for
   * the whole group. Events in the group are usually sufficiently similar
   * to each other such that showing an arbitrary representative provides
   * insight into the characteristics of the group as a whole.
   */
  representative: ErrorEvent | undefined;
}

/**
 * The number of errors in a given time period.
 * All numbers are approximate since the error events are sampled
 * before counting them.
 */
export interface TimedCount {
  /** Approximate number of occurrences in the given time period. */
  count: Long;
  /** Start of the time period to which `count` refers (included). */
  startTime:
    | Date
    | undefined;
  /** End of the time period to which `count` refers (excluded). */
  endTime: Date | undefined;
}

/** Specifies a set of error events to return. */
export interface ListEventsRequest {
  /**
   * Required. The resource name of the Google Cloud Platform project. Written
   * as `projects/{projectID}` or `projects/{projectID}/locations/{location}`,
   * where `{projectID}` is the [Google Cloud Platform project
   * ID](https://support.google.com/cloud/answer/6158840) and `{location}` is
   * a Cloud region.
   *
   * Examples: `projects/my-project-123`,
   * `projects/my-project-123/locations/global`.
   *
   * For a list of supported locations, see [Supported
   * Regions](https://cloud.google.com/logging/docs/region-support). `global` is
   * the default when unspecified.
   */
  projectName: string;
  /**
   * Required. The group for which events shall be returned.
   * The `group_id` is a unique identifier for a particular error group. The
   * identifier is derived from key parts of the error-log content and is
   * treated as Service Data. For information about how Service Data
   * is handled, see [Google Cloud Privacy
   * Notice](https://cloud.google.com/terms/cloud-privacy-notice).
   */
  groupId: string;
  /**
   * Optional. List only ErrorGroups which belong to a service context that
   * matches the filter.
   * Data for all service contexts is returned if this field is not specified.
   */
  serviceFilter:
    | ServiceContextFilter
    | undefined;
  /**
   * Optional. List only data for the given time range.
   * If not set a default time range is used. The field time_range_begin
   * in the response will specify the beginning of this time range.
   */
  timeRange:
    | QueryTimeRange
    | undefined;
  /** Optional. The maximum number of results to return per response. */
  pageSize: number;
  /** Optional. A `next_page_token` provided by a previous response. */
  pageToken: string;
}

/** Contains a set of requested error events. */
export interface ListEventsResponse {
  /** The error events which match the given request. */
  errorEvents: ErrorEvent[];
  /**
   * If non-empty, more results are available.
   * Pass this token, along with the same query parameters as the first
   * request, to view the next page of results.
   */
  nextPageToken: string;
  /** The timestamp specifies the start time to which the request was restricted. */
  timeRangeBegin: Date | undefined;
}

/**
 * A time range for which error group data shall be displayed.
 * Query time ranges end at 'now'.
 * When longer time ranges are selected, the resolution of the data decreases.
 * The description of each time range below indicates the suggested minimum
 * timed count duration for that range.
 *
 * Requests might be rejected or the resulting timed count durations might be
 * adjusted for lower durations.
 */
export interface QueryTimeRange {
  /** Restricts the query to the specified time range. */
  period: QueryTimeRange_Period;
}

/** The supported time ranges. */
export enum QueryTimeRange_Period {
  /** PERIOD_UNSPECIFIED - Do not use. */
  PERIOD_UNSPECIFIED = 0,
  /**
   * PERIOD_1_HOUR - Retrieve data for the last hour.
   * Recommended minimum timed count duration: 1 min.
   */
  PERIOD_1_HOUR = 1,
  /**
   * PERIOD_6_HOURS - Retrieve data for the last 6 hours.
   * Recommended minimum timed count duration: 10 min.
   */
  PERIOD_6_HOURS = 2,
  /**
   * PERIOD_1_DAY - Retrieve data for the last day.
   * Recommended minimum timed count duration: 1 hour.
   */
  PERIOD_1_DAY = 3,
  /**
   * PERIOD_1_WEEK - Retrieve data for the last week.
   * Recommended minimum timed count duration: 6 hours.
   */
  PERIOD_1_WEEK = 4,
  /**
   * PERIOD_30_DAYS - Retrieve data for the last 30 days.
   * Recommended minimum timed count duration: 1 day.
   */
  PERIOD_30_DAYS = 5,
  UNRECOGNIZED = -1,
}

export function queryTimeRange_PeriodFromJSON(object: any): QueryTimeRange_Period {
  switch (object) {
    case 0:
    case "PERIOD_UNSPECIFIED":
      return QueryTimeRange_Period.PERIOD_UNSPECIFIED;
    case 1:
    case "PERIOD_1_HOUR":
      return QueryTimeRange_Period.PERIOD_1_HOUR;
    case 2:
    case "PERIOD_6_HOURS":
      return QueryTimeRange_Period.PERIOD_6_HOURS;
    case 3:
    case "PERIOD_1_DAY":
      return QueryTimeRange_Period.PERIOD_1_DAY;
    case 4:
    case "PERIOD_1_WEEK":
      return QueryTimeRange_Period.PERIOD_1_WEEK;
    case 5:
    case "PERIOD_30_DAYS":
      return QueryTimeRange_Period.PERIOD_30_DAYS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return QueryTimeRange_Period.UNRECOGNIZED;
  }
}

export function queryTimeRange_PeriodToJSON(object: QueryTimeRange_Period): string {
  switch (object) {
    case QueryTimeRange_Period.PERIOD_UNSPECIFIED:
      return "PERIOD_UNSPECIFIED";
    case QueryTimeRange_Period.PERIOD_1_HOUR:
      return "PERIOD_1_HOUR";
    case QueryTimeRange_Period.PERIOD_6_HOURS:
      return "PERIOD_6_HOURS";
    case QueryTimeRange_Period.PERIOD_1_DAY:
      return "PERIOD_1_DAY";
    case QueryTimeRange_Period.PERIOD_1_WEEK:
      return "PERIOD_1_WEEK";
    case QueryTimeRange_Period.PERIOD_30_DAYS:
      return "PERIOD_30_DAYS";
    case QueryTimeRange_Period.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Specifies criteria for filtering a subset of service contexts.
 * The fields in the filter correspond to the fields in `ServiceContext`.
 * Only exact, case-sensitive matches are supported.
 * If a field is unset or empty, it matches arbitrary values.
 */
export interface ServiceContextFilter {
  /**
   * Optional. The exact value to match against
   * [`ServiceContext.service`](/error-reporting/reference/rest/v1beta1/ServiceContext#FIELDS.service).
   */
  service: string;
  /**
   * Optional. The exact value to match against
   * [`ServiceContext.version`](/error-reporting/reference/rest/v1beta1/ServiceContext#FIELDS.version).
   */
  version: string;
  /**
   * Optional. The exact value to match against
   * [`ServiceContext.resource_type`](/error-reporting/reference/rest/v1beta1/ServiceContext#FIELDS.resource_type).
   */
  resourceType: string;
}

/** Deletes all events in the project. */
export interface DeleteEventsRequest {
  /**
   * Required. The resource name of the Google Cloud Platform project. Written
   * as `projects/{projectID}` or `projects/{projectID}/locations/{location}`,
   * where `{projectID}` is the [Google Cloud Platform project
   * ID](https://support.google.com/cloud/answer/6158840) and `{location}` is
   * a Cloud region.
   *
   * Examples: `projects/my-project-123`,
   * `projects/my-project-123/locations/global`.
   *
   * For a list of supported locations, see [Supported
   * Regions](https://cloud.google.com/logging/docs/region-support). `global` is
   * the default when unspecified.
   */
  projectName: string;
}

/** Response message for deleting error events. */
export interface DeleteEventsResponse {
}

function createBaseListGroupStatsRequest(): ListGroupStatsRequest {
  return {
    projectName: "",
    groupId: [],
    serviceFilter: undefined,
    timeRange: undefined,
    timedCountDuration: undefined,
    alignment: 0,
    alignmentTime: undefined,
    order: 0,
    pageSize: 0,
    pageToken: "",
  };
}

export const ListGroupStatsRequest: MessageFns<ListGroupStatsRequest> = {
  encode(message: ListGroupStatsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectName !== "") {
      writer.uint32(10).string(message.projectName);
    }
    for (const v of message.groupId) {
      writer.uint32(18).string(v!);
    }
    if (message.serviceFilter !== undefined) {
      ServiceContextFilter.encode(message.serviceFilter, writer.uint32(26).fork()).join();
    }
    if (message.timeRange !== undefined) {
      QueryTimeRange.encode(message.timeRange, writer.uint32(42).fork()).join();
    }
    if (message.timedCountDuration !== undefined) {
      Duration.encode(message.timedCountDuration, writer.uint32(50).fork()).join();
    }
    if (message.alignment !== 0) {
      writer.uint32(56).int32(message.alignment);
    }
    if (message.alignmentTime !== undefined) {
      Timestamp.encode(toTimestamp(message.alignmentTime), writer.uint32(66).fork()).join();
    }
    if (message.order !== 0) {
      writer.uint32(72).int32(message.order);
    }
    if (message.pageSize !== 0) {
      writer.uint32(88).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(98).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListGroupStatsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListGroupStatsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.groupId.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.serviceFilter = ServiceContextFilter.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.timeRange = QueryTimeRange.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.timedCountDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.alignment = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.alignmentTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.order = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListGroupStatsRequest {
    return {
      projectName: isSet(object.projectName) ? globalThis.String(object.projectName) : "",
      groupId: globalThis.Array.isArray(object?.groupId) ? object.groupId.map((e: any) => globalThis.String(e)) : [],
      serviceFilter: isSet(object.serviceFilter) ? ServiceContextFilter.fromJSON(object.serviceFilter) : undefined,
      timeRange: isSet(object.timeRange) ? QueryTimeRange.fromJSON(object.timeRange) : undefined,
      timedCountDuration: isSet(object.timedCountDuration) ? Duration.fromJSON(object.timedCountDuration) : undefined,
      alignment: isSet(object.alignment) ? timedCountAlignmentFromJSON(object.alignment) : 0,
      alignmentTime: isSet(object.alignmentTime) ? fromJsonTimestamp(object.alignmentTime) : undefined,
      order: isSet(object.order) ? errorGroupOrderFromJSON(object.order) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListGroupStatsRequest): unknown {
    const obj: any = {};
    if (message.projectName !== "") {
      obj.projectName = message.projectName;
    }
    if (message.groupId?.length) {
      obj.groupId = message.groupId;
    }
    if (message.serviceFilter !== undefined) {
      obj.serviceFilter = ServiceContextFilter.toJSON(message.serviceFilter);
    }
    if (message.timeRange !== undefined) {
      obj.timeRange = QueryTimeRange.toJSON(message.timeRange);
    }
    if (message.timedCountDuration !== undefined) {
      obj.timedCountDuration = Duration.toJSON(message.timedCountDuration);
    }
    if (message.alignment !== 0) {
      obj.alignment = timedCountAlignmentToJSON(message.alignment);
    }
    if (message.alignmentTime !== undefined) {
      obj.alignmentTime = message.alignmentTime.toISOString();
    }
    if (message.order !== 0) {
      obj.order = errorGroupOrderToJSON(message.order);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListGroupStatsRequest>): ListGroupStatsRequest {
    return ListGroupStatsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListGroupStatsRequest>): ListGroupStatsRequest {
    const message = createBaseListGroupStatsRequest();
    message.projectName = object.projectName ?? "";
    message.groupId = object.groupId?.map((e) => e) || [];
    message.serviceFilter = (object.serviceFilter !== undefined && object.serviceFilter !== null)
      ? ServiceContextFilter.fromPartial(object.serviceFilter)
      : undefined;
    message.timeRange = (object.timeRange !== undefined && object.timeRange !== null)
      ? QueryTimeRange.fromPartial(object.timeRange)
      : undefined;
    message.timedCountDuration = (object.timedCountDuration !== undefined && object.timedCountDuration !== null)
      ? Duration.fromPartial(object.timedCountDuration)
      : undefined;
    message.alignment = object.alignment ?? 0;
    message.alignmentTime = object.alignmentTime ?? undefined;
    message.order = object.order ?? 0;
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListGroupStatsResponse(): ListGroupStatsResponse {
  return { errorGroupStats: [], nextPageToken: "", timeRangeBegin: undefined };
}

export const ListGroupStatsResponse: MessageFns<ListGroupStatsResponse> = {
  encode(message: ListGroupStatsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.errorGroupStats) {
      ErrorGroupStats.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    if (message.timeRangeBegin !== undefined) {
      Timestamp.encode(toTimestamp(message.timeRangeBegin), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListGroupStatsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListGroupStatsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.errorGroupStats.push(ErrorGroupStats.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.timeRangeBegin = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListGroupStatsResponse {
    return {
      errorGroupStats: globalThis.Array.isArray(object?.errorGroupStats)
        ? object.errorGroupStats.map((e: any) => ErrorGroupStats.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      timeRangeBegin: isSet(object.timeRangeBegin) ? fromJsonTimestamp(object.timeRangeBegin) : undefined,
    };
  },

  toJSON(message: ListGroupStatsResponse): unknown {
    const obj: any = {};
    if (message.errorGroupStats?.length) {
      obj.errorGroupStats = message.errorGroupStats.map((e) => ErrorGroupStats.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.timeRangeBegin !== undefined) {
      obj.timeRangeBegin = message.timeRangeBegin.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<ListGroupStatsResponse>): ListGroupStatsResponse {
    return ListGroupStatsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListGroupStatsResponse>): ListGroupStatsResponse {
    const message = createBaseListGroupStatsResponse();
    message.errorGroupStats = object.errorGroupStats?.map((e) => ErrorGroupStats.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.timeRangeBegin = object.timeRangeBegin ?? undefined;
    return message;
  },
};

function createBaseErrorGroupStats(): ErrorGroupStats {
  return {
    group: undefined,
    count: Long.ZERO,
    affectedUsersCount: Long.ZERO,
    timedCounts: [],
    firstSeenTime: undefined,
    lastSeenTime: undefined,
    affectedServices: [],
    numAffectedServices: 0,
    representative: undefined,
  };
}

export const ErrorGroupStats: MessageFns<ErrorGroupStats> = {
  encode(message: ErrorGroupStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.group !== undefined) {
      ErrorGroup.encode(message.group, writer.uint32(10).fork()).join();
    }
    if (!message.count.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.count.toString());
    }
    if (!message.affectedUsersCount.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.affectedUsersCount.toString());
    }
    for (const v of message.timedCounts) {
      TimedCount.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.firstSeenTime !== undefined) {
      Timestamp.encode(toTimestamp(message.firstSeenTime), writer.uint32(42).fork()).join();
    }
    if (message.lastSeenTime !== undefined) {
      Timestamp.encode(toTimestamp(message.lastSeenTime), writer.uint32(50).fork()).join();
    }
    for (const v of message.affectedServices) {
      ServiceContext.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.numAffectedServices !== 0) {
      writer.uint32(64).int32(message.numAffectedServices);
    }
    if (message.representative !== undefined) {
      ErrorEvent.encode(message.representative, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorGroupStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorGroupStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.group = ErrorGroup.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.count = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.affectedUsersCount = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.timedCounts.push(TimedCount.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.firstSeenTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.lastSeenTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.affectedServices.push(ServiceContext.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.numAffectedServices = reader.int32();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.representative = ErrorEvent.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorGroupStats {
    return {
      group: isSet(object.group) ? ErrorGroup.fromJSON(object.group) : undefined,
      count: isSet(object.count) ? Long.fromValue(object.count) : Long.ZERO,
      affectedUsersCount: isSet(object.affectedUsersCount) ? Long.fromValue(object.affectedUsersCount) : Long.ZERO,
      timedCounts: globalThis.Array.isArray(object?.timedCounts)
        ? object.timedCounts.map((e: any) => TimedCount.fromJSON(e))
        : [],
      firstSeenTime: isSet(object.firstSeenTime) ? fromJsonTimestamp(object.firstSeenTime) : undefined,
      lastSeenTime: isSet(object.lastSeenTime) ? fromJsonTimestamp(object.lastSeenTime) : undefined,
      affectedServices: globalThis.Array.isArray(object?.affectedServices)
        ? object.affectedServices.map((e: any) => ServiceContext.fromJSON(e))
        : [],
      numAffectedServices: isSet(object.numAffectedServices) ? globalThis.Number(object.numAffectedServices) : 0,
      representative: isSet(object.representative) ? ErrorEvent.fromJSON(object.representative) : undefined,
    };
  },

  toJSON(message: ErrorGroupStats): unknown {
    const obj: any = {};
    if (message.group !== undefined) {
      obj.group = ErrorGroup.toJSON(message.group);
    }
    if (!message.count.equals(Long.ZERO)) {
      obj.count = (message.count || Long.ZERO).toString();
    }
    if (!message.affectedUsersCount.equals(Long.ZERO)) {
      obj.affectedUsersCount = (message.affectedUsersCount || Long.ZERO).toString();
    }
    if (message.timedCounts?.length) {
      obj.timedCounts = message.timedCounts.map((e) => TimedCount.toJSON(e));
    }
    if (message.firstSeenTime !== undefined) {
      obj.firstSeenTime = message.firstSeenTime.toISOString();
    }
    if (message.lastSeenTime !== undefined) {
      obj.lastSeenTime = message.lastSeenTime.toISOString();
    }
    if (message.affectedServices?.length) {
      obj.affectedServices = message.affectedServices.map((e) => ServiceContext.toJSON(e));
    }
    if (message.numAffectedServices !== 0) {
      obj.numAffectedServices = Math.round(message.numAffectedServices);
    }
    if (message.representative !== undefined) {
      obj.representative = ErrorEvent.toJSON(message.representative);
    }
    return obj;
  },

  create(base?: DeepPartial<ErrorGroupStats>): ErrorGroupStats {
    return ErrorGroupStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ErrorGroupStats>): ErrorGroupStats {
    const message = createBaseErrorGroupStats();
    message.group = (object.group !== undefined && object.group !== null)
      ? ErrorGroup.fromPartial(object.group)
      : undefined;
    message.count = (object.count !== undefined && object.count !== null) ? Long.fromValue(object.count) : Long.ZERO;
    message.affectedUsersCount = (object.affectedUsersCount !== undefined && object.affectedUsersCount !== null)
      ? Long.fromValue(object.affectedUsersCount)
      : Long.ZERO;
    message.timedCounts = object.timedCounts?.map((e) => TimedCount.fromPartial(e)) || [];
    message.firstSeenTime = object.firstSeenTime ?? undefined;
    message.lastSeenTime = object.lastSeenTime ?? undefined;
    message.affectedServices = object.affectedServices?.map((e) => ServiceContext.fromPartial(e)) || [];
    message.numAffectedServices = object.numAffectedServices ?? 0;
    message.representative = (object.representative !== undefined && object.representative !== null)
      ? ErrorEvent.fromPartial(object.representative)
      : undefined;
    return message;
  },
};

function createBaseTimedCount(): TimedCount {
  return { count: Long.ZERO, startTime: undefined, endTime: undefined };
}

export const TimedCount: MessageFns<TimedCount> = {
  encode(message: TimedCount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.count.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.count.toString());
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(18).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimedCount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimedCount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.count = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimedCount {
    return {
      count: isSet(object.count) ? Long.fromValue(object.count) : Long.ZERO,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: TimedCount): unknown {
    const obj: any = {};
    if (!message.count.equals(Long.ZERO)) {
      obj.count = (message.count || Long.ZERO).toString();
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<TimedCount>): TimedCount {
    return TimedCount.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TimedCount>): TimedCount {
    const message = createBaseTimedCount();
    message.count = (object.count !== undefined && object.count !== null) ? Long.fromValue(object.count) : Long.ZERO;
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBaseListEventsRequest(): ListEventsRequest {
  return { projectName: "", groupId: "", serviceFilter: undefined, timeRange: undefined, pageSize: 0, pageToken: "" };
}

export const ListEventsRequest: MessageFns<ListEventsRequest> = {
  encode(message: ListEventsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectName !== "") {
      writer.uint32(10).string(message.projectName);
    }
    if (message.groupId !== "") {
      writer.uint32(18).string(message.groupId);
    }
    if (message.serviceFilter !== undefined) {
      ServiceContextFilter.encode(message.serviceFilter, writer.uint32(26).fork()).join();
    }
    if (message.timeRange !== undefined) {
      QueryTimeRange.encode(message.timeRange, writer.uint32(34).fork()).join();
    }
    if (message.pageSize !== 0) {
      writer.uint32(48).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(58).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListEventsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.groupId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.serviceFilter = ServiceContextFilter.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.timeRange = QueryTimeRange.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListEventsRequest {
    return {
      projectName: isSet(object.projectName) ? globalThis.String(object.projectName) : "",
      groupId: isSet(object.groupId) ? globalThis.String(object.groupId) : "",
      serviceFilter: isSet(object.serviceFilter) ? ServiceContextFilter.fromJSON(object.serviceFilter) : undefined,
      timeRange: isSet(object.timeRange) ? QueryTimeRange.fromJSON(object.timeRange) : undefined,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListEventsRequest): unknown {
    const obj: any = {};
    if (message.projectName !== "") {
      obj.projectName = message.projectName;
    }
    if (message.groupId !== "") {
      obj.groupId = message.groupId;
    }
    if (message.serviceFilter !== undefined) {
      obj.serviceFilter = ServiceContextFilter.toJSON(message.serviceFilter);
    }
    if (message.timeRange !== undefined) {
      obj.timeRange = QueryTimeRange.toJSON(message.timeRange);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListEventsRequest>): ListEventsRequest {
    return ListEventsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListEventsRequest>): ListEventsRequest {
    const message = createBaseListEventsRequest();
    message.projectName = object.projectName ?? "";
    message.groupId = object.groupId ?? "";
    message.serviceFilter = (object.serviceFilter !== undefined && object.serviceFilter !== null)
      ? ServiceContextFilter.fromPartial(object.serviceFilter)
      : undefined;
    message.timeRange = (object.timeRange !== undefined && object.timeRange !== null)
      ? QueryTimeRange.fromPartial(object.timeRange)
      : undefined;
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListEventsResponse(): ListEventsResponse {
  return { errorEvents: [], nextPageToken: "", timeRangeBegin: undefined };
}

export const ListEventsResponse: MessageFns<ListEventsResponse> = {
  encode(message: ListEventsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.errorEvents) {
      ErrorEvent.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    if (message.timeRangeBegin !== undefined) {
      Timestamp.encode(toTimestamp(message.timeRangeBegin), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListEventsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListEventsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.errorEvents.push(ErrorEvent.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.timeRangeBegin = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListEventsResponse {
    return {
      errorEvents: globalThis.Array.isArray(object?.errorEvents)
        ? object.errorEvents.map((e: any) => ErrorEvent.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      timeRangeBegin: isSet(object.timeRangeBegin) ? fromJsonTimestamp(object.timeRangeBegin) : undefined,
    };
  },

  toJSON(message: ListEventsResponse): unknown {
    const obj: any = {};
    if (message.errorEvents?.length) {
      obj.errorEvents = message.errorEvents.map((e) => ErrorEvent.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.timeRangeBegin !== undefined) {
      obj.timeRangeBegin = message.timeRangeBegin.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<ListEventsResponse>): ListEventsResponse {
    return ListEventsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListEventsResponse>): ListEventsResponse {
    const message = createBaseListEventsResponse();
    message.errorEvents = object.errorEvents?.map((e) => ErrorEvent.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.timeRangeBegin = object.timeRangeBegin ?? undefined;
    return message;
  },
};

function createBaseQueryTimeRange(): QueryTimeRange {
  return { period: 0 };
}

export const QueryTimeRange: MessageFns<QueryTimeRange> = {
  encode(message: QueryTimeRange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.period !== 0) {
      writer.uint32(8).int32(message.period);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryTimeRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTimeRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.period = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTimeRange {
    return { period: isSet(object.period) ? queryTimeRange_PeriodFromJSON(object.period) : 0 };
  },

  toJSON(message: QueryTimeRange): unknown {
    const obj: any = {};
    if (message.period !== 0) {
      obj.period = queryTimeRange_PeriodToJSON(message.period);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryTimeRange>): QueryTimeRange {
    return QueryTimeRange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryTimeRange>): QueryTimeRange {
    const message = createBaseQueryTimeRange();
    message.period = object.period ?? 0;
    return message;
  },
};

function createBaseServiceContextFilter(): ServiceContextFilter {
  return { service: "", version: "", resourceType: "" };
}

export const ServiceContextFilter: MessageFns<ServiceContextFilter> = {
  encode(message: ServiceContextFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.service !== "") {
      writer.uint32(18).string(message.service);
    }
    if (message.version !== "") {
      writer.uint32(26).string(message.version);
    }
    if (message.resourceType !== "") {
      writer.uint32(34).string(message.resourceType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceContextFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceContextFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.service = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.version = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.resourceType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceContextFilter {
    return {
      service: isSet(object.service) ? globalThis.String(object.service) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      resourceType: isSet(object.resourceType) ? globalThis.String(object.resourceType) : "",
    };
  },

  toJSON(message: ServiceContextFilter): unknown {
    const obj: any = {};
    if (message.service !== "") {
      obj.service = message.service;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.resourceType !== "") {
      obj.resourceType = message.resourceType;
    }
    return obj;
  },

  create(base?: DeepPartial<ServiceContextFilter>): ServiceContextFilter {
    return ServiceContextFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ServiceContextFilter>): ServiceContextFilter {
    const message = createBaseServiceContextFilter();
    message.service = object.service ?? "";
    message.version = object.version ?? "";
    message.resourceType = object.resourceType ?? "";
    return message;
  },
};

function createBaseDeleteEventsRequest(): DeleteEventsRequest {
  return { projectName: "" };
}

export const DeleteEventsRequest: MessageFns<DeleteEventsRequest> = {
  encode(message: DeleteEventsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectName !== "") {
      writer.uint32(10).string(message.projectName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteEventsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteEventsRequest {
    return { projectName: isSet(object.projectName) ? globalThis.String(object.projectName) : "" };
  },

  toJSON(message: DeleteEventsRequest): unknown {
    const obj: any = {};
    if (message.projectName !== "") {
      obj.projectName = message.projectName;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteEventsRequest>): DeleteEventsRequest {
    return DeleteEventsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteEventsRequest>): DeleteEventsRequest {
    const message = createBaseDeleteEventsRequest();
    message.projectName = object.projectName ?? "";
    return message;
  },
};

function createBaseDeleteEventsResponse(): DeleteEventsResponse {
  return {};
}

export const DeleteEventsResponse: MessageFns<DeleteEventsResponse> = {
  encode(_: DeleteEventsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteEventsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteEventsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeleteEventsResponse {
    return {};
  },

  toJSON(_: DeleteEventsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<DeleteEventsResponse>): DeleteEventsResponse {
    return DeleteEventsResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<DeleteEventsResponse>): DeleteEventsResponse {
    const message = createBaseDeleteEventsResponse();
    return message;
  },
};

/**
 * An API for retrieving and managing error statistics as well as data for
 * individual events.
 */
export type ErrorStatsServiceDefinition = typeof ErrorStatsServiceDefinition;
export const ErrorStatsServiceDefinition = {
  name: "ErrorStatsService",
  fullName: "google.devtools.clouderrorreporting.v1beta1.ErrorStatsService",
  methods: {
    /** Lists the specified groups. */
    listGroupStats: {
      name: "ListGroupStats",
      requestType: ListGroupStatsRequest,
      requestStream: false,
      responseType: ListGroupStatsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              23,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              110,
              97,
              109,
              101,
              44,
              116,
              105,
              109,
              101,
              95,
              114,
              97,
              110,
              103,
              101,
            ]),
          ],
          578365826: [
            Buffer.from([
              108,
              90,
              59,
              18,
              57,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              103,
              114,
              111,
              117,
              112,
              83,
              116,
              97,
              116,
              115,
              18,
              45,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              103,
              114,
              111,
              117,
              112,
              83,
              116,
              97,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Lists the specified events. */
    listEvents: {
      name: "ListEvents",
      requestType: ListEventsRequest,
      requestStream: false,
      responseType: ListEventsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              21,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              110,
              97,
              109,
              101,
              44,
              103,
              114,
              111,
              117,
              112,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              100,
              90,
              55,
              18,
              53,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              101,
              118,
              101,
              110,
              116,
              115,
              18,
              41,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              101,
              118,
              101,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Deletes all error events of a given project. */
    deleteEvents: {
      name: "DeleteEvents",
      requestType: DeleteEventsRequest,
      requestStream: false,
      responseType: DeleteEventsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([12, 112, 114, 111, 106, 101, 99, 116, 95, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              100,
              90,
              55,
              42,
              53,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              101,
              118,
              101,
              110,
              116,
              115,
              42,
              41,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              101,
              118,
              101,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface ErrorStatsServiceImplementation<CallContextExt = {}> {
  /** Lists the specified groups. */
  listGroupStats(
    request: ListGroupStatsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListGroupStatsResponse>>;
  /** Lists the specified events. */
  listEvents(
    request: ListEventsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListEventsResponse>>;
  /** Deletes all error events of a given project. */
  deleteEvents(
    request: DeleteEventsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<DeleteEventsResponse>>;
}

export interface ErrorStatsServiceClient<CallOptionsExt = {}> {
  /** Lists the specified groups. */
  listGroupStats(
    request: DeepPartial<ListGroupStatsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListGroupStatsResponse>;
  /** Lists the specified events. */
  listEvents(
    request: DeepPartial<ListEventsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListEventsResponse>;
  /** Deletes all error events of a given project. */
  deleteEvents(
    request: DeepPartial<DeleteEventsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<DeleteEventsResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
