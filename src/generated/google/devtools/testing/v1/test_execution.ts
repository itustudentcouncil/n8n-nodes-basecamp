// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/devtools/testing/v1/test_execution.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Duration } from "../../../protobuf/duration.js";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.devtools.testing.v1";

/** Specifies how to execute the test. */
export enum OrchestratorOption {
  /**
   * ORCHESTRATOR_OPTION_UNSPECIFIED - Default value: the server will choose the mode. Currently implies that
   * the test will run without the orchestrator. In the future,
   * all instrumentation tests will be run with the orchestrator.
   * Using the orchestrator is highly encouraged because of all the benefits it
   * offers.
   */
  ORCHESTRATOR_OPTION_UNSPECIFIED = 0,
  /**
   * USE_ORCHESTRATOR - Run test using orchestrator.
   * ** Only compatible with AndroidJUnitRunner version 1.1 or higher! **
   * Recommended.
   */
  USE_ORCHESTRATOR = 1,
  /** DO_NOT_USE_ORCHESTRATOR - Run test without using orchestrator. */
  DO_NOT_USE_ORCHESTRATOR = 2,
  UNRECOGNIZED = -1,
}

export function orchestratorOptionFromJSON(object: any): OrchestratorOption {
  switch (object) {
    case 0:
    case "ORCHESTRATOR_OPTION_UNSPECIFIED":
      return OrchestratorOption.ORCHESTRATOR_OPTION_UNSPECIFIED;
    case 1:
    case "USE_ORCHESTRATOR":
      return OrchestratorOption.USE_ORCHESTRATOR;
    case 2:
    case "DO_NOT_USE_ORCHESTRATOR":
      return OrchestratorOption.DO_NOT_USE_ORCHESTRATOR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OrchestratorOption.UNRECOGNIZED;
  }
}

export function orchestratorOptionToJSON(object: OrchestratorOption): string {
  switch (object) {
    case OrchestratorOption.ORCHESTRATOR_OPTION_UNSPECIFIED:
      return "ORCHESTRATOR_OPTION_UNSPECIFIED";
    case OrchestratorOption.USE_ORCHESTRATOR:
      return "USE_ORCHESTRATOR";
    case OrchestratorOption.DO_NOT_USE_ORCHESTRATOR:
      return "DO_NOT_USE_ORCHESTRATOR";
    case OrchestratorOption.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The mode in which Robo should run. */
export enum RoboMode {
  /**
   * ROBO_MODE_UNSPECIFIED - This means that the server should choose the mode.
   * Recommended.
   */
  ROBO_MODE_UNSPECIFIED = 0,
  /** ROBO_VERSION_1 - Runs Robo in UIAutomator-only mode without app resigning */
  ROBO_VERSION_1 = 1,
  /** ROBO_VERSION_2 - Runs Robo in standard Espresso with UIAutomator fallback */
  ROBO_VERSION_2 = 2,
  UNRECOGNIZED = -1,
}

export function roboModeFromJSON(object: any): RoboMode {
  switch (object) {
    case 0:
    case "ROBO_MODE_UNSPECIFIED":
      return RoboMode.ROBO_MODE_UNSPECIFIED;
    case 1:
    case "ROBO_VERSION_1":
      return RoboMode.ROBO_VERSION_1;
    case 2:
    case "ROBO_VERSION_2":
      return RoboMode.ROBO_VERSION_2;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RoboMode.UNRECOGNIZED;
  }
}

export function roboModeToJSON(object: RoboMode): string {
  switch (object) {
    case RoboMode.ROBO_MODE_UNSPECIFIED:
      return "ROBO_MODE_UNSPECIFIED";
    case RoboMode.ROBO_VERSION_1:
      return "ROBO_VERSION_1";
    case RoboMode.ROBO_VERSION_2:
      return "ROBO_VERSION_2";
    case RoboMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Actions which Robo can perform on UI elements. */
export enum RoboActionType {
  /** ACTION_TYPE_UNSPECIFIED - DO NOT USE. For proto versioning only. */
  ACTION_TYPE_UNSPECIFIED = 0,
  /**
   * SINGLE_CLICK - Direct Robo to click on the specified element. No-op if specified element
   * is not clickable.
   */
  SINGLE_CLICK = 1,
  /**
   * ENTER_TEXT - Direct Robo to enter text on the specified element. No-op if specified
   * element is not enabled or does not allow text entry.
   */
  ENTER_TEXT = 2,
  /** IGNORE - Direct Robo to ignore interactions with a specific element. */
  IGNORE = 3,
  UNRECOGNIZED = -1,
}

export function roboActionTypeFromJSON(object: any): RoboActionType {
  switch (object) {
    case 0:
    case "ACTION_TYPE_UNSPECIFIED":
      return RoboActionType.ACTION_TYPE_UNSPECIFIED;
    case 1:
    case "SINGLE_CLICK":
      return RoboActionType.SINGLE_CLICK;
    case 2:
    case "ENTER_TEXT":
      return RoboActionType.ENTER_TEXT;
    case 3:
    case "IGNORE":
      return RoboActionType.IGNORE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RoboActionType.UNRECOGNIZED;
  }
}

export function roboActionTypeToJSON(object: RoboActionType): string {
  switch (object) {
    case RoboActionType.ACTION_TYPE_UNSPECIFIED:
      return "ACTION_TYPE_UNSPECIFIED";
    case RoboActionType.SINGLE_CLICK:
      return "SINGLE_CLICK";
    case RoboActionType.ENTER_TEXT:
      return "ENTER_TEXT";
    case RoboActionType.IGNORE:
      return "IGNORE";
    case RoboActionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The detailed reason that a Matrix was deemed INVALID. */
export enum InvalidMatrixDetails {
  /** INVALID_MATRIX_DETAILS_UNSPECIFIED - Do not use. For proto versioning only. */
  INVALID_MATRIX_DETAILS_UNSPECIFIED = 0,
  /** DETAILS_UNAVAILABLE - The matrix is INVALID, but there are no further details available. */
  DETAILS_UNAVAILABLE = 1,
  /** MALFORMED_APK - The input app APK could not be parsed. */
  MALFORMED_APK = 2,
  /** MALFORMED_TEST_APK - The input test APK could not be parsed. */
  MALFORMED_TEST_APK = 3,
  /** NO_MANIFEST - The AndroidManifest.xml could not be found. */
  NO_MANIFEST = 4,
  /** NO_PACKAGE_NAME - The APK manifest does not declare a package name. */
  NO_PACKAGE_NAME = 5,
  /**
   * INVALID_PACKAGE_NAME - The APK application ID (aka package name) is invalid.
   * See also
   * https://developer.android.com/studio/build/application-id
   */
  INVALID_PACKAGE_NAME = 31,
  /** TEST_SAME_AS_APP - The test package and app package are the same. */
  TEST_SAME_AS_APP = 6,
  /** NO_INSTRUMENTATION - The test apk does not declare an instrumentation. */
  NO_INSTRUMENTATION = 7,
  /** NO_SIGNATURE - The input app apk does not have a signature. */
  NO_SIGNATURE = 20,
  /**
   * INSTRUMENTATION_ORCHESTRATOR_INCOMPATIBLE - The test runner class specified by user or in the test APK's manifest file
   * is not compatible with Android Test Orchestrator.
   * Orchestrator is only compatible with AndroidJUnitRunner version 1.1 or
   * higher.
   * Orchestrator can be disabled by using DO_NOT_USE_ORCHESTRATOR
   * OrchestratorOption.
   */
  INSTRUMENTATION_ORCHESTRATOR_INCOMPATIBLE = 18,
  /**
   * NO_TEST_RUNNER_CLASS - The test APK does not contain the test runner class specified by the user
   * or in the manifest file. This can be caused by one of the following
   * reasons:
   *
   * - the user provided a runner class name that's incorrect, or
   * - the test runner isn't built into the test APK (might be in the app APK
   * instead).
   */
  NO_TEST_RUNNER_CLASS = 19,
  /** NO_LAUNCHER_ACTIVITY - A main launcher activity could not be found. */
  NO_LAUNCHER_ACTIVITY = 8,
  /** FORBIDDEN_PERMISSIONS - The app declares one or more permissions that are not allowed. */
  FORBIDDEN_PERMISSIONS = 9,
  /** INVALID_ROBO_DIRECTIVES - There is a conflict in the provided robo_directives. */
  INVALID_ROBO_DIRECTIVES = 10,
  /**
   * INVALID_RESOURCE_NAME - There is at least one invalid resource name in the provided
   * robo directives
   */
  INVALID_RESOURCE_NAME = 33,
  /**
   * INVALID_DIRECTIVE_ACTION - Invalid definition of action in the robo directives
   * (e.g. a click or ignore action includes an input text field)
   */
  INVALID_DIRECTIVE_ACTION = 34,
  /**
   * TEST_LOOP_INTENT_FILTER_NOT_FOUND - There is no test loop intent filter, or the one that is given is
   * not formatted correctly.
   */
  TEST_LOOP_INTENT_FILTER_NOT_FOUND = 12,
  /**
   * SCENARIO_LABEL_NOT_DECLARED - The request contains a scenario label that was not declared in the
   * manifest.
   */
  SCENARIO_LABEL_NOT_DECLARED = 13,
  /** SCENARIO_LABEL_MALFORMED - There was an error when parsing a label's value. */
  SCENARIO_LABEL_MALFORMED = 14,
  /**
   * SCENARIO_NOT_DECLARED - The request contains a scenario number that was not declared in the
   * manifest.
   */
  SCENARIO_NOT_DECLARED = 15,
  /** DEVICE_ADMIN_RECEIVER - Device administrator applications are not allowed. */
  DEVICE_ADMIN_RECEIVER = 17,
  /**
   * MALFORMED_XC_TEST_ZIP - The zipped XCTest was malformed. The zip did not contain a single
   * .xctestrun file and the contents of the DerivedData/Build/Products
   * directory.
   */
  MALFORMED_XC_TEST_ZIP = 11,
  /**
   * BUILT_FOR_IOS_SIMULATOR - The zipped XCTest was built for the iOS simulator rather than for a
   * physical device.
   */
  BUILT_FOR_IOS_SIMULATOR = 24,
  /** NO_TESTS_IN_XC_TEST_ZIP - The .xctestrun file did not specify any test targets. */
  NO_TESTS_IN_XC_TEST_ZIP = 25,
  /**
   * USE_DESTINATION_ARTIFACTS - One or more of the test targets defined in the .xctestrun file specifies
   * "UseDestinationArtifacts", which is disallowed.
   */
  USE_DESTINATION_ARTIFACTS = 26,
  /**
   * TEST_NOT_APP_HOSTED - XC tests which run on physical devices must have
   * "IsAppHostedTestBundle" == "true" in the xctestrun file.
   */
  TEST_NOT_APP_HOSTED = 28,
  /** PLIST_CANNOT_BE_PARSED - An Info.plist file in the XCTest zip could not be parsed. */
  PLIST_CANNOT_BE_PARSED = 30,
  /**
   * TEST_ONLY_APK - The APK is marked as "testOnly".
   * Deprecated and not currently used.
   *
   * @deprecated
   */
  TEST_ONLY_APK = 21,
  /** MALFORMED_IPA - The input IPA could not be parsed. */
  MALFORMED_IPA = 22,
  /** MISSING_URL_SCHEME - The application doesn't register the game loop URL scheme. */
  MISSING_URL_SCHEME = 35,
  /** MALFORMED_APP_BUNDLE - The iOS application bundle (.app) couldn't be processed. */
  MALFORMED_APP_BUNDLE = 36,
  /**
   * NO_CODE_APK - APK contains no code.
   * See also
   * https://developer.android.com/guide/topics/manifest/application-element.html#code
   */
  NO_CODE_APK = 23,
  /**
   * INVALID_INPUT_APK - Either the provided input APK path was malformed,
   * the APK file does not exist, or the user does not have permission to
   * access the APK file.
   */
  INVALID_INPUT_APK = 27,
  /** INVALID_APK_PREVIEW_SDK - APK is built for a preview SDK which is unsupported */
  INVALID_APK_PREVIEW_SDK = 29,
  /** MATRIX_TOO_LARGE - The matrix expanded to contain too many executions. */
  MATRIX_TOO_LARGE = 37,
  /** TEST_QUOTA_EXCEEDED - Not enough test quota to run the executions in this matrix. */
  TEST_QUOTA_EXCEEDED = 39,
  /**
   * SERVICE_NOT_ACTIVATED - A required cloud service api is not activated.
   * See:
   * https://firebase.google.com/docs/test-lab/android/continuous#requirements
   */
  SERVICE_NOT_ACTIVATED = 40,
  /** UNKNOWN_PERMISSION_ERROR - There was an unknown permission issue running this test. */
  UNKNOWN_PERMISSION_ERROR = 41,
  UNRECOGNIZED = -1,
}

export function invalidMatrixDetailsFromJSON(object: any): InvalidMatrixDetails {
  switch (object) {
    case 0:
    case "INVALID_MATRIX_DETAILS_UNSPECIFIED":
      return InvalidMatrixDetails.INVALID_MATRIX_DETAILS_UNSPECIFIED;
    case 1:
    case "DETAILS_UNAVAILABLE":
      return InvalidMatrixDetails.DETAILS_UNAVAILABLE;
    case 2:
    case "MALFORMED_APK":
      return InvalidMatrixDetails.MALFORMED_APK;
    case 3:
    case "MALFORMED_TEST_APK":
      return InvalidMatrixDetails.MALFORMED_TEST_APK;
    case 4:
    case "NO_MANIFEST":
      return InvalidMatrixDetails.NO_MANIFEST;
    case 5:
    case "NO_PACKAGE_NAME":
      return InvalidMatrixDetails.NO_PACKAGE_NAME;
    case 31:
    case "INVALID_PACKAGE_NAME":
      return InvalidMatrixDetails.INVALID_PACKAGE_NAME;
    case 6:
    case "TEST_SAME_AS_APP":
      return InvalidMatrixDetails.TEST_SAME_AS_APP;
    case 7:
    case "NO_INSTRUMENTATION":
      return InvalidMatrixDetails.NO_INSTRUMENTATION;
    case 20:
    case "NO_SIGNATURE":
      return InvalidMatrixDetails.NO_SIGNATURE;
    case 18:
    case "INSTRUMENTATION_ORCHESTRATOR_INCOMPATIBLE":
      return InvalidMatrixDetails.INSTRUMENTATION_ORCHESTRATOR_INCOMPATIBLE;
    case 19:
    case "NO_TEST_RUNNER_CLASS":
      return InvalidMatrixDetails.NO_TEST_RUNNER_CLASS;
    case 8:
    case "NO_LAUNCHER_ACTIVITY":
      return InvalidMatrixDetails.NO_LAUNCHER_ACTIVITY;
    case 9:
    case "FORBIDDEN_PERMISSIONS":
      return InvalidMatrixDetails.FORBIDDEN_PERMISSIONS;
    case 10:
    case "INVALID_ROBO_DIRECTIVES":
      return InvalidMatrixDetails.INVALID_ROBO_DIRECTIVES;
    case 33:
    case "INVALID_RESOURCE_NAME":
      return InvalidMatrixDetails.INVALID_RESOURCE_NAME;
    case 34:
    case "INVALID_DIRECTIVE_ACTION":
      return InvalidMatrixDetails.INVALID_DIRECTIVE_ACTION;
    case 12:
    case "TEST_LOOP_INTENT_FILTER_NOT_FOUND":
      return InvalidMatrixDetails.TEST_LOOP_INTENT_FILTER_NOT_FOUND;
    case 13:
    case "SCENARIO_LABEL_NOT_DECLARED":
      return InvalidMatrixDetails.SCENARIO_LABEL_NOT_DECLARED;
    case 14:
    case "SCENARIO_LABEL_MALFORMED":
      return InvalidMatrixDetails.SCENARIO_LABEL_MALFORMED;
    case 15:
    case "SCENARIO_NOT_DECLARED":
      return InvalidMatrixDetails.SCENARIO_NOT_DECLARED;
    case 17:
    case "DEVICE_ADMIN_RECEIVER":
      return InvalidMatrixDetails.DEVICE_ADMIN_RECEIVER;
    case 11:
    case "MALFORMED_XC_TEST_ZIP":
      return InvalidMatrixDetails.MALFORMED_XC_TEST_ZIP;
    case 24:
    case "BUILT_FOR_IOS_SIMULATOR":
      return InvalidMatrixDetails.BUILT_FOR_IOS_SIMULATOR;
    case 25:
    case "NO_TESTS_IN_XC_TEST_ZIP":
      return InvalidMatrixDetails.NO_TESTS_IN_XC_TEST_ZIP;
    case 26:
    case "USE_DESTINATION_ARTIFACTS":
      return InvalidMatrixDetails.USE_DESTINATION_ARTIFACTS;
    case 28:
    case "TEST_NOT_APP_HOSTED":
      return InvalidMatrixDetails.TEST_NOT_APP_HOSTED;
    case 30:
    case "PLIST_CANNOT_BE_PARSED":
      return InvalidMatrixDetails.PLIST_CANNOT_BE_PARSED;
    case 21:
    case "TEST_ONLY_APK":
      return InvalidMatrixDetails.TEST_ONLY_APK;
    case 22:
    case "MALFORMED_IPA":
      return InvalidMatrixDetails.MALFORMED_IPA;
    case 35:
    case "MISSING_URL_SCHEME":
      return InvalidMatrixDetails.MISSING_URL_SCHEME;
    case 36:
    case "MALFORMED_APP_BUNDLE":
      return InvalidMatrixDetails.MALFORMED_APP_BUNDLE;
    case 23:
    case "NO_CODE_APK":
      return InvalidMatrixDetails.NO_CODE_APK;
    case 27:
    case "INVALID_INPUT_APK":
      return InvalidMatrixDetails.INVALID_INPUT_APK;
    case 29:
    case "INVALID_APK_PREVIEW_SDK":
      return InvalidMatrixDetails.INVALID_APK_PREVIEW_SDK;
    case 37:
    case "MATRIX_TOO_LARGE":
      return InvalidMatrixDetails.MATRIX_TOO_LARGE;
    case 39:
    case "TEST_QUOTA_EXCEEDED":
      return InvalidMatrixDetails.TEST_QUOTA_EXCEEDED;
    case 40:
    case "SERVICE_NOT_ACTIVATED":
      return InvalidMatrixDetails.SERVICE_NOT_ACTIVATED;
    case 41:
    case "UNKNOWN_PERMISSION_ERROR":
      return InvalidMatrixDetails.UNKNOWN_PERMISSION_ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return InvalidMatrixDetails.UNRECOGNIZED;
  }
}

export function invalidMatrixDetailsToJSON(object: InvalidMatrixDetails): string {
  switch (object) {
    case InvalidMatrixDetails.INVALID_MATRIX_DETAILS_UNSPECIFIED:
      return "INVALID_MATRIX_DETAILS_UNSPECIFIED";
    case InvalidMatrixDetails.DETAILS_UNAVAILABLE:
      return "DETAILS_UNAVAILABLE";
    case InvalidMatrixDetails.MALFORMED_APK:
      return "MALFORMED_APK";
    case InvalidMatrixDetails.MALFORMED_TEST_APK:
      return "MALFORMED_TEST_APK";
    case InvalidMatrixDetails.NO_MANIFEST:
      return "NO_MANIFEST";
    case InvalidMatrixDetails.NO_PACKAGE_NAME:
      return "NO_PACKAGE_NAME";
    case InvalidMatrixDetails.INVALID_PACKAGE_NAME:
      return "INVALID_PACKAGE_NAME";
    case InvalidMatrixDetails.TEST_SAME_AS_APP:
      return "TEST_SAME_AS_APP";
    case InvalidMatrixDetails.NO_INSTRUMENTATION:
      return "NO_INSTRUMENTATION";
    case InvalidMatrixDetails.NO_SIGNATURE:
      return "NO_SIGNATURE";
    case InvalidMatrixDetails.INSTRUMENTATION_ORCHESTRATOR_INCOMPATIBLE:
      return "INSTRUMENTATION_ORCHESTRATOR_INCOMPATIBLE";
    case InvalidMatrixDetails.NO_TEST_RUNNER_CLASS:
      return "NO_TEST_RUNNER_CLASS";
    case InvalidMatrixDetails.NO_LAUNCHER_ACTIVITY:
      return "NO_LAUNCHER_ACTIVITY";
    case InvalidMatrixDetails.FORBIDDEN_PERMISSIONS:
      return "FORBIDDEN_PERMISSIONS";
    case InvalidMatrixDetails.INVALID_ROBO_DIRECTIVES:
      return "INVALID_ROBO_DIRECTIVES";
    case InvalidMatrixDetails.INVALID_RESOURCE_NAME:
      return "INVALID_RESOURCE_NAME";
    case InvalidMatrixDetails.INVALID_DIRECTIVE_ACTION:
      return "INVALID_DIRECTIVE_ACTION";
    case InvalidMatrixDetails.TEST_LOOP_INTENT_FILTER_NOT_FOUND:
      return "TEST_LOOP_INTENT_FILTER_NOT_FOUND";
    case InvalidMatrixDetails.SCENARIO_LABEL_NOT_DECLARED:
      return "SCENARIO_LABEL_NOT_DECLARED";
    case InvalidMatrixDetails.SCENARIO_LABEL_MALFORMED:
      return "SCENARIO_LABEL_MALFORMED";
    case InvalidMatrixDetails.SCENARIO_NOT_DECLARED:
      return "SCENARIO_NOT_DECLARED";
    case InvalidMatrixDetails.DEVICE_ADMIN_RECEIVER:
      return "DEVICE_ADMIN_RECEIVER";
    case InvalidMatrixDetails.MALFORMED_XC_TEST_ZIP:
      return "MALFORMED_XC_TEST_ZIP";
    case InvalidMatrixDetails.BUILT_FOR_IOS_SIMULATOR:
      return "BUILT_FOR_IOS_SIMULATOR";
    case InvalidMatrixDetails.NO_TESTS_IN_XC_TEST_ZIP:
      return "NO_TESTS_IN_XC_TEST_ZIP";
    case InvalidMatrixDetails.USE_DESTINATION_ARTIFACTS:
      return "USE_DESTINATION_ARTIFACTS";
    case InvalidMatrixDetails.TEST_NOT_APP_HOSTED:
      return "TEST_NOT_APP_HOSTED";
    case InvalidMatrixDetails.PLIST_CANNOT_BE_PARSED:
      return "PLIST_CANNOT_BE_PARSED";
    case InvalidMatrixDetails.TEST_ONLY_APK:
      return "TEST_ONLY_APK";
    case InvalidMatrixDetails.MALFORMED_IPA:
      return "MALFORMED_IPA";
    case InvalidMatrixDetails.MISSING_URL_SCHEME:
      return "MISSING_URL_SCHEME";
    case InvalidMatrixDetails.MALFORMED_APP_BUNDLE:
      return "MALFORMED_APP_BUNDLE";
    case InvalidMatrixDetails.NO_CODE_APK:
      return "NO_CODE_APK";
    case InvalidMatrixDetails.INVALID_INPUT_APK:
      return "INVALID_INPUT_APK";
    case InvalidMatrixDetails.INVALID_APK_PREVIEW_SDK:
      return "INVALID_APK_PREVIEW_SDK";
    case InvalidMatrixDetails.MATRIX_TOO_LARGE:
      return "MATRIX_TOO_LARGE";
    case InvalidMatrixDetails.TEST_QUOTA_EXCEEDED:
      return "TEST_QUOTA_EXCEEDED";
    case InvalidMatrixDetails.SERVICE_NOT_ACTIVATED:
      return "SERVICE_NOT_ACTIVATED";
    case InvalidMatrixDetails.UNKNOWN_PERMISSION_ERROR:
      return "UNKNOWN_PERMISSION_ERROR";
    case InvalidMatrixDetails.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The state (i.e., progress) of a test execution or matrix. */
export enum TestState {
  /** TEST_STATE_UNSPECIFIED - Do not use.  For proto versioning only. */
  TEST_STATE_UNSPECIFIED = 0,
  /** VALIDATING - The execution or matrix is being validated. */
  VALIDATING = 8,
  /** PENDING - The execution or matrix is waiting for resources to become available. */
  PENDING = 1,
  /**
   * RUNNING - The execution is currently being processed.
   *
   * Can only be set on an execution.
   */
  RUNNING = 2,
  /**
   * FINISHED - The execution or matrix has terminated normally.
   *
   * On a matrix this means that the matrix level processing completed normally,
   * but individual executions may be in an ERROR state.
   */
  FINISHED = 3,
  /**
   * ERROR - The execution or matrix has stopped because it encountered an
   * infrastructure failure.
   */
  ERROR = 4,
  /**
   * UNSUPPORTED_ENVIRONMENT - The execution was not run because it corresponds to a unsupported
   * environment.
   *
   * Can only be set on an execution.
   */
  UNSUPPORTED_ENVIRONMENT = 5,
  /**
   * INCOMPATIBLE_ENVIRONMENT - The execution was not run because the provided inputs are incompatible with
   * the requested environment.
   *
   * Example: requested AndroidVersion is lower than APK's minSdkVersion
   *
   * Can only be set on an execution.
   */
  INCOMPATIBLE_ENVIRONMENT = 9,
  /**
   * INCOMPATIBLE_ARCHITECTURE - The execution was not run because the provided inputs are incompatible with
   * the requested architecture.
   *
   * Example: requested device does not support running the native code in
   * the supplied APK
   *
   * Can only be set on an execution.
   */
  INCOMPATIBLE_ARCHITECTURE = 10,
  /**
   * CANCELLED - The user cancelled the execution.
   *
   * Can only be set on an execution.
   */
  CANCELLED = 6,
  /**
   * INVALID - The execution or matrix was not run because the provided inputs are not
   * valid.
   *
   * Examples: input file is not of the expected type, is malformed/corrupt, or
   * was flagged as malware
   */
  INVALID = 7,
  UNRECOGNIZED = -1,
}

export function testStateFromJSON(object: any): TestState {
  switch (object) {
    case 0:
    case "TEST_STATE_UNSPECIFIED":
      return TestState.TEST_STATE_UNSPECIFIED;
    case 8:
    case "VALIDATING":
      return TestState.VALIDATING;
    case 1:
    case "PENDING":
      return TestState.PENDING;
    case 2:
    case "RUNNING":
      return TestState.RUNNING;
    case 3:
    case "FINISHED":
      return TestState.FINISHED;
    case 4:
    case "ERROR":
      return TestState.ERROR;
    case 5:
    case "UNSUPPORTED_ENVIRONMENT":
      return TestState.UNSUPPORTED_ENVIRONMENT;
    case 9:
    case "INCOMPATIBLE_ENVIRONMENT":
      return TestState.INCOMPATIBLE_ENVIRONMENT;
    case 10:
    case "INCOMPATIBLE_ARCHITECTURE":
      return TestState.INCOMPATIBLE_ARCHITECTURE;
    case 6:
    case "CANCELLED":
      return TestState.CANCELLED;
    case 7:
    case "INVALID":
      return TestState.INVALID;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TestState.UNRECOGNIZED;
  }
}

export function testStateToJSON(object: TestState): string {
  switch (object) {
    case TestState.TEST_STATE_UNSPECIFIED:
      return "TEST_STATE_UNSPECIFIED";
    case TestState.VALIDATING:
      return "VALIDATING";
    case TestState.PENDING:
      return "PENDING";
    case TestState.RUNNING:
      return "RUNNING";
    case TestState.FINISHED:
      return "FINISHED";
    case TestState.ERROR:
      return "ERROR";
    case TestState.UNSUPPORTED_ENVIRONMENT:
      return "UNSUPPORTED_ENVIRONMENT";
    case TestState.INCOMPATIBLE_ENVIRONMENT:
      return "INCOMPATIBLE_ENVIRONMENT";
    case TestState.INCOMPATIBLE_ARCHITECTURE:
      return "INCOMPATIBLE_ARCHITECTURE";
    case TestState.CANCELLED:
      return "CANCELLED";
    case TestState.INVALID:
      return "INVALID";
    case TestState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Outcome summary for a finished test matrix. */
export enum OutcomeSummary {
  /** OUTCOME_SUMMARY_UNSPECIFIED - Do not use. For proto versioning only. */
  OUTCOME_SUMMARY_UNSPECIFIED = 0,
  /**
   * SUCCESS - The test matrix run was successful, for instance:
   *
   * - All the test cases passed.
   * - Robo did not detect a crash of the application under test.
   */
  SUCCESS = 1,
  /**
   * FAILURE - A run failed, for instance:
   *
   * - One or more test cases failed.
   * - A test timed out.
   * - The application under test crashed.
   */
  FAILURE = 2,
  /**
   * INCONCLUSIVE - Something unexpected happened. The run should still be considered
   * unsuccessful but this is likely a transient problem and re-running the
   * test might be successful.
   */
  INCONCLUSIVE = 3,
  /**
   * SKIPPED - All tests were skipped, for instance:
   *
   * - All device configurations were incompatible.
   */
  SKIPPED = 4,
  UNRECOGNIZED = -1,
}

export function outcomeSummaryFromJSON(object: any): OutcomeSummary {
  switch (object) {
    case 0:
    case "OUTCOME_SUMMARY_UNSPECIFIED":
      return OutcomeSummary.OUTCOME_SUMMARY_UNSPECIFIED;
    case 1:
    case "SUCCESS":
      return OutcomeSummary.SUCCESS;
    case 2:
    case "FAILURE":
      return OutcomeSummary.FAILURE;
    case 3:
    case "INCONCLUSIVE":
      return OutcomeSummary.INCONCLUSIVE;
    case 4:
    case "SKIPPED":
      return OutcomeSummary.SKIPPED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OutcomeSummary.UNRECOGNIZED;
  }
}

export function outcomeSummaryToJSON(object: OutcomeSummary): string {
  switch (object) {
    case OutcomeSummary.OUTCOME_SUMMARY_UNSPECIFIED:
      return "OUTCOME_SUMMARY_UNSPECIFIED";
    case OutcomeSummary.SUCCESS:
      return "SUCCESS";
    case OutcomeSummary.FAILURE:
      return "FAILURE";
    case OutcomeSummary.INCONCLUSIVE:
      return "INCONCLUSIVE";
    case OutcomeSummary.SKIPPED:
      return "SKIPPED";
    case OutcomeSummary.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * TestMatrix captures all details about a test. It contains the environment
 * configuration, test specification, test executions and overall state and
 * outcome.
 */
export interface TestMatrix {
  /** Output only. Unique id set by the service. */
  testMatrixId: string;
  /** The cloud project that owns the test matrix. */
  projectId: string;
  /** Information about the client which invoked the test. */
  clientInfo:
    | ClientInfo
    | undefined;
  /** Required. How to run the test. */
  testSpecification:
    | TestSpecification
    | undefined;
  /** Required. The devices the tests are being executed on. */
  environmentMatrix:
    | EnvironmentMatrix
    | undefined;
  /**
   * Output only. The list of test executions that the service creates for
   * this matrix.
   */
  testExecutions: TestExecution[];
  /** Required. Where the results for the matrix are written. */
  resultStorage:
    | ResultStorage
    | undefined;
  /** Output only. Indicates the current progress of the test matrix. */
  state: TestState;
  /** Output only. The time this test matrix was initially created. */
  timestamp:
    | Date
    | undefined;
  /**
   * Output only. Describes why the matrix is considered invalid.
   * Only useful for matrices in the INVALID state.
   */
  invalidMatrixDetails: InvalidMatrixDetails;
  /**
   * Output only. Details about why a matrix was deemed invalid.
   * If multiple checks can be safely performed, they will be reported but no
   * assumptions should be made about the length of this list.
   */
  extendedInvalidMatrixDetails: MatrixErrorDetail[];
  /**
   * The number of times a TestExecution should be re-attempted if one or more
   * of its test cases fail for any reason.
   * The maximum number of reruns allowed is 10.
   *
   * Default is 0, which implies no reruns.
   */
  flakyTestAttempts: number;
  /**
   * Output Only. The overall outcome of the test.
   * Only set when the test matrix state is FINISHED.
   */
  outcomeSummary: OutcomeSummary;
  /**
   * If true, only a single attempt at most will be made to run each
   * execution/shard in the matrix. Flaky test attempts are not affected.
   *
   * Normally, 2 or more attempts are made if a potential infrastructure issue
   * is detected.
   *
   * This feature is for latency sensitive workloads. The incidence of
   * execution failures may be significantly greater for fail-fast matrices
   * and support is more limited because of that expectation.
   */
  failFast: boolean;
}

/** Describes a single error or issue with a matrix. */
export interface MatrixErrorDetail {
  /**
   * Output only. The reason for the error. This is a constant value in
   * UPPER_SNAKE_CASE that identifies the cause of the error.
   */
  reason: string;
  /**
   * Output only. A human-readable message about how the error in the
   * TestMatrix. Expands on the `reason` field with additional details and
   * possible options to fix the issue.
   */
  message: string;
}

/** A single test executed in a single environment. */
export interface TestExecution {
  /** Output only. Unique id set by the service. */
  id: string;
  /** Output only. Id of the containing TestMatrix. */
  matrixId: string;
  /** Output only. The cloud project that owns the test execution. */
  projectId: string;
  /** Output only. How to run the test. */
  testSpecification:
    | TestSpecification
    | undefined;
  /** Output only. Details about the shard. */
  shard:
    | Shard
    | undefined;
  /** Output only. How the host machine(s) are configured. */
  environment:
    | Environment
    | undefined;
  /**
   * Output only. Indicates the current progress of the test execution
   * (e.g., FINISHED).
   */
  state: TestState;
  /** Output only. Where the results for this execution are written. */
  toolResultsStep:
    | ToolResultsStep
    | undefined;
  /** Output only. The time this test execution was initially created. */
  timestamp:
    | Date
    | undefined;
  /** Output only. Additional details about the running test. */
  testDetails: TestDetails | undefined;
}

/** A description of how to run the test. */
export interface TestSpecification {
  /**
   * Max time a test execution is allowed to run before it is
   * automatically cancelled.
   * The default value is 5 min.
   */
  testTimeout:
    | Duration
    | undefined;
  /**
   * Test setup requirements for Android e.g. files to install, bootstrap
   * scripts.
   */
  testSetup?:
    | TestSetup
    | undefined;
  /** Test setup requirements for iOS. */
  iosTestSetup?:
    | IosTestSetup
    | undefined;
  /** An Android instrumentation test. */
  androidInstrumentationTest?:
    | AndroidInstrumentationTest
    | undefined;
  /** An Android robo test. */
  androidRoboTest?:
    | AndroidRoboTest
    | undefined;
  /** An Android Application with a Test Loop. */
  androidTestLoop?:
    | AndroidTestLoop
    | undefined;
  /** An iOS XCTest, via an .xctestrun file. */
  iosXcTest?:
    | IosXcTest
    | undefined;
  /** An iOS application with a test loop. */
  iosTestLoop?:
    | IosTestLoop
    | undefined;
  /** An iOS Robo test. */
  iosRoboTest?:
    | IosRoboTest
    | undefined;
  /** Disables video recording. May reduce test latency. */
  disableVideoRecording: boolean;
  /** Disables performance metrics recording. May reduce test latency. */
  disablePerformanceMetrics: boolean;
}

export interface SystraceSetup {
  /**
   * Systrace duration in seconds.
   * Should be between 1 and 30 seconds. 0 disables systrace.
   *
   * @deprecated
   */
  durationSeconds: number;
}

/** A description of how to set up the Android device prior to running the test. */
export interface TestSetup {
  /** List of files to push to the device before starting the test. */
  filesToPush: DeviceFile[];
  /**
   * List of directories on the device to upload to GCS at the end of the test;
   * they must be absolute paths under /sdcard, /storage or /data/local/tmp.
   * Path names are restricted to characters a-z A-Z 0-9 _ - . + and /
   *
   * Note: The paths /sdcard and /data will be made available and treated as
   * implicit path substitutions. E.g. if /sdcard on a particular device does
   * not map to external storage, the system will replace it with the external
   * storage path prefix for that device.
   */
  directoriesToPull: string[];
  /**
   * Optional. Initial setup APKs to install before the app under test is
   * installed. Currently capped at 100.
   */
  initialSetupApks: Apk[];
  /**
   * APKs to install in addition to those being directly tested. These will be
   * installed after the app under test.
   * Currently capped at 100.
   */
  additionalApks: Apk[];
  /** The device will be logged in on this account for the duration of the test. */
  account:
    | Account
    | undefined;
  /**
   * The network traffic profile used for running the test.
   * Available network profiles can be queried by using the
   * NETWORK_CONFIGURATION environment type when calling
   * TestEnvironmentDiscoveryService.GetTestEnvironmentCatalog.
   */
  networkProfile: string;
  /**
   * Environment variables to set for the test (only applicable for
   * instrumentation tests).
   */
  environmentVariables: EnvironmentVariable[];
  /**
   * Systrace configuration for the run.
   * Deprecated: Systrace used Python 2 which was sunsetted on 2020-01-01.
   * Systrace is no longer supported in the Cloud Testing API, and no Systrace
   * file will be provided in the results.
   *
   * @deprecated
   */
  systrace:
    | SystraceSetup
    | undefined;
  /** Whether to prevent all runtime permissions to be granted at app install */
  dontAutograntPermissions: boolean;
}

/** A description of how to set up an iOS device prior to running the test. */
export interface IosTestSetup {
  /**
   * The network traffic profile used for running the test.
   * Available network profiles can be queried by using the
   * NETWORK_CONFIGURATION environment type when calling
   * TestEnvironmentDiscoveryService.GetTestEnvironmentCatalog.
   */
  networkProfile: string;
  /** iOS apps to install in addition to those being directly tested. */
  additionalIpas: FileReference[];
  /** List of files to push to the device before starting the test. */
  pushFiles: IosDeviceFile[];
  /**
   * List of directories on the device to upload to Cloud Storage at the end of
   * the test.
   *
   * Directories should either be in a shared directory (such as
   * /private/var/mobile/Media) or within an accessible directory inside the
   * app's filesystem (such as /Documents) by specifying the bundle ID.
   */
  pullDirectories: IosDeviceFile[];
}

/** A key-value pair passed as an environment variable to the test. */
export interface EnvironmentVariable {
  /** Key for the environment variable. */
  key: string;
  /** Value for the environment variable. */
  value: string;
}

/** Identifies an account and how to log into it. */
export interface Account {
  /** An automatic google login account. */
  googleAuto?: GoogleAuto | undefined;
}

/**
 * Enables automatic Google account login.
 * If set, the service automatically generates a Google test account and adds
 * it to the device, before executing the test. Note that test accounts might be
 * reused.
 * Many applications show their full set of functionalities when an account is
 * present on the device. Logging into the device with these generated accounts
 * allows testing more functionalities.
 */
export interface GoogleAuto {
}

/** An Android package file to install. */
export interface Apk {
  /** The path to an APK to be installed on the device before the test begins. */
  location:
    | FileReference
    | undefined;
  /**
   * The java package for the APK to be installed.
   * Value is determined by examining the application's manifest.
   */
  packageName: string;
}

/**
 * An Android App Bundle file format, containing a BundleConfig.pb file,
 * a base module directory, zero or more dynamic feature module directories.
 * <p>See https://developer.android.com/guide/app-bundle/build for guidance on
 * building App Bundles.
 */
export interface AppBundle {
  /** .aab file representing the app bundle under test. */
  bundleLocation?: FileReference | undefined;
}

/** A single device file description. */
export interface DeviceFile {
  /** A reference to an opaque binary blob file. */
  obbFile?:
    | ObbFile
    | undefined;
  /** A reference to a regular file. */
  regularFile?: RegularFile | undefined;
}

/** An opaque binary blob file to install on the device before the test starts. */
export interface ObbFile {
  /**
   * Required. OBB file name which must conform to the format as specified by
   * Android
   * e.g. [main|patch].0300110.com.example.android.obb
   * which will be installed into
   *   \<shared-storage\>/Android/obb/\<package-name\>/
   * on the device.
   */
  obbFileName: string;
  /** Required. Opaque Binary Blob (OBB) file(s) to install on the device. */
  obb: FileReference | undefined;
}

/** A file or directory to install on the device before the test starts. */
export interface RegularFile {
  /** Required. The source file. */
  content:
    | FileReference
    | undefined;
  /**
   * Required. Where to put the content on the device. Must be an absolute,
   * allowlisted path. If the file exists, it will be replaced.
   * The following device-side directories and any of their subdirectories are
   * allowlisted:
   * <p>${EXTERNAL_STORAGE}, /sdcard, or /storage</p>
   * <p>${ANDROID_DATA}/local/tmp, or /data/local/tmp</p>
   * <p>Specifying a path outside of these directory trees is invalid.
   *
   * <p> The paths /sdcard and /data will be made available and treated as
   * implicit path substitutions. E.g. if /sdcard on a particular device does
   * not map to external storage, the system will replace it with the external
   * storage path prefix for that device and copy the file there.
   *
   * <p> It is strongly advised to use the <a href=
   * "http://developer.android.com/reference/android/os/Environment.html">
   * Environment API</a> in app and test code to access files on the device in a
   * portable way.
   */
  devicePath: string;
}

/** A file or directory to install on the device before the test starts. */
export interface IosDeviceFile {
  /** The source file */
  content:
    | FileReference
    | undefined;
  /**
   * The bundle id of the app where this file lives.
   *
   * iOS apps sandbox their own filesystem, so app files must specify which app
   * installed on the device.
   */
  bundleId: string;
  /** Location of the file on the device, inside the app's sandboxed filesystem */
  devicePath: string;
}

/**
 * A test of an Android Application with a Test Loop.
 * The intent \<intent-name\> will be implicitly added, since Games is the only
 * user of this api, for the time being.
 */
export interface AndroidTestLoop {
  /** The APK for the application under test. */
  appApk?:
    | FileReference
    | undefined;
  /** A multi-apk app bundle for the application under test. */
  appBundle?:
    | AppBundle
    | undefined;
  /**
   * The java package for the application under test.
   * The default is determined by examining the application's manifest.
   */
  appPackageId: string;
  /**
   * The list of scenarios that should be run during the test.
   * The default is all test loops, derived from the application's
   * manifest.
   */
  scenarios: number[];
  /**
   * The list of scenario labels that should be run during the test.
   * The scenario labels should map to labels defined in the application's
   * manifest. For example, player_experience and
   * com.google.test.loops.player_experience add all of the loops labeled in the
   * manifest with the com.google.test.loops.player_experience name to the
   * execution.
   * Scenarios can also be specified in the scenarios field.
   */
  scenarioLabels: string[];
}

/**
 * A test of an iOS application that uses the XCTest framework.
 * Xcode supports the option to "build for testing", which generates an
 * .xctestrun file that contains a test specification (arguments, test methods,
 * etc). This test type accepts a zip file containing the .xctestrun file and
 * the corresponding contents of the Build/Products directory that contains all
 * the binaries needed to run the tests.
 */
export interface IosXcTest {
  /**
   * Required. The .zip containing the .xctestrun file and the contents of the
   * DerivedData/Build/Products directory.
   * The .xctestrun file in this zip is ignored if the xctestrun field is
   * specified.
   */
  testsZip:
    | FileReference
    | undefined;
  /**
   * An .xctestrun file that will override the .xctestrun file in the
   * tests zip. Because the .xctestrun file contains environment variables along
   * with test methods to run and/or ignore, this can be useful for sharding
   * tests. Default is taken from the tests zip.
   */
  xctestrun:
    | FileReference
    | undefined;
  /**
   * The Xcode version that should be used for the test.
   * Use the TestEnvironmentDiscoveryService to get supported options.
   * Defaults to the latest Xcode version Firebase Test Lab supports.
   */
  xcodeVersion: string;
  /** Output only. The bundle id for the application under test. */
  appBundleId: string;
  /**
   * The option to test special app entitlements. Setting this would re-sign the
   * app having special entitlements with an explicit application-identifier.
   * Currently supports testing aps-environment entitlement.
   */
  testSpecialEntitlements: boolean;
}

/**
 * A test of an iOS application that implements one or more game loop scenarios.
 * This test type accepts an archived application (.ipa file) and a list of
 * integer scenarios that will be executed on the app sequentially.
 */
export interface IosTestLoop {
  /** Required. The .ipa of the application to test. */
  appIpa:
    | FileReference
    | undefined;
  /**
   * The list of scenarios that should be run during the test. Defaults to the
   * single scenario 0 if unspecified.
   */
  scenarios: number[];
  /** Output only. The bundle id for the application under test. */
  appBundleId: string;
}

/** A test that explores an iOS application on an iOS device. */
export interface IosRoboTest {
  /** Required. The ipa stored at this file should be used to run the test. */
  appIpa:
    | FileReference
    | undefined;
  /**
   * The bundle ID for the app-under-test.
   * This is determined by examining the application's "Info.plist" file.
   */
  appBundleId: string;
  /**
   * An optional Roboscript to customize the crawl. See
   * https://firebase.google.com/docs/test-lab/android/robo-scripts-reference
   * for more information about Roboscripts.
   */
  roboScript: FileReference | undefined;
}

/**
 * A test of an Android application that can control an Android component
 * independently of its normal lifecycle.
 * Android instrumentation tests run an application APK and test APK inside the
 * same process on a virtual or physical AndroidDevice.  They also specify
 * a test runner class, such as com.google.GoogleTestRunner, which can vary
 * on the specific instrumentation framework chosen.
 *
 * See <https://developer.android.com/training/testing/fundamentals> for
 * more information on types of Android tests.
 */
export interface AndroidInstrumentationTest {
  /** The APK for the application under test. */
  appApk?:
    | FileReference
    | undefined;
  /** A multi-apk app bundle for the application under test. */
  appBundle?:
    | AppBundle
    | undefined;
  /** Required. The APK containing the test code to be executed. */
  testApk:
    | FileReference
    | undefined;
  /**
   * The java package for the application under test.
   * The default value is determined by examining the application's manifest.
   */
  appPackageId: string;
  /**
   * The java package for the test to be executed.
   * The default value is determined by examining the application's manifest.
   */
  testPackageId: string;
  /**
   * The InstrumentationTestRunner class.
   * The default value is determined by examining the application's manifest.
   */
  testRunnerClass: string;
  /**
   * Each target must be fully qualified with the package name or class name,
   * in one of these formats:
   *
   *  - "package package_name"
   *  - "class package_name.class_name"
   *  - "class package_name.class_name#method_name"
   *
   * If empty, all targets in the module will be run.
   */
  testTargets: string[];
  /**
   * The option of whether running each test within its own invocation of
   * instrumentation with Android Test Orchestrator or not.
   * ** Orchestrator is only compatible with AndroidJUnitRunner version 1.1 or
   * higher! **
   * Orchestrator offers the following benefits:
   *
   *  - No shared state
   *  - Crashes are isolated
   *  - Logs are scoped per test
   *
   * See
   * <https://developer.android.com/training/testing/junit-runner.html#using-android-test-orchestrator>
   * for more information about Android Test Orchestrator.
   *
   * If not set, the test will be run without the orchestrator.
   */
  orchestratorOption: OrchestratorOption;
  /** The option to run tests in multiple shards in parallel. */
  shardingOption: ShardingOption | undefined;
}

/**
 * A test of an android application that explores the application on a virtual
 * or physical Android Device, finding culprits and crashes as it goes.
 */
export interface AndroidRoboTest {
  /** The APK for the application under test. */
  appApk?:
    | FileReference
    | undefined;
  /** A multi-apk app bundle for the application under test. */
  appBundle?:
    | AppBundle
    | undefined;
  /**
   * The java package for the application under test.
   * The default value is determined by examining the application's manifest.
   */
  appPackageId: string;
  /** The initial activity that should be used to start the app. */
  appInitialActivity: string;
  /**
   * The max depth of the traversal stack Robo can explore. Needs to be at least
   * 2 to make Robo explore the app beyond the first activity.
   * Default is 50.
   *
   * @deprecated
   */
  maxDepth: number;
  /**
   * The max number of steps Robo can execute.
   * Default is no limit.
   *
   * @deprecated
   */
  maxSteps: number;
  /**
   * A set of directives Robo should apply during the crawl.
   * This allows users to customize the crawl. For example, the username and
   * password for a test account can be provided.
   */
  roboDirectives: RoboDirective[];
  /**
   * The mode in which Robo should run. Most clients should allow the server to
   * populate this field automatically.
   */
  roboMode: RoboMode;
  /**
   * A JSON file with a sequence of actions Robo should perform as a prologue
   * for the crawl.
   */
  roboScript:
    | FileReference
    | undefined;
  /**
   * The intents used to launch the app for the crawl.
   * If none are provided, then the main launcher activity is launched.
   * If some are provided, then only those provided are launched (the main
   * launcher activity must be provided explicitly).
   */
  startingIntents: RoboStartingIntent[];
}

/**
 * Directs Robo to interact with a specific UI element if it is encountered
 * during the crawl. Currently, Robo can perform text entry or element click.
 */
export interface RoboDirective {
  /**
   * Required. The android resource name of the target UI element.
   * For example,
   *    in Java: R.string.foo
   *    in xml: @string/foo
   * Only the "foo" part is needed.
   * Reference doc:
   * https://developer.android.com/guide/topics/resources/accessing-resources.html
   */
  resourceName: string;
  /**
   * The text that Robo is directed to set. If left empty, the directive will be
   * treated as a CLICK on the element matching the resource_name.
   */
  inputText: string;
  /**
   * Required. The type of action that Robo should perform on the specified
   * element.
   */
  actionType: RoboActionType;
}

/** Message for specifying the start activities to crawl. */
export interface RoboStartingIntent {
  /** An intent that starts the main launcher activity. */
  launcherActivity?:
    | LauncherActivityIntent
    | undefined;
  /** An intent that starts an activity with specific details. */
  startActivity?:
    | StartActivityIntent
    | undefined;
  /** Skips the starting activity */
  noActivity?:
    | NoActivityIntent
    | undefined;
  /** Timeout in seconds for each intent. */
  timeout: Duration | undefined;
}

/** Specifies an intent that starts the main launcher activity. */
export interface LauncherActivityIntent {
}

/** A starting intent specified by an action, uri, and categories. */
export interface StartActivityIntent {
  /**
   * Action name.
   * Required for START_ACTIVITY.
   */
  action: string;
  /** URI for the action. */
  uri: string;
  /** Intent categories to set on the intent. */
  categories: string[];
}

/** Skips the starting activity */
export interface NoActivityIntent {
}

/** The matrix of environments in which the test is to be executed. */
export interface EnvironmentMatrix {
  /** A matrix of Android devices. */
  androidMatrix?:
    | AndroidMatrix
    | undefined;
  /**
   * A list of Android devices; the test will be run only on the specified
   * devices.
   */
  androidDeviceList?:
    | AndroidDeviceList
    | undefined;
  /** A list of iOS devices. */
  iosDeviceList?: IosDeviceList | undefined;
}

/** A list of Android device configurations in which the test is to be executed. */
export interface AndroidDeviceList {
  /** Required. A list of Android devices. */
  androidDevices: AndroidDevice[];
}

/** A list of iOS device configurations in which the test is to be executed. */
export interface IosDeviceList {
  /** Required. A list of iOS devices. */
  iosDevices: IosDevice[];
}

/**
 * A set of Android device configuration permutations is defined by the
 * the cross-product of the given axes. Internally, the given AndroidMatrix
 * will be expanded into a set of AndroidDevices.
 *
 * Only supported permutations will be instantiated.  Invalid permutations
 * (e.g., incompatible models/versions) are ignored.
 */
export interface AndroidMatrix {
  /**
   * Required. The ids of the set of Android device to be used.
   * Use the TestEnvironmentDiscoveryService to get supported options.
   */
  androidModelIds: string[];
  /**
   * Required. The ids of the set of Android OS version to be used.
   * Use the TestEnvironmentDiscoveryService to get supported options.
   */
  androidVersionIds: string[];
  /**
   * Required. The set of locales the test device will enable for testing.
   * Use the TestEnvironmentDiscoveryService to get supported options.
   */
  locales: string[];
  /**
   * Required. The set of orientations to test with.
   * Use the TestEnvironmentDiscoveryService to get supported options.
   */
  orientations: string[];
}

/** Information about the client which invoked the test. */
export interface ClientInfo {
  /** Required. Client name, such as gcloud. */
  name: string;
  /** The list of detailed information about client. */
  clientInfoDetails: ClientInfoDetail[];
}

/**
 * Key-value pair of detailed information about the client which invoked the
 * test. Examples: {'Version', '1.0'}, {'Release Track', 'BETA'}.
 */
export interface ClientInfoDetail {
  /** Required. The key of detailed client information. */
  key: string;
  /** Required. The value of detailed client information. */
  value: string;
}

/** Locations where the results of running the test are stored. */
export interface ResultStorage {
  /** Required. */
  googleCloudStorage:
    | GoogleCloudStorage
    | undefined;
  /**
   * The tool results history that contains the tool results execution that
   * results are written to.
   *
   * If not provided, the service will choose an appropriate value.
   */
  toolResultsHistory:
    | ToolResultsHistory
    | undefined;
  /** Output only. The tool results execution that results are written to. */
  toolResultsExecution:
    | ToolResultsExecution
    | undefined;
  /** Output only. URL to the results in the Firebase Web Console. */
  resultsUrl: string;
}

/** Represents a tool results history resource. */
export interface ToolResultsHistory {
  /** Required. The cloud project that owns the tool results history. */
  projectId: string;
  /** Required. A tool results history ID. */
  historyId: string;
}

/**
 * Represents a tool results execution resource.
 *
 * This has the results of a TestMatrix.
 */
export interface ToolResultsExecution {
  /** Output only. The cloud project that owns the tool results execution. */
  projectId: string;
  /** Output only. A tool results history ID. */
  historyId: string;
  /** Output only. A tool results execution ID. */
  executionId: string;
}

/**
 * Represents a tool results step resource.
 *
 * This has the results of a TestExecution.
 */
export interface ToolResultsStep {
  /** Output only. The cloud project that owns the tool results step. */
  projectId: string;
  /** Output only. A tool results history ID. */
  historyId: string;
  /** Output only. A tool results execution ID. */
  executionId: string;
  /** Output only. A tool results step ID. */
  stepId: string;
}

/** A storage location within Google cloud storage (GCS). */
export interface GoogleCloudStorage {
  /**
   * Required. The path to a directory in GCS that will
   * eventually contain the results for this test.
   * The requesting user must have write access on the bucket in the supplied
   * path.
   */
  gcsPath: string;
}

/** A reference to a file, used for user inputs. */
export interface FileReference {
  /**
   * A path to a file in Google Cloud Storage.
   * Example: gs://build-app-1414623860166/app%40debug-unaligned.apk
   * These paths are expected to be url encoded (percent encoding)
   */
  gcsPath?: string | undefined;
}

/** The environment in which the test is run. */
export interface Environment {
  /** An Android device which must be used with an Android test. */
  androidDevice?:
    | AndroidDevice
    | undefined;
  /** An iOS device which must be used with an iOS test. */
  iosDevice?: IosDevice | undefined;
}

/** A single Android device. */
export interface AndroidDevice {
  /**
   * Required. The id of the Android device to be used.
   * Use the TestEnvironmentDiscoveryService to get supported options.
   */
  androidModelId: string;
  /**
   * Required. The id of the Android OS version to be used.
   * Use the TestEnvironmentDiscoveryService to get supported options.
   */
  androidVersionId: string;
  /**
   * Required. The locale the test device used for testing.
   * Use the TestEnvironmentDiscoveryService to get supported options.
   */
  locale: string;
  /**
   * Required. How the device is oriented during the test.
   * Use the TestEnvironmentDiscoveryService to get supported options.
   */
  orientation: string;
}

/** A single iOS device. */
export interface IosDevice {
  /**
   * Required. The id of the iOS device to be used.
   * Use the TestEnvironmentDiscoveryService to get supported options.
   */
  iosModelId: string;
  /**
   * Required. The id of the iOS major software version to be used.
   * Use the TestEnvironmentDiscoveryService to get supported options.
   */
  iosVersionId: string;
  /**
   * Required. The locale the test device used for testing.
   * Use the TestEnvironmentDiscoveryService to get supported options.
   */
  locale: string;
  /**
   * Required. How the device is oriented during the test.
   * Use the TestEnvironmentDiscoveryService to get supported options.
   */
  orientation: string;
}

/** Additional details about the progress of the running test. */
export interface TestDetails {
  /**
   * Output only. Human-readable, detailed descriptions of the test's progress.
   * For example: "Provisioning a device", "Starting Test".
   *
   * During the course of execution new data may be appended
   * to the end of progress_messages.
   */
  progressMessages: string[];
  /**
   * Output only. If the TestState is ERROR, then this string will contain
   * human-readable details about the error.
   */
  errorMessage: string;
}

/** Details behind an invalid request. */
export interface InvalidRequestDetail {
  /** The reason behind the error. */
  reason: InvalidRequestDetail_Reason;
}

/** Possible invalid request reasons. */
export enum InvalidRequestDetail_Reason {
  /** REASON_UNSPECIFIED - No reason has been specified - the default. */
  REASON_UNSPECIFIED = 0,
  /** REQUEST_INVALID - The request is not valid. */
  REQUEST_INVALID = 1,
  /** RESOURCE_TOO_BIG - One or more of the resources specified in the request is too large. */
  RESOURCE_TOO_BIG = 2,
  /** RESOURCE_NOT_FOUND - One or more resources specified in the request cannot be found. */
  RESOURCE_NOT_FOUND = 3,
  /** UNSUPPORTED - This request is not (currently) supported. */
  UNSUPPORTED = 4,
  /** NOT_IMPLEMENTED - This request is not currently implemented. */
  NOT_IMPLEMENTED = 5,
  /** RESULT_STORAGE_PERMISSION_DENIED - The caller has no permission for storing the test results */
  RESULT_STORAGE_PERMISSION_DENIED = 6,
  UNRECOGNIZED = -1,
}

export function invalidRequestDetail_ReasonFromJSON(object: any): InvalidRequestDetail_Reason {
  switch (object) {
    case 0:
    case "REASON_UNSPECIFIED":
      return InvalidRequestDetail_Reason.REASON_UNSPECIFIED;
    case 1:
    case "REQUEST_INVALID":
      return InvalidRequestDetail_Reason.REQUEST_INVALID;
    case 2:
    case "RESOURCE_TOO_BIG":
      return InvalidRequestDetail_Reason.RESOURCE_TOO_BIG;
    case 3:
    case "RESOURCE_NOT_FOUND":
      return InvalidRequestDetail_Reason.RESOURCE_NOT_FOUND;
    case 4:
    case "UNSUPPORTED":
      return InvalidRequestDetail_Reason.UNSUPPORTED;
    case 5:
    case "NOT_IMPLEMENTED":
      return InvalidRequestDetail_Reason.NOT_IMPLEMENTED;
    case 6:
    case "RESULT_STORAGE_PERMISSION_DENIED":
      return InvalidRequestDetail_Reason.RESULT_STORAGE_PERMISSION_DENIED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return InvalidRequestDetail_Reason.UNRECOGNIZED;
  }
}

export function invalidRequestDetail_ReasonToJSON(object: InvalidRequestDetail_Reason): string {
  switch (object) {
    case InvalidRequestDetail_Reason.REASON_UNSPECIFIED:
      return "REASON_UNSPECIFIED";
    case InvalidRequestDetail_Reason.REQUEST_INVALID:
      return "REQUEST_INVALID";
    case InvalidRequestDetail_Reason.RESOURCE_TOO_BIG:
      return "RESOURCE_TOO_BIG";
    case InvalidRequestDetail_Reason.RESOURCE_NOT_FOUND:
      return "RESOURCE_NOT_FOUND";
    case InvalidRequestDetail_Reason.UNSUPPORTED:
      return "UNSUPPORTED";
    case InvalidRequestDetail_Reason.NOT_IMPLEMENTED:
      return "NOT_IMPLEMENTED";
    case InvalidRequestDetail_Reason.RESULT_STORAGE_PERMISSION_DENIED:
      return "RESULT_STORAGE_PERMISSION_DENIED";
    case InvalidRequestDetail_Reason.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Options for enabling sharding. */
export interface ShardingOption {
  /** Uniformly shards test cases given a total number of shards. */
  uniformSharding?:
    | UniformSharding
    | undefined;
  /**
   * Shards test cases into the specified groups of packages, classes, and/or
   * methods.
   */
  manualSharding?:
    | ManualSharding
    | undefined;
  /** Shards test based on previous test case timing records. */
  smartSharding?: SmartSharding | undefined;
}

/**
 * Uniformly shards test cases given a total number of shards.
 *
 * For instrumentation tests, it will be translated to "-e numShard" and "-e
 * shardIndex" AndroidJUnitRunner arguments. With uniform sharding enabled,
 * specifying either of these sharding arguments via `environment_variables` is
 * invalid.
 *
 * Based on the sharding mechanism AndroidJUnitRunner uses, there is no
 * guarantee that test cases will be distributed uniformly across all shards.
 */
export interface UniformSharding {
  /**
   * Required. The total number of shards to create. This must always be a
   * positive number that is no greater than the total number of test cases.
   * When you select one or more physical devices, the number of shards must be
   * <= 50. When you select one or more ARM virtual devices, it must be <= 200.
   * When you select only x86 virtual devices, it must be <= 500.
   */
  numShards: number;
}

/**
 * Shards test cases into the specified groups of packages, classes, and/or
 * methods.
 *
 * With manual sharding enabled, specifying test targets via
 * environment_variables or in InstrumentationTest is invalid.
 */
export interface ManualSharding {
  /**
   * Required. Group of packages, classes, and/or test methods to be run for
   * each manually-created shard. You must specify at least one shard if this
   * field is present. When you select one or more physical devices, the number
   * of repeated test_targets_for_shard must be <= 50. When you select one or
   * more ARM virtual devices, it must be <= 200. When you select only x86
   * virtual devices, it must be <= 500.
   */
  testTargetsForShard: TestTargetsForShard[];
}

/** Test targets for a shard. */
export interface TestTargetsForShard {
  /**
   * Group of packages, classes, and/or test methods to be run for each shard.
   * The targets need to be specified in AndroidJUnitRunner argument format. For
   * example, "package com.my.packages" "class com.my.package.MyClass".
   *
   * The number of test_targets must be greater than 0.
   */
  testTargets: string[];
}

/** Shards test based on previous test case timing records. */
export interface SmartSharding {
  /**
   * The amount of time tests within a shard should take.
   *
   * Default: 300 seconds (5 minutes).
   * The minimum allowed: 120 seconds (2 minutes).
   *
   * The shard count is dynamically set based on time, up to the maximum shard
   * limit (described below). To guarantee at least one test case for each
   * shard, the number of shards will not exceed the number of test cases. Shard
   * duration will be exceeded if:
   *
   * - The maximum shard limit is reached and there is more calculated test time
   * remaining to allocate into shards.
   * - Any individual test is estimated to be longer than the targeted shard
   * duration.
   *
   * Shard duration is not guaranteed because smart sharding uses test case
   * history and default durations which may not be accurate. The rules for
   * finding the test case timing records are:
   *
   * - If the service has processed a test case in the last 30 days, the record
   *  of the latest successful test case will be used.
   * - For new test cases, the average duration of other known test cases will
   *  be used.
   * - If there are no previous test case timing records available, the default
   *  test case duration is 15 seconds.
   *
   * Because the actual shard duration can exceed the targeted shard duration,
   * we recommend that you set the targeted value at least 5 minutes less than
   * the maximum allowed test timeout (45 minutes for physical devices and 60
   * minutes for virtual), or that you use the custom test timeout value that
   * you set. This approach avoids cancelling the shard before all tests can
   * finish.
   *
   * Note that there is a limit for maximum number of shards. When you select
   * one or more physical devices, the number of shards must be <= 50. When you
   * select one or more ARM virtual devices, it must be <= 200. When you select
   * only x86 virtual devices, it must be <= 500. To guarantee at least one test
   * case for per shard, the number of shards will not exceed the number of test
   * cases. Each shard created counts toward daily test quota.
   */
  targetedShardDuration: Duration | undefined;
}

/** Output only. Details about the shard. */
export interface Shard {
  /** Output only. The index of the shard among all the shards. */
  shardIndex: number;
  /** Output only. The total number of shards. */
  numShards: number;
  /** Output only. Test targets for each shard. Only set for manual sharding. */
  testTargetsForShard:
    | TestTargetsForShard
    | undefined;
  /**
   * Output only. The estimated shard duration based on previous test case
   * timing records, if available.
   */
  estimatedShardDuration: Duration | undefined;
}

/** Request to submit a matrix of tests for execution. */
export interface CreateTestMatrixRequest {
  /** The GCE project under which this job will run. */
  projectId: string;
  /** The matrix of tests that the user wants to run. */
  testMatrix:
    | TestMatrix
    | undefined;
  /**
   * A string id used to detect duplicated requests.
   * Ids are automatically scoped to a project, so
   * users should ensure the ID is unique per-project.
   * A UUID is recommended.
   *
   * Optional, but strongly recommended.
   */
  requestId: string;
}

/** Request to get the Test Matrix with the given id. */
export interface GetTestMatrixRequest {
  /** Cloud project that owns the test matrix. */
  projectId: string;
  /** Unique test matrix id which was assigned by the service. */
  testMatrixId: string;
}

/** Request to stop running all of the tests in the specified matrix. */
export interface CancelTestMatrixRequest {
  /** Cloud project that owns the test. */
  projectId: string;
  /** Test matrix that will be canceled. */
  testMatrixId: string;
}

/** Response containing the current state of the specified test matrix. */
export interface CancelTestMatrixResponse {
  /**
   * The current rolled-up state of the test matrix.
   * If this state is already final, then the cancelation request will
   * have no effect.
   */
  testState: TestState;
}

function createBaseTestMatrix(): TestMatrix {
  return {
    testMatrixId: "",
    projectId: "",
    clientInfo: undefined,
    testSpecification: undefined,
    environmentMatrix: undefined,
    testExecutions: [],
    resultStorage: undefined,
    state: 0,
    timestamp: undefined,
    invalidMatrixDetails: 0,
    extendedInvalidMatrixDetails: [],
    flakyTestAttempts: 0,
    outcomeSummary: 0,
    failFast: false,
  };
}

export const TestMatrix: MessageFns<TestMatrix> = {
  encode(message: TestMatrix, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.testMatrixId !== "") {
      writer.uint32(10).string(message.testMatrixId);
    }
    if (message.projectId !== "") {
      writer.uint32(58).string(message.projectId);
    }
    if (message.clientInfo !== undefined) {
      ClientInfo.encode(message.clientInfo, writer.uint32(82).fork()).join();
    }
    if (message.testSpecification !== undefined) {
      TestSpecification.encode(message.testSpecification, writer.uint32(26).fork()).join();
    }
    if (message.environmentMatrix !== undefined) {
      EnvironmentMatrix.encode(message.environmentMatrix, writer.uint32(34).fork()).join();
    }
    for (const v of message.testExecutions) {
      TestExecution.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.resultStorage !== undefined) {
      ResultStorage.encode(message.resultStorage, writer.uint32(50).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(64).int32(message.state);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(74).fork()).join();
    }
    if (message.invalidMatrixDetails !== 0) {
      writer.uint32(88).int32(message.invalidMatrixDetails);
    }
    for (const v of message.extendedInvalidMatrixDetails) {
      MatrixErrorDetail.encode(v!, writer.uint32(178).fork()).join();
    }
    if (message.flakyTestAttempts !== 0) {
      writer.uint32(104).int32(message.flakyTestAttempts);
    }
    if (message.outcomeSummary !== 0) {
      writer.uint32(112).int32(message.outcomeSummary);
    }
    if (message.failFast !== false) {
      writer.uint32(136).bool(message.failFast);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestMatrix {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestMatrix();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.testMatrixId = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.clientInfo = ClientInfo.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.testSpecification = TestSpecification.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.environmentMatrix = EnvironmentMatrix.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.testExecutions.push(TestExecution.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.resultStorage = ResultStorage.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.invalidMatrixDetails = reader.int32() as any;
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.extendedInvalidMatrixDetails.push(MatrixErrorDetail.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.flakyTestAttempts = reader.int32();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.outcomeSummary = reader.int32() as any;
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.failFast = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestMatrix {
    return {
      testMatrixId: isSet(object.testMatrixId) ? globalThis.String(object.testMatrixId) : "",
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      clientInfo: isSet(object.clientInfo) ? ClientInfo.fromJSON(object.clientInfo) : undefined,
      testSpecification: isSet(object.testSpecification)
        ? TestSpecification.fromJSON(object.testSpecification)
        : undefined,
      environmentMatrix: isSet(object.environmentMatrix)
        ? EnvironmentMatrix.fromJSON(object.environmentMatrix)
        : undefined,
      testExecutions: globalThis.Array.isArray(object?.testExecutions)
        ? object.testExecutions.map((e: any) => TestExecution.fromJSON(e))
        : [],
      resultStorage: isSet(object.resultStorage) ? ResultStorage.fromJSON(object.resultStorage) : undefined,
      state: isSet(object.state) ? testStateFromJSON(object.state) : 0,
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      invalidMatrixDetails: isSet(object.invalidMatrixDetails)
        ? invalidMatrixDetailsFromJSON(object.invalidMatrixDetails)
        : 0,
      extendedInvalidMatrixDetails: globalThis.Array.isArray(object?.extendedInvalidMatrixDetails)
        ? object.extendedInvalidMatrixDetails.map((e: any) => MatrixErrorDetail.fromJSON(e))
        : [],
      flakyTestAttempts: isSet(object.flakyTestAttempts) ? globalThis.Number(object.flakyTestAttempts) : 0,
      outcomeSummary: isSet(object.outcomeSummary) ? outcomeSummaryFromJSON(object.outcomeSummary) : 0,
      failFast: isSet(object.failFast) ? globalThis.Boolean(object.failFast) : false,
    };
  },

  toJSON(message: TestMatrix): unknown {
    const obj: any = {};
    if (message.testMatrixId !== "") {
      obj.testMatrixId = message.testMatrixId;
    }
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.clientInfo !== undefined) {
      obj.clientInfo = ClientInfo.toJSON(message.clientInfo);
    }
    if (message.testSpecification !== undefined) {
      obj.testSpecification = TestSpecification.toJSON(message.testSpecification);
    }
    if (message.environmentMatrix !== undefined) {
      obj.environmentMatrix = EnvironmentMatrix.toJSON(message.environmentMatrix);
    }
    if (message.testExecutions?.length) {
      obj.testExecutions = message.testExecutions.map((e) => TestExecution.toJSON(e));
    }
    if (message.resultStorage !== undefined) {
      obj.resultStorage = ResultStorage.toJSON(message.resultStorage);
    }
    if (message.state !== 0) {
      obj.state = testStateToJSON(message.state);
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.invalidMatrixDetails !== 0) {
      obj.invalidMatrixDetails = invalidMatrixDetailsToJSON(message.invalidMatrixDetails);
    }
    if (message.extendedInvalidMatrixDetails?.length) {
      obj.extendedInvalidMatrixDetails = message.extendedInvalidMatrixDetails.map((e) => MatrixErrorDetail.toJSON(e));
    }
    if (message.flakyTestAttempts !== 0) {
      obj.flakyTestAttempts = Math.round(message.flakyTestAttempts);
    }
    if (message.outcomeSummary !== 0) {
      obj.outcomeSummary = outcomeSummaryToJSON(message.outcomeSummary);
    }
    if (message.failFast !== false) {
      obj.failFast = message.failFast;
    }
    return obj;
  },

  create(base?: DeepPartial<TestMatrix>): TestMatrix {
    return TestMatrix.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TestMatrix>): TestMatrix {
    const message = createBaseTestMatrix();
    message.testMatrixId = object.testMatrixId ?? "";
    message.projectId = object.projectId ?? "";
    message.clientInfo = (object.clientInfo !== undefined && object.clientInfo !== null)
      ? ClientInfo.fromPartial(object.clientInfo)
      : undefined;
    message.testSpecification = (object.testSpecification !== undefined && object.testSpecification !== null)
      ? TestSpecification.fromPartial(object.testSpecification)
      : undefined;
    message.environmentMatrix = (object.environmentMatrix !== undefined && object.environmentMatrix !== null)
      ? EnvironmentMatrix.fromPartial(object.environmentMatrix)
      : undefined;
    message.testExecutions = object.testExecutions?.map((e) => TestExecution.fromPartial(e)) || [];
    message.resultStorage = (object.resultStorage !== undefined && object.resultStorage !== null)
      ? ResultStorage.fromPartial(object.resultStorage)
      : undefined;
    message.state = object.state ?? 0;
    message.timestamp = object.timestamp ?? undefined;
    message.invalidMatrixDetails = object.invalidMatrixDetails ?? 0;
    message.extendedInvalidMatrixDetails =
      object.extendedInvalidMatrixDetails?.map((e) => MatrixErrorDetail.fromPartial(e)) || [];
    message.flakyTestAttempts = object.flakyTestAttempts ?? 0;
    message.outcomeSummary = object.outcomeSummary ?? 0;
    message.failFast = object.failFast ?? false;
    return message;
  },
};

function createBaseMatrixErrorDetail(): MatrixErrorDetail {
  return { reason: "", message: "" };
}

export const MatrixErrorDetail: MessageFns<MatrixErrorDetail> = {
  encode(message: MatrixErrorDetail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reason !== "") {
      writer.uint32(10).string(message.reason);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MatrixErrorDetail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatrixErrorDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.reason = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MatrixErrorDetail {
    return {
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: MatrixErrorDetail): unknown {
    const obj: any = {};
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create(base?: DeepPartial<MatrixErrorDetail>): MatrixErrorDetail {
    return MatrixErrorDetail.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MatrixErrorDetail>): MatrixErrorDetail {
    const message = createBaseMatrixErrorDetail();
    message.reason = object.reason ?? "";
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseTestExecution(): TestExecution {
  return {
    id: "",
    matrixId: "",
    projectId: "",
    testSpecification: undefined,
    shard: undefined,
    environment: undefined,
    state: 0,
    toolResultsStep: undefined,
    timestamp: undefined,
    testDetails: undefined,
  };
}

export const TestExecution: MessageFns<TestExecution> = {
  encode(message: TestExecution, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.matrixId !== "") {
      writer.uint32(74).string(message.matrixId);
    }
    if (message.projectId !== "") {
      writer.uint32(82).string(message.projectId);
    }
    if (message.testSpecification !== undefined) {
      TestSpecification.encode(message.testSpecification, writer.uint32(26).fork()).join();
    }
    if (message.shard !== undefined) {
      Shard.encode(message.shard, writer.uint32(98).fork()).join();
    }
    if (message.environment !== undefined) {
      Environment.encode(message.environment, writer.uint32(34).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(40).int32(message.state);
    }
    if (message.toolResultsStep !== undefined) {
      ToolResultsStep.encode(message.toolResultsStep, writer.uint32(90).fork()).join();
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(58).fork()).join();
    }
    if (message.testDetails !== undefined) {
      TestDetails.encode(message.testDetails, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestExecution {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestExecution();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.matrixId = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.testSpecification = TestSpecification.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.shard = Shard.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.environment = Environment.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.toolResultsStep = ToolResultsStep.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.testDetails = TestDetails.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestExecution {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      matrixId: isSet(object.matrixId) ? globalThis.String(object.matrixId) : "",
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      testSpecification: isSet(object.testSpecification)
        ? TestSpecification.fromJSON(object.testSpecification)
        : undefined,
      shard: isSet(object.shard) ? Shard.fromJSON(object.shard) : undefined,
      environment: isSet(object.environment) ? Environment.fromJSON(object.environment) : undefined,
      state: isSet(object.state) ? testStateFromJSON(object.state) : 0,
      toolResultsStep: isSet(object.toolResultsStep) ? ToolResultsStep.fromJSON(object.toolResultsStep) : undefined,
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      testDetails: isSet(object.testDetails) ? TestDetails.fromJSON(object.testDetails) : undefined,
    };
  },

  toJSON(message: TestExecution): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.matrixId !== "") {
      obj.matrixId = message.matrixId;
    }
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.testSpecification !== undefined) {
      obj.testSpecification = TestSpecification.toJSON(message.testSpecification);
    }
    if (message.shard !== undefined) {
      obj.shard = Shard.toJSON(message.shard);
    }
    if (message.environment !== undefined) {
      obj.environment = Environment.toJSON(message.environment);
    }
    if (message.state !== 0) {
      obj.state = testStateToJSON(message.state);
    }
    if (message.toolResultsStep !== undefined) {
      obj.toolResultsStep = ToolResultsStep.toJSON(message.toolResultsStep);
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.testDetails !== undefined) {
      obj.testDetails = TestDetails.toJSON(message.testDetails);
    }
    return obj;
  },

  create(base?: DeepPartial<TestExecution>): TestExecution {
    return TestExecution.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TestExecution>): TestExecution {
    const message = createBaseTestExecution();
    message.id = object.id ?? "";
    message.matrixId = object.matrixId ?? "";
    message.projectId = object.projectId ?? "";
    message.testSpecification = (object.testSpecification !== undefined && object.testSpecification !== null)
      ? TestSpecification.fromPartial(object.testSpecification)
      : undefined;
    message.shard = (object.shard !== undefined && object.shard !== null) ? Shard.fromPartial(object.shard) : undefined;
    message.environment = (object.environment !== undefined && object.environment !== null)
      ? Environment.fromPartial(object.environment)
      : undefined;
    message.state = object.state ?? 0;
    message.toolResultsStep = (object.toolResultsStep !== undefined && object.toolResultsStep !== null)
      ? ToolResultsStep.fromPartial(object.toolResultsStep)
      : undefined;
    message.timestamp = object.timestamp ?? undefined;
    message.testDetails = (object.testDetails !== undefined && object.testDetails !== null)
      ? TestDetails.fromPartial(object.testDetails)
      : undefined;
    return message;
  },
};

function createBaseTestSpecification(): TestSpecification {
  return {
    testTimeout: undefined,
    testSetup: undefined,
    iosTestSetup: undefined,
    androidInstrumentationTest: undefined,
    androidRoboTest: undefined,
    androidTestLoop: undefined,
    iosXcTest: undefined,
    iosTestLoop: undefined,
    iosRoboTest: undefined,
    disableVideoRecording: false,
    disablePerformanceMetrics: false,
  };
}

export const TestSpecification: MessageFns<TestSpecification> = {
  encode(message: TestSpecification, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.testTimeout !== undefined) {
      Duration.encode(message.testTimeout, writer.uint32(10).fork()).join();
    }
    if (message.testSetup !== undefined) {
      TestSetup.encode(message.testSetup, writer.uint32(50).fork()).join();
    }
    if (message.iosTestSetup !== undefined) {
      IosTestSetup.encode(message.iosTestSetup, writer.uint32(114).fork()).join();
    }
    if (message.androidInstrumentationTest !== undefined) {
      AndroidInstrumentationTest.encode(message.androidInstrumentationTest, writer.uint32(18).fork()).join();
    }
    if (message.androidRoboTest !== undefined) {
      AndroidRoboTest.encode(message.androidRoboTest, writer.uint32(26).fork()).join();
    }
    if (message.androidTestLoop !== undefined) {
      AndroidTestLoop.encode(message.androidTestLoop, writer.uint32(74).fork()).join();
    }
    if (message.iosXcTest !== undefined) {
      IosXcTest.encode(message.iosXcTest, writer.uint32(106).fork()).join();
    }
    if (message.iosTestLoop !== undefined) {
      IosTestLoop.encode(message.iosTestLoop, writer.uint32(122).fork()).join();
    }
    if (message.iosRoboTest !== undefined) {
      IosRoboTest.encode(message.iosRoboTest, writer.uint32(138).fork()).join();
    }
    if (message.disableVideoRecording !== false) {
      writer.uint32(80).bool(message.disableVideoRecording);
    }
    if (message.disablePerformanceMetrics !== false) {
      writer.uint32(88).bool(message.disablePerformanceMetrics);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestSpecification {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestSpecification();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.testTimeout = Duration.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.testSetup = TestSetup.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.iosTestSetup = IosTestSetup.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.androidInstrumentationTest = AndroidInstrumentationTest.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.androidRoboTest = AndroidRoboTest.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.androidTestLoop = AndroidTestLoop.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.iosXcTest = IosXcTest.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.iosTestLoop = IosTestLoop.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.iosRoboTest = IosRoboTest.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.disableVideoRecording = reader.bool();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.disablePerformanceMetrics = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestSpecification {
    return {
      testTimeout: isSet(object.testTimeout) ? Duration.fromJSON(object.testTimeout) : undefined,
      testSetup: isSet(object.testSetup) ? TestSetup.fromJSON(object.testSetup) : undefined,
      iosTestSetup: isSet(object.iosTestSetup) ? IosTestSetup.fromJSON(object.iosTestSetup) : undefined,
      androidInstrumentationTest: isSet(object.androidInstrumentationTest)
        ? AndroidInstrumentationTest.fromJSON(object.androidInstrumentationTest)
        : undefined,
      androidRoboTest: isSet(object.androidRoboTest) ? AndroidRoboTest.fromJSON(object.androidRoboTest) : undefined,
      androidTestLoop: isSet(object.androidTestLoop) ? AndroidTestLoop.fromJSON(object.androidTestLoop) : undefined,
      iosXcTest: isSet(object.iosXcTest) ? IosXcTest.fromJSON(object.iosXcTest) : undefined,
      iosTestLoop: isSet(object.iosTestLoop) ? IosTestLoop.fromJSON(object.iosTestLoop) : undefined,
      iosRoboTest: isSet(object.iosRoboTest) ? IosRoboTest.fromJSON(object.iosRoboTest) : undefined,
      disableVideoRecording: isSet(object.disableVideoRecording)
        ? globalThis.Boolean(object.disableVideoRecording)
        : false,
      disablePerformanceMetrics: isSet(object.disablePerformanceMetrics)
        ? globalThis.Boolean(object.disablePerformanceMetrics)
        : false,
    };
  },

  toJSON(message: TestSpecification): unknown {
    const obj: any = {};
    if (message.testTimeout !== undefined) {
      obj.testTimeout = Duration.toJSON(message.testTimeout);
    }
    if (message.testSetup !== undefined) {
      obj.testSetup = TestSetup.toJSON(message.testSetup);
    }
    if (message.iosTestSetup !== undefined) {
      obj.iosTestSetup = IosTestSetup.toJSON(message.iosTestSetup);
    }
    if (message.androidInstrumentationTest !== undefined) {
      obj.androidInstrumentationTest = AndroidInstrumentationTest.toJSON(message.androidInstrumentationTest);
    }
    if (message.androidRoboTest !== undefined) {
      obj.androidRoboTest = AndroidRoboTest.toJSON(message.androidRoboTest);
    }
    if (message.androidTestLoop !== undefined) {
      obj.androidTestLoop = AndroidTestLoop.toJSON(message.androidTestLoop);
    }
    if (message.iosXcTest !== undefined) {
      obj.iosXcTest = IosXcTest.toJSON(message.iosXcTest);
    }
    if (message.iosTestLoop !== undefined) {
      obj.iosTestLoop = IosTestLoop.toJSON(message.iosTestLoop);
    }
    if (message.iosRoboTest !== undefined) {
      obj.iosRoboTest = IosRoboTest.toJSON(message.iosRoboTest);
    }
    if (message.disableVideoRecording !== false) {
      obj.disableVideoRecording = message.disableVideoRecording;
    }
    if (message.disablePerformanceMetrics !== false) {
      obj.disablePerformanceMetrics = message.disablePerformanceMetrics;
    }
    return obj;
  },

  create(base?: DeepPartial<TestSpecification>): TestSpecification {
    return TestSpecification.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TestSpecification>): TestSpecification {
    const message = createBaseTestSpecification();
    message.testTimeout = (object.testTimeout !== undefined && object.testTimeout !== null)
      ? Duration.fromPartial(object.testTimeout)
      : undefined;
    message.testSetup = (object.testSetup !== undefined && object.testSetup !== null)
      ? TestSetup.fromPartial(object.testSetup)
      : undefined;
    message.iosTestSetup = (object.iosTestSetup !== undefined && object.iosTestSetup !== null)
      ? IosTestSetup.fromPartial(object.iosTestSetup)
      : undefined;
    message.androidInstrumentationTest =
      (object.androidInstrumentationTest !== undefined && object.androidInstrumentationTest !== null)
        ? AndroidInstrumentationTest.fromPartial(object.androidInstrumentationTest)
        : undefined;
    message.androidRoboTest = (object.androidRoboTest !== undefined && object.androidRoboTest !== null)
      ? AndroidRoboTest.fromPartial(object.androidRoboTest)
      : undefined;
    message.androidTestLoop = (object.androidTestLoop !== undefined && object.androidTestLoop !== null)
      ? AndroidTestLoop.fromPartial(object.androidTestLoop)
      : undefined;
    message.iosXcTest = (object.iosXcTest !== undefined && object.iosXcTest !== null)
      ? IosXcTest.fromPartial(object.iosXcTest)
      : undefined;
    message.iosTestLoop = (object.iosTestLoop !== undefined && object.iosTestLoop !== null)
      ? IosTestLoop.fromPartial(object.iosTestLoop)
      : undefined;
    message.iosRoboTest = (object.iosRoboTest !== undefined && object.iosRoboTest !== null)
      ? IosRoboTest.fromPartial(object.iosRoboTest)
      : undefined;
    message.disableVideoRecording = object.disableVideoRecording ?? false;
    message.disablePerformanceMetrics = object.disablePerformanceMetrics ?? false;
    return message;
  },
};

function createBaseSystraceSetup(): SystraceSetup {
  return { durationSeconds: 0 };
}

export const SystraceSetup: MessageFns<SystraceSetup> = {
  encode(message: SystraceSetup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.durationSeconds !== 0) {
      writer.uint32(8).int32(message.durationSeconds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SystraceSetup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSystraceSetup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.durationSeconds = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SystraceSetup {
    return { durationSeconds: isSet(object.durationSeconds) ? globalThis.Number(object.durationSeconds) : 0 };
  },

  toJSON(message: SystraceSetup): unknown {
    const obj: any = {};
    if (message.durationSeconds !== 0) {
      obj.durationSeconds = Math.round(message.durationSeconds);
    }
    return obj;
  },

  create(base?: DeepPartial<SystraceSetup>): SystraceSetup {
    return SystraceSetup.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SystraceSetup>): SystraceSetup {
    const message = createBaseSystraceSetup();
    message.durationSeconds = object.durationSeconds ?? 0;
    return message;
  },
};

function createBaseTestSetup(): TestSetup {
  return {
    filesToPush: [],
    directoriesToPull: [],
    initialSetupApks: [],
    additionalApks: [],
    account: undefined,
    networkProfile: "",
    environmentVariables: [],
    systrace: undefined,
    dontAutograntPermissions: false,
  };
}

export const TestSetup: MessageFns<TestSetup> = {
  encode(message: TestSetup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.filesToPush) {
      DeviceFile.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.directoriesToPull) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.initialSetupApks) {
      Apk.encode(v!, writer.uint32(234).fork()).join();
    }
    for (const v of message.additionalApks) {
      Apk.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.account !== undefined) {
      Account.encode(message.account, writer.uint32(34).fork()).join();
    }
    if (message.networkProfile !== "") {
      writer.uint32(42).string(message.networkProfile);
    }
    for (const v of message.environmentVariables) {
      EnvironmentVariable.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.systrace !== undefined) {
      SystraceSetup.encode(message.systrace, writer.uint32(74).fork()).join();
    }
    if (message.dontAutograntPermissions !== false) {
      writer.uint32(184).bool(message.dontAutograntPermissions);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestSetup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestSetup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.filesToPush.push(DeviceFile.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.directoriesToPull.push(reader.string());
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }

          message.initialSetupApks.push(Apk.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.additionalApks.push(Apk.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.account = Account.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.networkProfile = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.environmentVariables.push(EnvironmentVariable.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.systrace = SystraceSetup.decode(reader, reader.uint32());
          continue;
        case 23:
          if (tag !== 184) {
            break;
          }

          message.dontAutograntPermissions = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestSetup {
    return {
      filesToPush: globalThis.Array.isArray(object?.filesToPush)
        ? object.filesToPush.map((e: any) => DeviceFile.fromJSON(e))
        : [],
      directoriesToPull: globalThis.Array.isArray(object?.directoriesToPull)
        ? object.directoriesToPull.map((e: any) => globalThis.String(e))
        : [],
      initialSetupApks: globalThis.Array.isArray(object?.initialSetupApks)
        ? object.initialSetupApks.map((e: any) => Apk.fromJSON(e))
        : [],
      additionalApks: globalThis.Array.isArray(object?.additionalApks)
        ? object.additionalApks.map((e: any) => Apk.fromJSON(e))
        : [],
      account: isSet(object.account) ? Account.fromJSON(object.account) : undefined,
      networkProfile: isSet(object.networkProfile) ? globalThis.String(object.networkProfile) : "",
      environmentVariables: globalThis.Array.isArray(object?.environmentVariables)
        ? object.environmentVariables.map((e: any) => EnvironmentVariable.fromJSON(e))
        : [],
      systrace: isSet(object.systrace) ? SystraceSetup.fromJSON(object.systrace) : undefined,
      dontAutograntPermissions: isSet(object.dontAutograntPermissions)
        ? globalThis.Boolean(object.dontAutograntPermissions)
        : false,
    };
  },

  toJSON(message: TestSetup): unknown {
    const obj: any = {};
    if (message.filesToPush?.length) {
      obj.filesToPush = message.filesToPush.map((e) => DeviceFile.toJSON(e));
    }
    if (message.directoriesToPull?.length) {
      obj.directoriesToPull = message.directoriesToPull;
    }
    if (message.initialSetupApks?.length) {
      obj.initialSetupApks = message.initialSetupApks.map((e) => Apk.toJSON(e));
    }
    if (message.additionalApks?.length) {
      obj.additionalApks = message.additionalApks.map((e) => Apk.toJSON(e));
    }
    if (message.account !== undefined) {
      obj.account = Account.toJSON(message.account);
    }
    if (message.networkProfile !== "") {
      obj.networkProfile = message.networkProfile;
    }
    if (message.environmentVariables?.length) {
      obj.environmentVariables = message.environmentVariables.map((e) => EnvironmentVariable.toJSON(e));
    }
    if (message.systrace !== undefined) {
      obj.systrace = SystraceSetup.toJSON(message.systrace);
    }
    if (message.dontAutograntPermissions !== false) {
      obj.dontAutograntPermissions = message.dontAutograntPermissions;
    }
    return obj;
  },

  create(base?: DeepPartial<TestSetup>): TestSetup {
    return TestSetup.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TestSetup>): TestSetup {
    const message = createBaseTestSetup();
    message.filesToPush = object.filesToPush?.map((e) => DeviceFile.fromPartial(e)) || [];
    message.directoriesToPull = object.directoriesToPull?.map((e) => e) || [];
    message.initialSetupApks = object.initialSetupApks?.map((e) => Apk.fromPartial(e)) || [];
    message.additionalApks = object.additionalApks?.map((e) => Apk.fromPartial(e)) || [];
    message.account = (object.account !== undefined && object.account !== null)
      ? Account.fromPartial(object.account)
      : undefined;
    message.networkProfile = object.networkProfile ?? "";
    message.environmentVariables = object.environmentVariables?.map((e) => EnvironmentVariable.fromPartial(e)) || [];
    message.systrace = (object.systrace !== undefined && object.systrace !== null)
      ? SystraceSetup.fromPartial(object.systrace)
      : undefined;
    message.dontAutograntPermissions = object.dontAutograntPermissions ?? false;
    return message;
  },
};

function createBaseIosTestSetup(): IosTestSetup {
  return { networkProfile: "", additionalIpas: [], pushFiles: [], pullDirectories: [] };
}

export const IosTestSetup: MessageFns<IosTestSetup> = {
  encode(message: IosTestSetup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.networkProfile !== "") {
      writer.uint32(10).string(message.networkProfile);
    }
    for (const v of message.additionalIpas) {
      FileReference.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.pushFiles) {
      IosDeviceFile.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.pullDirectories) {
      IosDeviceFile.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IosTestSetup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIosTestSetup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.networkProfile = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.additionalIpas.push(FileReference.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pushFiles.push(IosDeviceFile.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pullDirectories.push(IosDeviceFile.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IosTestSetup {
    return {
      networkProfile: isSet(object.networkProfile) ? globalThis.String(object.networkProfile) : "",
      additionalIpas: globalThis.Array.isArray(object?.additionalIpas)
        ? object.additionalIpas.map((e: any) => FileReference.fromJSON(e))
        : [],
      pushFiles: globalThis.Array.isArray(object?.pushFiles)
        ? object.pushFiles.map((e: any) => IosDeviceFile.fromJSON(e))
        : [],
      pullDirectories: globalThis.Array.isArray(object?.pullDirectories)
        ? object.pullDirectories.map((e: any) => IosDeviceFile.fromJSON(e))
        : [],
    };
  },

  toJSON(message: IosTestSetup): unknown {
    const obj: any = {};
    if (message.networkProfile !== "") {
      obj.networkProfile = message.networkProfile;
    }
    if (message.additionalIpas?.length) {
      obj.additionalIpas = message.additionalIpas.map((e) => FileReference.toJSON(e));
    }
    if (message.pushFiles?.length) {
      obj.pushFiles = message.pushFiles.map((e) => IosDeviceFile.toJSON(e));
    }
    if (message.pullDirectories?.length) {
      obj.pullDirectories = message.pullDirectories.map((e) => IosDeviceFile.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<IosTestSetup>): IosTestSetup {
    return IosTestSetup.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IosTestSetup>): IosTestSetup {
    const message = createBaseIosTestSetup();
    message.networkProfile = object.networkProfile ?? "";
    message.additionalIpas = object.additionalIpas?.map((e) => FileReference.fromPartial(e)) || [];
    message.pushFiles = object.pushFiles?.map((e) => IosDeviceFile.fromPartial(e)) || [];
    message.pullDirectories = object.pullDirectories?.map((e) => IosDeviceFile.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEnvironmentVariable(): EnvironmentVariable {
  return { key: "", value: "" };
}

export const EnvironmentVariable: MessageFns<EnvironmentVariable> = {
  encode(message: EnvironmentVariable, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnvironmentVariable {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnvironmentVariable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnvironmentVariable {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: EnvironmentVariable): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<EnvironmentVariable>): EnvironmentVariable {
    return EnvironmentVariable.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EnvironmentVariable>): EnvironmentVariable {
    const message = createBaseEnvironmentVariable();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAccount(): Account {
  return { googleAuto: undefined };
}

export const Account: MessageFns<Account> = {
  encode(message: Account, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.googleAuto !== undefined) {
      GoogleAuto.encode(message.googleAuto, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Account {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.googleAuto = GoogleAuto.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Account {
    return { googleAuto: isSet(object.googleAuto) ? GoogleAuto.fromJSON(object.googleAuto) : undefined };
  },

  toJSON(message: Account): unknown {
    const obj: any = {};
    if (message.googleAuto !== undefined) {
      obj.googleAuto = GoogleAuto.toJSON(message.googleAuto);
    }
    return obj;
  },

  create(base?: DeepPartial<Account>): Account {
    return Account.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Account>): Account {
    const message = createBaseAccount();
    message.googleAuto = (object.googleAuto !== undefined && object.googleAuto !== null)
      ? GoogleAuto.fromPartial(object.googleAuto)
      : undefined;
    return message;
  },
};

function createBaseGoogleAuto(): GoogleAuto {
  return {};
}

export const GoogleAuto: MessageFns<GoogleAuto> = {
  encode(_: GoogleAuto, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GoogleAuto {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGoogleAuto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GoogleAuto {
    return {};
  },

  toJSON(_: GoogleAuto): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<GoogleAuto>): GoogleAuto {
    return GoogleAuto.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GoogleAuto>): GoogleAuto {
    const message = createBaseGoogleAuto();
    return message;
  },
};

function createBaseApk(): Apk {
  return { location: undefined, packageName: "" };
}

export const Apk: MessageFns<Apk> = {
  encode(message: Apk, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.location !== undefined) {
      FileReference.encode(message.location, writer.uint32(10).fork()).join();
    }
    if (message.packageName !== "") {
      writer.uint32(18).string(message.packageName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Apk {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.location = FileReference.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.packageName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Apk {
    return {
      location: isSet(object.location) ? FileReference.fromJSON(object.location) : undefined,
      packageName: isSet(object.packageName) ? globalThis.String(object.packageName) : "",
    };
  },

  toJSON(message: Apk): unknown {
    const obj: any = {};
    if (message.location !== undefined) {
      obj.location = FileReference.toJSON(message.location);
    }
    if (message.packageName !== "") {
      obj.packageName = message.packageName;
    }
    return obj;
  },

  create(base?: DeepPartial<Apk>): Apk {
    return Apk.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Apk>): Apk {
    const message = createBaseApk();
    message.location = (object.location !== undefined && object.location !== null)
      ? FileReference.fromPartial(object.location)
      : undefined;
    message.packageName = object.packageName ?? "";
    return message;
  },
};

function createBaseAppBundle(): AppBundle {
  return { bundleLocation: undefined };
}

export const AppBundle: MessageFns<AppBundle> = {
  encode(message: AppBundle, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bundleLocation !== undefined) {
      FileReference.encode(message.bundleLocation, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppBundle {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppBundle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.bundleLocation = FileReference.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppBundle {
    return { bundleLocation: isSet(object.bundleLocation) ? FileReference.fromJSON(object.bundleLocation) : undefined };
  },

  toJSON(message: AppBundle): unknown {
    const obj: any = {};
    if (message.bundleLocation !== undefined) {
      obj.bundleLocation = FileReference.toJSON(message.bundleLocation);
    }
    return obj;
  },

  create(base?: DeepPartial<AppBundle>): AppBundle {
    return AppBundle.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AppBundle>): AppBundle {
    const message = createBaseAppBundle();
    message.bundleLocation = (object.bundleLocation !== undefined && object.bundleLocation !== null)
      ? FileReference.fromPartial(object.bundleLocation)
      : undefined;
    return message;
  },
};

function createBaseDeviceFile(): DeviceFile {
  return { obbFile: undefined, regularFile: undefined };
}

export const DeviceFile: MessageFns<DeviceFile> = {
  encode(message: DeviceFile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.obbFile !== undefined) {
      ObbFile.encode(message.obbFile, writer.uint32(10).fork()).join();
    }
    if (message.regularFile !== undefined) {
      RegularFile.encode(message.regularFile, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeviceFile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeviceFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.obbFile = ObbFile.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.regularFile = RegularFile.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeviceFile {
    return {
      obbFile: isSet(object.obbFile) ? ObbFile.fromJSON(object.obbFile) : undefined,
      regularFile: isSet(object.regularFile) ? RegularFile.fromJSON(object.regularFile) : undefined,
    };
  },

  toJSON(message: DeviceFile): unknown {
    const obj: any = {};
    if (message.obbFile !== undefined) {
      obj.obbFile = ObbFile.toJSON(message.obbFile);
    }
    if (message.regularFile !== undefined) {
      obj.regularFile = RegularFile.toJSON(message.regularFile);
    }
    return obj;
  },

  create(base?: DeepPartial<DeviceFile>): DeviceFile {
    return DeviceFile.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeviceFile>): DeviceFile {
    const message = createBaseDeviceFile();
    message.obbFile = (object.obbFile !== undefined && object.obbFile !== null)
      ? ObbFile.fromPartial(object.obbFile)
      : undefined;
    message.regularFile = (object.regularFile !== undefined && object.regularFile !== null)
      ? RegularFile.fromPartial(object.regularFile)
      : undefined;
    return message;
  },
};

function createBaseObbFile(): ObbFile {
  return { obbFileName: "", obb: undefined };
}

export const ObbFile: MessageFns<ObbFile> = {
  encode(message: ObbFile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.obbFileName !== "") {
      writer.uint32(10).string(message.obbFileName);
    }
    if (message.obb !== undefined) {
      FileReference.encode(message.obb, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ObbFile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseObbFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.obbFileName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.obb = FileReference.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ObbFile {
    return {
      obbFileName: isSet(object.obbFileName) ? globalThis.String(object.obbFileName) : "",
      obb: isSet(object.obb) ? FileReference.fromJSON(object.obb) : undefined,
    };
  },

  toJSON(message: ObbFile): unknown {
    const obj: any = {};
    if (message.obbFileName !== "") {
      obj.obbFileName = message.obbFileName;
    }
    if (message.obb !== undefined) {
      obj.obb = FileReference.toJSON(message.obb);
    }
    return obj;
  },

  create(base?: DeepPartial<ObbFile>): ObbFile {
    return ObbFile.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ObbFile>): ObbFile {
    const message = createBaseObbFile();
    message.obbFileName = object.obbFileName ?? "";
    message.obb = (object.obb !== undefined && object.obb !== null) ? FileReference.fromPartial(object.obb) : undefined;
    return message;
  },
};

function createBaseRegularFile(): RegularFile {
  return { content: undefined, devicePath: "" };
}

export const RegularFile: MessageFns<RegularFile> = {
  encode(message: RegularFile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.content !== undefined) {
      FileReference.encode(message.content, writer.uint32(10).fork()).join();
    }
    if (message.devicePath !== "") {
      writer.uint32(18).string(message.devicePath);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegularFile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegularFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.content = FileReference.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.devicePath = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegularFile {
    return {
      content: isSet(object.content) ? FileReference.fromJSON(object.content) : undefined,
      devicePath: isSet(object.devicePath) ? globalThis.String(object.devicePath) : "",
    };
  },

  toJSON(message: RegularFile): unknown {
    const obj: any = {};
    if (message.content !== undefined) {
      obj.content = FileReference.toJSON(message.content);
    }
    if (message.devicePath !== "") {
      obj.devicePath = message.devicePath;
    }
    return obj;
  },

  create(base?: DeepPartial<RegularFile>): RegularFile {
    return RegularFile.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RegularFile>): RegularFile {
    const message = createBaseRegularFile();
    message.content = (object.content !== undefined && object.content !== null)
      ? FileReference.fromPartial(object.content)
      : undefined;
    message.devicePath = object.devicePath ?? "";
    return message;
  },
};

function createBaseIosDeviceFile(): IosDeviceFile {
  return { content: undefined, bundleId: "", devicePath: "" };
}

export const IosDeviceFile: MessageFns<IosDeviceFile> = {
  encode(message: IosDeviceFile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.content !== undefined) {
      FileReference.encode(message.content, writer.uint32(10).fork()).join();
    }
    if (message.bundleId !== "") {
      writer.uint32(18).string(message.bundleId);
    }
    if (message.devicePath !== "") {
      writer.uint32(26).string(message.devicePath);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IosDeviceFile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIosDeviceFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.content = FileReference.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.bundleId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.devicePath = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IosDeviceFile {
    return {
      content: isSet(object.content) ? FileReference.fromJSON(object.content) : undefined,
      bundleId: isSet(object.bundleId) ? globalThis.String(object.bundleId) : "",
      devicePath: isSet(object.devicePath) ? globalThis.String(object.devicePath) : "",
    };
  },

  toJSON(message: IosDeviceFile): unknown {
    const obj: any = {};
    if (message.content !== undefined) {
      obj.content = FileReference.toJSON(message.content);
    }
    if (message.bundleId !== "") {
      obj.bundleId = message.bundleId;
    }
    if (message.devicePath !== "") {
      obj.devicePath = message.devicePath;
    }
    return obj;
  },

  create(base?: DeepPartial<IosDeviceFile>): IosDeviceFile {
    return IosDeviceFile.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IosDeviceFile>): IosDeviceFile {
    const message = createBaseIosDeviceFile();
    message.content = (object.content !== undefined && object.content !== null)
      ? FileReference.fromPartial(object.content)
      : undefined;
    message.bundleId = object.bundleId ?? "";
    message.devicePath = object.devicePath ?? "";
    return message;
  },
};

function createBaseAndroidTestLoop(): AndroidTestLoop {
  return { appApk: undefined, appBundle: undefined, appPackageId: "", scenarios: [], scenarioLabels: [] };
}

export const AndroidTestLoop: MessageFns<AndroidTestLoop> = {
  encode(message: AndroidTestLoop, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.appApk !== undefined) {
      FileReference.encode(message.appApk, writer.uint32(10).fork()).join();
    }
    if (message.appBundle !== undefined) {
      AppBundle.encode(message.appBundle, writer.uint32(42).fork()).join();
    }
    if (message.appPackageId !== "") {
      writer.uint32(18).string(message.appPackageId);
    }
    writer.uint32(26).fork();
    for (const v of message.scenarios) {
      writer.int32(v);
    }
    writer.join();
    for (const v of message.scenarioLabels) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AndroidTestLoop {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAndroidTestLoop();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.appApk = FileReference.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.appBundle = AppBundle.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.appPackageId = reader.string();
          continue;
        case 3:
          if (tag === 24) {
            message.scenarios.push(reader.int32());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.scenarios.push(reader.int32());
            }

            continue;
          }

          break;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.scenarioLabels.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AndroidTestLoop {
    return {
      appApk: isSet(object.appApk) ? FileReference.fromJSON(object.appApk) : undefined,
      appBundle: isSet(object.appBundle) ? AppBundle.fromJSON(object.appBundle) : undefined,
      appPackageId: isSet(object.appPackageId) ? globalThis.String(object.appPackageId) : "",
      scenarios: globalThis.Array.isArray(object?.scenarios)
        ? object.scenarios.map((e: any) => globalThis.Number(e))
        : [],
      scenarioLabels: globalThis.Array.isArray(object?.scenarioLabels)
        ? object.scenarioLabels.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: AndroidTestLoop): unknown {
    const obj: any = {};
    if (message.appApk !== undefined) {
      obj.appApk = FileReference.toJSON(message.appApk);
    }
    if (message.appBundle !== undefined) {
      obj.appBundle = AppBundle.toJSON(message.appBundle);
    }
    if (message.appPackageId !== "") {
      obj.appPackageId = message.appPackageId;
    }
    if (message.scenarios?.length) {
      obj.scenarios = message.scenarios.map((e) => Math.round(e));
    }
    if (message.scenarioLabels?.length) {
      obj.scenarioLabels = message.scenarioLabels;
    }
    return obj;
  },

  create(base?: DeepPartial<AndroidTestLoop>): AndroidTestLoop {
    return AndroidTestLoop.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AndroidTestLoop>): AndroidTestLoop {
    const message = createBaseAndroidTestLoop();
    message.appApk = (object.appApk !== undefined && object.appApk !== null)
      ? FileReference.fromPartial(object.appApk)
      : undefined;
    message.appBundle = (object.appBundle !== undefined && object.appBundle !== null)
      ? AppBundle.fromPartial(object.appBundle)
      : undefined;
    message.appPackageId = object.appPackageId ?? "";
    message.scenarios = object.scenarios?.map((e) => e) || [];
    message.scenarioLabels = object.scenarioLabels?.map((e) => e) || [];
    return message;
  },
};

function createBaseIosXcTest(): IosXcTest {
  return {
    testsZip: undefined,
    xctestrun: undefined,
    xcodeVersion: "",
    appBundleId: "",
    testSpecialEntitlements: false,
  };
}

export const IosXcTest: MessageFns<IosXcTest> = {
  encode(message: IosXcTest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.testsZip !== undefined) {
      FileReference.encode(message.testsZip, writer.uint32(10).fork()).join();
    }
    if (message.xctestrun !== undefined) {
      FileReference.encode(message.xctestrun, writer.uint32(18).fork()).join();
    }
    if (message.xcodeVersion !== "") {
      writer.uint32(26).string(message.xcodeVersion);
    }
    if (message.appBundleId !== "") {
      writer.uint32(34).string(message.appBundleId);
    }
    if (message.testSpecialEntitlements !== false) {
      writer.uint32(48).bool(message.testSpecialEntitlements);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IosXcTest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIosXcTest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.testsZip = FileReference.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.xctestrun = FileReference.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.xcodeVersion = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.appBundleId = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.testSpecialEntitlements = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IosXcTest {
    return {
      testsZip: isSet(object.testsZip) ? FileReference.fromJSON(object.testsZip) : undefined,
      xctestrun: isSet(object.xctestrun) ? FileReference.fromJSON(object.xctestrun) : undefined,
      xcodeVersion: isSet(object.xcodeVersion) ? globalThis.String(object.xcodeVersion) : "",
      appBundleId: isSet(object.appBundleId) ? globalThis.String(object.appBundleId) : "",
      testSpecialEntitlements: isSet(object.testSpecialEntitlements)
        ? globalThis.Boolean(object.testSpecialEntitlements)
        : false,
    };
  },

  toJSON(message: IosXcTest): unknown {
    const obj: any = {};
    if (message.testsZip !== undefined) {
      obj.testsZip = FileReference.toJSON(message.testsZip);
    }
    if (message.xctestrun !== undefined) {
      obj.xctestrun = FileReference.toJSON(message.xctestrun);
    }
    if (message.xcodeVersion !== "") {
      obj.xcodeVersion = message.xcodeVersion;
    }
    if (message.appBundleId !== "") {
      obj.appBundleId = message.appBundleId;
    }
    if (message.testSpecialEntitlements !== false) {
      obj.testSpecialEntitlements = message.testSpecialEntitlements;
    }
    return obj;
  },

  create(base?: DeepPartial<IosXcTest>): IosXcTest {
    return IosXcTest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IosXcTest>): IosXcTest {
    const message = createBaseIosXcTest();
    message.testsZip = (object.testsZip !== undefined && object.testsZip !== null)
      ? FileReference.fromPartial(object.testsZip)
      : undefined;
    message.xctestrun = (object.xctestrun !== undefined && object.xctestrun !== null)
      ? FileReference.fromPartial(object.xctestrun)
      : undefined;
    message.xcodeVersion = object.xcodeVersion ?? "";
    message.appBundleId = object.appBundleId ?? "";
    message.testSpecialEntitlements = object.testSpecialEntitlements ?? false;
    return message;
  },
};

function createBaseIosTestLoop(): IosTestLoop {
  return { appIpa: undefined, scenarios: [], appBundleId: "" };
}

export const IosTestLoop: MessageFns<IosTestLoop> = {
  encode(message: IosTestLoop, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.appIpa !== undefined) {
      FileReference.encode(message.appIpa, writer.uint32(10).fork()).join();
    }
    writer.uint32(18).fork();
    for (const v of message.scenarios) {
      writer.int32(v);
    }
    writer.join();
    if (message.appBundleId !== "") {
      writer.uint32(26).string(message.appBundleId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IosTestLoop {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIosTestLoop();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.appIpa = FileReference.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag === 16) {
            message.scenarios.push(reader.int32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.scenarios.push(reader.int32());
            }

            continue;
          }

          break;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.appBundleId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IosTestLoop {
    return {
      appIpa: isSet(object.appIpa) ? FileReference.fromJSON(object.appIpa) : undefined,
      scenarios: globalThis.Array.isArray(object?.scenarios)
        ? object.scenarios.map((e: any) => globalThis.Number(e))
        : [],
      appBundleId: isSet(object.appBundleId) ? globalThis.String(object.appBundleId) : "",
    };
  },

  toJSON(message: IosTestLoop): unknown {
    const obj: any = {};
    if (message.appIpa !== undefined) {
      obj.appIpa = FileReference.toJSON(message.appIpa);
    }
    if (message.scenarios?.length) {
      obj.scenarios = message.scenarios.map((e) => Math.round(e));
    }
    if (message.appBundleId !== "") {
      obj.appBundleId = message.appBundleId;
    }
    return obj;
  },

  create(base?: DeepPartial<IosTestLoop>): IosTestLoop {
    return IosTestLoop.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IosTestLoop>): IosTestLoop {
    const message = createBaseIosTestLoop();
    message.appIpa = (object.appIpa !== undefined && object.appIpa !== null)
      ? FileReference.fromPartial(object.appIpa)
      : undefined;
    message.scenarios = object.scenarios?.map((e) => e) || [];
    message.appBundleId = object.appBundleId ?? "";
    return message;
  },
};

function createBaseIosRoboTest(): IosRoboTest {
  return { appIpa: undefined, appBundleId: "", roboScript: undefined };
}

export const IosRoboTest: MessageFns<IosRoboTest> = {
  encode(message: IosRoboTest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.appIpa !== undefined) {
      FileReference.encode(message.appIpa, writer.uint32(10).fork()).join();
    }
    if (message.appBundleId !== "") {
      writer.uint32(34).string(message.appBundleId);
    }
    if (message.roboScript !== undefined) {
      FileReference.encode(message.roboScript, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IosRoboTest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIosRoboTest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.appIpa = FileReference.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.appBundleId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.roboScript = FileReference.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IosRoboTest {
    return {
      appIpa: isSet(object.appIpa) ? FileReference.fromJSON(object.appIpa) : undefined,
      appBundleId: isSet(object.appBundleId) ? globalThis.String(object.appBundleId) : "",
      roboScript: isSet(object.roboScript) ? FileReference.fromJSON(object.roboScript) : undefined,
    };
  },

  toJSON(message: IosRoboTest): unknown {
    const obj: any = {};
    if (message.appIpa !== undefined) {
      obj.appIpa = FileReference.toJSON(message.appIpa);
    }
    if (message.appBundleId !== "") {
      obj.appBundleId = message.appBundleId;
    }
    if (message.roboScript !== undefined) {
      obj.roboScript = FileReference.toJSON(message.roboScript);
    }
    return obj;
  },

  create(base?: DeepPartial<IosRoboTest>): IosRoboTest {
    return IosRoboTest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IosRoboTest>): IosRoboTest {
    const message = createBaseIosRoboTest();
    message.appIpa = (object.appIpa !== undefined && object.appIpa !== null)
      ? FileReference.fromPartial(object.appIpa)
      : undefined;
    message.appBundleId = object.appBundleId ?? "";
    message.roboScript = (object.roboScript !== undefined && object.roboScript !== null)
      ? FileReference.fromPartial(object.roboScript)
      : undefined;
    return message;
  },
};

function createBaseAndroidInstrumentationTest(): AndroidInstrumentationTest {
  return {
    appApk: undefined,
    appBundle: undefined,
    testApk: undefined,
    appPackageId: "",
    testPackageId: "",
    testRunnerClass: "",
    testTargets: [],
    orchestratorOption: 0,
    shardingOption: undefined,
  };
}

export const AndroidInstrumentationTest: MessageFns<AndroidInstrumentationTest> = {
  encode(message: AndroidInstrumentationTest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.appApk !== undefined) {
      FileReference.encode(message.appApk, writer.uint32(10).fork()).join();
    }
    if (message.appBundle !== undefined) {
      AppBundle.encode(message.appBundle, writer.uint32(66).fork()).join();
    }
    if (message.testApk !== undefined) {
      FileReference.encode(message.testApk, writer.uint32(18).fork()).join();
    }
    if (message.appPackageId !== "") {
      writer.uint32(26).string(message.appPackageId);
    }
    if (message.testPackageId !== "") {
      writer.uint32(34).string(message.testPackageId);
    }
    if (message.testRunnerClass !== "") {
      writer.uint32(42).string(message.testRunnerClass);
    }
    for (const v of message.testTargets) {
      writer.uint32(50).string(v!);
    }
    if (message.orchestratorOption !== 0) {
      writer.uint32(56).int32(message.orchestratorOption);
    }
    if (message.shardingOption !== undefined) {
      ShardingOption.encode(message.shardingOption, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AndroidInstrumentationTest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAndroidInstrumentationTest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.appApk = FileReference.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.appBundle = AppBundle.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.testApk = FileReference.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.appPackageId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.testPackageId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.testRunnerClass = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.testTargets.push(reader.string());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.orchestratorOption = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.shardingOption = ShardingOption.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AndroidInstrumentationTest {
    return {
      appApk: isSet(object.appApk) ? FileReference.fromJSON(object.appApk) : undefined,
      appBundle: isSet(object.appBundle) ? AppBundle.fromJSON(object.appBundle) : undefined,
      testApk: isSet(object.testApk) ? FileReference.fromJSON(object.testApk) : undefined,
      appPackageId: isSet(object.appPackageId) ? globalThis.String(object.appPackageId) : "",
      testPackageId: isSet(object.testPackageId) ? globalThis.String(object.testPackageId) : "",
      testRunnerClass: isSet(object.testRunnerClass) ? globalThis.String(object.testRunnerClass) : "",
      testTargets: globalThis.Array.isArray(object?.testTargets)
        ? object.testTargets.map((e: any) => globalThis.String(e))
        : [],
      orchestratorOption: isSet(object.orchestratorOption) ? orchestratorOptionFromJSON(object.orchestratorOption) : 0,
      shardingOption: isSet(object.shardingOption) ? ShardingOption.fromJSON(object.shardingOption) : undefined,
    };
  },

  toJSON(message: AndroidInstrumentationTest): unknown {
    const obj: any = {};
    if (message.appApk !== undefined) {
      obj.appApk = FileReference.toJSON(message.appApk);
    }
    if (message.appBundle !== undefined) {
      obj.appBundle = AppBundle.toJSON(message.appBundle);
    }
    if (message.testApk !== undefined) {
      obj.testApk = FileReference.toJSON(message.testApk);
    }
    if (message.appPackageId !== "") {
      obj.appPackageId = message.appPackageId;
    }
    if (message.testPackageId !== "") {
      obj.testPackageId = message.testPackageId;
    }
    if (message.testRunnerClass !== "") {
      obj.testRunnerClass = message.testRunnerClass;
    }
    if (message.testTargets?.length) {
      obj.testTargets = message.testTargets;
    }
    if (message.orchestratorOption !== 0) {
      obj.orchestratorOption = orchestratorOptionToJSON(message.orchestratorOption);
    }
    if (message.shardingOption !== undefined) {
      obj.shardingOption = ShardingOption.toJSON(message.shardingOption);
    }
    return obj;
  },

  create(base?: DeepPartial<AndroidInstrumentationTest>): AndroidInstrumentationTest {
    return AndroidInstrumentationTest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AndroidInstrumentationTest>): AndroidInstrumentationTest {
    const message = createBaseAndroidInstrumentationTest();
    message.appApk = (object.appApk !== undefined && object.appApk !== null)
      ? FileReference.fromPartial(object.appApk)
      : undefined;
    message.appBundle = (object.appBundle !== undefined && object.appBundle !== null)
      ? AppBundle.fromPartial(object.appBundle)
      : undefined;
    message.testApk = (object.testApk !== undefined && object.testApk !== null)
      ? FileReference.fromPartial(object.testApk)
      : undefined;
    message.appPackageId = object.appPackageId ?? "";
    message.testPackageId = object.testPackageId ?? "";
    message.testRunnerClass = object.testRunnerClass ?? "";
    message.testTargets = object.testTargets?.map((e) => e) || [];
    message.orchestratorOption = object.orchestratorOption ?? 0;
    message.shardingOption = (object.shardingOption !== undefined && object.shardingOption !== null)
      ? ShardingOption.fromPartial(object.shardingOption)
      : undefined;
    return message;
  },
};

function createBaseAndroidRoboTest(): AndroidRoboTest {
  return {
    appApk: undefined,
    appBundle: undefined,
    appPackageId: "",
    appInitialActivity: "",
    maxDepth: 0,
    maxSteps: 0,
    roboDirectives: [],
    roboMode: 0,
    roboScript: undefined,
    startingIntents: [],
  };
}

export const AndroidRoboTest: MessageFns<AndroidRoboTest> = {
  encode(message: AndroidRoboTest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.appApk !== undefined) {
      FileReference.encode(message.appApk, writer.uint32(10).fork()).join();
    }
    if (message.appBundle !== undefined) {
      AppBundle.encode(message.appBundle, writer.uint32(130).fork()).join();
    }
    if (message.appPackageId !== "") {
      writer.uint32(18).string(message.appPackageId);
    }
    if (message.appInitialActivity !== "") {
      writer.uint32(26).string(message.appInitialActivity);
    }
    if (message.maxDepth !== 0) {
      writer.uint32(56).int32(message.maxDepth);
    }
    if (message.maxSteps !== 0) {
      writer.uint32(64).int32(message.maxSteps);
    }
    for (const v of message.roboDirectives) {
      RoboDirective.encode(v!, writer.uint32(90).fork()).join();
    }
    if (message.roboMode !== 0) {
      writer.uint32(112).int32(message.roboMode);
    }
    if (message.roboScript !== undefined) {
      FileReference.encode(message.roboScript, writer.uint32(106).fork()).join();
    }
    for (const v of message.startingIntents) {
      RoboStartingIntent.encode(v!, writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AndroidRoboTest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAndroidRoboTest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.appApk = FileReference.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.appBundle = AppBundle.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.appPackageId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.appInitialActivity = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.maxDepth = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.maxSteps = reader.int32();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.roboDirectives.push(RoboDirective.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.roboMode = reader.int32() as any;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.roboScript = FileReference.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.startingIntents.push(RoboStartingIntent.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AndroidRoboTest {
    return {
      appApk: isSet(object.appApk) ? FileReference.fromJSON(object.appApk) : undefined,
      appBundle: isSet(object.appBundle) ? AppBundle.fromJSON(object.appBundle) : undefined,
      appPackageId: isSet(object.appPackageId) ? globalThis.String(object.appPackageId) : "",
      appInitialActivity: isSet(object.appInitialActivity) ? globalThis.String(object.appInitialActivity) : "",
      maxDepth: isSet(object.maxDepth) ? globalThis.Number(object.maxDepth) : 0,
      maxSteps: isSet(object.maxSteps) ? globalThis.Number(object.maxSteps) : 0,
      roboDirectives: globalThis.Array.isArray(object?.roboDirectives)
        ? object.roboDirectives.map((e: any) => RoboDirective.fromJSON(e))
        : [],
      roboMode: isSet(object.roboMode) ? roboModeFromJSON(object.roboMode) : 0,
      roboScript: isSet(object.roboScript) ? FileReference.fromJSON(object.roboScript) : undefined,
      startingIntents: globalThis.Array.isArray(object?.startingIntents)
        ? object.startingIntents.map((e: any) => RoboStartingIntent.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AndroidRoboTest): unknown {
    const obj: any = {};
    if (message.appApk !== undefined) {
      obj.appApk = FileReference.toJSON(message.appApk);
    }
    if (message.appBundle !== undefined) {
      obj.appBundle = AppBundle.toJSON(message.appBundle);
    }
    if (message.appPackageId !== "") {
      obj.appPackageId = message.appPackageId;
    }
    if (message.appInitialActivity !== "") {
      obj.appInitialActivity = message.appInitialActivity;
    }
    if (message.maxDepth !== 0) {
      obj.maxDepth = Math.round(message.maxDepth);
    }
    if (message.maxSteps !== 0) {
      obj.maxSteps = Math.round(message.maxSteps);
    }
    if (message.roboDirectives?.length) {
      obj.roboDirectives = message.roboDirectives.map((e) => RoboDirective.toJSON(e));
    }
    if (message.roboMode !== 0) {
      obj.roboMode = roboModeToJSON(message.roboMode);
    }
    if (message.roboScript !== undefined) {
      obj.roboScript = FileReference.toJSON(message.roboScript);
    }
    if (message.startingIntents?.length) {
      obj.startingIntents = message.startingIntents.map((e) => RoboStartingIntent.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AndroidRoboTest>): AndroidRoboTest {
    return AndroidRoboTest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AndroidRoboTest>): AndroidRoboTest {
    const message = createBaseAndroidRoboTest();
    message.appApk = (object.appApk !== undefined && object.appApk !== null)
      ? FileReference.fromPartial(object.appApk)
      : undefined;
    message.appBundle = (object.appBundle !== undefined && object.appBundle !== null)
      ? AppBundle.fromPartial(object.appBundle)
      : undefined;
    message.appPackageId = object.appPackageId ?? "";
    message.appInitialActivity = object.appInitialActivity ?? "";
    message.maxDepth = object.maxDepth ?? 0;
    message.maxSteps = object.maxSteps ?? 0;
    message.roboDirectives = object.roboDirectives?.map((e) => RoboDirective.fromPartial(e)) || [];
    message.roboMode = object.roboMode ?? 0;
    message.roboScript = (object.roboScript !== undefined && object.roboScript !== null)
      ? FileReference.fromPartial(object.roboScript)
      : undefined;
    message.startingIntents = object.startingIntents?.map((e) => RoboStartingIntent.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRoboDirective(): RoboDirective {
  return { resourceName: "", inputText: "", actionType: 0 };
}

export const RoboDirective: MessageFns<RoboDirective> = {
  encode(message: RoboDirective, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resourceName !== "") {
      writer.uint32(10).string(message.resourceName);
    }
    if (message.inputText !== "") {
      writer.uint32(18).string(message.inputText);
    }
    if (message.actionType !== 0) {
      writer.uint32(24).int32(message.actionType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoboDirective {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoboDirective();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resourceName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.inputText = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.actionType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoboDirective {
    return {
      resourceName: isSet(object.resourceName) ? globalThis.String(object.resourceName) : "",
      inputText: isSet(object.inputText) ? globalThis.String(object.inputText) : "",
      actionType: isSet(object.actionType) ? roboActionTypeFromJSON(object.actionType) : 0,
    };
  },

  toJSON(message: RoboDirective): unknown {
    const obj: any = {};
    if (message.resourceName !== "") {
      obj.resourceName = message.resourceName;
    }
    if (message.inputText !== "") {
      obj.inputText = message.inputText;
    }
    if (message.actionType !== 0) {
      obj.actionType = roboActionTypeToJSON(message.actionType);
    }
    return obj;
  },

  create(base?: DeepPartial<RoboDirective>): RoboDirective {
    return RoboDirective.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RoboDirective>): RoboDirective {
    const message = createBaseRoboDirective();
    message.resourceName = object.resourceName ?? "";
    message.inputText = object.inputText ?? "";
    message.actionType = object.actionType ?? 0;
    return message;
  },
};

function createBaseRoboStartingIntent(): RoboStartingIntent {
  return { launcherActivity: undefined, startActivity: undefined, noActivity: undefined, timeout: undefined };
}

export const RoboStartingIntent: MessageFns<RoboStartingIntent> = {
  encode(message: RoboStartingIntent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.launcherActivity !== undefined) {
      LauncherActivityIntent.encode(message.launcherActivity, writer.uint32(10).fork()).join();
    }
    if (message.startActivity !== undefined) {
      StartActivityIntent.encode(message.startActivity, writer.uint32(18).fork()).join();
    }
    if (message.noActivity !== undefined) {
      NoActivityIntent.encode(message.noActivity, writer.uint32(34).fork()).join();
    }
    if (message.timeout !== undefined) {
      Duration.encode(message.timeout, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoboStartingIntent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoboStartingIntent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.launcherActivity = LauncherActivityIntent.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.startActivity = StartActivityIntent.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.noActivity = NoActivityIntent.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.timeout = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoboStartingIntent {
    return {
      launcherActivity: isSet(object.launcherActivity)
        ? LauncherActivityIntent.fromJSON(object.launcherActivity)
        : undefined,
      startActivity: isSet(object.startActivity) ? StartActivityIntent.fromJSON(object.startActivity) : undefined,
      noActivity: isSet(object.noActivity) ? NoActivityIntent.fromJSON(object.noActivity) : undefined,
      timeout: isSet(object.timeout) ? Duration.fromJSON(object.timeout) : undefined,
    };
  },

  toJSON(message: RoboStartingIntent): unknown {
    const obj: any = {};
    if (message.launcherActivity !== undefined) {
      obj.launcherActivity = LauncherActivityIntent.toJSON(message.launcherActivity);
    }
    if (message.startActivity !== undefined) {
      obj.startActivity = StartActivityIntent.toJSON(message.startActivity);
    }
    if (message.noActivity !== undefined) {
      obj.noActivity = NoActivityIntent.toJSON(message.noActivity);
    }
    if (message.timeout !== undefined) {
      obj.timeout = Duration.toJSON(message.timeout);
    }
    return obj;
  },

  create(base?: DeepPartial<RoboStartingIntent>): RoboStartingIntent {
    return RoboStartingIntent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RoboStartingIntent>): RoboStartingIntent {
    const message = createBaseRoboStartingIntent();
    message.launcherActivity = (object.launcherActivity !== undefined && object.launcherActivity !== null)
      ? LauncherActivityIntent.fromPartial(object.launcherActivity)
      : undefined;
    message.startActivity = (object.startActivity !== undefined && object.startActivity !== null)
      ? StartActivityIntent.fromPartial(object.startActivity)
      : undefined;
    message.noActivity = (object.noActivity !== undefined && object.noActivity !== null)
      ? NoActivityIntent.fromPartial(object.noActivity)
      : undefined;
    message.timeout = (object.timeout !== undefined && object.timeout !== null)
      ? Duration.fromPartial(object.timeout)
      : undefined;
    return message;
  },
};

function createBaseLauncherActivityIntent(): LauncherActivityIntent {
  return {};
}

export const LauncherActivityIntent: MessageFns<LauncherActivityIntent> = {
  encode(_: LauncherActivityIntent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LauncherActivityIntent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLauncherActivityIntent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): LauncherActivityIntent {
    return {};
  },

  toJSON(_: LauncherActivityIntent): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<LauncherActivityIntent>): LauncherActivityIntent {
    return LauncherActivityIntent.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<LauncherActivityIntent>): LauncherActivityIntent {
    const message = createBaseLauncherActivityIntent();
    return message;
  },
};

function createBaseStartActivityIntent(): StartActivityIntent {
  return { action: "", uri: "", categories: [] };
}

export const StartActivityIntent: MessageFns<StartActivityIntent> = {
  encode(message: StartActivityIntent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.action !== "") {
      writer.uint32(18).string(message.action);
    }
    if (message.uri !== "") {
      writer.uint32(26).string(message.uri);
    }
    for (const v of message.categories) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartActivityIntent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartActivityIntent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.action = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.categories.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartActivityIntent {
    return {
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      categories: globalThis.Array.isArray(object?.categories)
        ? object.categories.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: StartActivityIntent): unknown {
    const obj: any = {};
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.categories?.length) {
      obj.categories = message.categories;
    }
    return obj;
  },

  create(base?: DeepPartial<StartActivityIntent>): StartActivityIntent {
    return StartActivityIntent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartActivityIntent>): StartActivityIntent {
    const message = createBaseStartActivityIntent();
    message.action = object.action ?? "";
    message.uri = object.uri ?? "";
    message.categories = object.categories?.map((e) => e) || [];
    return message;
  },
};

function createBaseNoActivityIntent(): NoActivityIntent {
  return {};
}

export const NoActivityIntent: MessageFns<NoActivityIntent> = {
  encode(_: NoActivityIntent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NoActivityIntent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNoActivityIntent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): NoActivityIntent {
    return {};
  },

  toJSON(_: NoActivityIntent): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<NoActivityIntent>): NoActivityIntent {
    return NoActivityIntent.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<NoActivityIntent>): NoActivityIntent {
    const message = createBaseNoActivityIntent();
    return message;
  },
};

function createBaseEnvironmentMatrix(): EnvironmentMatrix {
  return { androidMatrix: undefined, androidDeviceList: undefined, iosDeviceList: undefined };
}

export const EnvironmentMatrix: MessageFns<EnvironmentMatrix> = {
  encode(message: EnvironmentMatrix, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.androidMatrix !== undefined) {
      AndroidMatrix.encode(message.androidMatrix, writer.uint32(10).fork()).join();
    }
    if (message.androidDeviceList !== undefined) {
      AndroidDeviceList.encode(message.androidDeviceList, writer.uint32(18).fork()).join();
    }
    if (message.iosDeviceList !== undefined) {
      IosDeviceList.encode(message.iosDeviceList, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnvironmentMatrix {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnvironmentMatrix();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.androidMatrix = AndroidMatrix.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.androidDeviceList = AndroidDeviceList.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.iosDeviceList = IosDeviceList.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnvironmentMatrix {
    return {
      androidMatrix: isSet(object.androidMatrix) ? AndroidMatrix.fromJSON(object.androidMatrix) : undefined,
      androidDeviceList: isSet(object.androidDeviceList)
        ? AndroidDeviceList.fromJSON(object.androidDeviceList)
        : undefined,
      iosDeviceList: isSet(object.iosDeviceList) ? IosDeviceList.fromJSON(object.iosDeviceList) : undefined,
    };
  },

  toJSON(message: EnvironmentMatrix): unknown {
    const obj: any = {};
    if (message.androidMatrix !== undefined) {
      obj.androidMatrix = AndroidMatrix.toJSON(message.androidMatrix);
    }
    if (message.androidDeviceList !== undefined) {
      obj.androidDeviceList = AndroidDeviceList.toJSON(message.androidDeviceList);
    }
    if (message.iosDeviceList !== undefined) {
      obj.iosDeviceList = IosDeviceList.toJSON(message.iosDeviceList);
    }
    return obj;
  },

  create(base?: DeepPartial<EnvironmentMatrix>): EnvironmentMatrix {
    return EnvironmentMatrix.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EnvironmentMatrix>): EnvironmentMatrix {
    const message = createBaseEnvironmentMatrix();
    message.androidMatrix = (object.androidMatrix !== undefined && object.androidMatrix !== null)
      ? AndroidMatrix.fromPartial(object.androidMatrix)
      : undefined;
    message.androidDeviceList = (object.androidDeviceList !== undefined && object.androidDeviceList !== null)
      ? AndroidDeviceList.fromPartial(object.androidDeviceList)
      : undefined;
    message.iosDeviceList = (object.iosDeviceList !== undefined && object.iosDeviceList !== null)
      ? IosDeviceList.fromPartial(object.iosDeviceList)
      : undefined;
    return message;
  },
};

function createBaseAndroidDeviceList(): AndroidDeviceList {
  return { androidDevices: [] };
}

export const AndroidDeviceList: MessageFns<AndroidDeviceList> = {
  encode(message: AndroidDeviceList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.androidDevices) {
      AndroidDevice.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AndroidDeviceList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAndroidDeviceList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.androidDevices.push(AndroidDevice.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AndroidDeviceList {
    return {
      androidDevices: globalThis.Array.isArray(object?.androidDevices)
        ? object.androidDevices.map((e: any) => AndroidDevice.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AndroidDeviceList): unknown {
    const obj: any = {};
    if (message.androidDevices?.length) {
      obj.androidDevices = message.androidDevices.map((e) => AndroidDevice.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AndroidDeviceList>): AndroidDeviceList {
    return AndroidDeviceList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AndroidDeviceList>): AndroidDeviceList {
    const message = createBaseAndroidDeviceList();
    message.androidDevices = object.androidDevices?.map((e) => AndroidDevice.fromPartial(e)) || [];
    return message;
  },
};

function createBaseIosDeviceList(): IosDeviceList {
  return { iosDevices: [] };
}

export const IosDeviceList: MessageFns<IosDeviceList> = {
  encode(message: IosDeviceList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.iosDevices) {
      IosDevice.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IosDeviceList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIosDeviceList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.iosDevices.push(IosDevice.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IosDeviceList {
    return {
      iosDevices: globalThis.Array.isArray(object?.iosDevices)
        ? object.iosDevices.map((e: any) => IosDevice.fromJSON(e))
        : [],
    };
  },

  toJSON(message: IosDeviceList): unknown {
    const obj: any = {};
    if (message.iosDevices?.length) {
      obj.iosDevices = message.iosDevices.map((e) => IosDevice.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<IosDeviceList>): IosDeviceList {
    return IosDeviceList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IosDeviceList>): IosDeviceList {
    const message = createBaseIosDeviceList();
    message.iosDevices = object.iosDevices?.map((e) => IosDevice.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAndroidMatrix(): AndroidMatrix {
  return { androidModelIds: [], androidVersionIds: [], locales: [], orientations: [] };
}

export const AndroidMatrix: MessageFns<AndroidMatrix> = {
  encode(message: AndroidMatrix, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.androidModelIds) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.androidVersionIds) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.locales) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.orientations) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AndroidMatrix {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAndroidMatrix();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.androidModelIds.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.androidVersionIds.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.locales.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.orientations.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AndroidMatrix {
    return {
      androidModelIds: globalThis.Array.isArray(object?.androidModelIds)
        ? object.androidModelIds.map((e: any) => globalThis.String(e))
        : [],
      androidVersionIds: globalThis.Array.isArray(object?.androidVersionIds)
        ? object.androidVersionIds.map((e: any) => globalThis.String(e))
        : [],
      locales: globalThis.Array.isArray(object?.locales) ? object.locales.map((e: any) => globalThis.String(e)) : [],
      orientations: globalThis.Array.isArray(object?.orientations)
        ? object.orientations.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: AndroidMatrix): unknown {
    const obj: any = {};
    if (message.androidModelIds?.length) {
      obj.androidModelIds = message.androidModelIds;
    }
    if (message.androidVersionIds?.length) {
      obj.androidVersionIds = message.androidVersionIds;
    }
    if (message.locales?.length) {
      obj.locales = message.locales;
    }
    if (message.orientations?.length) {
      obj.orientations = message.orientations;
    }
    return obj;
  },

  create(base?: DeepPartial<AndroidMatrix>): AndroidMatrix {
    return AndroidMatrix.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AndroidMatrix>): AndroidMatrix {
    const message = createBaseAndroidMatrix();
    message.androidModelIds = object.androidModelIds?.map((e) => e) || [];
    message.androidVersionIds = object.androidVersionIds?.map((e) => e) || [];
    message.locales = object.locales?.map((e) => e) || [];
    message.orientations = object.orientations?.map((e) => e) || [];
    return message;
  },
};

function createBaseClientInfo(): ClientInfo {
  return { name: "", clientInfoDetails: [] };
}

export const ClientInfo: MessageFns<ClientInfo> = {
  encode(message: ClientInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.clientInfoDetails) {
      ClientInfoDetail.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clientInfoDetails.push(ClientInfoDetail.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientInfo {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      clientInfoDetails: globalThis.Array.isArray(object?.clientInfoDetails)
        ? object.clientInfoDetails.map((e: any) => ClientInfoDetail.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ClientInfo): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.clientInfoDetails?.length) {
      obj.clientInfoDetails = message.clientInfoDetails.map((e) => ClientInfoDetail.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ClientInfo>): ClientInfo {
    return ClientInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClientInfo>): ClientInfo {
    const message = createBaseClientInfo();
    message.name = object.name ?? "";
    message.clientInfoDetails = object.clientInfoDetails?.map((e) => ClientInfoDetail.fromPartial(e)) || [];
    return message;
  },
};

function createBaseClientInfoDetail(): ClientInfoDetail {
  return { key: "", value: "" };
}

export const ClientInfoDetail: MessageFns<ClientInfoDetail> = {
  encode(message: ClientInfoDetail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientInfoDetail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientInfoDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientInfoDetail {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ClientInfoDetail): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ClientInfoDetail>): ClientInfoDetail {
    return ClientInfoDetail.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClientInfoDetail>): ClientInfoDetail {
    const message = createBaseClientInfoDetail();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseResultStorage(): ResultStorage {
  return {
    googleCloudStorage: undefined,
    toolResultsHistory: undefined,
    toolResultsExecution: undefined,
    resultsUrl: "",
  };
}

export const ResultStorage: MessageFns<ResultStorage> = {
  encode(message: ResultStorage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.googleCloudStorage !== undefined) {
      GoogleCloudStorage.encode(message.googleCloudStorage, writer.uint32(10).fork()).join();
    }
    if (message.toolResultsHistory !== undefined) {
      ToolResultsHistory.encode(message.toolResultsHistory, writer.uint32(42).fork()).join();
    }
    if (message.toolResultsExecution !== undefined) {
      ToolResultsExecution.encode(message.toolResultsExecution, writer.uint32(50).fork()).join();
    }
    if (message.resultsUrl !== "") {
      writer.uint32(58).string(message.resultsUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResultStorage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResultStorage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.googleCloudStorage = GoogleCloudStorage.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.toolResultsHistory = ToolResultsHistory.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.toolResultsExecution = ToolResultsExecution.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.resultsUrl = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResultStorage {
    return {
      googleCloudStorage: isSet(object.googleCloudStorage)
        ? GoogleCloudStorage.fromJSON(object.googleCloudStorage)
        : undefined,
      toolResultsHistory: isSet(object.toolResultsHistory)
        ? ToolResultsHistory.fromJSON(object.toolResultsHistory)
        : undefined,
      toolResultsExecution: isSet(object.toolResultsExecution)
        ? ToolResultsExecution.fromJSON(object.toolResultsExecution)
        : undefined,
      resultsUrl: isSet(object.resultsUrl) ? globalThis.String(object.resultsUrl) : "",
    };
  },

  toJSON(message: ResultStorage): unknown {
    const obj: any = {};
    if (message.googleCloudStorage !== undefined) {
      obj.googleCloudStorage = GoogleCloudStorage.toJSON(message.googleCloudStorage);
    }
    if (message.toolResultsHistory !== undefined) {
      obj.toolResultsHistory = ToolResultsHistory.toJSON(message.toolResultsHistory);
    }
    if (message.toolResultsExecution !== undefined) {
      obj.toolResultsExecution = ToolResultsExecution.toJSON(message.toolResultsExecution);
    }
    if (message.resultsUrl !== "") {
      obj.resultsUrl = message.resultsUrl;
    }
    return obj;
  },

  create(base?: DeepPartial<ResultStorage>): ResultStorage {
    return ResultStorage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResultStorage>): ResultStorage {
    const message = createBaseResultStorage();
    message.googleCloudStorage = (object.googleCloudStorage !== undefined && object.googleCloudStorage !== null)
      ? GoogleCloudStorage.fromPartial(object.googleCloudStorage)
      : undefined;
    message.toolResultsHistory = (object.toolResultsHistory !== undefined && object.toolResultsHistory !== null)
      ? ToolResultsHistory.fromPartial(object.toolResultsHistory)
      : undefined;
    message.toolResultsExecution = (object.toolResultsExecution !== undefined && object.toolResultsExecution !== null)
      ? ToolResultsExecution.fromPartial(object.toolResultsExecution)
      : undefined;
    message.resultsUrl = object.resultsUrl ?? "";
    return message;
  },
};

function createBaseToolResultsHistory(): ToolResultsHistory {
  return { projectId: "", historyId: "" };
}

export const ToolResultsHistory: MessageFns<ToolResultsHistory> = {
  encode(message: ToolResultsHistory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.historyId !== "") {
      writer.uint32(18).string(message.historyId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolResultsHistory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolResultsHistory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.historyId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolResultsHistory {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      historyId: isSet(object.historyId) ? globalThis.String(object.historyId) : "",
    };
  },

  toJSON(message: ToolResultsHistory): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.historyId !== "") {
      obj.historyId = message.historyId;
    }
    return obj;
  },

  create(base?: DeepPartial<ToolResultsHistory>): ToolResultsHistory {
    return ToolResultsHistory.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ToolResultsHistory>): ToolResultsHistory {
    const message = createBaseToolResultsHistory();
    message.projectId = object.projectId ?? "";
    message.historyId = object.historyId ?? "";
    return message;
  },
};

function createBaseToolResultsExecution(): ToolResultsExecution {
  return { projectId: "", historyId: "", executionId: "" };
}

export const ToolResultsExecution: MessageFns<ToolResultsExecution> = {
  encode(message: ToolResultsExecution, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.historyId !== "") {
      writer.uint32(18).string(message.historyId);
    }
    if (message.executionId !== "") {
      writer.uint32(26).string(message.executionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolResultsExecution {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolResultsExecution();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.historyId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.executionId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolResultsExecution {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      historyId: isSet(object.historyId) ? globalThis.String(object.historyId) : "",
      executionId: isSet(object.executionId) ? globalThis.String(object.executionId) : "",
    };
  },

  toJSON(message: ToolResultsExecution): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.historyId !== "") {
      obj.historyId = message.historyId;
    }
    if (message.executionId !== "") {
      obj.executionId = message.executionId;
    }
    return obj;
  },

  create(base?: DeepPartial<ToolResultsExecution>): ToolResultsExecution {
    return ToolResultsExecution.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ToolResultsExecution>): ToolResultsExecution {
    const message = createBaseToolResultsExecution();
    message.projectId = object.projectId ?? "";
    message.historyId = object.historyId ?? "";
    message.executionId = object.executionId ?? "";
    return message;
  },
};

function createBaseToolResultsStep(): ToolResultsStep {
  return { projectId: "", historyId: "", executionId: "", stepId: "" };
}

export const ToolResultsStep: MessageFns<ToolResultsStep> = {
  encode(message: ToolResultsStep, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.historyId !== "") {
      writer.uint32(18).string(message.historyId);
    }
    if (message.executionId !== "") {
      writer.uint32(26).string(message.executionId);
    }
    if (message.stepId !== "") {
      writer.uint32(34).string(message.stepId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolResultsStep {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolResultsStep();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.historyId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.executionId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.stepId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolResultsStep {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      historyId: isSet(object.historyId) ? globalThis.String(object.historyId) : "",
      executionId: isSet(object.executionId) ? globalThis.String(object.executionId) : "",
      stepId: isSet(object.stepId) ? globalThis.String(object.stepId) : "",
    };
  },

  toJSON(message: ToolResultsStep): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.historyId !== "") {
      obj.historyId = message.historyId;
    }
    if (message.executionId !== "") {
      obj.executionId = message.executionId;
    }
    if (message.stepId !== "") {
      obj.stepId = message.stepId;
    }
    return obj;
  },

  create(base?: DeepPartial<ToolResultsStep>): ToolResultsStep {
    return ToolResultsStep.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ToolResultsStep>): ToolResultsStep {
    const message = createBaseToolResultsStep();
    message.projectId = object.projectId ?? "";
    message.historyId = object.historyId ?? "";
    message.executionId = object.executionId ?? "";
    message.stepId = object.stepId ?? "";
    return message;
  },
};

function createBaseGoogleCloudStorage(): GoogleCloudStorage {
  return { gcsPath: "" };
}

export const GoogleCloudStorage: MessageFns<GoogleCloudStorage> = {
  encode(message: GoogleCloudStorage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gcsPath !== "") {
      writer.uint32(10).string(message.gcsPath);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GoogleCloudStorage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGoogleCloudStorage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gcsPath = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GoogleCloudStorage {
    return { gcsPath: isSet(object.gcsPath) ? globalThis.String(object.gcsPath) : "" };
  },

  toJSON(message: GoogleCloudStorage): unknown {
    const obj: any = {};
    if (message.gcsPath !== "") {
      obj.gcsPath = message.gcsPath;
    }
    return obj;
  },

  create(base?: DeepPartial<GoogleCloudStorage>): GoogleCloudStorage {
    return GoogleCloudStorage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GoogleCloudStorage>): GoogleCloudStorage {
    const message = createBaseGoogleCloudStorage();
    message.gcsPath = object.gcsPath ?? "";
    return message;
  },
};

function createBaseFileReference(): FileReference {
  return { gcsPath: undefined };
}

export const FileReference: MessageFns<FileReference> = {
  encode(message: FileReference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gcsPath !== undefined) {
      writer.uint32(10).string(message.gcsPath);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileReference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gcsPath = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileReference {
    return { gcsPath: isSet(object.gcsPath) ? globalThis.String(object.gcsPath) : undefined };
  },

  toJSON(message: FileReference): unknown {
    const obj: any = {};
    if (message.gcsPath !== undefined) {
      obj.gcsPath = message.gcsPath;
    }
    return obj;
  },

  create(base?: DeepPartial<FileReference>): FileReference {
    return FileReference.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FileReference>): FileReference {
    const message = createBaseFileReference();
    message.gcsPath = object.gcsPath ?? undefined;
    return message;
  },
};

function createBaseEnvironment(): Environment {
  return { androidDevice: undefined, iosDevice: undefined };
}

export const Environment: MessageFns<Environment> = {
  encode(message: Environment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.androidDevice !== undefined) {
      AndroidDevice.encode(message.androidDevice, writer.uint32(10).fork()).join();
    }
    if (message.iosDevice !== undefined) {
      IosDevice.encode(message.iosDevice, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Environment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnvironment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.androidDevice = AndroidDevice.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.iosDevice = IosDevice.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Environment {
    return {
      androidDevice: isSet(object.androidDevice) ? AndroidDevice.fromJSON(object.androidDevice) : undefined,
      iosDevice: isSet(object.iosDevice) ? IosDevice.fromJSON(object.iosDevice) : undefined,
    };
  },

  toJSON(message: Environment): unknown {
    const obj: any = {};
    if (message.androidDevice !== undefined) {
      obj.androidDevice = AndroidDevice.toJSON(message.androidDevice);
    }
    if (message.iosDevice !== undefined) {
      obj.iosDevice = IosDevice.toJSON(message.iosDevice);
    }
    return obj;
  },

  create(base?: DeepPartial<Environment>): Environment {
    return Environment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Environment>): Environment {
    const message = createBaseEnvironment();
    message.androidDevice = (object.androidDevice !== undefined && object.androidDevice !== null)
      ? AndroidDevice.fromPartial(object.androidDevice)
      : undefined;
    message.iosDevice = (object.iosDevice !== undefined && object.iosDevice !== null)
      ? IosDevice.fromPartial(object.iosDevice)
      : undefined;
    return message;
  },
};

function createBaseAndroidDevice(): AndroidDevice {
  return { androidModelId: "", androidVersionId: "", locale: "", orientation: "" };
}

export const AndroidDevice: MessageFns<AndroidDevice> = {
  encode(message: AndroidDevice, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.androidModelId !== "") {
      writer.uint32(10).string(message.androidModelId);
    }
    if (message.androidVersionId !== "") {
      writer.uint32(18).string(message.androidVersionId);
    }
    if (message.locale !== "") {
      writer.uint32(26).string(message.locale);
    }
    if (message.orientation !== "") {
      writer.uint32(34).string(message.orientation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AndroidDevice {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAndroidDevice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.androidModelId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.androidVersionId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.locale = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.orientation = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AndroidDevice {
    return {
      androidModelId: isSet(object.androidModelId) ? globalThis.String(object.androidModelId) : "",
      androidVersionId: isSet(object.androidVersionId) ? globalThis.String(object.androidVersionId) : "",
      locale: isSet(object.locale) ? globalThis.String(object.locale) : "",
      orientation: isSet(object.orientation) ? globalThis.String(object.orientation) : "",
    };
  },

  toJSON(message: AndroidDevice): unknown {
    const obj: any = {};
    if (message.androidModelId !== "") {
      obj.androidModelId = message.androidModelId;
    }
    if (message.androidVersionId !== "") {
      obj.androidVersionId = message.androidVersionId;
    }
    if (message.locale !== "") {
      obj.locale = message.locale;
    }
    if (message.orientation !== "") {
      obj.orientation = message.orientation;
    }
    return obj;
  },

  create(base?: DeepPartial<AndroidDevice>): AndroidDevice {
    return AndroidDevice.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AndroidDevice>): AndroidDevice {
    const message = createBaseAndroidDevice();
    message.androidModelId = object.androidModelId ?? "";
    message.androidVersionId = object.androidVersionId ?? "";
    message.locale = object.locale ?? "";
    message.orientation = object.orientation ?? "";
    return message;
  },
};

function createBaseIosDevice(): IosDevice {
  return { iosModelId: "", iosVersionId: "", locale: "", orientation: "" };
}

export const IosDevice: MessageFns<IosDevice> = {
  encode(message: IosDevice, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.iosModelId !== "") {
      writer.uint32(10).string(message.iosModelId);
    }
    if (message.iosVersionId !== "") {
      writer.uint32(18).string(message.iosVersionId);
    }
    if (message.locale !== "") {
      writer.uint32(26).string(message.locale);
    }
    if (message.orientation !== "") {
      writer.uint32(34).string(message.orientation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IosDevice {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIosDevice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.iosModelId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.iosVersionId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.locale = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.orientation = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IosDevice {
    return {
      iosModelId: isSet(object.iosModelId) ? globalThis.String(object.iosModelId) : "",
      iosVersionId: isSet(object.iosVersionId) ? globalThis.String(object.iosVersionId) : "",
      locale: isSet(object.locale) ? globalThis.String(object.locale) : "",
      orientation: isSet(object.orientation) ? globalThis.String(object.orientation) : "",
    };
  },

  toJSON(message: IosDevice): unknown {
    const obj: any = {};
    if (message.iosModelId !== "") {
      obj.iosModelId = message.iosModelId;
    }
    if (message.iosVersionId !== "") {
      obj.iosVersionId = message.iosVersionId;
    }
    if (message.locale !== "") {
      obj.locale = message.locale;
    }
    if (message.orientation !== "") {
      obj.orientation = message.orientation;
    }
    return obj;
  },

  create(base?: DeepPartial<IosDevice>): IosDevice {
    return IosDevice.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IosDevice>): IosDevice {
    const message = createBaseIosDevice();
    message.iosModelId = object.iosModelId ?? "";
    message.iosVersionId = object.iosVersionId ?? "";
    message.locale = object.locale ?? "";
    message.orientation = object.orientation ?? "";
    return message;
  },
};

function createBaseTestDetails(): TestDetails {
  return { progressMessages: [], errorMessage: "" };
}

export const TestDetails: MessageFns<TestDetails> = {
  encode(message: TestDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.progressMessages) {
      writer.uint32(26).string(v!);
    }
    if (message.errorMessage !== "") {
      writer.uint32(34).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.progressMessages.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestDetails {
    return {
      progressMessages: globalThis.Array.isArray(object?.progressMessages)
        ? object.progressMessages.map((e: any) => globalThis.String(e))
        : [],
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
    };
  },

  toJSON(message: TestDetails): unknown {
    const obj: any = {};
    if (message.progressMessages?.length) {
      obj.progressMessages = message.progressMessages;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create(base?: DeepPartial<TestDetails>): TestDetails {
    return TestDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TestDetails>): TestDetails {
    const message = createBaseTestDetails();
    message.progressMessages = object.progressMessages?.map((e) => e) || [];
    message.errorMessage = object.errorMessage ?? "";
    return message;
  },
};

function createBaseInvalidRequestDetail(): InvalidRequestDetail {
  return { reason: 0 };
}

export const InvalidRequestDetail: MessageFns<InvalidRequestDetail> = {
  encode(message: InvalidRequestDetail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reason !== 0) {
      writer.uint32(8).int32(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InvalidRequestDetail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvalidRequestDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.reason = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvalidRequestDetail {
    return { reason: isSet(object.reason) ? invalidRequestDetail_ReasonFromJSON(object.reason) : 0 };
  },

  toJSON(message: InvalidRequestDetail): unknown {
    const obj: any = {};
    if (message.reason !== 0) {
      obj.reason = invalidRequestDetail_ReasonToJSON(message.reason);
    }
    return obj;
  },

  create(base?: DeepPartial<InvalidRequestDetail>): InvalidRequestDetail {
    return InvalidRequestDetail.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InvalidRequestDetail>): InvalidRequestDetail {
    const message = createBaseInvalidRequestDetail();
    message.reason = object.reason ?? 0;
    return message;
  },
};

function createBaseShardingOption(): ShardingOption {
  return { uniformSharding: undefined, manualSharding: undefined, smartSharding: undefined };
}

export const ShardingOption: MessageFns<ShardingOption> = {
  encode(message: ShardingOption, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uniformSharding !== undefined) {
      UniformSharding.encode(message.uniformSharding, writer.uint32(10).fork()).join();
    }
    if (message.manualSharding !== undefined) {
      ManualSharding.encode(message.manualSharding, writer.uint32(18).fork()).join();
    }
    if (message.smartSharding !== undefined) {
      SmartSharding.encode(message.smartSharding, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShardingOption {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShardingOption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uniformSharding = UniformSharding.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.manualSharding = ManualSharding.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.smartSharding = SmartSharding.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShardingOption {
    return {
      uniformSharding: isSet(object.uniformSharding) ? UniformSharding.fromJSON(object.uniformSharding) : undefined,
      manualSharding: isSet(object.manualSharding) ? ManualSharding.fromJSON(object.manualSharding) : undefined,
      smartSharding: isSet(object.smartSharding) ? SmartSharding.fromJSON(object.smartSharding) : undefined,
    };
  },

  toJSON(message: ShardingOption): unknown {
    const obj: any = {};
    if (message.uniformSharding !== undefined) {
      obj.uniformSharding = UniformSharding.toJSON(message.uniformSharding);
    }
    if (message.manualSharding !== undefined) {
      obj.manualSharding = ManualSharding.toJSON(message.manualSharding);
    }
    if (message.smartSharding !== undefined) {
      obj.smartSharding = SmartSharding.toJSON(message.smartSharding);
    }
    return obj;
  },

  create(base?: DeepPartial<ShardingOption>): ShardingOption {
    return ShardingOption.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ShardingOption>): ShardingOption {
    const message = createBaseShardingOption();
    message.uniformSharding = (object.uniformSharding !== undefined && object.uniformSharding !== null)
      ? UniformSharding.fromPartial(object.uniformSharding)
      : undefined;
    message.manualSharding = (object.manualSharding !== undefined && object.manualSharding !== null)
      ? ManualSharding.fromPartial(object.manualSharding)
      : undefined;
    message.smartSharding = (object.smartSharding !== undefined && object.smartSharding !== null)
      ? SmartSharding.fromPartial(object.smartSharding)
      : undefined;
    return message;
  },
};

function createBaseUniformSharding(): UniformSharding {
  return { numShards: 0 };
}

export const UniformSharding: MessageFns<UniformSharding> = {
  encode(message: UniformSharding, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.numShards !== 0) {
      writer.uint32(8).int32(message.numShards);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UniformSharding {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUniformSharding();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.numShards = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UniformSharding {
    return { numShards: isSet(object.numShards) ? globalThis.Number(object.numShards) : 0 };
  },

  toJSON(message: UniformSharding): unknown {
    const obj: any = {};
    if (message.numShards !== 0) {
      obj.numShards = Math.round(message.numShards);
    }
    return obj;
  },

  create(base?: DeepPartial<UniformSharding>): UniformSharding {
    return UniformSharding.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UniformSharding>): UniformSharding {
    const message = createBaseUniformSharding();
    message.numShards = object.numShards ?? 0;
    return message;
  },
};

function createBaseManualSharding(): ManualSharding {
  return { testTargetsForShard: [] };
}

export const ManualSharding: MessageFns<ManualSharding> = {
  encode(message: ManualSharding, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.testTargetsForShard) {
      TestTargetsForShard.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ManualSharding {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseManualSharding();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.testTargetsForShard.push(TestTargetsForShard.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ManualSharding {
    return {
      testTargetsForShard: globalThis.Array.isArray(object?.testTargetsForShard)
        ? object.testTargetsForShard.map((e: any) => TestTargetsForShard.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ManualSharding): unknown {
    const obj: any = {};
    if (message.testTargetsForShard?.length) {
      obj.testTargetsForShard = message.testTargetsForShard.map((e) => TestTargetsForShard.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ManualSharding>): ManualSharding {
    return ManualSharding.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ManualSharding>): ManualSharding {
    const message = createBaseManualSharding();
    message.testTargetsForShard = object.testTargetsForShard?.map((e) => TestTargetsForShard.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTestTargetsForShard(): TestTargetsForShard {
  return { testTargets: [] };
}

export const TestTargetsForShard: MessageFns<TestTargetsForShard> = {
  encode(message: TestTargetsForShard, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.testTargets) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestTargetsForShard {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestTargetsForShard();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.testTargets.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestTargetsForShard {
    return {
      testTargets: globalThis.Array.isArray(object?.testTargets)
        ? object.testTargets.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: TestTargetsForShard): unknown {
    const obj: any = {};
    if (message.testTargets?.length) {
      obj.testTargets = message.testTargets;
    }
    return obj;
  },

  create(base?: DeepPartial<TestTargetsForShard>): TestTargetsForShard {
    return TestTargetsForShard.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TestTargetsForShard>): TestTargetsForShard {
    const message = createBaseTestTargetsForShard();
    message.testTargets = object.testTargets?.map((e) => e) || [];
    return message;
  },
};

function createBaseSmartSharding(): SmartSharding {
  return { targetedShardDuration: undefined };
}

export const SmartSharding: MessageFns<SmartSharding> = {
  encode(message: SmartSharding, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.targetedShardDuration !== undefined) {
      Duration.encode(message.targetedShardDuration, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SmartSharding {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSmartSharding();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.targetedShardDuration = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SmartSharding {
    return {
      targetedShardDuration: isSet(object.targetedShardDuration)
        ? Duration.fromJSON(object.targetedShardDuration)
        : undefined,
    };
  },

  toJSON(message: SmartSharding): unknown {
    const obj: any = {};
    if (message.targetedShardDuration !== undefined) {
      obj.targetedShardDuration = Duration.toJSON(message.targetedShardDuration);
    }
    return obj;
  },

  create(base?: DeepPartial<SmartSharding>): SmartSharding {
    return SmartSharding.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SmartSharding>): SmartSharding {
    const message = createBaseSmartSharding();
    message.targetedShardDuration =
      (object.targetedShardDuration !== undefined && object.targetedShardDuration !== null)
        ? Duration.fromPartial(object.targetedShardDuration)
        : undefined;
    return message;
  },
};

function createBaseShard(): Shard {
  return { shardIndex: 0, numShards: 0, testTargetsForShard: undefined, estimatedShardDuration: undefined };
}

export const Shard: MessageFns<Shard> = {
  encode(message: Shard, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shardIndex !== 0) {
      writer.uint32(8).int32(message.shardIndex);
    }
    if (message.numShards !== 0) {
      writer.uint32(16).int32(message.numShards);
    }
    if (message.testTargetsForShard !== undefined) {
      TestTargetsForShard.encode(message.testTargetsForShard, writer.uint32(26).fork()).join();
    }
    if (message.estimatedShardDuration !== undefined) {
      Duration.encode(message.estimatedShardDuration, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Shard {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShard();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.shardIndex = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.numShards = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.testTargetsForShard = TestTargetsForShard.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.estimatedShardDuration = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Shard {
    return {
      shardIndex: isSet(object.shardIndex) ? globalThis.Number(object.shardIndex) : 0,
      numShards: isSet(object.numShards) ? globalThis.Number(object.numShards) : 0,
      testTargetsForShard: isSet(object.testTargetsForShard)
        ? TestTargetsForShard.fromJSON(object.testTargetsForShard)
        : undefined,
      estimatedShardDuration: isSet(object.estimatedShardDuration)
        ? Duration.fromJSON(object.estimatedShardDuration)
        : undefined,
    };
  },

  toJSON(message: Shard): unknown {
    const obj: any = {};
    if (message.shardIndex !== 0) {
      obj.shardIndex = Math.round(message.shardIndex);
    }
    if (message.numShards !== 0) {
      obj.numShards = Math.round(message.numShards);
    }
    if (message.testTargetsForShard !== undefined) {
      obj.testTargetsForShard = TestTargetsForShard.toJSON(message.testTargetsForShard);
    }
    if (message.estimatedShardDuration !== undefined) {
      obj.estimatedShardDuration = Duration.toJSON(message.estimatedShardDuration);
    }
    return obj;
  },

  create(base?: DeepPartial<Shard>): Shard {
    return Shard.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Shard>): Shard {
    const message = createBaseShard();
    message.shardIndex = object.shardIndex ?? 0;
    message.numShards = object.numShards ?? 0;
    message.testTargetsForShard = (object.testTargetsForShard !== undefined && object.testTargetsForShard !== null)
      ? TestTargetsForShard.fromPartial(object.testTargetsForShard)
      : undefined;
    message.estimatedShardDuration =
      (object.estimatedShardDuration !== undefined && object.estimatedShardDuration !== null)
        ? Duration.fromPartial(object.estimatedShardDuration)
        : undefined;
    return message;
  },
};

function createBaseCreateTestMatrixRequest(): CreateTestMatrixRequest {
  return { projectId: "", testMatrix: undefined, requestId: "" };
}

export const CreateTestMatrixRequest: MessageFns<CreateTestMatrixRequest> = {
  encode(message: CreateTestMatrixRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.testMatrix !== undefined) {
      TestMatrix.encode(message.testMatrix, writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTestMatrixRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTestMatrixRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.testMatrix = TestMatrix.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTestMatrixRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      testMatrix: isSet(object.testMatrix) ? TestMatrix.fromJSON(object.testMatrix) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateTestMatrixRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.testMatrix !== undefined) {
      obj.testMatrix = TestMatrix.toJSON(message.testMatrix);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateTestMatrixRequest>): CreateTestMatrixRequest {
    return CreateTestMatrixRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateTestMatrixRequest>): CreateTestMatrixRequest {
    const message = createBaseCreateTestMatrixRequest();
    message.projectId = object.projectId ?? "";
    message.testMatrix = (object.testMatrix !== undefined && object.testMatrix !== null)
      ? TestMatrix.fromPartial(object.testMatrix)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseGetTestMatrixRequest(): GetTestMatrixRequest {
  return { projectId: "", testMatrixId: "" };
}

export const GetTestMatrixRequest: MessageFns<GetTestMatrixRequest> = {
  encode(message: GetTestMatrixRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.testMatrixId !== "") {
      writer.uint32(18).string(message.testMatrixId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTestMatrixRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTestMatrixRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.testMatrixId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTestMatrixRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      testMatrixId: isSet(object.testMatrixId) ? globalThis.String(object.testMatrixId) : "",
    };
  },

  toJSON(message: GetTestMatrixRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.testMatrixId !== "") {
      obj.testMatrixId = message.testMatrixId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetTestMatrixRequest>): GetTestMatrixRequest {
    return GetTestMatrixRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTestMatrixRequest>): GetTestMatrixRequest {
    const message = createBaseGetTestMatrixRequest();
    message.projectId = object.projectId ?? "";
    message.testMatrixId = object.testMatrixId ?? "";
    return message;
  },
};

function createBaseCancelTestMatrixRequest(): CancelTestMatrixRequest {
  return { projectId: "", testMatrixId: "" };
}

export const CancelTestMatrixRequest: MessageFns<CancelTestMatrixRequest> = {
  encode(message: CancelTestMatrixRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.testMatrixId !== "") {
      writer.uint32(18).string(message.testMatrixId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelTestMatrixRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelTestMatrixRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.testMatrixId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelTestMatrixRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      testMatrixId: isSet(object.testMatrixId) ? globalThis.String(object.testMatrixId) : "",
    };
  },

  toJSON(message: CancelTestMatrixRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.testMatrixId !== "") {
      obj.testMatrixId = message.testMatrixId;
    }
    return obj;
  },

  create(base?: DeepPartial<CancelTestMatrixRequest>): CancelTestMatrixRequest {
    return CancelTestMatrixRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CancelTestMatrixRequest>): CancelTestMatrixRequest {
    const message = createBaseCancelTestMatrixRequest();
    message.projectId = object.projectId ?? "";
    message.testMatrixId = object.testMatrixId ?? "";
    return message;
  },
};

function createBaseCancelTestMatrixResponse(): CancelTestMatrixResponse {
  return { testState: 0 };
}

export const CancelTestMatrixResponse: MessageFns<CancelTestMatrixResponse> = {
  encode(message: CancelTestMatrixResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.testState !== 0) {
      writer.uint32(8).int32(message.testState);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelTestMatrixResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelTestMatrixResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.testState = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelTestMatrixResponse {
    return { testState: isSet(object.testState) ? testStateFromJSON(object.testState) : 0 };
  },

  toJSON(message: CancelTestMatrixResponse): unknown {
    const obj: any = {};
    if (message.testState !== 0) {
      obj.testState = testStateToJSON(message.testState);
    }
    return obj;
  },

  create(base?: DeepPartial<CancelTestMatrixResponse>): CancelTestMatrixResponse {
    return CancelTestMatrixResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CancelTestMatrixResponse>): CancelTestMatrixResponse {
    const message = createBaseCancelTestMatrixResponse();
    message.testState = object.testState ?? 0;
    return message;
  },
};

/**
 * A service for requesting test executions and querying their status.
 *
 * This service is part of Firebase Test Lab. To learn about how to use the
 * product, and how to integrate it with your system,
 * visit https://firebase.google.com/docs/test-lab.
 *
 * Each test execution will wait for available capacity. It will then be
 * invoked as described. The test may be invoked multiple times if an
 * infrastructure failure is detected. Results and other files generated by
 * the test will be stored in an external storage system.
 *
 * The TestExecutionService models this behavior using two resource types:
 *
 * - TestMatrix: a group of one or more TestExecutions, built by taking a
 *   product of values over a pre-defined set of axes. In the case of Android
 *   Tests, for example, device model and OS version are two axes of the matrix.
 *
 * - TestExecution: a single execution of one or more test targets on a
 *   single device. These are created automatically when a TestMatrix is
 *   created.
 *
 * This service returns any error codes from the canonical error space (i.e.
 * google.rpc.Code). The errors which may be returned are specified on each
 * method. In addition, any method may return UNAVAILABLE or INTERNAL.
 */
export type TestExecutionServiceDefinition = typeof TestExecutionServiceDefinition;
export const TestExecutionServiceDefinition = {
  name: "TestExecutionService",
  fullName: "google.devtools.testing.v1.TestExecutionService",
  methods: {
    /**
     * Creates and runs a matrix of tests according to the given specifications.
     * Unsupported environments will be returned in the state UNSUPPORTED.
     * A test matrix is limited to use at most 2000 devices in parallel.
     *
     * The returned matrix will not yet contain the executions that will be
     * created for this matrix. Execution creation happens later on and will
     * require a call to GetTestMatrix.
     *
     * May return any of the following canonical error codes:
     *
     * - PERMISSION_DENIED - if the user is not authorized to write to project
     * - INVALID_ARGUMENT - if the request is malformed or if the matrix tries
     *                      to use too many simultaneous devices.
     */
    createTestMatrix: {
      name: "CreateTestMatrix",
      requestType: CreateTestMatrixRequest,
      requestStream: false,
      responseType: TestMatrix,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              53,
              58,
              11,
              116,
              101,
              115,
              116,
              95,
              109,
              97,
              116,
              114,
              105,
              120,
              34,
              38,
              47,
              118,
              49,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              125,
              47,
              116,
              101,
              115,
              116,
              77,
              97,
              116,
              114,
              105,
              99,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Checks the status of a test matrix and the executions once they
     * are created.
     *
     * The test matrix will contain the list of test executions to run if and only
     * if the resultStorage.toolResultsExecution fields have been populated.
     *
     * Note: Flaky test executions may be added to the matrix at a later stage.
     *
     * May return any of the following canonical error codes:
     *
     * - PERMISSION_DENIED - if the user is not authorized to read project
     * - INVALID_ARGUMENT - if the request is malformed
     * - NOT_FOUND - if the Test Matrix does not exist
     */
    getTestMatrix: {
      name: "GetTestMatrix",
      requestType: GetTestMatrixRequest,
      requestStream: false,
      responseType: TestMatrix,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              57,
              18,
              55,
              47,
              118,
              49,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              125,
              47,
              116,
              101,
              115,
              116,
              77,
              97,
              116,
              114,
              105,
              99,
              101,
              115,
              47,
              123,
              116,
              101,
              115,
              116,
              95,
              109,
              97,
              116,
              114,
              105,
              120,
              95,
              105,
              100,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Cancels unfinished test executions in a test matrix.
     * This call returns immediately and cancellation proceeds asynchronously.
     * If the matrix is already final, this operation will have no effect.
     *
     * May return any of the following canonical error codes:
     *
     * - PERMISSION_DENIED - if the user is not authorized to read project
     * - INVALID_ARGUMENT - if the request is malformed
     * - NOT_FOUND - if the Test Matrix does not exist
     */
    cancelTestMatrix: {
      name: "CancelTestMatrix",
      requestType: CancelTestMatrixRequest,
      requestStream: false,
      responseType: CancelTestMatrixResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              64,
              34,
              62,
              47,
              118,
              49,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              125,
              47,
              116,
              101,
              115,
              116,
              77,
              97,
              116,
              114,
              105,
              99,
              101,
              115,
              47,
              123,
              116,
              101,
              115,
              116,
              95,
              109,
              97,
              116,
              114,
              105,
              120,
              95,
              105,
              100,
              125,
              58,
              99,
              97,
              110,
              99,
              101,
              108,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface TestExecutionServiceImplementation<CallContextExt = {}> {
  /**
   * Creates and runs a matrix of tests according to the given specifications.
   * Unsupported environments will be returned in the state UNSUPPORTED.
   * A test matrix is limited to use at most 2000 devices in parallel.
   *
   * The returned matrix will not yet contain the executions that will be
   * created for this matrix. Execution creation happens later on and will
   * require a call to GetTestMatrix.
   *
   * May return any of the following canonical error codes:
   *
   * - PERMISSION_DENIED - if the user is not authorized to write to project
   * - INVALID_ARGUMENT - if the request is malformed or if the matrix tries
   *                      to use too many simultaneous devices.
   */
  createTestMatrix(
    request: CreateTestMatrixRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<TestMatrix>>;
  /**
   * Checks the status of a test matrix and the executions once they
   * are created.
   *
   * The test matrix will contain the list of test executions to run if and only
   * if the resultStorage.toolResultsExecution fields have been populated.
   *
   * Note: Flaky test executions may be added to the matrix at a later stage.
   *
   * May return any of the following canonical error codes:
   *
   * - PERMISSION_DENIED - if the user is not authorized to read project
   * - INVALID_ARGUMENT - if the request is malformed
   * - NOT_FOUND - if the Test Matrix does not exist
   */
  getTestMatrix(request: GetTestMatrixRequest, context: CallContext & CallContextExt): Promise<DeepPartial<TestMatrix>>;
  /**
   * Cancels unfinished test executions in a test matrix.
   * This call returns immediately and cancellation proceeds asynchronously.
   * If the matrix is already final, this operation will have no effect.
   *
   * May return any of the following canonical error codes:
   *
   * - PERMISSION_DENIED - if the user is not authorized to read project
   * - INVALID_ARGUMENT - if the request is malformed
   * - NOT_FOUND - if the Test Matrix does not exist
   */
  cancelTestMatrix(
    request: CancelTestMatrixRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CancelTestMatrixResponse>>;
}

export interface TestExecutionServiceClient<CallOptionsExt = {}> {
  /**
   * Creates and runs a matrix of tests according to the given specifications.
   * Unsupported environments will be returned in the state UNSUPPORTED.
   * A test matrix is limited to use at most 2000 devices in parallel.
   *
   * The returned matrix will not yet contain the executions that will be
   * created for this matrix. Execution creation happens later on and will
   * require a call to GetTestMatrix.
   *
   * May return any of the following canonical error codes:
   *
   * - PERMISSION_DENIED - if the user is not authorized to write to project
   * - INVALID_ARGUMENT - if the request is malformed or if the matrix tries
   *                      to use too many simultaneous devices.
   */
  createTestMatrix(
    request: DeepPartial<CreateTestMatrixRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<TestMatrix>;
  /**
   * Checks the status of a test matrix and the executions once they
   * are created.
   *
   * The test matrix will contain the list of test executions to run if and only
   * if the resultStorage.toolResultsExecution fields have been populated.
   *
   * Note: Flaky test executions may be added to the matrix at a later stage.
   *
   * May return any of the following canonical error codes:
   *
   * - PERMISSION_DENIED - if the user is not authorized to read project
   * - INVALID_ARGUMENT - if the request is malformed
   * - NOT_FOUND - if the Test Matrix does not exist
   */
  getTestMatrix(
    request: DeepPartial<GetTestMatrixRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<TestMatrix>;
  /**
   * Cancels unfinished test executions in a test matrix.
   * This call returns immediately and cancellation proceeds asynchronously.
   * If the matrix is already final, this operation will have no effect.
   *
   * May return any of the following canonical error codes:
   *
   * - PERMISSION_DENIED - if the user is not authorized to read project
   * - INVALID_ARGUMENT - if the request is malformed
   * - NOT_FOUND - if the Test Matrix does not exist
   */
  cancelTestMatrix(
    request: DeepPartial<CancelTestMatrixRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CancelTestMatrixResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
