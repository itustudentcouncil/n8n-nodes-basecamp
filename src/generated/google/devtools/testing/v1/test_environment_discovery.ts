// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/devtools/testing/v1/test_environment_discovery.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Duration } from "../../../protobuf/duration.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { DateMessage } from "../../../type/date.js";

export const protobufPackage = "google.devtools.testing.v1";

/** Whether the device is physical or virtual. */
export enum DeviceForm {
  /** DEVICE_FORM_UNSPECIFIED - Do not use.  For proto versioning only. */
  DEVICE_FORM_UNSPECIFIED = 0,
  /**
   * VIRTUAL - Android virtual device using Compute Engine native virtualization. Firebase
   * Test Lab only.
   */
  VIRTUAL = 1,
  /** PHYSICAL - Actual hardware. */
  PHYSICAL = 2,
  /**
   * EMULATOR - Android virtual device using emulator in nested virtualization. Equivalent
   * to Android Studio.
   */
  EMULATOR = 3,
  UNRECOGNIZED = -1,
}

export function deviceFormFromJSON(object: any): DeviceForm {
  switch (object) {
    case 0:
    case "DEVICE_FORM_UNSPECIFIED":
      return DeviceForm.DEVICE_FORM_UNSPECIFIED;
    case 1:
    case "VIRTUAL":
      return DeviceForm.VIRTUAL;
    case 2:
    case "PHYSICAL":
      return DeviceForm.PHYSICAL;
    case 3:
    case "EMULATOR":
      return DeviceForm.EMULATOR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DeviceForm.UNRECOGNIZED;
  }
}

export function deviceFormToJSON(object: DeviceForm): string {
  switch (object) {
    case DeviceForm.DEVICE_FORM_UNSPECIFIED:
      return "DEVICE_FORM_UNSPECIFIED";
    case DeviceForm.VIRTUAL:
      return "VIRTUAL";
    case DeviceForm.PHYSICAL:
      return "PHYSICAL";
    case DeviceForm.EMULATOR:
      return "EMULATOR";
    case DeviceForm.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The form factor of a device. */
export enum DeviceFormFactor {
  /** DEVICE_FORM_FACTOR_UNSPECIFIED - Do not use. For proto versioning only. */
  DEVICE_FORM_FACTOR_UNSPECIFIED = 0,
  /** PHONE - This device has the shape of a phone. */
  PHONE = 1,
  /** TABLET - This device has the shape of a tablet. */
  TABLET = 2,
  /** WEARABLE - This device has the shape of a watch or other wearable. */
  WEARABLE = 3,
  UNRECOGNIZED = -1,
}

export function deviceFormFactorFromJSON(object: any): DeviceFormFactor {
  switch (object) {
    case 0:
    case "DEVICE_FORM_FACTOR_UNSPECIFIED":
      return DeviceFormFactor.DEVICE_FORM_FACTOR_UNSPECIFIED;
    case 1:
    case "PHONE":
      return DeviceFormFactor.PHONE;
    case 2:
    case "TABLET":
      return DeviceFormFactor.TABLET;
    case 3:
    case "WEARABLE":
      return DeviceFormFactor.WEARABLE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DeviceFormFactor.UNRECOGNIZED;
  }
}

export function deviceFormFactorToJSON(object: DeviceFormFactor): string {
  switch (object) {
    case DeviceFormFactor.DEVICE_FORM_FACTOR_UNSPECIFIED:
      return "DEVICE_FORM_FACTOR_UNSPECIFIED";
    case DeviceFormFactor.PHONE:
      return "PHONE";
    case DeviceFormFactor.TABLET:
      return "TABLET";
    case DeviceFormFactor.WEARABLE:
      return "WEARABLE";
    case DeviceFormFactor.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Capacity based on the number of online devices in the lab.
 *
 * Important: device capacity does not directly reflect the length of the
 * queue at a moment in time. It does not take into account current traffic or
 * the state of the devices.
 *
 * For physical devices, the number is the average of online devices in the last
 * 30 days.
 */
export enum DeviceCapacity {
  /** DEVICE_CAPACITY_UNSPECIFIED - The value of device capacity is unknown or unset. */
  DEVICE_CAPACITY_UNSPECIFIED = 0,
  /**
   * DEVICE_CAPACITY_HIGH - Devices that are high in capacity (The lab has a large number of these
   * devices).
   *
   * These devices are generally suggested for running a large number of
   * simultaneous tests (e.g. more than 100 tests).
   *
   * Please note that high capacity devices do not guarantee short wait times
   * due to several factors:
   * 1. Traffic (how heavily they are used at any given moment)
   * 2. High capacity devices are prioritized for certain usages, which may
   * cause user tests to be slower than selecting other similar device types.
   */
  DEVICE_CAPACITY_HIGH = 1,
  /**
   * DEVICE_CAPACITY_MEDIUM - Devices that are medium in capacity (The lab has a decent number of these
   * devices, though not as many as high capacity devices).
   *
   * These devices are suitable for fewer test runs (e.g. fewer than 100 tests)
   * and only for low shard counts (e.g. less than 10 shards).
   */
  DEVICE_CAPACITY_MEDIUM = 2,
  /**
   * DEVICE_CAPACITY_LOW - Devices that are low in capacity (The lab has a small number of these
   * devices).
   *
   * These devices may be used if users need to test on this specific device
   * model and version. Please note that due to low capacity, the tests may take
   * much longer to finish, especially if a large number of tests are invoked at
   * once. These devices are not suitable for test sharding.
   */
  DEVICE_CAPACITY_LOW = 3,
  /**
   * DEVICE_CAPACITY_NONE - Devices that are completely missing from the lab.
   *
   * These devices are unavailable either temporarily or permanently and should
   * not be requested. If the device is also marked as deprecated, this state
   * is very likely permanent.
   */
  DEVICE_CAPACITY_NONE = 4,
  UNRECOGNIZED = -1,
}

export function deviceCapacityFromJSON(object: any): DeviceCapacity {
  switch (object) {
    case 0:
    case "DEVICE_CAPACITY_UNSPECIFIED":
      return DeviceCapacity.DEVICE_CAPACITY_UNSPECIFIED;
    case 1:
    case "DEVICE_CAPACITY_HIGH":
      return DeviceCapacity.DEVICE_CAPACITY_HIGH;
    case 2:
    case "DEVICE_CAPACITY_MEDIUM":
      return DeviceCapacity.DEVICE_CAPACITY_MEDIUM;
    case 3:
    case "DEVICE_CAPACITY_LOW":
      return DeviceCapacity.DEVICE_CAPACITY_LOW;
    case 4:
    case "DEVICE_CAPACITY_NONE":
      return DeviceCapacity.DEVICE_CAPACITY_NONE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DeviceCapacity.UNRECOGNIZED;
  }
}

export function deviceCapacityToJSON(object: DeviceCapacity): string {
  switch (object) {
    case DeviceCapacity.DEVICE_CAPACITY_UNSPECIFIED:
      return "DEVICE_CAPACITY_UNSPECIFIED";
    case DeviceCapacity.DEVICE_CAPACITY_HIGH:
      return "DEVICE_CAPACITY_HIGH";
    case DeviceCapacity.DEVICE_CAPACITY_MEDIUM:
      return "DEVICE_CAPACITY_MEDIUM";
    case DeviceCapacity.DEVICE_CAPACITY_LOW:
      return "DEVICE_CAPACITY_LOW";
    case DeviceCapacity.DEVICE_CAPACITY_NONE:
      return "DEVICE_CAPACITY_NONE";
    case DeviceCapacity.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A single device IP block */
export interface DeviceIpBlock {
  /** An IP address block in CIDR notation eg: 34.68.194.64/29 */
  block: string;
  /** Whether this block is used by physical or virtual devices */
  form: DeviceForm;
  /** The date this block was added to Firebase Test Lab */
  addedDate: DateMessage | undefined;
}

/** Request to list the currently supported values for an environment type. */
export interface GetTestEnvironmentCatalogRequest {
  /** Required. The type of environment that should be listed. */
  environmentType: GetTestEnvironmentCatalogRequest_EnvironmentType;
  /** For authorization, the cloud project requesting the TestEnvironmentCatalog. */
  projectId: string;
}

/** Types of environments the Test API supports. */
export enum GetTestEnvironmentCatalogRequest_EnvironmentType {
  /** ENVIRONMENT_TYPE_UNSPECIFIED - Do not use.  For proto versioning only. */
  ENVIRONMENT_TYPE_UNSPECIFIED = 0,
  /** ANDROID - A device running a version of the Android OS. */
  ANDROID = 1,
  /** IOS - A device running a version of iOS. */
  IOS = 3,
  /** NETWORK_CONFIGURATION - A network configuration to use when running a test. */
  NETWORK_CONFIGURATION = 4,
  /** PROVIDED_SOFTWARE - The software environment provided by TestExecutionService. */
  PROVIDED_SOFTWARE = 5,
  /** DEVICE_IP_BLOCKS - The IP blocks used by devices in the test environment. */
  DEVICE_IP_BLOCKS = 6,
  UNRECOGNIZED = -1,
}

export function getTestEnvironmentCatalogRequest_EnvironmentTypeFromJSON(
  object: any,
): GetTestEnvironmentCatalogRequest_EnvironmentType {
  switch (object) {
    case 0:
    case "ENVIRONMENT_TYPE_UNSPECIFIED":
      return GetTestEnvironmentCatalogRequest_EnvironmentType.ENVIRONMENT_TYPE_UNSPECIFIED;
    case 1:
    case "ANDROID":
      return GetTestEnvironmentCatalogRequest_EnvironmentType.ANDROID;
    case 3:
    case "IOS":
      return GetTestEnvironmentCatalogRequest_EnvironmentType.IOS;
    case 4:
    case "NETWORK_CONFIGURATION":
      return GetTestEnvironmentCatalogRequest_EnvironmentType.NETWORK_CONFIGURATION;
    case 5:
    case "PROVIDED_SOFTWARE":
      return GetTestEnvironmentCatalogRequest_EnvironmentType.PROVIDED_SOFTWARE;
    case 6:
    case "DEVICE_IP_BLOCKS":
      return GetTestEnvironmentCatalogRequest_EnvironmentType.DEVICE_IP_BLOCKS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GetTestEnvironmentCatalogRequest_EnvironmentType.UNRECOGNIZED;
  }
}

export function getTestEnvironmentCatalogRequest_EnvironmentTypeToJSON(
  object: GetTestEnvironmentCatalogRequest_EnvironmentType,
): string {
  switch (object) {
    case GetTestEnvironmentCatalogRequest_EnvironmentType.ENVIRONMENT_TYPE_UNSPECIFIED:
      return "ENVIRONMENT_TYPE_UNSPECIFIED";
    case GetTestEnvironmentCatalogRequest_EnvironmentType.ANDROID:
      return "ANDROID";
    case GetTestEnvironmentCatalogRequest_EnvironmentType.IOS:
      return "IOS";
    case GetTestEnvironmentCatalogRequest_EnvironmentType.NETWORK_CONFIGURATION:
      return "NETWORK_CONFIGURATION";
    case GetTestEnvironmentCatalogRequest_EnvironmentType.PROVIDED_SOFTWARE:
      return "PROVIDED_SOFTWARE";
    case GetTestEnvironmentCatalogRequest_EnvironmentType.DEVICE_IP_BLOCKS:
      return "DEVICE_IP_BLOCKS";
    case GetTestEnvironmentCatalogRequest_EnvironmentType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A description of a test environment. */
export interface TestEnvironmentCatalog {
  /** Supported Android devices. */
  androidDeviceCatalog?:
    | AndroidDeviceCatalog
    | undefined;
  /** Supported iOS devices. */
  iosDeviceCatalog?:
    | IosDeviceCatalog
    | undefined;
  /** Supported network configurations. */
  networkConfigurationCatalog?:
    | NetworkConfigurationCatalog
    | undefined;
  /** The software test environment provided by TestExecutionService. */
  softwareCatalog?:
    | ProvidedSoftwareCatalog
    | undefined;
  /** The IP blocks used by devices in the test environment. */
  deviceIpBlockCatalog?: DeviceIpBlockCatalog | undefined;
}

/** List of IP blocks used by the Firebase Test Lab */
export interface DeviceIpBlockCatalog {
  /** The device IP blocks used by Firebase Test Lab */
  ipBlocks: DeviceIpBlock[];
}

/** The currently supported Android devices. */
export interface AndroidDeviceCatalog {
  /** The set of supported Android device models. */
  models: AndroidModel[];
  /** The set of supported Android OS versions. */
  versions: AndroidVersion[];
  /** The set of supported runtime configurations. */
  runtimeConfiguration: AndroidRuntimeConfiguration | undefined;
}

/** Android configuration that can be selected at the time a test is run. */
export interface AndroidRuntimeConfiguration {
  /** The set of available locales. */
  locales: Locale[];
  /** The set of available orientations. */
  orientations: Orientation[];
}

/** A description of an Android device tests may be run on. */
export interface AndroidModel {
  /**
   * The unique opaque id for this model.
   * Use this for invoking the TestExecutionService.
   */
  id: string;
  /**
   * The human-readable marketing name for this device model.
   * Examples: "Nexus 5", "Galaxy S5".
   */
  name: string;
  /** The manufacturer of this device. */
  manufacturer: string;
  /**
   * The company that this device is branded with.
   * Example: "Google", "Samsung".
   */
  brand: string;
  /**
   * The name of the industrial design.
   * This corresponds to android.os.Build.DEVICE.
   */
  codename: string;
  /** Whether this device is virtual or physical. */
  form: DeviceForm;
  /** Whether this device is a phone, tablet, wearable, etc. */
  formFactor: DeviceFormFactor;
  /** Version-specific information of an Android model. */
  perVersionInfo: PerAndroidVersionInfo[];
  /** Screen size in the horizontal (X) dimension measured in pixels. */
  screenX: number;
  /** Screen size in the vertical (Y) dimension measured in pixels. */
  screenY: number;
  /**
   * Screen density in DPI.
   * This corresponds to ro.sf.lcd_density
   */
  screenDensity: number;
  /**
   * True if and only if tests with this model are recorded by stitching
   * together screenshots. See use_low_spec_video_recording in device config.
   */
  lowFpsVideoRecording: boolean;
  /** The set of Android versions this device supports. */
  supportedVersionIds: string[];
  /**
   * The list of supported ABIs for this device.
   * This corresponds to either android.os.Build.SUPPORTED_ABIS (for API level
   * 21 and above) or android.os.Build.CPU_ABI/CPU_ABI2.
   * The most preferred ABI is the first element in the list.
   *
   * Elements are optionally prefixed by "version_id:" (where version_id is
   * the id of an AndroidVersion), denoting an ABI that is supported only on
   * a particular version.
   */
  supportedAbis: string[];
  /**
   * Tags for this dimension.
   * Examples: "default", "preview", "deprecated".
   */
  tags: string[];
  /** URL of a thumbnail image (photo) of the device. */
  thumbnailUrl: string;
}

/** A version of the Android OS. */
export interface AndroidVersion {
  /**
   * An opaque id for this Android version.
   * Use this id to invoke the TestExecutionService.
   */
  id: string;
  /**
   * A string representing this version of the Android OS.
   * Examples: "4.3", "4.4".
   */
  versionString: string;
  /**
   * The API level for this Android version.
   * Examples: 18, 19.
   */
  apiLevel: number;
  /**
   * The code name for this Android version.
   * Examples: "JellyBean", "KitKat".
   */
  codeName: string;
  /** The date this Android version became available in the market. */
  releaseDate:
    | DateMessage
    | undefined;
  /** Market share for this version. */
  distribution:
    | Distribution
    | undefined;
  /**
   * Tags for this dimension.
   * Examples: "default", "preview", "deprecated".
   */
  tags: string[];
}

/** A version-specific information of an Android model. */
export interface PerAndroidVersionInfo {
  /** An Android version. */
  versionId: string;
  /** The number of online devices for an Android version. */
  deviceCapacity: DeviceCapacity;
  /**
   * Output only. The estimated wait time for a single interactive device
   * session using Direct Access.
   */
  interactiveDeviceAvailabilityEstimate:
    | Duration
    | undefined;
  /**
   * Output only. Identifies supported clients for DirectAccess for this Android
   * version.
   */
  directAccessVersionInfo: DirectAccessVersionInfo | undefined;
}

/**
 * Denotes whether Direct Access is supported, and by which client versions.
 *
 * DirectAccessService is currently available as a preview to select developers.
 * You can register today on behalf of you and your team at
 * https://developer.android.com/studio/preview/android-device-streaming
 */
export interface DirectAccessVersionInfo {
  /**
   * Whether direct access is supported at all. Clients are expected to
   * filter down the device list to only android models and versions which
   * support Direct Access when that is the user intent.
   */
  directAccessSupported: boolean;
  /**
   * Output only. Indicates client-device compatibility, where a device is known
   * to work only with certain workarounds implemented in the Android Studio
   * client. Expected format "major.minor.micro.patch", e.g.
   * "5921.22.2211.8881706".
   */
  minimumAndroidStudioVersion: string;
}

/**
 * Data about the relative number of devices running a
 * given configuration of the Android platform.
 */
export interface Distribution {
  /** Output only. The time this distribution was measured. */
  measurementTime:
    | Date
    | undefined;
  /**
   * Output only. The estimated fraction (0-1) of the total market with this
   * configuration.
   */
  marketShare: number;
}

/** The currently supported iOS devices. */
export interface IosDeviceCatalog {
  /** The set of supported iOS device models. */
  models: IosModel[];
  /** The set of supported iOS software versions. */
  versions: IosVersion[];
  /** The set of supported Xcode versions. */
  xcodeVersions: XcodeVersion[];
  /** The set of supported runtime configurations. */
  runtimeConfiguration: IosRuntimeConfiguration | undefined;
}

/** iOS configuration that can be selected at the time a test is run. */
export interface IosRuntimeConfiguration {
  /** The set of available locales. */
  locales: Locale[];
  /** The set of available orientations. */
  orientations: Orientation[];
}

/** A description of an iOS device tests may be run on. */
export interface IosModel {
  /**
   * The unique opaque id for this model.
   * Use this for invoking the TestExecutionService.
   */
  id: string;
  /**
   * The human-readable name for this device model.
   * Examples: "iPhone 4s", "iPad Mini 2".
   */
  name: string;
  /** The set of iOS major software versions this device supports. */
  supportedVersionIds: string[];
  /**
   * Tags for this dimension.
   * Examples: "default", "preview", "deprecated".
   */
  tags: string[];
  /**
   * Device capabilities.
   * Copied from
   * https://developer.apple.com/library/archive/documentation/DeviceInformation/Reference/iOSDeviceCompatibility/DeviceCompatibilityMatrix/DeviceCompatibilityMatrix.html
   */
  deviceCapabilities: string[];
  /** Screen size in the horizontal (X) dimension measured in pixels. */
  screenX: number;
  /** Screen size in the vertical (Y) dimension measured in pixels. */
  screenY: number;
  /** Screen density in DPI. */
  screenDensity: number;
  /** Whether this device is a phone, tablet, wearable, etc. */
  formFactor: DeviceFormFactor;
  /** Version-specific information of an iOS model. */
  perVersionInfo: PerIosVersionInfo[];
}

/** An iOS version. */
export interface IosVersion {
  /**
   * An opaque id for this iOS version.
   * Use this id to invoke the TestExecutionService.
   */
  id: string;
  /**
   * An integer representing the major iOS version.
   * Examples: "8", "9".
   */
  majorVersion: number;
  /**
   * An integer representing the minor iOS version.
   * Examples: "1", "2".
   */
  minorVersion: number;
  /**
   * Tags for this dimension.
   * Examples: "default", "preview", "deprecated".
   */
  tags: string[];
  /** The available Xcode versions for this version. */
  supportedXcodeVersionIds: string[];
}

/** A version-specific information of an iOS model. */
export interface PerIosVersionInfo {
  /** An iOS version. */
  versionId: string;
  /** The number of online devices for an iOS version. */
  deviceCapacity: DeviceCapacity;
}

/** A location/region designation for language. */
export interface Locale {
  /**
   * The id for this locale.
   * Example: "en_US".
   */
  id: string;
  /**
   * A human-friendly name for this language/locale.
   * Example: "English".
   */
  name: string;
  /**
   * A human-friendly string representing the region for this
   * locale. Example: "United States". Not present for every locale.
   */
  region: string;
  /**
   * Tags for this dimension.
   * Example: "default".
   */
  tags: string[];
}

/** Screen orientation of the device. */
export interface Orientation {
  /**
   * The id for this orientation.
   * Example: "portrait".
   */
  id: string;
  /**
   * A human-friendly name for this orientation.
   * Example: "portrait".
   */
  name: string;
  /**
   * Tags for this dimension.
   * Example: "default".
   */
  tags: string[];
}

/** An Xcode version that an iOS version is compatible with. */
export interface XcodeVersion {
  /**
   * The id for this version.
   * Example: "9.2".
   */
  version: string;
  /**
   * Tags for this Xcode version.
   * Example: "default".
   */
  tags: string[];
}

export interface NetworkConfigurationCatalog {
  configurations: NetworkConfiguration[];
}

export interface NetworkConfiguration {
  /** The unique opaque id for this network traffic configuration. */
  id: string;
  /** The emulation rule applying to the upload traffic. */
  upRule:
    | TrafficRule
    | undefined;
  /** The emulation rule applying to the download traffic. */
  downRule: TrafficRule | undefined;
}

/** Network emulation parameters. */
export interface TrafficRule {
  /** Packet delay, must be >= 0. */
  delay:
    | Duration
    | undefined;
  /** Packet loss ratio (0.0 - 1.0). */
  packetLossRatio: number;
  /** Packet duplication ratio (0.0 - 1.0). */
  packetDuplicationRatio: number;
  /** Bandwidth in kbits/second. */
  bandwidth: number;
  /** Burst size in kbits. */
  burst: number;
}

/** The currently provided software environment on the devices under test. */
export interface ProvidedSoftwareCatalog {
  /**
   * Deprecated: Use AndroidX Test Orchestrator going forward.
   *
   * A string representing the current version of Android Test Orchestrator
   * that is used in the environment. The package is available at
   * https://maven.google.com/web/index.html#com.android.support.test:orchestrator.
   *
   * @deprecated
   */
  orchestratorVersion: string;
  /**
   * A string representing the current version of AndroidX Test Orchestrator
   * that is used in the environment. The package is available at
   * https://maven.google.com/web/index.html#androidx.test:orchestrator.
   */
  androidxOrchestratorVersion: string;
}

function createBaseDeviceIpBlock(): DeviceIpBlock {
  return { block: "", form: 0, addedDate: undefined };
}

export const DeviceIpBlock: MessageFns<DeviceIpBlock> = {
  encode(message: DeviceIpBlock, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.block !== "") {
      writer.uint32(10).string(message.block);
    }
    if (message.form !== 0) {
      writer.uint32(16).int32(message.form);
    }
    if (message.addedDate !== undefined) {
      DateMessage.encode(message.addedDate, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeviceIpBlock {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeviceIpBlock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.block = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.form = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.addedDate = DateMessage.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeviceIpBlock {
    return {
      block: isSet(object.block) ? globalThis.String(object.block) : "",
      form: isSet(object.form) ? deviceFormFromJSON(object.form) : 0,
      addedDate: isSet(object.addedDate) ? DateMessage.fromJSON(object.addedDate) : undefined,
    };
  },

  toJSON(message: DeviceIpBlock): unknown {
    const obj: any = {};
    if (message.block !== "") {
      obj.block = message.block;
    }
    if (message.form !== 0) {
      obj.form = deviceFormToJSON(message.form);
    }
    if (message.addedDate !== undefined) {
      obj.addedDate = DateMessage.toJSON(message.addedDate);
    }
    return obj;
  },

  create(base?: DeepPartial<DeviceIpBlock>): DeviceIpBlock {
    return DeviceIpBlock.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeviceIpBlock>): DeviceIpBlock {
    const message = createBaseDeviceIpBlock();
    message.block = object.block ?? "";
    message.form = object.form ?? 0;
    message.addedDate = (object.addedDate !== undefined && object.addedDate !== null)
      ? DateMessage.fromPartial(object.addedDate)
      : undefined;
    return message;
  },
};

function createBaseGetTestEnvironmentCatalogRequest(): GetTestEnvironmentCatalogRequest {
  return { environmentType: 0, projectId: "" };
}

export const GetTestEnvironmentCatalogRequest: MessageFns<GetTestEnvironmentCatalogRequest> = {
  encode(message: GetTestEnvironmentCatalogRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.environmentType !== 0) {
      writer.uint32(8).int32(message.environmentType);
    }
    if (message.projectId !== "") {
      writer.uint32(18).string(message.projectId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTestEnvironmentCatalogRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTestEnvironmentCatalogRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.environmentType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.projectId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTestEnvironmentCatalogRequest {
    return {
      environmentType: isSet(object.environmentType)
        ? getTestEnvironmentCatalogRequest_EnvironmentTypeFromJSON(object.environmentType)
        : 0,
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
    };
  },

  toJSON(message: GetTestEnvironmentCatalogRequest): unknown {
    const obj: any = {};
    if (message.environmentType !== 0) {
      obj.environmentType = getTestEnvironmentCatalogRequest_EnvironmentTypeToJSON(message.environmentType);
    }
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetTestEnvironmentCatalogRequest>): GetTestEnvironmentCatalogRequest {
    return GetTestEnvironmentCatalogRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTestEnvironmentCatalogRequest>): GetTestEnvironmentCatalogRequest {
    const message = createBaseGetTestEnvironmentCatalogRequest();
    message.environmentType = object.environmentType ?? 0;
    message.projectId = object.projectId ?? "";
    return message;
  },
};

function createBaseTestEnvironmentCatalog(): TestEnvironmentCatalog {
  return {
    androidDeviceCatalog: undefined,
    iosDeviceCatalog: undefined,
    networkConfigurationCatalog: undefined,
    softwareCatalog: undefined,
    deviceIpBlockCatalog: undefined,
  };
}

export const TestEnvironmentCatalog: MessageFns<TestEnvironmentCatalog> = {
  encode(message: TestEnvironmentCatalog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.androidDeviceCatalog !== undefined) {
      AndroidDeviceCatalog.encode(message.androidDeviceCatalog, writer.uint32(10).fork()).join();
    }
    if (message.iosDeviceCatalog !== undefined) {
      IosDeviceCatalog.encode(message.iosDeviceCatalog, writer.uint32(26).fork()).join();
    }
    if (message.networkConfigurationCatalog !== undefined) {
      NetworkConfigurationCatalog.encode(message.networkConfigurationCatalog, writer.uint32(34).fork()).join();
    }
    if (message.softwareCatalog !== undefined) {
      ProvidedSoftwareCatalog.encode(message.softwareCatalog, writer.uint32(42).fork()).join();
    }
    if (message.deviceIpBlockCatalog !== undefined) {
      DeviceIpBlockCatalog.encode(message.deviceIpBlockCatalog, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestEnvironmentCatalog {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestEnvironmentCatalog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.androidDeviceCatalog = AndroidDeviceCatalog.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.iosDeviceCatalog = IosDeviceCatalog.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.networkConfigurationCatalog = NetworkConfigurationCatalog.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.softwareCatalog = ProvidedSoftwareCatalog.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.deviceIpBlockCatalog = DeviceIpBlockCatalog.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestEnvironmentCatalog {
    return {
      androidDeviceCatalog: isSet(object.androidDeviceCatalog)
        ? AndroidDeviceCatalog.fromJSON(object.androidDeviceCatalog)
        : undefined,
      iosDeviceCatalog: isSet(object.iosDeviceCatalog) ? IosDeviceCatalog.fromJSON(object.iosDeviceCatalog) : undefined,
      networkConfigurationCatalog: isSet(object.networkConfigurationCatalog)
        ? NetworkConfigurationCatalog.fromJSON(object.networkConfigurationCatalog)
        : undefined,
      softwareCatalog: isSet(object.softwareCatalog)
        ? ProvidedSoftwareCatalog.fromJSON(object.softwareCatalog)
        : undefined,
      deviceIpBlockCatalog: isSet(object.deviceIpBlockCatalog)
        ? DeviceIpBlockCatalog.fromJSON(object.deviceIpBlockCatalog)
        : undefined,
    };
  },

  toJSON(message: TestEnvironmentCatalog): unknown {
    const obj: any = {};
    if (message.androidDeviceCatalog !== undefined) {
      obj.androidDeviceCatalog = AndroidDeviceCatalog.toJSON(message.androidDeviceCatalog);
    }
    if (message.iosDeviceCatalog !== undefined) {
      obj.iosDeviceCatalog = IosDeviceCatalog.toJSON(message.iosDeviceCatalog);
    }
    if (message.networkConfigurationCatalog !== undefined) {
      obj.networkConfigurationCatalog = NetworkConfigurationCatalog.toJSON(message.networkConfigurationCatalog);
    }
    if (message.softwareCatalog !== undefined) {
      obj.softwareCatalog = ProvidedSoftwareCatalog.toJSON(message.softwareCatalog);
    }
    if (message.deviceIpBlockCatalog !== undefined) {
      obj.deviceIpBlockCatalog = DeviceIpBlockCatalog.toJSON(message.deviceIpBlockCatalog);
    }
    return obj;
  },

  create(base?: DeepPartial<TestEnvironmentCatalog>): TestEnvironmentCatalog {
    return TestEnvironmentCatalog.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TestEnvironmentCatalog>): TestEnvironmentCatalog {
    const message = createBaseTestEnvironmentCatalog();
    message.androidDeviceCatalog = (object.androidDeviceCatalog !== undefined && object.androidDeviceCatalog !== null)
      ? AndroidDeviceCatalog.fromPartial(object.androidDeviceCatalog)
      : undefined;
    message.iosDeviceCatalog = (object.iosDeviceCatalog !== undefined && object.iosDeviceCatalog !== null)
      ? IosDeviceCatalog.fromPartial(object.iosDeviceCatalog)
      : undefined;
    message.networkConfigurationCatalog =
      (object.networkConfigurationCatalog !== undefined && object.networkConfigurationCatalog !== null)
        ? NetworkConfigurationCatalog.fromPartial(object.networkConfigurationCatalog)
        : undefined;
    message.softwareCatalog = (object.softwareCatalog !== undefined && object.softwareCatalog !== null)
      ? ProvidedSoftwareCatalog.fromPartial(object.softwareCatalog)
      : undefined;
    message.deviceIpBlockCatalog = (object.deviceIpBlockCatalog !== undefined && object.deviceIpBlockCatalog !== null)
      ? DeviceIpBlockCatalog.fromPartial(object.deviceIpBlockCatalog)
      : undefined;
    return message;
  },
};

function createBaseDeviceIpBlockCatalog(): DeviceIpBlockCatalog {
  return { ipBlocks: [] };
}

export const DeviceIpBlockCatalog: MessageFns<DeviceIpBlockCatalog> = {
  encode(message: DeviceIpBlockCatalog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.ipBlocks) {
      DeviceIpBlock.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeviceIpBlockCatalog {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeviceIpBlockCatalog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ipBlocks.push(DeviceIpBlock.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeviceIpBlockCatalog {
    return {
      ipBlocks: globalThis.Array.isArray(object?.ipBlocks)
        ? object.ipBlocks.map((e: any) => DeviceIpBlock.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DeviceIpBlockCatalog): unknown {
    const obj: any = {};
    if (message.ipBlocks?.length) {
      obj.ipBlocks = message.ipBlocks.map((e) => DeviceIpBlock.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<DeviceIpBlockCatalog>): DeviceIpBlockCatalog {
    return DeviceIpBlockCatalog.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeviceIpBlockCatalog>): DeviceIpBlockCatalog {
    const message = createBaseDeviceIpBlockCatalog();
    message.ipBlocks = object.ipBlocks?.map((e) => DeviceIpBlock.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAndroidDeviceCatalog(): AndroidDeviceCatalog {
  return { models: [], versions: [], runtimeConfiguration: undefined };
}

export const AndroidDeviceCatalog: MessageFns<AndroidDeviceCatalog> = {
  encode(message: AndroidDeviceCatalog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.models) {
      AndroidModel.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.versions) {
      AndroidVersion.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.runtimeConfiguration !== undefined) {
      AndroidRuntimeConfiguration.encode(message.runtimeConfiguration, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AndroidDeviceCatalog {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAndroidDeviceCatalog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.models.push(AndroidModel.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.versions.push(AndroidVersion.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.runtimeConfiguration = AndroidRuntimeConfiguration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AndroidDeviceCatalog {
    return {
      models: globalThis.Array.isArray(object?.models) ? object.models.map((e: any) => AndroidModel.fromJSON(e)) : [],
      versions: globalThis.Array.isArray(object?.versions)
        ? object.versions.map((e: any) => AndroidVersion.fromJSON(e))
        : [],
      runtimeConfiguration: isSet(object.runtimeConfiguration)
        ? AndroidRuntimeConfiguration.fromJSON(object.runtimeConfiguration)
        : undefined,
    };
  },

  toJSON(message: AndroidDeviceCatalog): unknown {
    const obj: any = {};
    if (message.models?.length) {
      obj.models = message.models.map((e) => AndroidModel.toJSON(e));
    }
    if (message.versions?.length) {
      obj.versions = message.versions.map((e) => AndroidVersion.toJSON(e));
    }
    if (message.runtimeConfiguration !== undefined) {
      obj.runtimeConfiguration = AndroidRuntimeConfiguration.toJSON(message.runtimeConfiguration);
    }
    return obj;
  },

  create(base?: DeepPartial<AndroidDeviceCatalog>): AndroidDeviceCatalog {
    return AndroidDeviceCatalog.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AndroidDeviceCatalog>): AndroidDeviceCatalog {
    const message = createBaseAndroidDeviceCatalog();
    message.models = object.models?.map((e) => AndroidModel.fromPartial(e)) || [];
    message.versions = object.versions?.map((e) => AndroidVersion.fromPartial(e)) || [];
    message.runtimeConfiguration = (object.runtimeConfiguration !== undefined && object.runtimeConfiguration !== null)
      ? AndroidRuntimeConfiguration.fromPartial(object.runtimeConfiguration)
      : undefined;
    return message;
  },
};

function createBaseAndroidRuntimeConfiguration(): AndroidRuntimeConfiguration {
  return { locales: [], orientations: [] };
}

export const AndroidRuntimeConfiguration: MessageFns<AndroidRuntimeConfiguration> = {
  encode(message: AndroidRuntimeConfiguration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.locales) {
      Locale.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.orientations) {
      Orientation.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AndroidRuntimeConfiguration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAndroidRuntimeConfiguration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.locales.push(Locale.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.orientations.push(Orientation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AndroidRuntimeConfiguration {
    return {
      locales: globalThis.Array.isArray(object?.locales) ? object.locales.map((e: any) => Locale.fromJSON(e)) : [],
      orientations: globalThis.Array.isArray(object?.orientations)
        ? object.orientations.map((e: any) => Orientation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AndroidRuntimeConfiguration): unknown {
    const obj: any = {};
    if (message.locales?.length) {
      obj.locales = message.locales.map((e) => Locale.toJSON(e));
    }
    if (message.orientations?.length) {
      obj.orientations = message.orientations.map((e) => Orientation.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AndroidRuntimeConfiguration>): AndroidRuntimeConfiguration {
    return AndroidRuntimeConfiguration.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AndroidRuntimeConfiguration>): AndroidRuntimeConfiguration {
    const message = createBaseAndroidRuntimeConfiguration();
    message.locales = object.locales?.map((e) => Locale.fromPartial(e)) || [];
    message.orientations = object.orientations?.map((e) => Orientation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAndroidModel(): AndroidModel {
  return {
    id: "",
    name: "",
    manufacturer: "",
    brand: "",
    codename: "",
    form: 0,
    formFactor: 0,
    perVersionInfo: [],
    screenX: 0,
    screenY: 0,
    screenDensity: 0,
    lowFpsVideoRecording: false,
    supportedVersionIds: [],
    supportedAbis: [],
    tags: [],
    thumbnailUrl: "",
  };
}

export const AndroidModel: MessageFns<AndroidModel> = {
  encode(message: AndroidModel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.manufacturer !== "") {
      writer.uint32(26).string(message.manufacturer);
    }
    if (message.brand !== "") {
      writer.uint32(74).string(message.brand);
    }
    if (message.codename !== "") {
      writer.uint32(82).string(message.codename);
    }
    if (message.form !== 0) {
      writer.uint32(32).int32(message.form);
    }
    if (message.formFactor !== 0) {
      writer.uint32(128).int32(message.formFactor);
    }
    for (const v of message.perVersionInfo) {
      PerAndroidVersionInfo.encode(v!, writer.uint32(170).fork()).join();
    }
    if (message.screenX !== 0) {
      writer.uint32(40).int32(message.screenX);
    }
    if (message.screenY !== 0) {
      writer.uint32(48).int32(message.screenY);
    }
    if (message.screenDensity !== 0) {
      writer.uint32(96).int32(message.screenDensity);
    }
    if (message.lowFpsVideoRecording !== false) {
      writer.uint32(136).bool(message.lowFpsVideoRecording);
    }
    for (const v of message.supportedVersionIds) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.supportedAbis) {
      writer.uint32(90).string(v!);
    }
    for (const v of message.tags) {
      writer.uint32(66).string(v!);
    }
    if (message.thumbnailUrl !== "") {
      writer.uint32(154).string(message.thumbnailUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AndroidModel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAndroidModel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.manufacturer = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.brand = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.codename = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.form = reader.int32() as any;
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.formFactor = reader.int32() as any;
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.perVersionInfo.push(PerAndroidVersionInfo.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.screenX = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.screenY = reader.int32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.screenDensity = reader.int32();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.lowFpsVideoRecording = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.supportedVersionIds.push(reader.string());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.supportedAbis.push(reader.string());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.thumbnailUrl = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AndroidModel {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      manufacturer: isSet(object.manufacturer) ? globalThis.String(object.manufacturer) : "",
      brand: isSet(object.brand) ? globalThis.String(object.brand) : "",
      codename: isSet(object.codename) ? globalThis.String(object.codename) : "",
      form: isSet(object.form) ? deviceFormFromJSON(object.form) : 0,
      formFactor: isSet(object.formFactor) ? deviceFormFactorFromJSON(object.formFactor) : 0,
      perVersionInfo: globalThis.Array.isArray(object?.perVersionInfo)
        ? object.perVersionInfo.map((e: any) => PerAndroidVersionInfo.fromJSON(e))
        : [],
      screenX: isSet(object.screenX) ? globalThis.Number(object.screenX) : 0,
      screenY: isSet(object.screenY) ? globalThis.Number(object.screenY) : 0,
      screenDensity: isSet(object.screenDensity) ? globalThis.Number(object.screenDensity) : 0,
      lowFpsVideoRecording: isSet(object.lowFpsVideoRecording)
        ? globalThis.Boolean(object.lowFpsVideoRecording)
        : false,
      supportedVersionIds: globalThis.Array.isArray(object?.supportedVersionIds)
        ? object.supportedVersionIds.map((e: any) => globalThis.String(e))
        : [],
      supportedAbis: globalThis.Array.isArray(object?.supportedAbis)
        ? object.supportedAbis.map((e: any) => globalThis.String(e))
        : [],
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      thumbnailUrl: isSet(object.thumbnailUrl) ? globalThis.String(object.thumbnailUrl) : "",
    };
  },

  toJSON(message: AndroidModel): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.manufacturer !== "") {
      obj.manufacturer = message.manufacturer;
    }
    if (message.brand !== "") {
      obj.brand = message.brand;
    }
    if (message.codename !== "") {
      obj.codename = message.codename;
    }
    if (message.form !== 0) {
      obj.form = deviceFormToJSON(message.form);
    }
    if (message.formFactor !== 0) {
      obj.formFactor = deviceFormFactorToJSON(message.formFactor);
    }
    if (message.perVersionInfo?.length) {
      obj.perVersionInfo = message.perVersionInfo.map((e) => PerAndroidVersionInfo.toJSON(e));
    }
    if (message.screenX !== 0) {
      obj.screenX = Math.round(message.screenX);
    }
    if (message.screenY !== 0) {
      obj.screenY = Math.round(message.screenY);
    }
    if (message.screenDensity !== 0) {
      obj.screenDensity = Math.round(message.screenDensity);
    }
    if (message.lowFpsVideoRecording !== false) {
      obj.lowFpsVideoRecording = message.lowFpsVideoRecording;
    }
    if (message.supportedVersionIds?.length) {
      obj.supportedVersionIds = message.supportedVersionIds;
    }
    if (message.supportedAbis?.length) {
      obj.supportedAbis = message.supportedAbis;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.thumbnailUrl !== "") {
      obj.thumbnailUrl = message.thumbnailUrl;
    }
    return obj;
  },

  create(base?: DeepPartial<AndroidModel>): AndroidModel {
    return AndroidModel.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AndroidModel>): AndroidModel {
    const message = createBaseAndroidModel();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.manufacturer = object.manufacturer ?? "";
    message.brand = object.brand ?? "";
    message.codename = object.codename ?? "";
    message.form = object.form ?? 0;
    message.formFactor = object.formFactor ?? 0;
    message.perVersionInfo = object.perVersionInfo?.map((e) => PerAndroidVersionInfo.fromPartial(e)) || [];
    message.screenX = object.screenX ?? 0;
    message.screenY = object.screenY ?? 0;
    message.screenDensity = object.screenDensity ?? 0;
    message.lowFpsVideoRecording = object.lowFpsVideoRecording ?? false;
    message.supportedVersionIds = object.supportedVersionIds?.map((e) => e) || [];
    message.supportedAbis = object.supportedAbis?.map((e) => e) || [];
    message.tags = object.tags?.map((e) => e) || [];
    message.thumbnailUrl = object.thumbnailUrl ?? "";
    return message;
  },
};

function createBaseAndroidVersion(): AndroidVersion {
  return {
    id: "",
    versionString: "",
    apiLevel: 0,
    codeName: "",
    releaseDate: undefined,
    distribution: undefined,
    tags: [],
  };
}

export const AndroidVersion: MessageFns<AndroidVersion> = {
  encode(message: AndroidVersion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.versionString !== "") {
      writer.uint32(18).string(message.versionString);
    }
    if (message.apiLevel !== 0) {
      writer.uint32(24).int32(message.apiLevel);
    }
    if (message.codeName !== "") {
      writer.uint32(34).string(message.codeName);
    }
    if (message.releaseDate !== undefined) {
      DateMessage.encode(message.releaseDate, writer.uint32(42).fork()).join();
    }
    if (message.distribution !== undefined) {
      Distribution.encode(message.distribution, writer.uint32(50).fork()).join();
    }
    for (const v of message.tags) {
      writer.uint32(58).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AndroidVersion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAndroidVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.versionString = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.apiLevel = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.codeName = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.releaseDate = DateMessage.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.distribution = Distribution.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.tags.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AndroidVersion {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      versionString: isSet(object.versionString) ? globalThis.String(object.versionString) : "",
      apiLevel: isSet(object.apiLevel) ? globalThis.Number(object.apiLevel) : 0,
      codeName: isSet(object.codeName) ? globalThis.String(object.codeName) : "",
      releaseDate: isSet(object.releaseDate) ? DateMessage.fromJSON(object.releaseDate) : undefined,
      distribution: isSet(object.distribution) ? Distribution.fromJSON(object.distribution) : undefined,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: AndroidVersion): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.versionString !== "") {
      obj.versionString = message.versionString;
    }
    if (message.apiLevel !== 0) {
      obj.apiLevel = Math.round(message.apiLevel);
    }
    if (message.codeName !== "") {
      obj.codeName = message.codeName;
    }
    if (message.releaseDate !== undefined) {
      obj.releaseDate = DateMessage.toJSON(message.releaseDate);
    }
    if (message.distribution !== undefined) {
      obj.distribution = Distribution.toJSON(message.distribution);
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    return obj;
  },

  create(base?: DeepPartial<AndroidVersion>): AndroidVersion {
    return AndroidVersion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AndroidVersion>): AndroidVersion {
    const message = createBaseAndroidVersion();
    message.id = object.id ?? "";
    message.versionString = object.versionString ?? "";
    message.apiLevel = object.apiLevel ?? 0;
    message.codeName = object.codeName ?? "";
    message.releaseDate = (object.releaseDate !== undefined && object.releaseDate !== null)
      ? DateMessage.fromPartial(object.releaseDate)
      : undefined;
    message.distribution = (object.distribution !== undefined && object.distribution !== null)
      ? Distribution.fromPartial(object.distribution)
      : undefined;
    message.tags = object.tags?.map((e) => e) || [];
    return message;
  },
};

function createBasePerAndroidVersionInfo(): PerAndroidVersionInfo {
  return {
    versionId: "",
    deviceCapacity: 0,
    interactiveDeviceAvailabilityEstimate: undefined,
    directAccessVersionInfo: undefined,
  };
}

export const PerAndroidVersionInfo: MessageFns<PerAndroidVersionInfo> = {
  encode(message: PerAndroidVersionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.versionId !== "") {
      writer.uint32(10).string(message.versionId);
    }
    if (message.deviceCapacity !== 0) {
      writer.uint32(16).int32(message.deviceCapacity);
    }
    if (message.interactiveDeviceAvailabilityEstimate !== undefined) {
      Duration.encode(message.interactiveDeviceAvailabilityEstimate, writer.uint32(26).fork()).join();
    }
    if (message.directAccessVersionInfo !== undefined) {
      DirectAccessVersionInfo.encode(message.directAccessVersionInfo, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PerAndroidVersionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePerAndroidVersionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.versionId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.deviceCapacity = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.interactiveDeviceAvailabilityEstimate = Duration.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.directAccessVersionInfo = DirectAccessVersionInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PerAndroidVersionInfo {
    return {
      versionId: isSet(object.versionId) ? globalThis.String(object.versionId) : "",
      deviceCapacity: isSet(object.deviceCapacity) ? deviceCapacityFromJSON(object.deviceCapacity) : 0,
      interactiveDeviceAvailabilityEstimate: isSet(object.interactiveDeviceAvailabilityEstimate)
        ? Duration.fromJSON(object.interactiveDeviceAvailabilityEstimate)
        : undefined,
      directAccessVersionInfo: isSet(object.directAccessVersionInfo)
        ? DirectAccessVersionInfo.fromJSON(object.directAccessVersionInfo)
        : undefined,
    };
  },

  toJSON(message: PerAndroidVersionInfo): unknown {
    const obj: any = {};
    if (message.versionId !== "") {
      obj.versionId = message.versionId;
    }
    if (message.deviceCapacity !== 0) {
      obj.deviceCapacity = deviceCapacityToJSON(message.deviceCapacity);
    }
    if (message.interactiveDeviceAvailabilityEstimate !== undefined) {
      obj.interactiveDeviceAvailabilityEstimate = Duration.toJSON(message.interactiveDeviceAvailabilityEstimate);
    }
    if (message.directAccessVersionInfo !== undefined) {
      obj.directAccessVersionInfo = DirectAccessVersionInfo.toJSON(message.directAccessVersionInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<PerAndroidVersionInfo>): PerAndroidVersionInfo {
    return PerAndroidVersionInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PerAndroidVersionInfo>): PerAndroidVersionInfo {
    const message = createBasePerAndroidVersionInfo();
    message.versionId = object.versionId ?? "";
    message.deviceCapacity = object.deviceCapacity ?? 0;
    message.interactiveDeviceAvailabilityEstimate =
      (object.interactiveDeviceAvailabilityEstimate !== undefined &&
          object.interactiveDeviceAvailabilityEstimate !== null)
        ? Duration.fromPartial(object.interactiveDeviceAvailabilityEstimate)
        : undefined;
    message.directAccessVersionInfo =
      (object.directAccessVersionInfo !== undefined && object.directAccessVersionInfo !== null)
        ? DirectAccessVersionInfo.fromPartial(object.directAccessVersionInfo)
        : undefined;
    return message;
  },
};

function createBaseDirectAccessVersionInfo(): DirectAccessVersionInfo {
  return { directAccessSupported: false, minimumAndroidStudioVersion: "" };
}

export const DirectAccessVersionInfo: MessageFns<DirectAccessVersionInfo> = {
  encode(message: DirectAccessVersionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.directAccessSupported !== false) {
      writer.uint32(8).bool(message.directAccessSupported);
    }
    if (message.minimumAndroidStudioVersion !== "") {
      writer.uint32(18).string(message.minimumAndroidStudioVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DirectAccessVersionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDirectAccessVersionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.directAccessSupported = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.minimumAndroidStudioVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DirectAccessVersionInfo {
    return {
      directAccessSupported: isSet(object.directAccessSupported)
        ? globalThis.Boolean(object.directAccessSupported)
        : false,
      minimumAndroidStudioVersion: isSet(object.minimumAndroidStudioVersion)
        ? globalThis.String(object.minimumAndroidStudioVersion)
        : "",
    };
  },

  toJSON(message: DirectAccessVersionInfo): unknown {
    const obj: any = {};
    if (message.directAccessSupported !== false) {
      obj.directAccessSupported = message.directAccessSupported;
    }
    if (message.minimumAndroidStudioVersion !== "") {
      obj.minimumAndroidStudioVersion = message.minimumAndroidStudioVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<DirectAccessVersionInfo>): DirectAccessVersionInfo {
    return DirectAccessVersionInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DirectAccessVersionInfo>): DirectAccessVersionInfo {
    const message = createBaseDirectAccessVersionInfo();
    message.directAccessSupported = object.directAccessSupported ?? false;
    message.minimumAndroidStudioVersion = object.minimumAndroidStudioVersion ?? "";
    return message;
  },
};

function createBaseDistribution(): Distribution {
  return { measurementTime: undefined, marketShare: 0 };
}

export const Distribution: MessageFns<Distribution> = {
  encode(message: Distribution, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.measurementTime !== undefined) {
      Timestamp.encode(toTimestamp(message.measurementTime), writer.uint32(10).fork()).join();
    }
    if (message.marketShare !== 0) {
      writer.uint32(17).double(message.marketShare);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Distribution {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDistribution();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.measurementTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.marketShare = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Distribution {
    return {
      measurementTime: isSet(object.measurementTime) ? fromJsonTimestamp(object.measurementTime) : undefined,
      marketShare: isSet(object.marketShare) ? globalThis.Number(object.marketShare) : 0,
    };
  },

  toJSON(message: Distribution): unknown {
    const obj: any = {};
    if (message.measurementTime !== undefined) {
      obj.measurementTime = message.measurementTime.toISOString();
    }
    if (message.marketShare !== 0) {
      obj.marketShare = message.marketShare;
    }
    return obj;
  },

  create(base?: DeepPartial<Distribution>): Distribution {
    return Distribution.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Distribution>): Distribution {
    const message = createBaseDistribution();
    message.measurementTime = object.measurementTime ?? undefined;
    message.marketShare = object.marketShare ?? 0;
    return message;
  },
};

function createBaseIosDeviceCatalog(): IosDeviceCatalog {
  return { models: [], versions: [], xcodeVersions: [], runtimeConfiguration: undefined };
}

export const IosDeviceCatalog: MessageFns<IosDeviceCatalog> = {
  encode(message: IosDeviceCatalog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.models) {
      IosModel.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.versions) {
      IosVersion.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.xcodeVersions) {
      XcodeVersion.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.runtimeConfiguration !== undefined) {
      IosRuntimeConfiguration.encode(message.runtimeConfiguration, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IosDeviceCatalog {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIosDeviceCatalog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.models.push(IosModel.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.versions.push(IosVersion.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.xcodeVersions.push(XcodeVersion.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.runtimeConfiguration = IosRuntimeConfiguration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IosDeviceCatalog {
    return {
      models: globalThis.Array.isArray(object?.models) ? object.models.map((e: any) => IosModel.fromJSON(e)) : [],
      versions: globalThis.Array.isArray(object?.versions)
        ? object.versions.map((e: any) => IosVersion.fromJSON(e))
        : [],
      xcodeVersions: globalThis.Array.isArray(object?.xcodeVersions)
        ? object.xcodeVersions.map((e: any) => XcodeVersion.fromJSON(e))
        : [],
      runtimeConfiguration: isSet(object.runtimeConfiguration)
        ? IosRuntimeConfiguration.fromJSON(object.runtimeConfiguration)
        : undefined,
    };
  },

  toJSON(message: IosDeviceCatalog): unknown {
    const obj: any = {};
    if (message.models?.length) {
      obj.models = message.models.map((e) => IosModel.toJSON(e));
    }
    if (message.versions?.length) {
      obj.versions = message.versions.map((e) => IosVersion.toJSON(e));
    }
    if (message.xcodeVersions?.length) {
      obj.xcodeVersions = message.xcodeVersions.map((e) => XcodeVersion.toJSON(e));
    }
    if (message.runtimeConfiguration !== undefined) {
      obj.runtimeConfiguration = IosRuntimeConfiguration.toJSON(message.runtimeConfiguration);
    }
    return obj;
  },

  create(base?: DeepPartial<IosDeviceCatalog>): IosDeviceCatalog {
    return IosDeviceCatalog.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IosDeviceCatalog>): IosDeviceCatalog {
    const message = createBaseIosDeviceCatalog();
    message.models = object.models?.map((e) => IosModel.fromPartial(e)) || [];
    message.versions = object.versions?.map((e) => IosVersion.fromPartial(e)) || [];
    message.xcodeVersions = object.xcodeVersions?.map((e) => XcodeVersion.fromPartial(e)) || [];
    message.runtimeConfiguration = (object.runtimeConfiguration !== undefined && object.runtimeConfiguration !== null)
      ? IosRuntimeConfiguration.fromPartial(object.runtimeConfiguration)
      : undefined;
    return message;
  },
};

function createBaseIosRuntimeConfiguration(): IosRuntimeConfiguration {
  return { locales: [], orientations: [] };
}

export const IosRuntimeConfiguration: MessageFns<IosRuntimeConfiguration> = {
  encode(message: IosRuntimeConfiguration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.locales) {
      Locale.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.orientations) {
      Orientation.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IosRuntimeConfiguration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIosRuntimeConfiguration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.locales.push(Locale.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.orientations.push(Orientation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IosRuntimeConfiguration {
    return {
      locales: globalThis.Array.isArray(object?.locales) ? object.locales.map((e: any) => Locale.fromJSON(e)) : [],
      orientations: globalThis.Array.isArray(object?.orientations)
        ? object.orientations.map((e: any) => Orientation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: IosRuntimeConfiguration): unknown {
    const obj: any = {};
    if (message.locales?.length) {
      obj.locales = message.locales.map((e) => Locale.toJSON(e));
    }
    if (message.orientations?.length) {
      obj.orientations = message.orientations.map((e) => Orientation.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<IosRuntimeConfiguration>): IosRuntimeConfiguration {
    return IosRuntimeConfiguration.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IosRuntimeConfiguration>): IosRuntimeConfiguration {
    const message = createBaseIosRuntimeConfiguration();
    message.locales = object.locales?.map((e) => Locale.fromPartial(e)) || [];
    message.orientations = object.orientations?.map((e) => Orientation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseIosModel(): IosModel {
  return {
    id: "",
    name: "",
    supportedVersionIds: [],
    tags: [],
    deviceCapabilities: [],
    screenX: 0,
    screenY: 0,
    screenDensity: 0,
    formFactor: 0,
    perVersionInfo: [],
  };
}

export const IosModel: MessageFns<IosModel> = {
  encode(message: IosModel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    for (const v of message.supportedVersionIds) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.tags) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.deviceCapabilities) {
      writer.uint32(42).string(v!);
    }
    if (message.screenX !== 0) {
      writer.uint32(56).int32(message.screenX);
    }
    if (message.screenY !== 0) {
      writer.uint32(64).int32(message.screenY);
    }
    if (message.screenDensity !== 0) {
      writer.uint32(72).int32(message.screenDensity);
    }
    if (message.formFactor !== 0) {
      writer.uint32(48).int32(message.formFactor);
    }
    for (const v of message.perVersionInfo) {
      PerIosVersionInfo.encode(v!, writer.uint32(114).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IosModel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIosModel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.supportedVersionIds.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.deviceCapabilities.push(reader.string());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.screenX = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.screenY = reader.int32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.screenDensity = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.formFactor = reader.int32() as any;
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.perVersionInfo.push(PerIosVersionInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IosModel {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      supportedVersionIds: globalThis.Array.isArray(object?.supportedVersionIds)
        ? object.supportedVersionIds.map((e: any) => globalThis.String(e))
        : [],
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      deviceCapabilities: globalThis.Array.isArray(object?.deviceCapabilities)
        ? object.deviceCapabilities.map((e: any) => globalThis.String(e))
        : [],
      screenX: isSet(object.screenX) ? globalThis.Number(object.screenX) : 0,
      screenY: isSet(object.screenY) ? globalThis.Number(object.screenY) : 0,
      screenDensity: isSet(object.screenDensity) ? globalThis.Number(object.screenDensity) : 0,
      formFactor: isSet(object.formFactor) ? deviceFormFactorFromJSON(object.formFactor) : 0,
      perVersionInfo: globalThis.Array.isArray(object?.perVersionInfo)
        ? object.perVersionInfo.map((e: any) => PerIosVersionInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: IosModel): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.supportedVersionIds?.length) {
      obj.supportedVersionIds = message.supportedVersionIds;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.deviceCapabilities?.length) {
      obj.deviceCapabilities = message.deviceCapabilities;
    }
    if (message.screenX !== 0) {
      obj.screenX = Math.round(message.screenX);
    }
    if (message.screenY !== 0) {
      obj.screenY = Math.round(message.screenY);
    }
    if (message.screenDensity !== 0) {
      obj.screenDensity = Math.round(message.screenDensity);
    }
    if (message.formFactor !== 0) {
      obj.formFactor = deviceFormFactorToJSON(message.formFactor);
    }
    if (message.perVersionInfo?.length) {
      obj.perVersionInfo = message.perVersionInfo.map((e) => PerIosVersionInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<IosModel>): IosModel {
    return IosModel.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IosModel>): IosModel {
    const message = createBaseIosModel();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.supportedVersionIds = object.supportedVersionIds?.map((e) => e) || [];
    message.tags = object.tags?.map((e) => e) || [];
    message.deviceCapabilities = object.deviceCapabilities?.map((e) => e) || [];
    message.screenX = object.screenX ?? 0;
    message.screenY = object.screenY ?? 0;
    message.screenDensity = object.screenDensity ?? 0;
    message.formFactor = object.formFactor ?? 0;
    message.perVersionInfo = object.perVersionInfo?.map((e) => PerIosVersionInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseIosVersion(): IosVersion {
  return { id: "", majorVersion: 0, minorVersion: 0, tags: [], supportedXcodeVersionIds: [] };
}

export const IosVersion: MessageFns<IosVersion> = {
  encode(message: IosVersion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.majorVersion !== 0) {
      writer.uint32(16).int32(message.majorVersion);
    }
    if (message.minorVersion !== 0) {
      writer.uint32(32).int32(message.minorVersion);
    }
    for (const v of message.tags) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.supportedXcodeVersionIds) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IosVersion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIosVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.majorVersion = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.minorVersion = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.supportedXcodeVersionIds.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IosVersion {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      majorVersion: isSet(object.majorVersion) ? globalThis.Number(object.majorVersion) : 0,
      minorVersion: isSet(object.minorVersion) ? globalThis.Number(object.minorVersion) : 0,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      supportedXcodeVersionIds: globalThis.Array.isArray(object?.supportedXcodeVersionIds)
        ? object.supportedXcodeVersionIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: IosVersion): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.majorVersion !== 0) {
      obj.majorVersion = Math.round(message.majorVersion);
    }
    if (message.minorVersion !== 0) {
      obj.minorVersion = Math.round(message.minorVersion);
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.supportedXcodeVersionIds?.length) {
      obj.supportedXcodeVersionIds = message.supportedXcodeVersionIds;
    }
    return obj;
  },

  create(base?: DeepPartial<IosVersion>): IosVersion {
    return IosVersion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IosVersion>): IosVersion {
    const message = createBaseIosVersion();
    message.id = object.id ?? "";
    message.majorVersion = object.majorVersion ?? 0;
    message.minorVersion = object.minorVersion ?? 0;
    message.tags = object.tags?.map((e) => e) || [];
    message.supportedXcodeVersionIds = object.supportedXcodeVersionIds?.map((e) => e) || [];
    return message;
  },
};

function createBasePerIosVersionInfo(): PerIosVersionInfo {
  return { versionId: "", deviceCapacity: 0 };
}

export const PerIosVersionInfo: MessageFns<PerIosVersionInfo> = {
  encode(message: PerIosVersionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.versionId !== "") {
      writer.uint32(10).string(message.versionId);
    }
    if (message.deviceCapacity !== 0) {
      writer.uint32(16).int32(message.deviceCapacity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PerIosVersionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePerIosVersionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.versionId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.deviceCapacity = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PerIosVersionInfo {
    return {
      versionId: isSet(object.versionId) ? globalThis.String(object.versionId) : "",
      deviceCapacity: isSet(object.deviceCapacity) ? deviceCapacityFromJSON(object.deviceCapacity) : 0,
    };
  },

  toJSON(message: PerIosVersionInfo): unknown {
    const obj: any = {};
    if (message.versionId !== "") {
      obj.versionId = message.versionId;
    }
    if (message.deviceCapacity !== 0) {
      obj.deviceCapacity = deviceCapacityToJSON(message.deviceCapacity);
    }
    return obj;
  },

  create(base?: DeepPartial<PerIosVersionInfo>): PerIosVersionInfo {
    return PerIosVersionInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PerIosVersionInfo>): PerIosVersionInfo {
    const message = createBasePerIosVersionInfo();
    message.versionId = object.versionId ?? "";
    message.deviceCapacity = object.deviceCapacity ?? 0;
    return message;
  },
};

function createBaseLocale(): Locale {
  return { id: "", name: "", region: "", tags: [] };
}

export const Locale: MessageFns<Locale> = {
  encode(message: Locale, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.region !== "") {
      writer.uint32(26).string(message.region);
    }
    for (const v of message.tags) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Locale {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocale();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.region = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.tags.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Locale {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      region: isSet(object.region) ? globalThis.String(object.region) : "",
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: Locale): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.region !== "") {
      obj.region = message.region;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    return obj;
  },

  create(base?: DeepPartial<Locale>): Locale {
    return Locale.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Locale>): Locale {
    const message = createBaseLocale();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.region = object.region ?? "";
    message.tags = object.tags?.map((e) => e) || [];
    return message;
  },
};

function createBaseOrientation(): Orientation {
  return { id: "", name: "", tags: [] };
}

export const Orientation: MessageFns<Orientation> = {
  encode(message: Orientation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    for (const v of message.tags) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Orientation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrientation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tags.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Orientation {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: Orientation): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    return obj;
  },

  create(base?: DeepPartial<Orientation>): Orientation {
    return Orientation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Orientation>): Orientation {
    const message = createBaseOrientation();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.tags = object.tags?.map((e) => e) || [];
    return message;
  },
};

function createBaseXcodeVersion(): XcodeVersion {
  return { version: "", tags: [] };
}

export const XcodeVersion: MessageFns<XcodeVersion> = {
  encode(message: XcodeVersion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    for (const v of message.tags) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): XcodeVersion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXcodeVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tags.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XcodeVersion {
    return {
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: XcodeVersion): unknown {
    const obj: any = {};
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    return obj;
  },

  create(base?: DeepPartial<XcodeVersion>): XcodeVersion {
    return XcodeVersion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XcodeVersion>): XcodeVersion {
    const message = createBaseXcodeVersion();
    message.version = object.version ?? "";
    message.tags = object.tags?.map((e) => e) || [];
    return message;
  },
};

function createBaseNetworkConfigurationCatalog(): NetworkConfigurationCatalog {
  return { configurations: [] };
}

export const NetworkConfigurationCatalog: MessageFns<NetworkConfigurationCatalog> = {
  encode(message: NetworkConfigurationCatalog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.configurations) {
      NetworkConfiguration.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkConfigurationCatalog {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkConfigurationCatalog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.configurations.push(NetworkConfiguration.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkConfigurationCatalog {
    return {
      configurations: globalThis.Array.isArray(object?.configurations)
        ? object.configurations.map((e: any) => NetworkConfiguration.fromJSON(e))
        : [],
    };
  },

  toJSON(message: NetworkConfigurationCatalog): unknown {
    const obj: any = {};
    if (message.configurations?.length) {
      obj.configurations = message.configurations.map((e) => NetworkConfiguration.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<NetworkConfigurationCatalog>): NetworkConfigurationCatalog {
    return NetworkConfigurationCatalog.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NetworkConfigurationCatalog>): NetworkConfigurationCatalog {
    const message = createBaseNetworkConfigurationCatalog();
    message.configurations = object.configurations?.map((e) => NetworkConfiguration.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNetworkConfiguration(): NetworkConfiguration {
  return { id: "", upRule: undefined, downRule: undefined };
}

export const NetworkConfiguration: MessageFns<NetworkConfiguration> = {
  encode(message: NetworkConfiguration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.upRule !== undefined) {
      TrafficRule.encode(message.upRule, writer.uint32(18).fork()).join();
    }
    if (message.downRule !== undefined) {
      TrafficRule.encode(message.downRule, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkConfiguration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkConfiguration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.upRule = TrafficRule.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.downRule = TrafficRule.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkConfiguration {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      upRule: isSet(object.upRule) ? TrafficRule.fromJSON(object.upRule) : undefined,
      downRule: isSet(object.downRule) ? TrafficRule.fromJSON(object.downRule) : undefined,
    };
  },

  toJSON(message: NetworkConfiguration): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.upRule !== undefined) {
      obj.upRule = TrafficRule.toJSON(message.upRule);
    }
    if (message.downRule !== undefined) {
      obj.downRule = TrafficRule.toJSON(message.downRule);
    }
    return obj;
  },

  create(base?: DeepPartial<NetworkConfiguration>): NetworkConfiguration {
    return NetworkConfiguration.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NetworkConfiguration>): NetworkConfiguration {
    const message = createBaseNetworkConfiguration();
    message.id = object.id ?? "";
    message.upRule = (object.upRule !== undefined && object.upRule !== null)
      ? TrafficRule.fromPartial(object.upRule)
      : undefined;
    message.downRule = (object.downRule !== undefined && object.downRule !== null)
      ? TrafficRule.fromPartial(object.downRule)
      : undefined;
    return message;
  },
};

function createBaseTrafficRule(): TrafficRule {
  return { delay: undefined, packetLossRatio: 0, packetDuplicationRatio: 0, bandwidth: 0, burst: 0 };
}

export const TrafficRule: MessageFns<TrafficRule> = {
  encode(message: TrafficRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.delay !== undefined) {
      Duration.encode(message.delay, writer.uint32(10).fork()).join();
    }
    if (message.packetLossRatio !== 0) {
      writer.uint32(21).float(message.packetLossRatio);
    }
    if (message.packetDuplicationRatio !== 0) {
      writer.uint32(29).float(message.packetDuplicationRatio);
    }
    if (message.bandwidth !== 0) {
      writer.uint32(37).float(message.bandwidth);
    }
    if (message.burst !== 0) {
      writer.uint32(45).float(message.burst);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrafficRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrafficRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.delay = Duration.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.packetLossRatio = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.packetDuplicationRatio = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.bandwidth = reader.float();
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.burst = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrafficRule {
    return {
      delay: isSet(object.delay) ? Duration.fromJSON(object.delay) : undefined,
      packetLossRatio: isSet(object.packetLossRatio) ? globalThis.Number(object.packetLossRatio) : 0,
      packetDuplicationRatio: isSet(object.packetDuplicationRatio)
        ? globalThis.Number(object.packetDuplicationRatio)
        : 0,
      bandwidth: isSet(object.bandwidth) ? globalThis.Number(object.bandwidth) : 0,
      burst: isSet(object.burst) ? globalThis.Number(object.burst) : 0,
    };
  },

  toJSON(message: TrafficRule): unknown {
    const obj: any = {};
    if (message.delay !== undefined) {
      obj.delay = Duration.toJSON(message.delay);
    }
    if (message.packetLossRatio !== 0) {
      obj.packetLossRatio = message.packetLossRatio;
    }
    if (message.packetDuplicationRatio !== 0) {
      obj.packetDuplicationRatio = message.packetDuplicationRatio;
    }
    if (message.bandwidth !== 0) {
      obj.bandwidth = message.bandwidth;
    }
    if (message.burst !== 0) {
      obj.burst = message.burst;
    }
    return obj;
  },

  create(base?: DeepPartial<TrafficRule>): TrafficRule {
    return TrafficRule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TrafficRule>): TrafficRule {
    const message = createBaseTrafficRule();
    message.delay = (object.delay !== undefined && object.delay !== null)
      ? Duration.fromPartial(object.delay)
      : undefined;
    message.packetLossRatio = object.packetLossRatio ?? 0;
    message.packetDuplicationRatio = object.packetDuplicationRatio ?? 0;
    message.bandwidth = object.bandwidth ?? 0;
    message.burst = object.burst ?? 0;
    return message;
  },
};

function createBaseProvidedSoftwareCatalog(): ProvidedSoftwareCatalog {
  return { orchestratorVersion: "", androidxOrchestratorVersion: "" };
}

export const ProvidedSoftwareCatalog: MessageFns<ProvidedSoftwareCatalog> = {
  encode(message: ProvidedSoftwareCatalog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orchestratorVersion !== "") {
      writer.uint32(10).string(message.orchestratorVersion);
    }
    if (message.androidxOrchestratorVersion !== "") {
      writer.uint32(18).string(message.androidxOrchestratorVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProvidedSoftwareCatalog {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProvidedSoftwareCatalog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.orchestratorVersion = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.androidxOrchestratorVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProvidedSoftwareCatalog {
    return {
      orchestratorVersion: isSet(object.orchestratorVersion) ? globalThis.String(object.orchestratorVersion) : "",
      androidxOrchestratorVersion: isSet(object.androidxOrchestratorVersion)
        ? globalThis.String(object.androidxOrchestratorVersion)
        : "",
    };
  },

  toJSON(message: ProvidedSoftwareCatalog): unknown {
    const obj: any = {};
    if (message.orchestratorVersion !== "") {
      obj.orchestratorVersion = message.orchestratorVersion;
    }
    if (message.androidxOrchestratorVersion !== "") {
      obj.androidxOrchestratorVersion = message.androidxOrchestratorVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<ProvidedSoftwareCatalog>): ProvidedSoftwareCatalog {
    return ProvidedSoftwareCatalog.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProvidedSoftwareCatalog>): ProvidedSoftwareCatalog {
    const message = createBaseProvidedSoftwareCatalog();
    message.orchestratorVersion = object.orchestratorVersion ?? "";
    message.androidxOrchestratorVersion = object.androidxOrchestratorVersion ?? "";
    return message;
  },
};

/**
 * Service for discovering environments supported by the TestExecutionService.
 *
 * Over time the TestService may add or remove devices or configuration options
 * (e.g., when new devices and APIs are released).  Clients should check here
 * periodically to discover what options are supported.
 *
 * It defines the following resource model:
 *
 * - The API a collection of [TestEnvironmentCatalog]
 *   [google.devtools.test.v1.TestEnvironmentCatalog] resources, named
 *   `testEnvironmentCatalog/*`
 *
 * - Each TestEnvironmentCatalog resource describes a set of supported
 *   environments.
 *
 * - An [AndroidDeviceCatalog][google.devtools.test.v1.AndroidDeviceCatalog]
 *   describes supported Android devices. It contains lists of supported
 *   [AndroidModels][google.devtools.test.v1.AndroidModel] and
 *   [AndroidVersions][google.devtools.test.v1.AndroidVersion] along with a
 *   [AndroidRuntimeConfiguration][google.devtools.test.v1.AndroidRuntimeConfiguration].
 *   Each AndroidModel contains a list of Versions it supports. All
 *   models support all locales and orientations described by the
 *   AndroidRuntimeConfiguration
 *
 * - An [IosDeviceCatalog][google.devtools.test.v1.IosDeviceCatalog]
 *   describes supported iOS devices. It contains lists of supported
 *   [IosModels][google.devtools.test.v1.IosModel] and
 *   [IosVersions][google.devtools.test.v1.IosVersion] along with a
 *   [IosRuntimeConfiguration][google.devtools.test.v1.IosRuntimeConfiguration].
 *   Each IosModel contains a list of Versions it supports. All
 *   models support all locales and orientations described by the
 *   IosRuntimeConfiguration.
 */
export type TestEnvironmentDiscoveryServiceDefinition = typeof TestEnvironmentDiscoveryServiceDefinition;
export const TestEnvironmentDiscoveryServiceDefinition = {
  name: "TestEnvironmentDiscoveryService",
  fullName: "google.devtools.testing.v1.TestEnvironmentDiscoveryService",
  methods: {
    /**
     * Gets the catalog of supported test environments.
     *
     * May return any of the following canonical error codes:
     *
     * - INVALID_ARGUMENT - if the request is malformed
     * - NOT_FOUND - if the environment type does not exist
     * - INTERNAL - if an internal error occurred
     */
    getTestEnvironmentCatalog: {
      name: "GetTestEnvironmentCatalog",
      requestType: GetTestEnvironmentCatalogRequest,
      requestStream: false,
      responseType: TestEnvironmentCatalog,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              47,
              18,
              45,
              47,
              118,
              49,
              47,
              116,
              101,
              115,
              116,
              69,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              67,
              97,
              116,
              97,
              108,
              111,
              103,
              47,
              123,
              101,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              95,
              116,
              121,
              112,
              101,
              125,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface TestEnvironmentDiscoveryServiceImplementation<CallContextExt = {}> {
  /**
   * Gets the catalog of supported test environments.
   *
   * May return any of the following canonical error codes:
   *
   * - INVALID_ARGUMENT - if the request is malformed
   * - NOT_FOUND - if the environment type does not exist
   * - INTERNAL - if an internal error occurred
   */
  getTestEnvironmentCatalog(
    request: GetTestEnvironmentCatalogRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<TestEnvironmentCatalog>>;
}

export interface TestEnvironmentDiscoveryServiceClient<CallOptionsExt = {}> {
  /**
   * Gets the catalog of supported test environments.
   *
   * May return any of the following canonical error codes:
   *
   * - INVALID_ARGUMENT - if the request is malformed
   * - NOT_FOUND - if the environment type does not exist
   * - INTERNAL - if an internal error occurred
   */
  getTestEnvironmentCatalog(
    request: DeepPartial<GetTestEnvironmentCatalogRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<TestEnvironmentCatalog>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
