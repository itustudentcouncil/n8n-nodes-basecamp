// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/devtools/resultstore/v2/test_suite.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Property, Timing } from "./common.js";
import { File } from "./file.js";

export const protobufPackage = "google.devtools.resultstore.v2";

/**
 * The result of running a test suite, as reported in a <testsuite> element of
 * an XML log.
 */
export interface TestSuite {
  /**
   * The full name of this suite, as reported in the name attribute. For Java
   * tests, this is normally the fully qualified class name. Eg.
   * "com.google.common.hash.BloomFilterTest".
   */
  suiteName: string;
  /**
   * The results of the test cases and test suites contained in this suite,
   * as reported in the <testcase> and <testsuite> elements contained within
   * this <testsuite>.
   */
  tests: Test[];
  /** Failures reported in <failure> elements within this <testsuite>. */
  failures: TestFailure[];
  /** Errors reported in <error> elements within this <testsuite>. */
  errors: TestError[];
  /** The timing for the entire TestSuite, as reported by the time attribute. */
  timing:
    | Timing
    | undefined;
  /**
   * Arbitrary name-value pairs, as reported in custom attributes or in a
   * <properties> element within this <testsuite>. Multiple properties are
   * allowed with the same key. Properties will be returned in lexicographical
   * order by key.
   */
  properties: Property[];
  /**
   * Files produced by this test suite, as reported by undeclared output
   * annotations.
   * The file IDs must be unique within this list. Duplicate file IDs will
   * result in an error. Files will be returned in lexicographical order by ID.
   */
  files: File[];
}

/**
 * The result of running a test case or test suite. JUnit3 TestDecorators are
 * represented as a TestSuite with a single test.
 */
export interface Test {
  /** When this contains just a single TestCase */
  testCase?:
    | TestCase
    | undefined;
  /** When this contains a TestSuite of test cases. */
  testSuite?: TestSuite | undefined;
}

/**
 * The result of running a test case, as reported in a <testcase> element of
 * an XML log.
 */
export interface TestCase {
  /**
   * The name of the test case, as reported in the name attribute. For Java,
   * this is normally the method name. Eg. "testBasic".
   */
  caseName: string;
  /**
   * The name of the class in which the test case was defined, as reported in
   * the classname attribute. For Java, this is normally the fully qualified
   * class name. Eg. "com.google.common.hash.BloomFilterTest".
   */
  className: string;
  /**
   * An enum reported in the result attribute that is used in conjunction with
   * failures and errors below to report the outcome.
   */
  result: TestCase_Result;
  /** Failures reported in <failure> elements within this <testcase>. */
  failures: TestFailure[];
  /** Errors reported in <error> elements within this <testcase>. */
  errors: TestError[];
  /** The timing for the TestCase, as reported by the time attribute. */
  timing:
    | Timing
    | undefined;
  /**
   * Arbitrary name-value pairs, as reported in custom attributes or in a
   * <properties> element within this <testcase>. Multiple properties are
   * allowed with the same key. Properties will be returned in lexicographical
   * order by key.
   */
  properties: Property[];
  /**
   * Files produced by this test case, as reported by undeclared output
   * annotations.
   * The file IDs must be unique within this list. Duplicate file IDs will
   * result in an error. Files will be returned in lexicographical order by ID.
   */
  files: File[];
  /**
   * The 0-indexed retry number of the test case. A value of `0` may indicate
   * either that this is the first in a series of retries, or that no retries
   * were requested.
   */
  retryNumber: number;
  /**
   * The 0-indexed repeat number of the test case. A value of `0` may indicate
   * either that this is the first in a series of repeats, or that no repeats
   * were requested.
   */
  repeatNumber: number;
}

/** The result of running a test case. */
export enum TestCase_Result {
  /** RESULT_UNSPECIFIED - The implicit default enum value. Do not use. */
  RESULT_UNSPECIFIED = 0,
  /**
   * COMPLETED - Test case ran to completion. Look for failures or errors to determine
   * whether it passed, failed, or errored.
   */
  COMPLETED = 1,
  /**
   * INTERRUPTED - Test case started but did not complete because the test harness received
   * a signal and decided to stop running tests.
   */
  INTERRUPTED = 2,
  /**
   * CANCELLED - Test case was not started because the test harness received a SIGINT or
   * timed out.
   */
  CANCELLED = 3,
  /**
   * FILTERED - Test case was not run because the user or process running the test
   * specified a filter that excluded this test case.
   */
  FILTERED = 4,
  /**
   * SKIPPED - Test case was not run to completion because the test case decided it
   * should not be run (eg. due to a failed assumption in a JUnit4 test).
   * Per-test setup or tear-down may or may not have run.
   */
  SKIPPED = 5,
  /**
   * SUPPRESSED - The test framework did not run the test case because it was labeled as
   * suppressed.  Eg. if someone temporarily disables a failing test.
   */
  SUPPRESSED = 6,
  UNRECOGNIZED = -1,
}

export function testCase_ResultFromJSON(object: any): TestCase_Result {
  switch (object) {
    case 0:
    case "RESULT_UNSPECIFIED":
      return TestCase_Result.RESULT_UNSPECIFIED;
    case 1:
    case "COMPLETED":
      return TestCase_Result.COMPLETED;
    case 2:
    case "INTERRUPTED":
      return TestCase_Result.INTERRUPTED;
    case 3:
    case "CANCELLED":
      return TestCase_Result.CANCELLED;
    case 4:
    case "FILTERED":
      return TestCase_Result.FILTERED;
    case 5:
    case "SKIPPED":
      return TestCase_Result.SKIPPED;
    case 6:
    case "SUPPRESSED":
      return TestCase_Result.SUPPRESSED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TestCase_Result.UNRECOGNIZED;
  }
}

export function testCase_ResultToJSON(object: TestCase_Result): string {
  switch (object) {
    case TestCase_Result.RESULT_UNSPECIFIED:
      return "RESULT_UNSPECIFIED";
    case TestCase_Result.COMPLETED:
      return "COMPLETED";
    case TestCase_Result.INTERRUPTED:
      return "INTERRUPTED";
    case TestCase_Result.CANCELLED:
      return "CANCELLED";
    case TestCase_Result.FILTERED:
      return "FILTERED";
    case TestCase_Result.SKIPPED:
      return "SKIPPED";
    case TestCase_Result.SUPPRESSED:
      return "SUPPRESSED";
    case TestCase_Result.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Represents a violated assertion, as reported in a <failure> element within a
 * <testcase>. Some languages allow assertions to be made without stopping the
 * test case when they're violated, leading to multiple TestFailures. For Java,
 * multiple TestFailures are used to represent a chained exception.
 */
export interface TestFailure {
  /**
   * The exception message reported in the message attribute. Typically short,
   * but may be multi-line. Eg. "Expected 'foo' but was 'bar'".
   */
  failureMessage: string;
  /**
   * The type of the exception being thrown, reported in the type attribute.
   * Eg: "org.junit.ComparisonFailure"
   */
  exceptionType: string;
  /**
   * The stack trace reported as the content of the <failure> element, often in
   * a CDATA block. This contains one line for each stack frame, each including
   * a method/function name, a class/file name, and a line number. Most recent
   * call is usually first, but not for Python stack traces. May contain the
   * exception_type and message.
   */
  stackTrace: string;
  /**
   * The expected values.
   *
   * These values can be diffed against the actual values. Often, there is just
   * one actual and one expected value. If there is more than one, they should
   * be compared as an unordered collection.
   */
  expected: string[];
  /**
   * The actual values.
   *
   * These values can be diffed against the expected values. Often, there is
   * just one actual and one expected value. If there is more than one, they
   * should be compared as an unordered collection.
   */
  actual: string[];
}

/**
 * Represents an exception that prevented a test case from completing, as
 * reported in an <error> element within a <testcase>. For Java, multiple
 * TestErrors are used to represent a chained exception.
 */
export interface TestError {
  /**
   * The exception message, as reported in the message attribute. Typically
   * short, but may be multi-line. Eg. "argument cannot be null".
   */
  errorMessage: string;
  /**
   * The type of the exception being thrown, reported in the type attribute.
   * For Java, this is a fully qualified Throwable class name.
   * Eg: "java.lang.IllegalArgumentException"
   */
  exceptionType: string;
  /**
   * The stack trace reported as the content of the <error> element, often in
   * a CDATA block. This contains one line for each stack frame, each including
   * a method/function name, a class/file name, and a line number. Most recent
   * call is usually first, but not for Python stack traces. May contain the
   * exception_type and message.
   */
  stackTrace: string;
}

function createBaseTestSuite(): TestSuite {
  return { suiteName: "", tests: [], failures: [], errors: [], timing: undefined, properties: [], files: [] };
}

export const TestSuite: MessageFns<TestSuite> = {
  encode(message: TestSuite, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.suiteName !== "") {
      writer.uint32(10).string(message.suiteName);
    }
    for (const v of message.tests) {
      Test.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.failures) {
      TestFailure.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.errors) {
      TestError.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.timing !== undefined) {
      Timing.encode(message.timing, writer.uint32(50).fork()).join();
    }
    for (const v of message.properties) {
      Property.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.files) {
      File.encode(v!, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestSuite {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestSuite();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.suiteName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tests.push(Test.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.failures.push(TestFailure.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.errors.push(TestError.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.timing = Timing.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.properties.push(Property.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.files.push(File.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestSuite {
    return {
      suiteName: isSet(object.suiteName) ? globalThis.String(object.suiteName) : "",
      tests: globalThis.Array.isArray(object?.tests) ? object.tests.map((e: any) => Test.fromJSON(e)) : [],
      failures: globalThis.Array.isArray(object?.failures)
        ? object.failures.map((e: any) => TestFailure.fromJSON(e))
        : [],
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e: any) => TestError.fromJSON(e)) : [],
      timing: isSet(object.timing) ? Timing.fromJSON(object.timing) : undefined,
      properties: globalThis.Array.isArray(object?.properties)
        ? object.properties.map((e: any) => Property.fromJSON(e))
        : [],
      files: globalThis.Array.isArray(object?.files) ? object.files.map((e: any) => File.fromJSON(e)) : [],
    };
  },

  toJSON(message: TestSuite): unknown {
    const obj: any = {};
    if (message.suiteName !== "") {
      obj.suiteName = message.suiteName;
    }
    if (message.tests?.length) {
      obj.tests = message.tests.map((e) => Test.toJSON(e));
    }
    if (message.failures?.length) {
      obj.failures = message.failures.map((e) => TestFailure.toJSON(e));
    }
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => TestError.toJSON(e));
    }
    if (message.timing !== undefined) {
      obj.timing = Timing.toJSON(message.timing);
    }
    if (message.properties?.length) {
      obj.properties = message.properties.map((e) => Property.toJSON(e));
    }
    if (message.files?.length) {
      obj.files = message.files.map((e) => File.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TestSuite>): TestSuite {
    return TestSuite.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TestSuite>): TestSuite {
    const message = createBaseTestSuite();
    message.suiteName = object.suiteName ?? "";
    message.tests = object.tests?.map((e) => Test.fromPartial(e)) || [];
    message.failures = object.failures?.map((e) => TestFailure.fromPartial(e)) || [];
    message.errors = object.errors?.map((e) => TestError.fromPartial(e)) || [];
    message.timing = (object.timing !== undefined && object.timing !== null)
      ? Timing.fromPartial(object.timing)
      : undefined;
    message.properties = object.properties?.map((e) => Property.fromPartial(e)) || [];
    message.files = object.files?.map((e) => File.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTest(): Test {
  return { testCase: undefined, testSuite: undefined };
}

export const Test: MessageFns<Test> = {
  encode(message: Test, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.testCase !== undefined) {
      TestCase.encode(message.testCase, writer.uint32(10).fork()).join();
    }
    if (message.testSuite !== undefined) {
      TestSuite.encode(message.testSuite, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Test {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.testCase = TestCase.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.testSuite = TestSuite.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Test {
    return {
      testCase: isSet(object.testCase) ? TestCase.fromJSON(object.testCase) : undefined,
      testSuite: isSet(object.testSuite) ? TestSuite.fromJSON(object.testSuite) : undefined,
    };
  },

  toJSON(message: Test): unknown {
    const obj: any = {};
    if (message.testCase !== undefined) {
      obj.testCase = TestCase.toJSON(message.testCase);
    }
    if (message.testSuite !== undefined) {
      obj.testSuite = TestSuite.toJSON(message.testSuite);
    }
    return obj;
  },

  create(base?: DeepPartial<Test>): Test {
    return Test.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Test>): Test {
    const message = createBaseTest();
    message.testCase = (object.testCase !== undefined && object.testCase !== null)
      ? TestCase.fromPartial(object.testCase)
      : undefined;
    message.testSuite = (object.testSuite !== undefined && object.testSuite !== null)
      ? TestSuite.fromPartial(object.testSuite)
      : undefined;
    return message;
  },
};

function createBaseTestCase(): TestCase {
  return {
    caseName: "",
    className: "",
    result: 0,
    failures: [],
    errors: [],
    timing: undefined,
    properties: [],
    files: [],
    retryNumber: 0,
    repeatNumber: 0,
  };
}

export const TestCase: MessageFns<TestCase> = {
  encode(message: TestCase, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.caseName !== "") {
      writer.uint32(10).string(message.caseName);
    }
    if (message.className !== "") {
      writer.uint32(18).string(message.className);
    }
    if (message.result !== 0) {
      writer.uint32(24).int32(message.result);
    }
    for (const v of message.failures) {
      TestFailure.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.errors) {
      TestError.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.timing !== undefined) {
      Timing.encode(message.timing, writer.uint32(58).fork()).join();
    }
    for (const v of message.properties) {
      Property.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.files) {
      File.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.retryNumber !== 0) {
      writer.uint32(80).int32(message.retryNumber);
    }
    if (message.repeatNumber !== 0) {
      writer.uint32(88).int32(message.repeatNumber);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestCase {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestCase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.caseName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.className = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.failures.push(TestFailure.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.errors.push(TestError.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.timing = Timing.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.properties.push(Property.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.files.push(File.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.retryNumber = reader.int32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.repeatNumber = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestCase {
    return {
      caseName: isSet(object.caseName) ? globalThis.String(object.caseName) : "",
      className: isSet(object.className) ? globalThis.String(object.className) : "",
      result: isSet(object.result) ? testCase_ResultFromJSON(object.result) : 0,
      failures: globalThis.Array.isArray(object?.failures)
        ? object.failures.map((e: any) => TestFailure.fromJSON(e))
        : [],
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e: any) => TestError.fromJSON(e)) : [],
      timing: isSet(object.timing) ? Timing.fromJSON(object.timing) : undefined,
      properties: globalThis.Array.isArray(object?.properties)
        ? object.properties.map((e: any) => Property.fromJSON(e))
        : [],
      files: globalThis.Array.isArray(object?.files) ? object.files.map((e: any) => File.fromJSON(e)) : [],
      retryNumber: isSet(object.retryNumber) ? globalThis.Number(object.retryNumber) : 0,
      repeatNumber: isSet(object.repeatNumber) ? globalThis.Number(object.repeatNumber) : 0,
    };
  },

  toJSON(message: TestCase): unknown {
    const obj: any = {};
    if (message.caseName !== "") {
      obj.caseName = message.caseName;
    }
    if (message.className !== "") {
      obj.className = message.className;
    }
    if (message.result !== 0) {
      obj.result = testCase_ResultToJSON(message.result);
    }
    if (message.failures?.length) {
      obj.failures = message.failures.map((e) => TestFailure.toJSON(e));
    }
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => TestError.toJSON(e));
    }
    if (message.timing !== undefined) {
      obj.timing = Timing.toJSON(message.timing);
    }
    if (message.properties?.length) {
      obj.properties = message.properties.map((e) => Property.toJSON(e));
    }
    if (message.files?.length) {
      obj.files = message.files.map((e) => File.toJSON(e));
    }
    if (message.retryNumber !== 0) {
      obj.retryNumber = Math.round(message.retryNumber);
    }
    if (message.repeatNumber !== 0) {
      obj.repeatNumber = Math.round(message.repeatNumber);
    }
    return obj;
  },

  create(base?: DeepPartial<TestCase>): TestCase {
    return TestCase.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TestCase>): TestCase {
    const message = createBaseTestCase();
    message.caseName = object.caseName ?? "";
    message.className = object.className ?? "";
    message.result = object.result ?? 0;
    message.failures = object.failures?.map((e) => TestFailure.fromPartial(e)) || [];
    message.errors = object.errors?.map((e) => TestError.fromPartial(e)) || [];
    message.timing = (object.timing !== undefined && object.timing !== null)
      ? Timing.fromPartial(object.timing)
      : undefined;
    message.properties = object.properties?.map((e) => Property.fromPartial(e)) || [];
    message.files = object.files?.map((e) => File.fromPartial(e)) || [];
    message.retryNumber = object.retryNumber ?? 0;
    message.repeatNumber = object.repeatNumber ?? 0;
    return message;
  },
};

function createBaseTestFailure(): TestFailure {
  return { failureMessage: "", exceptionType: "", stackTrace: "", expected: [], actual: [] };
}

export const TestFailure: MessageFns<TestFailure> = {
  encode(message: TestFailure, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.failureMessage !== "") {
      writer.uint32(10).string(message.failureMessage);
    }
    if (message.exceptionType !== "") {
      writer.uint32(18).string(message.exceptionType);
    }
    if (message.stackTrace !== "") {
      writer.uint32(26).string(message.stackTrace);
    }
    for (const v of message.expected) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.actual) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestFailure {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestFailure();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.failureMessage = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.exceptionType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.stackTrace = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.expected.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.actual.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestFailure {
    return {
      failureMessage: isSet(object.failureMessage) ? globalThis.String(object.failureMessage) : "",
      exceptionType: isSet(object.exceptionType) ? globalThis.String(object.exceptionType) : "",
      stackTrace: isSet(object.stackTrace) ? globalThis.String(object.stackTrace) : "",
      expected: globalThis.Array.isArray(object?.expected) ? object.expected.map((e: any) => globalThis.String(e)) : [],
      actual: globalThis.Array.isArray(object?.actual) ? object.actual.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: TestFailure): unknown {
    const obj: any = {};
    if (message.failureMessage !== "") {
      obj.failureMessage = message.failureMessage;
    }
    if (message.exceptionType !== "") {
      obj.exceptionType = message.exceptionType;
    }
    if (message.stackTrace !== "") {
      obj.stackTrace = message.stackTrace;
    }
    if (message.expected?.length) {
      obj.expected = message.expected;
    }
    if (message.actual?.length) {
      obj.actual = message.actual;
    }
    return obj;
  },

  create(base?: DeepPartial<TestFailure>): TestFailure {
    return TestFailure.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TestFailure>): TestFailure {
    const message = createBaseTestFailure();
    message.failureMessage = object.failureMessage ?? "";
    message.exceptionType = object.exceptionType ?? "";
    message.stackTrace = object.stackTrace ?? "";
    message.expected = object.expected?.map((e) => e) || [];
    message.actual = object.actual?.map((e) => e) || [];
    return message;
  },
};

function createBaseTestError(): TestError {
  return { errorMessage: "", exceptionType: "", stackTrace: "" };
}

export const TestError: MessageFns<TestError> = {
  encode(message: TestError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.errorMessage !== "") {
      writer.uint32(10).string(message.errorMessage);
    }
    if (message.exceptionType !== "") {
      writer.uint32(18).string(message.exceptionType);
    }
    if (message.stackTrace !== "") {
      writer.uint32(26).string(message.stackTrace);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.exceptionType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.stackTrace = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestError {
    return {
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      exceptionType: isSet(object.exceptionType) ? globalThis.String(object.exceptionType) : "",
      stackTrace: isSet(object.stackTrace) ? globalThis.String(object.stackTrace) : "",
    };
  },

  toJSON(message: TestError): unknown {
    const obj: any = {};
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.exceptionType !== "") {
      obj.exceptionType = message.exceptionType;
    }
    if (message.stackTrace !== "") {
      obj.stackTrace = message.stackTrace;
    }
    return obj;
  },

  create(base?: DeepPartial<TestError>): TestError {
    return TestError.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TestError>): TestError {
    const message = createBaseTestError();
    message.errorMessage = object.errorMessage ?? "";
    message.exceptionType = object.exceptionType ?? "";
    message.stackTrace = object.stackTrace ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
