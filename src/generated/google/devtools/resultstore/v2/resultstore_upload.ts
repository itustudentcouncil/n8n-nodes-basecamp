// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/devtools/resultstore/v2/resultstore_upload.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Empty } from "../../../protobuf/empty.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Action } from "./action.js";
import { Configuration } from "./configuration.js";
import { ConfiguredTarget, ConfiguredTarget_Id } from "./configured_target.js";
import { FileSet } from "./file_set.js";
import { Invocation, Invocation_Id } from "./invocation.js";
import { Target, Target_Id } from "./target.js";
import { UploadMetadata } from "./upload_metadata.js";

export const protobufPackage = "google.devtools.resultstore.v2";

/** Request passed into CreateInvocation */
export interface CreateInvocationRequest {
  /**
   * A unique identifier for this request. Must be set to a different value for
   * each request that affects a given resource (eg. a random UUID). Required
   * for the operation to be idempotent. This is achieved by ignoring this
   * request if the last successful operation on the resource had the same
   * request ID. If set, invocation_id must also be provided.
   * Restricted to 36 Unicode characters.
   */
  requestId: string;
  /**
   * The invocation ID. It is optional, but strongly recommended.
   *
   * If left empty then a new unique ID will be assigned by the server. If
   * populated, a RFC 4122-compliant v4 UUID is preferred, but v3 or v5 UUIDs
   * are allowed too.
   */
  invocationId: string;
  /**
   * Required. The invocation to create.  Its name field will be ignored, since
   * the name will be derived from the id field above and assigned by the
   * server.
   */
  invocation:
    | Invocation
    | undefined;
  /**
   * This is a token to authorize upload access to this invocation. It must be
   * set to a RFC 4122-compliant v3, v4, or v5 UUID. Once this is set in
   * CreateInvocation, all other upload RPCs for that Invocation and any of its
   * child resources must also include the exact same token, or they will be
   * rejected. The generated token should be unique to this invocation, and it
   * should be kept secret.
   *
   * The purpose of this field is to prevent other users and tools from
   * clobbering your upload intentionally or accidentally. The standard way of
   * using this token is to create a second v4 UUID when the invocation_id is
   * created, and storing them together during the upload. Essentially, this is
   * a "password" to the invocation.
   */
  authorizationToken: string;
  /**
   * By default, Invocations are auto-finalized if they are not modified for 24
   * hours. If you need auto-finalize to happen sooner, set this field to the
   * time you'd like auto-finalize to occur.
   */
  autoFinalizeTime:
    | Date
    | undefined;
  /**
   * Client provided unique token for batch upload to ensure data integrity and
   * to provide a way to resume batch upload in case of a distributed failure on
   * the client side. The standard uploading client is presumed to have many
   * machines uploading to ResultStore, and that any given machine could process
   * any given Invocation at any time. This field is used to coordinate between
   * the client's machines, resolve concurrency issues, and enforce "exactly
   * once" semantics on each batch within the upload.
   *
   * The typical usage of the resume_token is that it should contain a "key"
   * indicating to the client where it is in the upload process, so that the
   * client can use it to resume the upload by reconstructing the state of
   * upload from the point where it was interrupted.
   *
   * If this matches the previously uploaded resume_token, then this request
   * will silently do nothing, making CreateInvocation idempotent.
   * If this token is provided, all further upload RPCs must be done through
   * UploadBatch. This token must not be combined with request_id.
   * Must be web safe Base64 encoded bytes.
   */
  initialResumeToken: string;
  /**
   * Client-specific data used to resume batch upload if an error occurs and
   * retry is needed. This serves a role closely related to resume_token, as
   * both fields may be used to provide state required to restore a Batch
   * Upload, but they differ in two important aspects:
   *  - it is not compared to previous values, and as such does not provide
   *    concurrency control;
   *  - it allows for a larger payload, since the contents are never
   *    inspected/compared;
   * The size of the message must be within 1 MiB. Too large requests will be
   * rejected.
   */
  uploaderState: Buffer;
}

/** Request passed into UpdateInvocation */
export interface UpdateInvocationRequest {
  /**
   * Contains the name and the fields of the invocation to be updated.  The
   * name format must be: invocations/${INVOCATION_ID}
   */
  invocation:
    | Invocation
    | undefined;
  /** Indicates which fields to update. */
  updateMask:
    | string[]
    | undefined;
  /**
   * This is a token to authorize access to this invocation. It must be set to
   * the same value that was provided in the CreateInvocationRequest.
   */
  authorizationToken: string;
}

/** Request passed into MergeInvocation */
export interface MergeInvocationRequest {
  /**
   * A unique identifier for this request. Must be set to a different value for
   * each request that affects a given resource (eg. a random UUID). Required
   * for the operation to be idempotent. This is achieved by ignoring this
   * request if the last successful operation on the resource had the same
   * request ID.  Restricted to 36 Unicode characters.
   */
  requestId: string;
  /**
   * Contains the name and the fields of the invocation to be merged.  The
   * name format must be: invocations/${INVOCATION_ID}
   */
  invocation:
    | Invocation
    | undefined;
  /** Indicates which fields to merge. */
  updateMask:
    | string[]
    | undefined;
  /**
   * This is a token to authorize access to this invocation. It must be set to
   * the same value that was provided in the CreateInvocationRequest.
   */
  authorizationToken: string;
}

/** Request passed into TouchInvocation */
export interface TouchInvocationRequest {
  /**
   * Required. The name of the invocation.  Its format must be:
   * invocations/${INVOCATION_ID}
   */
  name: string;
  /**
   * This is a token to authorize access to this invocation. It must be set to
   * the same value that was provided in the CreateInvocationRequest.
   */
  authorizationToken: string;
}

/** Response returned from TouchInvocation */
export interface TouchInvocationResponse {
  /**
   * The name of the invocation.  Its format will be:
   * invocations/${INVOCATION_ID}
   */
  name: string;
  /** The resource ID components that identify the Invocation. */
  id: Invocation_Id | undefined;
}

/** Request passed into DeleteInvocation */
export interface DeleteInvocationRequest {
  /**
   * Required. The name of the invocation.  Its format must be:
   * invocations/${INVOCATION_ID}
   */
  name: string;
}

/** Request passed into FinalizeInvocation */
export interface FinalizeInvocationRequest {
  /**
   * Required. The name of the invocation.  Its format must be:
   * invocations/${INVOCATION_ID}
   */
  name: string;
  /**
   * This is a token to authorize access to this invocation. It must be set to
   * the same value that was provided in the CreateInvocationRequest.
   */
  authorizationToken: string;
}

/** Response returned from FinalizeInvocation */
export interface FinalizeInvocationResponse {
  /**
   * The name of the invocation.  Its format will be:
   * invocations/${INVOCATION_ID}
   */
  name: string;
  /** The resource ID components that identify the Invocation. */
  id: Invocation_Id | undefined;
}

/** Request passed into CreateTarget */
export interface CreateTargetRequest {
  /**
   * A unique identifier for this request. Must be set to a different value for
   * each request that affects a given resource (eg. a random UUID). Required
   * for the operation to be idempotent. This is achieved by ignoring this
   * request if the last successful operation on the resource had the same
   * request ID.  Restricted to 36 Unicode characters.
   */
  requestId: string;
  /**
   * Required. The name of the parent invocation in which the target is created.
   * Its format must be invocations/${INVOCATION_ID}
   */
  parent: string;
  /**
   * The target identifier.  It can be any string up to 1024 Unicode characters
   * long except for the reserved id '-'.
   */
  targetId: string;
  /**
   * Required. The target to create.  Its name field will be ignored, since the
   * name will be derived from the id field above and assigned by the server.
   */
  target:
    | Target
    | undefined;
  /**
   * This is a token to authorize access to this invocation. It must be set to
   * the same value that was provided in the CreateInvocationRequest.
   */
  authorizationToken: string;
}

/** Request passed into UpdateTarget */
export interface UpdateTargetRequest {
  /**
   * Contains the name and the fields of the target to be updated.  The name
   * format must be:
   * invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}
   */
  target:
    | Target
    | undefined;
  /** Indicates which fields to update. */
  updateMask:
    | string[]
    | undefined;
  /**
   * This is a token to authorize access to this invocation. It must be set to
   * the same value that was provided in the CreateInvocationRequest.
   */
  authorizationToken: string;
  /**
   * If true then the Update operation will become a Create operation if the
   * Target is NOT_FOUND.
   */
  createIfNotFound: boolean;
}

/** Request passed into MergeTarget */
export interface MergeTargetRequest {
  /**
   * A unique identifier for this request. Must be set to a different value for
   * each request that affects a given resource (eg. a random UUID). Required
   * for the operation to be idempotent. This is achieved by ignoring this
   * request if the last successful operation on the resource had the same
   * request ID.  Restricted to 36 Unicode characters.
   */
  requestId: string;
  /**
   * Contains the name and the fields of the target to be merged.  The name
   * format must be:
   * invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}
   */
  target:
    | Target
    | undefined;
  /** Indicates which fields to merge. */
  updateMask:
    | string[]
    | undefined;
  /**
   * This is a token to authorize access to this invocation. It must be set to
   * the same value that was provided in the CreateInvocationRequest.
   */
  authorizationToken: string;
  /**
   * If true then the Merge operation will become a Create operation if the
   * Target is NOT_FOUND.
   */
  createIfNotFound: boolean;
}

/** Request passed into FinalizeTarget */
export interface FinalizeTargetRequest {
  /**
   * Required. The name of the target.  Its format must be:
   * invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}
   */
  name: string;
  /**
   * This is a token to authorize access to this invocation. It must be set to
   * the same value that was provided in the CreateInvocationRequest.
   */
  authorizationToken: string;
}

/** Response returned from FinalizeTarget */
export interface FinalizeTargetResponse {
  /**
   * The name of the target.  Its format will be:
   * invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}
   */
  name: string;
  /** The resource ID components that identify the Target. */
  id: Target_Id | undefined;
}

/** Request passed into CreateConfiguredTarget */
export interface CreateConfiguredTargetRequest {
  /**
   * A unique identifier for this request. Must be set to a different value for
   * each request that affects a given resource (eg. a random UUID). Required
   * for the operation to be idempotent. This is achieved by ignoring this
   * request if the last successful operation on the resource had the same
   * request ID.  Restricted to 36 Unicode characters.
   */
  requestId: string;
  /**
   * Required. The name of the parent target in which the configured target is
   * created. Its format must be:
   * invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}
   */
  parent: string;
  /**
   * The configuration identifier. This must match the ID of an existing
   * Configuration under this Invocation. Cannot be the reserved id '-'.
   */
  configId: string;
  /**
   * Required. The configured target to create. Its name field will be ignored,
   * since the name will be derived from the id field above and assigned by the
   * server.
   */
  configuredTarget:
    | ConfiguredTarget
    | undefined;
  /**
   * This is a token to authorize access to this invocation. It must be set to
   * the same value that was provided in the CreateInvocationRequest.
   */
  authorizationToken: string;
}

/** Request passed into UpdateConfiguredTarget */
export interface UpdateConfiguredTargetRequest {
  /**
   * Contains the name and the fields of the configured target to be updated.
   * The name format must be:
   * invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}/configuredTargets/${CONFIG_ID}
   */
  configuredTarget:
    | ConfiguredTarget
    | undefined;
  /** Indicates which fields to update. */
  updateMask:
    | string[]
    | undefined;
  /**
   * This is a token to authorize access to this invocation. It must be set to
   * the same value that was provided in the CreateInvocationRequest.
   */
  authorizationToken: string;
  /**
   * If true then the Update operation will become a Create operation if the
   * ConfiguredTarget is NOT_FOUND.
   */
  createIfNotFound: boolean;
}

/** Request passed into MergeConfiguredTarget */
export interface MergeConfiguredTargetRequest {
  /**
   * A unique identifier for this request. Must be set to a different value for
   * each request that affects a given resource (eg. a random UUID). Required
   * for the operation to be idempotent. This is achieved by ignoring this
   * request if the last successful operation on the resource had the same
   * request ID.  Restricted to 36 Unicode characters.
   */
  requestId: string;
  /**
   * Contains the name and the fields of the configured target to be merged.
   * The name format must be:
   * invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}/configuredTargets/${CONFIG_ID}
   */
  configuredTarget:
    | ConfiguredTarget
    | undefined;
  /** Indicates which fields to merge. */
  updateMask:
    | string[]
    | undefined;
  /**
   * This is a token to authorize access to this invocation. It must be set to
   * the same value that was provided in the CreateInvocationRequest.
   */
  authorizationToken: string;
  /**
   * If true then the Merge operation will become a Create operation if the
   * ConfiguredTarget is NOT_FOUND.
   */
  createIfNotFound: boolean;
}

/** Request passed into FinalizeConfiguredTarget */
export interface FinalizeConfiguredTargetRequest {
  /**
   * Required. The name of the configured target. Its format must be:
   * invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}/configuredTargets/${CONFIG_ID}
   */
  name: string;
  /**
   * This is a token to authorize access to this invocation. It must be set to
   * the same value that was provided in the CreateInvocationRequest.
   */
  authorizationToken: string;
}

/** Response returned from FinalizeConfiguredTarget */
export interface FinalizeConfiguredTargetResponse {
  /**
   * The name of the configured target. Its format must be:
   * invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}/configuredTargets/${CONFIG_ID}
   */
  name: string;
  /** The resource ID components that identify the ConfiguredTarget. */
  id: ConfiguredTarget_Id | undefined;
}

/** Request passed into CreateAction */
export interface CreateActionRequest {
  /**
   * A unique identifier for this request. Must be set to a different value for
   * each request that affects a given resource (eg. a random UUID). Required
   * for the operation to be idempotent. This is achieved by ignoring this
   * request if the last successful operation on the resource had the same
   * request ID.  Restricted to 36 Unicode characters.
   */
  requestId: string;
  /**
   * Required. The name of the parent configured target in which the action is
   * created. Its format must be:
   * invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}/configuredTargets/${CONFIG_ID}
   */
  parent: string;
  /**
   * The action identifier. It can be any string of up to 512 alphanumeric
   * characters [a-zA-Z_-], except for the reserved id '-'.
   *
   * Recommended IDs for Test Actions:
   * "test": For a single test action.
   * "test_shard0_run0_attempt0" ... "test_shard9_run9_attempt9": For tests with
   *  shard/run/attempts.
   *
   * Recommended IDs for Build Actions:
   * "build": If you only have a single build action.
   */
  actionId: string;
  /**
   * Required. The action to create.  Its name field will be ignored, since the
   * name will be derived from the id field above and assigned by the server.
   */
  action:
    | Action
    | undefined;
  /**
   * This is a token to authorize access to this invocation. It must be set to
   * the same value that was provided in the CreateInvocationRequest.
   */
  authorizationToken: string;
}

/** Request passed into UpdateAction */
export interface UpdateActionRequest {
  /**
   * Contains the name and the fields of the action to be updated.  The
   * name format must be:
   * invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}/configuredTargets/${CONFIG_ID}/actions/${ACTION_ID}
   */
  action:
    | Action
    | undefined;
  /** Indicates which fields to update. */
  updateMask:
    | string[]
    | undefined;
  /**
   * This is a token to authorize access to this invocation. It must be set to
   * the same value that was provided in the CreateInvocationRequest.
   */
  authorizationToken: string;
  /**
   * If true then the Update operation will become a Create operation if the
   * Action is NOT_FOUND.
   */
  createIfNotFound: boolean;
}

/** Request passed into MergeAction */
export interface MergeActionRequest {
  /**
   * A unique identifier for this request. Must be set to a different value for
   * each request that affects a given resource (eg. a random UUID). Required
   * for the operation to be idempotent. This is achieved by ignoring this
   * request if the last successful operation on the resource had the same
   * request ID.  Restricted to 36 Unicode characters.
   */
  requestId: string;
  /**
   * Contains the name and the fields of the action to be merged.  The
   * name format must be:
   * invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}/configuredTargets/${CONFIG_ID}/actions/${ACTION_ID}
   */
  action:
    | Action
    | undefined;
  /** Indicates which fields to merge. */
  updateMask:
    | string[]
    | undefined;
  /**
   * This is a token to authorize access to this invocation. It must be set to
   * the same value that was provided in the CreateInvocationRequest.
   */
  authorizationToken: string;
  /**
   * If true then the Merge operation will become a Create operation if the
   * Action is NOT_FOUND.
   */
  createIfNotFound: boolean;
}

/** Request passed into CreateConfiguration */
export interface CreateConfigurationRequest {
  /**
   * A unique identifier for this request. Must be set to a different value for
   * each request that affects a given resource (eg. a random UUID). Required
   * for the operation to be idempotent. This is achieved by ignoring this
   * request if the last successful operation on the resource had the same
   * request ID.  Restricted to 36 Unicode characters.
   */
  requestId: string;
  /**
   * Required. The name of the parent invocation in which the configuration is
   * created. Its format must be invocations/${INVOCATION_ID}
   */
  parent: string;
  /**
   * The configuration identifier.  It can be any string of up to 512
   * alphanumeric characters [a-zA-Z_-], except for the reserved id '-'. The
   * configuration ID of "default" should be preferred for the default
   * configuration in a single-config invocation.
   */
  configId: string;
  /**
   * Required. The configuration to create. Its name field will be ignored,
   * since the name will be derived from the id field above and assigned by the
   * server.
   */
  configuration:
    | Configuration
    | undefined;
  /**
   * This is a token to authorize access to this invocation. It must be set to
   * the same value that was provided in the CreateInvocationRequest.
   */
  authorizationToken: string;
}

/** Request passed into UpdateConfiguration */
export interface UpdateConfigurationRequest {
  /**
   * Contains the name and fields of the configuration to be updated. The name
   * format must be:
   * invocations/${INVOCATION_ID}/configs/${CONFIG_ID}
   */
  configuration:
    | Configuration
    | undefined;
  /** Indicates which fields to update. */
  updateMask:
    | string[]
    | undefined;
  /**
   * This is a token to authorize access to this invocation. It must be set to
   * the same value that was provided in the CreateInvocationRequest.
   */
  authorizationToken: string;
  /**
   * If true then the Update operation will become a Create operation if the
   * Configuration is NOT_FOUND.
   */
  createIfNotFound: boolean;
}

/** Request passed into CreateFileSet */
export interface CreateFileSetRequest {
  /**
   * A unique identifier for this request. Must be set to a different value for
   * each request that affects a given resource (eg. a random UUID). Required
   * for the operation to be idempotent. This is achieved by ignoring this
   * request if the last successful operation on the resource had the same
   * request ID.  Restricted to 36 Unicode characters.
   */
  requestId: string;
  /**
   * Required. The name of the parent invocation in which the file set is
   * created. Its format must be invocations/${INVOCATION_ID}
   */
  parent: string;
  /**
   * The file set identifier.  It can be any string of up to 512 alphanumeric
   * characters [a-zA-Z_-], except for the reserved id '-'.
   */
  fileSetId: string;
  /**
   * Required. The file set to create. Its name field will be ignored, since the
   * name will be derived from the id field above and assigned by the server.
   */
  fileSet:
    | FileSet
    | undefined;
  /**
   * This is a token to authorize access to this invocation. It must be set to
   * the same value that was provided in the CreateInvocationRequest.
   */
  authorizationToken: string;
}

/** Request passed into UpdateFileSet */
export interface UpdateFileSetRequest {
  /**
   * Contains the name and fields of the file set to be updated. The name format
   * must be: invocations/${INVOCATION_ID}/fileSets/${FILE_SET_ID}
   */
  fileSet:
    | FileSet
    | undefined;
  /** Indicates which fields to update. */
  updateMask:
    | string[]
    | undefined;
  /**
   * This is a token to authorize access to this invocation. It must be set to
   * the same value that was provided in the CreateInvocationRequest.
   */
  authorizationToken: string;
  /**
   * If true then the Update operation will become a Create operation if the
   * FileSet is NOT_FOUND.
   */
  createIfNotFound: boolean;
}

/** Request passed into MergeFileSet */
export interface MergeFileSetRequest {
  /**
   * A unique identifier for this request. Must be set to a different value for
   * each request that affects a given resource (eg. a random UUID). Required
   * for the operation to be idempotent. This is achieved by ignoring this
   * request if the last successful operation on the resource had the same
   * request ID.  Restricted to 36 Unicode characters.
   */
  requestId: string;
  /**
   * Contains the name and fields of the file set to be merged. The name
   * format must be:
   * invocations/${INVOCATION_ID}/fileSets/${FILE_SET_ID}
   */
  fileSet:
    | FileSet
    | undefined;
  /** Indicates which fields to merge. */
  updateMask:
    | string[]
    | undefined;
  /**
   * This is a token to authorize access to this invocation. It must be set to
   * the same value that was provided in the CreateInvocationRequest.
   */
  authorizationToken: string;
  /**
   * If true then the Merge operation will become a Create operation if the
   * FileSet is NOT_FOUND.
   */
  createIfNotFound: boolean;
}

/** Request passed into UploadBatch */
export interface UploadBatchRequest {
  /**
   * Required. The name of the invocation being modified.
   * The name format must be: invocations/${INVOCATION_ID}
   */
  parent: string;
  /**
   * Required. A UUID that must match the value provided in
   * CreateInvocationRequest.
   */
  authorizationToken: string;
  /**
   * Required. The token of this batch, that will be committed in this
   * UploadBatchRequest. If this matches the previously uploaded resume_token,
   * then this request will silently do nothing. See
   * CreateInvocationRequest.initial_resume_token for more information. Must be
   * web safe Base64 encoded bytes.
   */
  nextResumeToken: string;
  /**
   * Required. The token of the previous batch that was committed in a
   * UploadBatchRequest. This will be checked after next_resume_token match is
   * checked. If this does not match the previously uploaded resume_token, a 409
   * Conflict (HTTPS) or ABORTED (gRPC ) error code indicating a concurrency
   * failure will be returned, and that the user should call
   * GetInvocationUploadMetadata to fetch the current resume_token to
   * reconstruct the state of the upload to resume it.
   * See CreateInvocationRequest.initial_resume_token for more information.
   * Must be web safe Base64 encoded bytes.
   */
  resumeToken: string;
  /**
   * Client-specific data used to resume batch upload if an error occurs and
   * retry is needed. This serves a role closely related to resume_token, as
   * both fields may be used to provide state required to restore a Batch
   * Upload, but they differ in two important aspects:
   *  - it is not compared to previous values, and as such does not provide
   *    concurrency control;
   *  - it allows for a larger payload, since the contents are never
   *    inspected/compared;
   * The size of the message must be within 1 MiB. Too large requests will be
   * rejected.
   */
  uploaderState: Buffer;
  /**
   * The individual upload requests for this batch.
   * This field may be empty, allowing this RPC to be used like TouchInvocation.
   */
  uploadRequests: UploadRequest[];
}

/** Response for UploadBatch */
export interface UploadBatchResponse {
}

/** The individual upload requests for this batch. */
export interface UploadRequest {
  /** The resource ID components that identify the resource being uploaded. */
  id:
    | UploadRequest_Id
    | undefined;
  /** The operation for the request (e.g. Create(), Update(), etc.) */
  uploadOperation: UploadRequest_UploadOperation;
  /**
   * Required for Update and Merge operations.
   * Ignored for Create and Finalize operations.
   * Masks the fields of the resource being uploaded. Provides support for a
   * more granular upload. FieldMasks are limited to certain fields and must
   * match one of the follow patterns, where * means any single field name.
   *
   * For Update Operations:
   *
   * Invocation: [*, status_attributes.*, timing.*, invocation_attributes.*,
   * workspace_info.*].
   * Target: [*, status_attributes.*, timing.*].
   * Configuration: [*, status_attributes.*].
   * ConfiguredTarget: [*, status_attributes.*].
   * Action: [*, status_attributes.*, timing.*, test_action.test_suite,
   * test_action.infrastructure_failure_info].
   * FileSet: [*].
   *
   * For Merge Operations:
   *
   * Invocation: [invocation_attributes.labels, workspace_info.command_lines,
   * properties, files, file_processing_errors].
   * Target: [files].
   * ConfiguredTarget: [files].
   * Action: [files, file_processing_errors].
   */
  updateMask:
    | string[]
    | undefined;
  /**
   * If true then the Update, Merge operation will become a Create operation if
   * the resource is NOT_FOUND. Not supported for Invocation resource.
   */
  createIfNotFound: boolean;
  /** The Invocation Resource */
  invocation?:
    | Invocation
    | undefined;
  /** The Target Resource */
  target?:
    | Target
    | undefined;
  /** The Configuration Resource */
  configuration?:
    | Configuration
    | undefined;
  /** The ConfiguredTarget Resource */
  configuredTarget?:
    | ConfiguredTarget
    | undefined;
  /** The Action Resource */
  action?:
    | Action
    | undefined;
  /** The FileSet Resource */
  fileSet?: FileSet | undefined;
}

/** The operation for the request (e.g. Create(), Update(), etc.) */
export enum UploadRequest_UploadOperation {
  /** UPLOAD_OPERATION_UNSPECIFIED - Unspecified */
  UPLOAD_OPERATION_UNSPECIFIED = 0,
  /**
   * CREATE - Create the given resources except Invocation.
   * For more information, check the Create APIs.
   */
  CREATE = 1,
  /**
   * UPDATE - Applies a standard update to the resource identified by the given
   * proto's name. For more information, see the Update APIs.
   * UploadBatch does not support arbitrary field masks. The list of allowed
   * field masks can be found below.
   */
  UPDATE = 2,
  /**
   * MERGE - Applies an merge update to the resource identified by the given
   * proto's name. For more information, see the Merge APIs.
   * UploadBatch does not support arbitrary field masks. The list of allowed
   * field masks can be found below.
   */
  MERGE = 3,
  /**
   * FINALIZE - Declares the resource with the given name as finalized and immutable by
   * the uploader. Only supported for Invocation, Target, ConfiguredTarget.
   * There must be no operation on child resources after parent resource is
   * Finalized. If there is a Finalize of Invocation, it must be the final
   * UploadRequest. For more information, see the Finalize APIs.
   * An empty resource should be provided below.
   */
  FINALIZE = 4,
  UNRECOGNIZED = -1,
}

export function uploadRequest_UploadOperationFromJSON(object: any): UploadRequest_UploadOperation {
  switch (object) {
    case 0:
    case "UPLOAD_OPERATION_UNSPECIFIED":
      return UploadRequest_UploadOperation.UPLOAD_OPERATION_UNSPECIFIED;
    case 1:
    case "CREATE":
      return UploadRequest_UploadOperation.CREATE;
    case 2:
    case "UPDATE":
      return UploadRequest_UploadOperation.UPDATE;
    case 3:
    case "MERGE":
      return UploadRequest_UploadOperation.MERGE;
    case 4:
    case "FINALIZE":
      return UploadRequest_UploadOperation.FINALIZE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UploadRequest_UploadOperation.UNRECOGNIZED;
  }
}

export function uploadRequest_UploadOperationToJSON(object: UploadRequest_UploadOperation): string {
  switch (object) {
    case UploadRequest_UploadOperation.UPLOAD_OPERATION_UNSPECIFIED:
      return "UPLOAD_OPERATION_UNSPECIFIED";
    case UploadRequest_UploadOperation.CREATE:
      return "CREATE";
    case UploadRequest_UploadOperation.UPDATE:
      return "UPDATE";
    case UploadRequest_UploadOperation.MERGE:
      return "MERGE";
    case UploadRequest_UploadOperation.FINALIZE:
      return "FINALIZE";
    case UploadRequest_UploadOperation.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The resource ID components that identify the resource being uploaded. */
export interface UploadRequest_Id {
  /**
   * Required for Target, ConfiguredTarget, or Action.
   * The Target ID.
   */
  targetId: string;
  /**
   * Required for Configuration, ConfiguredTarget, or Action.
   * The Configuration ID.
   */
  configurationId: string;
  /**
   * Required for Action.
   * The Action ID.
   */
  actionId: string;
  /**
   * Required for FileSet.
   * The FileSet ID.
   */
  fileSetId: string;
}

/** Request passed into GetInvocationUploadMetadata */
export interface GetInvocationUploadMetadataRequest {
  /**
   * Required. The name of the UploadMetadata being requested.
   * The name format must be: invocations/${INVOCATION_ID}/uploadMetadata
   */
  name: string;
  /**
   * Required. A UUID that must match the value provided in
   * CreateInvocationRequest.
   */
  authorizationToken: string;
}

function createBaseCreateInvocationRequest(): CreateInvocationRequest {
  return {
    requestId: "",
    invocationId: "",
    invocation: undefined,
    authorizationToken: "",
    autoFinalizeTime: undefined,
    initialResumeToken: "",
    uploaderState: Buffer.alloc(0),
  };
}

export const CreateInvocationRequest: MessageFns<CreateInvocationRequest> = {
  encode(message: CreateInvocationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.invocationId !== "") {
      writer.uint32(18).string(message.invocationId);
    }
    if (message.invocation !== undefined) {
      Invocation.encode(message.invocation, writer.uint32(26).fork()).join();
    }
    if (message.authorizationToken !== "") {
      writer.uint32(34).string(message.authorizationToken);
    }
    if (message.autoFinalizeTime !== undefined) {
      Timestamp.encode(toTimestamp(message.autoFinalizeTime), writer.uint32(50).fork()).join();
    }
    if (message.initialResumeToken !== "") {
      writer.uint32(58).string(message.initialResumeToken);
    }
    if (message.uploaderState.length !== 0) {
      writer.uint32(66).bytes(message.uploaderState);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateInvocationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateInvocationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.invocationId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.invocation = Invocation.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.authorizationToken = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.autoFinalizeTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.initialResumeToken = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.uploaderState = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateInvocationRequest {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      invocationId: isSet(object.invocationId) ? globalThis.String(object.invocationId) : "",
      invocation: isSet(object.invocation) ? Invocation.fromJSON(object.invocation) : undefined,
      authorizationToken: isSet(object.authorizationToken) ? globalThis.String(object.authorizationToken) : "",
      autoFinalizeTime: isSet(object.autoFinalizeTime) ? fromJsonTimestamp(object.autoFinalizeTime) : undefined,
      initialResumeToken: isSet(object.initialResumeToken) ? globalThis.String(object.initialResumeToken) : "",
      uploaderState: isSet(object.uploaderState) ? Buffer.from(bytesFromBase64(object.uploaderState)) : Buffer.alloc(0),
    };
  },

  toJSON(message: CreateInvocationRequest): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.invocationId !== "") {
      obj.invocationId = message.invocationId;
    }
    if (message.invocation !== undefined) {
      obj.invocation = Invocation.toJSON(message.invocation);
    }
    if (message.authorizationToken !== "") {
      obj.authorizationToken = message.authorizationToken;
    }
    if (message.autoFinalizeTime !== undefined) {
      obj.autoFinalizeTime = message.autoFinalizeTime.toISOString();
    }
    if (message.initialResumeToken !== "") {
      obj.initialResumeToken = message.initialResumeToken;
    }
    if (message.uploaderState.length !== 0) {
      obj.uploaderState = base64FromBytes(message.uploaderState);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateInvocationRequest>): CreateInvocationRequest {
    return CreateInvocationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateInvocationRequest>): CreateInvocationRequest {
    const message = createBaseCreateInvocationRequest();
    message.requestId = object.requestId ?? "";
    message.invocationId = object.invocationId ?? "";
    message.invocation = (object.invocation !== undefined && object.invocation !== null)
      ? Invocation.fromPartial(object.invocation)
      : undefined;
    message.authorizationToken = object.authorizationToken ?? "";
    message.autoFinalizeTime = object.autoFinalizeTime ?? undefined;
    message.initialResumeToken = object.initialResumeToken ?? "";
    message.uploaderState = object.uploaderState ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseUpdateInvocationRequest(): UpdateInvocationRequest {
  return { invocation: undefined, updateMask: undefined, authorizationToken: "" };
}

export const UpdateInvocationRequest: MessageFns<UpdateInvocationRequest> = {
  encode(message: UpdateInvocationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.invocation !== undefined) {
      Invocation.encode(message.invocation, writer.uint32(26).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(34).fork()).join();
    }
    if (message.authorizationToken !== "") {
      writer.uint32(42).string(message.authorizationToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateInvocationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateInvocationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.invocation = Invocation.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.authorizationToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateInvocationRequest {
    return {
      invocation: isSet(object.invocation) ? Invocation.fromJSON(object.invocation) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      authorizationToken: isSet(object.authorizationToken) ? globalThis.String(object.authorizationToken) : "",
    };
  },

  toJSON(message: UpdateInvocationRequest): unknown {
    const obj: any = {};
    if (message.invocation !== undefined) {
      obj.invocation = Invocation.toJSON(message.invocation);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.authorizationToken !== "") {
      obj.authorizationToken = message.authorizationToken;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateInvocationRequest>): UpdateInvocationRequest {
    return UpdateInvocationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateInvocationRequest>): UpdateInvocationRequest {
    const message = createBaseUpdateInvocationRequest();
    message.invocation = (object.invocation !== undefined && object.invocation !== null)
      ? Invocation.fromPartial(object.invocation)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    message.authorizationToken = object.authorizationToken ?? "";
    return message;
  },
};

function createBaseMergeInvocationRequest(): MergeInvocationRequest {
  return { requestId: "", invocation: undefined, updateMask: undefined, authorizationToken: "" };
}

export const MergeInvocationRequest: MessageFns<MergeInvocationRequest> = {
  encode(message: MergeInvocationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.invocation !== undefined) {
      Invocation.encode(message.invocation, writer.uint32(26).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(34).fork()).join();
    }
    if (message.authorizationToken !== "") {
      writer.uint32(42).string(message.authorizationToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MergeInvocationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMergeInvocationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.invocation = Invocation.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.authorizationToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MergeInvocationRequest {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      invocation: isSet(object.invocation) ? Invocation.fromJSON(object.invocation) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      authorizationToken: isSet(object.authorizationToken) ? globalThis.String(object.authorizationToken) : "",
    };
  },

  toJSON(message: MergeInvocationRequest): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.invocation !== undefined) {
      obj.invocation = Invocation.toJSON(message.invocation);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.authorizationToken !== "") {
      obj.authorizationToken = message.authorizationToken;
    }
    return obj;
  },

  create(base?: DeepPartial<MergeInvocationRequest>): MergeInvocationRequest {
    return MergeInvocationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MergeInvocationRequest>): MergeInvocationRequest {
    const message = createBaseMergeInvocationRequest();
    message.requestId = object.requestId ?? "";
    message.invocation = (object.invocation !== undefined && object.invocation !== null)
      ? Invocation.fromPartial(object.invocation)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    message.authorizationToken = object.authorizationToken ?? "";
    return message;
  },
};

function createBaseTouchInvocationRequest(): TouchInvocationRequest {
  return { name: "", authorizationToken: "" };
}

export const TouchInvocationRequest: MessageFns<TouchInvocationRequest> = {
  encode(message: TouchInvocationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.authorizationToken !== "") {
      writer.uint32(18).string(message.authorizationToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TouchInvocationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTouchInvocationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.authorizationToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TouchInvocationRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      authorizationToken: isSet(object.authorizationToken) ? globalThis.String(object.authorizationToken) : "",
    };
  },

  toJSON(message: TouchInvocationRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.authorizationToken !== "") {
      obj.authorizationToken = message.authorizationToken;
    }
    return obj;
  },

  create(base?: DeepPartial<TouchInvocationRequest>): TouchInvocationRequest {
    return TouchInvocationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TouchInvocationRequest>): TouchInvocationRequest {
    const message = createBaseTouchInvocationRequest();
    message.name = object.name ?? "";
    message.authorizationToken = object.authorizationToken ?? "";
    return message;
  },
};

function createBaseTouchInvocationResponse(): TouchInvocationResponse {
  return { name: "", id: undefined };
}

export const TouchInvocationResponse: MessageFns<TouchInvocationResponse> = {
  encode(message: TouchInvocationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.id !== undefined) {
      Invocation_Id.encode(message.id, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TouchInvocationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTouchInvocationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id = Invocation_Id.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TouchInvocationResponse {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      id: isSet(object.id) ? Invocation_Id.fromJSON(object.id) : undefined,
    };
  },

  toJSON(message: TouchInvocationResponse): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.id !== undefined) {
      obj.id = Invocation_Id.toJSON(message.id);
    }
    return obj;
  },

  create(base?: DeepPartial<TouchInvocationResponse>): TouchInvocationResponse {
    return TouchInvocationResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TouchInvocationResponse>): TouchInvocationResponse {
    const message = createBaseTouchInvocationResponse();
    message.name = object.name ?? "";
    message.id = (object.id !== undefined && object.id !== null) ? Invocation_Id.fromPartial(object.id) : undefined;
    return message;
  },
};

function createBaseDeleteInvocationRequest(): DeleteInvocationRequest {
  return { name: "" };
}

export const DeleteInvocationRequest: MessageFns<DeleteInvocationRequest> = {
  encode(message: DeleteInvocationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteInvocationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteInvocationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteInvocationRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteInvocationRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteInvocationRequest>): DeleteInvocationRequest {
    return DeleteInvocationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteInvocationRequest>): DeleteInvocationRequest {
    const message = createBaseDeleteInvocationRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseFinalizeInvocationRequest(): FinalizeInvocationRequest {
  return { name: "", authorizationToken: "" };
}

export const FinalizeInvocationRequest: MessageFns<FinalizeInvocationRequest> = {
  encode(message: FinalizeInvocationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.authorizationToken !== "") {
      writer.uint32(26).string(message.authorizationToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinalizeInvocationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalizeInvocationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.authorizationToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinalizeInvocationRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      authorizationToken: isSet(object.authorizationToken) ? globalThis.String(object.authorizationToken) : "",
    };
  },

  toJSON(message: FinalizeInvocationRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.authorizationToken !== "") {
      obj.authorizationToken = message.authorizationToken;
    }
    return obj;
  },

  create(base?: DeepPartial<FinalizeInvocationRequest>): FinalizeInvocationRequest {
    return FinalizeInvocationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FinalizeInvocationRequest>): FinalizeInvocationRequest {
    const message = createBaseFinalizeInvocationRequest();
    message.name = object.name ?? "";
    message.authorizationToken = object.authorizationToken ?? "";
    return message;
  },
};

function createBaseFinalizeInvocationResponse(): FinalizeInvocationResponse {
  return { name: "", id: undefined };
}

export const FinalizeInvocationResponse: MessageFns<FinalizeInvocationResponse> = {
  encode(message: FinalizeInvocationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.id !== undefined) {
      Invocation_Id.encode(message.id, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinalizeInvocationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalizeInvocationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id = Invocation_Id.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinalizeInvocationResponse {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      id: isSet(object.id) ? Invocation_Id.fromJSON(object.id) : undefined,
    };
  },

  toJSON(message: FinalizeInvocationResponse): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.id !== undefined) {
      obj.id = Invocation_Id.toJSON(message.id);
    }
    return obj;
  },

  create(base?: DeepPartial<FinalizeInvocationResponse>): FinalizeInvocationResponse {
    return FinalizeInvocationResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FinalizeInvocationResponse>): FinalizeInvocationResponse {
    const message = createBaseFinalizeInvocationResponse();
    message.name = object.name ?? "";
    message.id = (object.id !== undefined && object.id !== null) ? Invocation_Id.fromPartial(object.id) : undefined;
    return message;
  },
};

function createBaseCreateTargetRequest(): CreateTargetRequest {
  return { requestId: "", parent: "", targetId: "", target: undefined, authorizationToken: "" };
}

export const CreateTargetRequest: MessageFns<CreateTargetRequest> = {
  encode(message: CreateTargetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.parent !== "") {
      writer.uint32(18).string(message.parent);
    }
    if (message.targetId !== "") {
      writer.uint32(26).string(message.targetId);
    }
    if (message.target !== undefined) {
      Target.encode(message.target, writer.uint32(34).fork()).join();
    }
    if (message.authorizationToken !== "") {
      writer.uint32(42).string(message.authorizationToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTargetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTargetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.targetId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.target = Target.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.authorizationToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTargetRequest {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      targetId: isSet(object.targetId) ? globalThis.String(object.targetId) : "",
      target: isSet(object.target) ? Target.fromJSON(object.target) : undefined,
      authorizationToken: isSet(object.authorizationToken) ? globalThis.String(object.authorizationToken) : "",
    };
  },

  toJSON(message: CreateTargetRequest): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.targetId !== "") {
      obj.targetId = message.targetId;
    }
    if (message.target !== undefined) {
      obj.target = Target.toJSON(message.target);
    }
    if (message.authorizationToken !== "") {
      obj.authorizationToken = message.authorizationToken;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateTargetRequest>): CreateTargetRequest {
    return CreateTargetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateTargetRequest>): CreateTargetRequest {
    const message = createBaseCreateTargetRequest();
    message.requestId = object.requestId ?? "";
    message.parent = object.parent ?? "";
    message.targetId = object.targetId ?? "";
    message.target = (object.target !== undefined && object.target !== null)
      ? Target.fromPartial(object.target)
      : undefined;
    message.authorizationToken = object.authorizationToken ?? "";
    return message;
  },
};

function createBaseUpdateTargetRequest(): UpdateTargetRequest {
  return { target: undefined, updateMask: undefined, authorizationToken: "", createIfNotFound: false };
}

export const UpdateTargetRequest: MessageFns<UpdateTargetRequest> = {
  encode(message: UpdateTargetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.target !== undefined) {
      Target.encode(message.target, writer.uint32(26).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(34).fork()).join();
    }
    if (message.authorizationToken !== "") {
      writer.uint32(42).string(message.authorizationToken);
    }
    if (message.createIfNotFound !== false) {
      writer.uint32(48).bool(message.createIfNotFound);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateTargetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateTargetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.target = Target.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.authorizationToken = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.createIfNotFound = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateTargetRequest {
    return {
      target: isSet(object.target) ? Target.fromJSON(object.target) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      authorizationToken: isSet(object.authorizationToken) ? globalThis.String(object.authorizationToken) : "",
      createIfNotFound: isSet(object.createIfNotFound) ? globalThis.Boolean(object.createIfNotFound) : false,
    };
  },

  toJSON(message: UpdateTargetRequest): unknown {
    const obj: any = {};
    if (message.target !== undefined) {
      obj.target = Target.toJSON(message.target);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.authorizationToken !== "") {
      obj.authorizationToken = message.authorizationToken;
    }
    if (message.createIfNotFound !== false) {
      obj.createIfNotFound = message.createIfNotFound;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateTargetRequest>): UpdateTargetRequest {
    return UpdateTargetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateTargetRequest>): UpdateTargetRequest {
    const message = createBaseUpdateTargetRequest();
    message.target = (object.target !== undefined && object.target !== null)
      ? Target.fromPartial(object.target)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    message.authorizationToken = object.authorizationToken ?? "";
    message.createIfNotFound = object.createIfNotFound ?? false;
    return message;
  },
};

function createBaseMergeTargetRequest(): MergeTargetRequest {
  return { requestId: "", target: undefined, updateMask: undefined, authorizationToken: "", createIfNotFound: false };
}

export const MergeTargetRequest: MessageFns<MergeTargetRequest> = {
  encode(message: MergeTargetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.target !== undefined) {
      Target.encode(message.target, writer.uint32(26).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(34).fork()).join();
    }
    if (message.authorizationToken !== "") {
      writer.uint32(42).string(message.authorizationToken);
    }
    if (message.createIfNotFound !== false) {
      writer.uint32(48).bool(message.createIfNotFound);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MergeTargetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMergeTargetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.target = Target.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.authorizationToken = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.createIfNotFound = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MergeTargetRequest {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      target: isSet(object.target) ? Target.fromJSON(object.target) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      authorizationToken: isSet(object.authorizationToken) ? globalThis.String(object.authorizationToken) : "",
      createIfNotFound: isSet(object.createIfNotFound) ? globalThis.Boolean(object.createIfNotFound) : false,
    };
  },

  toJSON(message: MergeTargetRequest): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.target !== undefined) {
      obj.target = Target.toJSON(message.target);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.authorizationToken !== "") {
      obj.authorizationToken = message.authorizationToken;
    }
    if (message.createIfNotFound !== false) {
      obj.createIfNotFound = message.createIfNotFound;
    }
    return obj;
  },

  create(base?: DeepPartial<MergeTargetRequest>): MergeTargetRequest {
    return MergeTargetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MergeTargetRequest>): MergeTargetRequest {
    const message = createBaseMergeTargetRequest();
    message.requestId = object.requestId ?? "";
    message.target = (object.target !== undefined && object.target !== null)
      ? Target.fromPartial(object.target)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    message.authorizationToken = object.authorizationToken ?? "";
    message.createIfNotFound = object.createIfNotFound ?? false;
    return message;
  },
};

function createBaseFinalizeTargetRequest(): FinalizeTargetRequest {
  return { name: "", authorizationToken: "" };
}

export const FinalizeTargetRequest: MessageFns<FinalizeTargetRequest> = {
  encode(message: FinalizeTargetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.authorizationToken !== "") {
      writer.uint32(26).string(message.authorizationToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinalizeTargetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalizeTargetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.authorizationToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinalizeTargetRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      authorizationToken: isSet(object.authorizationToken) ? globalThis.String(object.authorizationToken) : "",
    };
  },

  toJSON(message: FinalizeTargetRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.authorizationToken !== "") {
      obj.authorizationToken = message.authorizationToken;
    }
    return obj;
  },

  create(base?: DeepPartial<FinalizeTargetRequest>): FinalizeTargetRequest {
    return FinalizeTargetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FinalizeTargetRequest>): FinalizeTargetRequest {
    const message = createBaseFinalizeTargetRequest();
    message.name = object.name ?? "";
    message.authorizationToken = object.authorizationToken ?? "";
    return message;
  },
};

function createBaseFinalizeTargetResponse(): FinalizeTargetResponse {
  return { name: "", id: undefined };
}

export const FinalizeTargetResponse: MessageFns<FinalizeTargetResponse> = {
  encode(message: FinalizeTargetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.id !== undefined) {
      Target_Id.encode(message.id, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinalizeTargetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalizeTargetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id = Target_Id.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinalizeTargetResponse {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      id: isSet(object.id) ? Target_Id.fromJSON(object.id) : undefined,
    };
  },

  toJSON(message: FinalizeTargetResponse): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.id !== undefined) {
      obj.id = Target_Id.toJSON(message.id);
    }
    return obj;
  },

  create(base?: DeepPartial<FinalizeTargetResponse>): FinalizeTargetResponse {
    return FinalizeTargetResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FinalizeTargetResponse>): FinalizeTargetResponse {
    const message = createBaseFinalizeTargetResponse();
    message.name = object.name ?? "";
    message.id = (object.id !== undefined && object.id !== null) ? Target_Id.fromPartial(object.id) : undefined;
    return message;
  },
};

function createBaseCreateConfiguredTargetRequest(): CreateConfiguredTargetRequest {
  return { requestId: "", parent: "", configId: "", configuredTarget: undefined, authorizationToken: "" };
}

export const CreateConfiguredTargetRequest: MessageFns<CreateConfiguredTargetRequest> = {
  encode(message: CreateConfiguredTargetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.parent !== "") {
      writer.uint32(18).string(message.parent);
    }
    if (message.configId !== "") {
      writer.uint32(26).string(message.configId);
    }
    if (message.configuredTarget !== undefined) {
      ConfiguredTarget.encode(message.configuredTarget, writer.uint32(34).fork()).join();
    }
    if (message.authorizationToken !== "") {
      writer.uint32(42).string(message.authorizationToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateConfiguredTargetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateConfiguredTargetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.configId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.configuredTarget = ConfiguredTarget.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.authorizationToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateConfiguredTargetRequest {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      configId: isSet(object.configId) ? globalThis.String(object.configId) : "",
      configuredTarget: isSet(object.configuredTarget) ? ConfiguredTarget.fromJSON(object.configuredTarget) : undefined,
      authorizationToken: isSet(object.authorizationToken) ? globalThis.String(object.authorizationToken) : "",
    };
  },

  toJSON(message: CreateConfiguredTargetRequest): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.configId !== "") {
      obj.configId = message.configId;
    }
    if (message.configuredTarget !== undefined) {
      obj.configuredTarget = ConfiguredTarget.toJSON(message.configuredTarget);
    }
    if (message.authorizationToken !== "") {
      obj.authorizationToken = message.authorizationToken;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateConfiguredTargetRequest>): CreateConfiguredTargetRequest {
    return CreateConfiguredTargetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateConfiguredTargetRequest>): CreateConfiguredTargetRequest {
    const message = createBaseCreateConfiguredTargetRequest();
    message.requestId = object.requestId ?? "";
    message.parent = object.parent ?? "";
    message.configId = object.configId ?? "";
    message.configuredTarget = (object.configuredTarget !== undefined && object.configuredTarget !== null)
      ? ConfiguredTarget.fromPartial(object.configuredTarget)
      : undefined;
    message.authorizationToken = object.authorizationToken ?? "";
    return message;
  },
};

function createBaseUpdateConfiguredTargetRequest(): UpdateConfiguredTargetRequest {
  return { configuredTarget: undefined, updateMask: undefined, authorizationToken: "", createIfNotFound: false };
}

export const UpdateConfiguredTargetRequest: MessageFns<UpdateConfiguredTargetRequest> = {
  encode(message: UpdateConfiguredTargetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.configuredTarget !== undefined) {
      ConfiguredTarget.encode(message.configuredTarget, writer.uint32(26).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(34).fork()).join();
    }
    if (message.authorizationToken !== "") {
      writer.uint32(42).string(message.authorizationToken);
    }
    if (message.createIfNotFound !== false) {
      writer.uint32(48).bool(message.createIfNotFound);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateConfiguredTargetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateConfiguredTargetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.configuredTarget = ConfiguredTarget.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.authorizationToken = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.createIfNotFound = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateConfiguredTargetRequest {
    return {
      configuredTarget: isSet(object.configuredTarget) ? ConfiguredTarget.fromJSON(object.configuredTarget) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      authorizationToken: isSet(object.authorizationToken) ? globalThis.String(object.authorizationToken) : "",
      createIfNotFound: isSet(object.createIfNotFound) ? globalThis.Boolean(object.createIfNotFound) : false,
    };
  },

  toJSON(message: UpdateConfiguredTargetRequest): unknown {
    const obj: any = {};
    if (message.configuredTarget !== undefined) {
      obj.configuredTarget = ConfiguredTarget.toJSON(message.configuredTarget);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.authorizationToken !== "") {
      obj.authorizationToken = message.authorizationToken;
    }
    if (message.createIfNotFound !== false) {
      obj.createIfNotFound = message.createIfNotFound;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateConfiguredTargetRequest>): UpdateConfiguredTargetRequest {
    return UpdateConfiguredTargetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateConfiguredTargetRequest>): UpdateConfiguredTargetRequest {
    const message = createBaseUpdateConfiguredTargetRequest();
    message.configuredTarget = (object.configuredTarget !== undefined && object.configuredTarget !== null)
      ? ConfiguredTarget.fromPartial(object.configuredTarget)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    message.authorizationToken = object.authorizationToken ?? "";
    message.createIfNotFound = object.createIfNotFound ?? false;
    return message;
  },
};

function createBaseMergeConfiguredTargetRequest(): MergeConfiguredTargetRequest {
  return {
    requestId: "",
    configuredTarget: undefined,
    updateMask: undefined,
    authorizationToken: "",
    createIfNotFound: false,
  };
}

export const MergeConfiguredTargetRequest: MessageFns<MergeConfiguredTargetRequest> = {
  encode(message: MergeConfiguredTargetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.configuredTarget !== undefined) {
      ConfiguredTarget.encode(message.configuredTarget, writer.uint32(26).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(34).fork()).join();
    }
    if (message.authorizationToken !== "") {
      writer.uint32(42).string(message.authorizationToken);
    }
    if (message.createIfNotFound !== false) {
      writer.uint32(48).bool(message.createIfNotFound);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MergeConfiguredTargetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMergeConfiguredTargetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.configuredTarget = ConfiguredTarget.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.authorizationToken = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.createIfNotFound = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MergeConfiguredTargetRequest {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      configuredTarget: isSet(object.configuredTarget) ? ConfiguredTarget.fromJSON(object.configuredTarget) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      authorizationToken: isSet(object.authorizationToken) ? globalThis.String(object.authorizationToken) : "",
      createIfNotFound: isSet(object.createIfNotFound) ? globalThis.Boolean(object.createIfNotFound) : false,
    };
  },

  toJSON(message: MergeConfiguredTargetRequest): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.configuredTarget !== undefined) {
      obj.configuredTarget = ConfiguredTarget.toJSON(message.configuredTarget);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.authorizationToken !== "") {
      obj.authorizationToken = message.authorizationToken;
    }
    if (message.createIfNotFound !== false) {
      obj.createIfNotFound = message.createIfNotFound;
    }
    return obj;
  },

  create(base?: DeepPartial<MergeConfiguredTargetRequest>): MergeConfiguredTargetRequest {
    return MergeConfiguredTargetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MergeConfiguredTargetRequest>): MergeConfiguredTargetRequest {
    const message = createBaseMergeConfiguredTargetRequest();
    message.requestId = object.requestId ?? "";
    message.configuredTarget = (object.configuredTarget !== undefined && object.configuredTarget !== null)
      ? ConfiguredTarget.fromPartial(object.configuredTarget)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    message.authorizationToken = object.authorizationToken ?? "";
    message.createIfNotFound = object.createIfNotFound ?? false;
    return message;
  },
};

function createBaseFinalizeConfiguredTargetRequest(): FinalizeConfiguredTargetRequest {
  return { name: "", authorizationToken: "" };
}

export const FinalizeConfiguredTargetRequest: MessageFns<FinalizeConfiguredTargetRequest> = {
  encode(message: FinalizeConfiguredTargetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.authorizationToken !== "") {
      writer.uint32(26).string(message.authorizationToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinalizeConfiguredTargetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalizeConfiguredTargetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.authorizationToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinalizeConfiguredTargetRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      authorizationToken: isSet(object.authorizationToken) ? globalThis.String(object.authorizationToken) : "",
    };
  },

  toJSON(message: FinalizeConfiguredTargetRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.authorizationToken !== "") {
      obj.authorizationToken = message.authorizationToken;
    }
    return obj;
  },

  create(base?: DeepPartial<FinalizeConfiguredTargetRequest>): FinalizeConfiguredTargetRequest {
    return FinalizeConfiguredTargetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FinalizeConfiguredTargetRequest>): FinalizeConfiguredTargetRequest {
    const message = createBaseFinalizeConfiguredTargetRequest();
    message.name = object.name ?? "";
    message.authorizationToken = object.authorizationToken ?? "";
    return message;
  },
};

function createBaseFinalizeConfiguredTargetResponse(): FinalizeConfiguredTargetResponse {
  return { name: "", id: undefined };
}

export const FinalizeConfiguredTargetResponse: MessageFns<FinalizeConfiguredTargetResponse> = {
  encode(message: FinalizeConfiguredTargetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.id !== undefined) {
      ConfiguredTarget_Id.encode(message.id, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinalizeConfiguredTargetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalizeConfiguredTargetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id = ConfiguredTarget_Id.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinalizeConfiguredTargetResponse {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      id: isSet(object.id) ? ConfiguredTarget_Id.fromJSON(object.id) : undefined,
    };
  },

  toJSON(message: FinalizeConfiguredTargetResponse): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.id !== undefined) {
      obj.id = ConfiguredTarget_Id.toJSON(message.id);
    }
    return obj;
  },

  create(base?: DeepPartial<FinalizeConfiguredTargetResponse>): FinalizeConfiguredTargetResponse {
    return FinalizeConfiguredTargetResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FinalizeConfiguredTargetResponse>): FinalizeConfiguredTargetResponse {
    const message = createBaseFinalizeConfiguredTargetResponse();
    message.name = object.name ?? "";
    message.id = (object.id !== undefined && object.id !== null)
      ? ConfiguredTarget_Id.fromPartial(object.id)
      : undefined;
    return message;
  },
};

function createBaseCreateActionRequest(): CreateActionRequest {
  return { requestId: "", parent: "", actionId: "", action: undefined, authorizationToken: "" };
}

export const CreateActionRequest: MessageFns<CreateActionRequest> = {
  encode(message: CreateActionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.parent !== "") {
      writer.uint32(18).string(message.parent);
    }
    if (message.actionId !== "") {
      writer.uint32(26).string(message.actionId);
    }
    if (message.action !== undefined) {
      Action.encode(message.action, writer.uint32(34).fork()).join();
    }
    if (message.authorizationToken !== "") {
      writer.uint32(42).string(message.authorizationToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateActionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateActionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.actionId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.action = Action.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.authorizationToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateActionRequest {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      actionId: isSet(object.actionId) ? globalThis.String(object.actionId) : "",
      action: isSet(object.action) ? Action.fromJSON(object.action) : undefined,
      authorizationToken: isSet(object.authorizationToken) ? globalThis.String(object.authorizationToken) : "",
    };
  },

  toJSON(message: CreateActionRequest): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.actionId !== "") {
      obj.actionId = message.actionId;
    }
    if (message.action !== undefined) {
      obj.action = Action.toJSON(message.action);
    }
    if (message.authorizationToken !== "") {
      obj.authorizationToken = message.authorizationToken;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateActionRequest>): CreateActionRequest {
    return CreateActionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateActionRequest>): CreateActionRequest {
    const message = createBaseCreateActionRequest();
    message.requestId = object.requestId ?? "";
    message.parent = object.parent ?? "";
    message.actionId = object.actionId ?? "";
    message.action = (object.action !== undefined && object.action !== null)
      ? Action.fromPartial(object.action)
      : undefined;
    message.authorizationToken = object.authorizationToken ?? "";
    return message;
  },
};

function createBaseUpdateActionRequest(): UpdateActionRequest {
  return { action: undefined, updateMask: undefined, authorizationToken: "", createIfNotFound: false };
}

export const UpdateActionRequest: MessageFns<UpdateActionRequest> = {
  encode(message: UpdateActionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.action !== undefined) {
      Action.encode(message.action, writer.uint32(26).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(34).fork()).join();
    }
    if (message.authorizationToken !== "") {
      writer.uint32(42).string(message.authorizationToken);
    }
    if (message.createIfNotFound !== false) {
      writer.uint32(48).bool(message.createIfNotFound);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateActionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateActionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.action = Action.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.authorizationToken = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.createIfNotFound = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateActionRequest {
    return {
      action: isSet(object.action) ? Action.fromJSON(object.action) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      authorizationToken: isSet(object.authorizationToken) ? globalThis.String(object.authorizationToken) : "",
      createIfNotFound: isSet(object.createIfNotFound) ? globalThis.Boolean(object.createIfNotFound) : false,
    };
  },

  toJSON(message: UpdateActionRequest): unknown {
    const obj: any = {};
    if (message.action !== undefined) {
      obj.action = Action.toJSON(message.action);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.authorizationToken !== "") {
      obj.authorizationToken = message.authorizationToken;
    }
    if (message.createIfNotFound !== false) {
      obj.createIfNotFound = message.createIfNotFound;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateActionRequest>): UpdateActionRequest {
    return UpdateActionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateActionRequest>): UpdateActionRequest {
    const message = createBaseUpdateActionRequest();
    message.action = (object.action !== undefined && object.action !== null)
      ? Action.fromPartial(object.action)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    message.authorizationToken = object.authorizationToken ?? "";
    message.createIfNotFound = object.createIfNotFound ?? false;
    return message;
  },
};

function createBaseMergeActionRequest(): MergeActionRequest {
  return { requestId: "", action: undefined, updateMask: undefined, authorizationToken: "", createIfNotFound: false };
}

export const MergeActionRequest: MessageFns<MergeActionRequest> = {
  encode(message: MergeActionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.action !== undefined) {
      Action.encode(message.action, writer.uint32(26).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(34).fork()).join();
    }
    if (message.authorizationToken !== "") {
      writer.uint32(42).string(message.authorizationToken);
    }
    if (message.createIfNotFound !== false) {
      writer.uint32(48).bool(message.createIfNotFound);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MergeActionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMergeActionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.action = Action.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.authorizationToken = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.createIfNotFound = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MergeActionRequest {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      action: isSet(object.action) ? Action.fromJSON(object.action) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      authorizationToken: isSet(object.authorizationToken) ? globalThis.String(object.authorizationToken) : "",
      createIfNotFound: isSet(object.createIfNotFound) ? globalThis.Boolean(object.createIfNotFound) : false,
    };
  },

  toJSON(message: MergeActionRequest): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.action !== undefined) {
      obj.action = Action.toJSON(message.action);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.authorizationToken !== "") {
      obj.authorizationToken = message.authorizationToken;
    }
    if (message.createIfNotFound !== false) {
      obj.createIfNotFound = message.createIfNotFound;
    }
    return obj;
  },

  create(base?: DeepPartial<MergeActionRequest>): MergeActionRequest {
    return MergeActionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MergeActionRequest>): MergeActionRequest {
    const message = createBaseMergeActionRequest();
    message.requestId = object.requestId ?? "";
    message.action = (object.action !== undefined && object.action !== null)
      ? Action.fromPartial(object.action)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    message.authorizationToken = object.authorizationToken ?? "";
    message.createIfNotFound = object.createIfNotFound ?? false;
    return message;
  },
};

function createBaseCreateConfigurationRequest(): CreateConfigurationRequest {
  return { requestId: "", parent: "", configId: "", configuration: undefined, authorizationToken: "" };
}

export const CreateConfigurationRequest: MessageFns<CreateConfigurationRequest> = {
  encode(message: CreateConfigurationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.parent !== "") {
      writer.uint32(18).string(message.parent);
    }
    if (message.configId !== "") {
      writer.uint32(26).string(message.configId);
    }
    if (message.configuration !== undefined) {
      Configuration.encode(message.configuration, writer.uint32(34).fork()).join();
    }
    if (message.authorizationToken !== "") {
      writer.uint32(42).string(message.authorizationToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateConfigurationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateConfigurationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.configId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.configuration = Configuration.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.authorizationToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateConfigurationRequest {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      configId: isSet(object.configId) ? globalThis.String(object.configId) : "",
      configuration: isSet(object.configuration) ? Configuration.fromJSON(object.configuration) : undefined,
      authorizationToken: isSet(object.authorizationToken) ? globalThis.String(object.authorizationToken) : "",
    };
  },

  toJSON(message: CreateConfigurationRequest): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.configId !== "") {
      obj.configId = message.configId;
    }
    if (message.configuration !== undefined) {
      obj.configuration = Configuration.toJSON(message.configuration);
    }
    if (message.authorizationToken !== "") {
      obj.authorizationToken = message.authorizationToken;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateConfigurationRequest>): CreateConfigurationRequest {
    return CreateConfigurationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateConfigurationRequest>): CreateConfigurationRequest {
    const message = createBaseCreateConfigurationRequest();
    message.requestId = object.requestId ?? "";
    message.parent = object.parent ?? "";
    message.configId = object.configId ?? "";
    message.configuration = (object.configuration !== undefined && object.configuration !== null)
      ? Configuration.fromPartial(object.configuration)
      : undefined;
    message.authorizationToken = object.authorizationToken ?? "";
    return message;
  },
};

function createBaseUpdateConfigurationRequest(): UpdateConfigurationRequest {
  return { configuration: undefined, updateMask: undefined, authorizationToken: "", createIfNotFound: false };
}

export const UpdateConfigurationRequest: MessageFns<UpdateConfigurationRequest> = {
  encode(message: UpdateConfigurationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.configuration !== undefined) {
      Configuration.encode(message.configuration, writer.uint32(26).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(34).fork()).join();
    }
    if (message.authorizationToken !== "") {
      writer.uint32(42).string(message.authorizationToken);
    }
    if (message.createIfNotFound !== false) {
      writer.uint32(48).bool(message.createIfNotFound);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateConfigurationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateConfigurationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.configuration = Configuration.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.authorizationToken = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.createIfNotFound = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateConfigurationRequest {
    return {
      configuration: isSet(object.configuration) ? Configuration.fromJSON(object.configuration) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      authorizationToken: isSet(object.authorizationToken) ? globalThis.String(object.authorizationToken) : "",
      createIfNotFound: isSet(object.createIfNotFound) ? globalThis.Boolean(object.createIfNotFound) : false,
    };
  },

  toJSON(message: UpdateConfigurationRequest): unknown {
    const obj: any = {};
    if (message.configuration !== undefined) {
      obj.configuration = Configuration.toJSON(message.configuration);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.authorizationToken !== "") {
      obj.authorizationToken = message.authorizationToken;
    }
    if (message.createIfNotFound !== false) {
      obj.createIfNotFound = message.createIfNotFound;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateConfigurationRequest>): UpdateConfigurationRequest {
    return UpdateConfigurationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateConfigurationRequest>): UpdateConfigurationRequest {
    const message = createBaseUpdateConfigurationRequest();
    message.configuration = (object.configuration !== undefined && object.configuration !== null)
      ? Configuration.fromPartial(object.configuration)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    message.authorizationToken = object.authorizationToken ?? "";
    message.createIfNotFound = object.createIfNotFound ?? false;
    return message;
  },
};

function createBaseCreateFileSetRequest(): CreateFileSetRequest {
  return { requestId: "", parent: "", fileSetId: "", fileSet: undefined, authorizationToken: "" };
}

export const CreateFileSetRequest: MessageFns<CreateFileSetRequest> = {
  encode(message: CreateFileSetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.parent !== "") {
      writer.uint32(18).string(message.parent);
    }
    if (message.fileSetId !== "") {
      writer.uint32(26).string(message.fileSetId);
    }
    if (message.fileSet !== undefined) {
      FileSet.encode(message.fileSet, writer.uint32(34).fork()).join();
    }
    if (message.authorizationToken !== "") {
      writer.uint32(42).string(message.authorizationToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateFileSetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateFileSetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.fileSetId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.fileSet = FileSet.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.authorizationToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateFileSetRequest {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      fileSetId: isSet(object.fileSetId) ? globalThis.String(object.fileSetId) : "",
      fileSet: isSet(object.fileSet) ? FileSet.fromJSON(object.fileSet) : undefined,
      authorizationToken: isSet(object.authorizationToken) ? globalThis.String(object.authorizationToken) : "",
    };
  },

  toJSON(message: CreateFileSetRequest): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.fileSetId !== "") {
      obj.fileSetId = message.fileSetId;
    }
    if (message.fileSet !== undefined) {
      obj.fileSet = FileSet.toJSON(message.fileSet);
    }
    if (message.authorizationToken !== "") {
      obj.authorizationToken = message.authorizationToken;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateFileSetRequest>): CreateFileSetRequest {
    return CreateFileSetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateFileSetRequest>): CreateFileSetRequest {
    const message = createBaseCreateFileSetRequest();
    message.requestId = object.requestId ?? "";
    message.parent = object.parent ?? "";
    message.fileSetId = object.fileSetId ?? "";
    message.fileSet = (object.fileSet !== undefined && object.fileSet !== null)
      ? FileSet.fromPartial(object.fileSet)
      : undefined;
    message.authorizationToken = object.authorizationToken ?? "";
    return message;
  },
};

function createBaseUpdateFileSetRequest(): UpdateFileSetRequest {
  return { fileSet: undefined, updateMask: undefined, authorizationToken: "", createIfNotFound: false };
}

export const UpdateFileSetRequest: MessageFns<UpdateFileSetRequest> = {
  encode(message: UpdateFileSetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fileSet !== undefined) {
      FileSet.encode(message.fileSet, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    if (message.authorizationToken !== "") {
      writer.uint32(26).string(message.authorizationToken);
    }
    if (message.createIfNotFound !== false) {
      writer.uint32(32).bool(message.createIfNotFound);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateFileSetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateFileSetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fileSet = FileSet.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.authorizationToken = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.createIfNotFound = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateFileSetRequest {
    return {
      fileSet: isSet(object.fileSet) ? FileSet.fromJSON(object.fileSet) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      authorizationToken: isSet(object.authorizationToken) ? globalThis.String(object.authorizationToken) : "",
      createIfNotFound: isSet(object.createIfNotFound) ? globalThis.Boolean(object.createIfNotFound) : false,
    };
  },

  toJSON(message: UpdateFileSetRequest): unknown {
    const obj: any = {};
    if (message.fileSet !== undefined) {
      obj.fileSet = FileSet.toJSON(message.fileSet);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.authorizationToken !== "") {
      obj.authorizationToken = message.authorizationToken;
    }
    if (message.createIfNotFound !== false) {
      obj.createIfNotFound = message.createIfNotFound;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateFileSetRequest>): UpdateFileSetRequest {
    return UpdateFileSetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateFileSetRequest>): UpdateFileSetRequest {
    const message = createBaseUpdateFileSetRequest();
    message.fileSet = (object.fileSet !== undefined && object.fileSet !== null)
      ? FileSet.fromPartial(object.fileSet)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    message.authorizationToken = object.authorizationToken ?? "";
    message.createIfNotFound = object.createIfNotFound ?? false;
    return message;
  },
};

function createBaseMergeFileSetRequest(): MergeFileSetRequest {
  return { requestId: "", fileSet: undefined, updateMask: undefined, authorizationToken: "", createIfNotFound: false };
}

export const MergeFileSetRequest: MessageFns<MergeFileSetRequest> = {
  encode(message: MergeFileSetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.fileSet !== undefined) {
      FileSet.encode(message.fileSet, writer.uint32(18).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(26).fork()).join();
    }
    if (message.authorizationToken !== "") {
      writer.uint32(34).string(message.authorizationToken);
    }
    if (message.createIfNotFound !== false) {
      writer.uint32(40).bool(message.createIfNotFound);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MergeFileSetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMergeFileSetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fileSet = FileSet.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.authorizationToken = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.createIfNotFound = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MergeFileSetRequest {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      fileSet: isSet(object.fileSet) ? FileSet.fromJSON(object.fileSet) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      authorizationToken: isSet(object.authorizationToken) ? globalThis.String(object.authorizationToken) : "",
      createIfNotFound: isSet(object.createIfNotFound) ? globalThis.Boolean(object.createIfNotFound) : false,
    };
  },

  toJSON(message: MergeFileSetRequest): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.fileSet !== undefined) {
      obj.fileSet = FileSet.toJSON(message.fileSet);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.authorizationToken !== "") {
      obj.authorizationToken = message.authorizationToken;
    }
    if (message.createIfNotFound !== false) {
      obj.createIfNotFound = message.createIfNotFound;
    }
    return obj;
  },

  create(base?: DeepPartial<MergeFileSetRequest>): MergeFileSetRequest {
    return MergeFileSetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MergeFileSetRequest>): MergeFileSetRequest {
    const message = createBaseMergeFileSetRequest();
    message.requestId = object.requestId ?? "";
    message.fileSet = (object.fileSet !== undefined && object.fileSet !== null)
      ? FileSet.fromPartial(object.fileSet)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    message.authorizationToken = object.authorizationToken ?? "";
    message.createIfNotFound = object.createIfNotFound ?? false;
    return message;
  },
};

function createBaseUploadBatchRequest(): UploadBatchRequest {
  return {
    parent: "",
    authorizationToken: "",
    nextResumeToken: "",
    resumeToken: "",
    uploaderState: Buffer.alloc(0),
    uploadRequests: [],
  };
}

export const UploadBatchRequest: MessageFns<UploadBatchRequest> = {
  encode(message: UploadBatchRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.authorizationToken !== "") {
      writer.uint32(18).string(message.authorizationToken);
    }
    if (message.nextResumeToken !== "") {
      writer.uint32(26).string(message.nextResumeToken);
    }
    if (message.resumeToken !== "") {
      writer.uint32(34).string(message.resumeToken);
    }
    if (message.uploaderState.length !== 0) {
      writer.uint32(50).bytes(message.uploaderState);
    }
    for (const v of message.uploadRequests) {
      UploadRequest.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UploadBatchRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadBatchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.authorizationToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nextResumeToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.resumeToken = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.uploaderState = Buffer.from(reader.bytes());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.uploadRequests.push(UploadRequest.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UploadBatchRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      authorizationToken: isSet(object.authorizationToken) ? globalThis.String(object.authorizationToken) : "",
      nextResumeToken: isSet(object.nextResumeToken) ? globalThis.String(object.nextResumeToken) : "",
      resumeToken: isSet(object.resumeToken) ? globalThis.String(object.resumeToken) : "",
      uploaderState: isSet(object.uploaderState) ? Buffer.from(bytesFromBase64(object.uploaderState)) : Buffer.alloc(0),
      uploadRequests: globalThis.Array.isArray(object?.uploadRequests)
        ? object.uploadRequests.map((e: any) => UploadRequest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UploadBatchRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.authorizationToken !== "") {
      obj.authorizationToken = message.authorizationToken;
    }
    if (message.nextResumeToken !== "") {
      obj.nextResumeToken = message.nextResumeToken;
    }
    if (message.resumeToken !== "") {
      obj.resumeToken = message.resumeToken;
    }
    if (message.uploaderState.length !== 0) {
      obj.uploaderState = base64FromBytes(message.uploaderState);
    }
    if (message.uploadRequests?.length) {
      obj.uploadRequests = message.uploadRequests.map((e) => UploadRequest.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<UploadBatchRequest>): UploadBatchRequest {
    return UploadBatchRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UploadBatchRequest>): UploadBatchRequest {
    const message = createBaseUploadBatchRequest();
    message.parent = object.parent ?? "";
    message.authorizationToken = object.authorizationToken ?? "";
    message.nextResumeToken = object.nextResumeToken ?? "";
    message.resumeToken = object.resumeToken ?? "";
    message.uploaderState = object.uploaderState ?? Buffer.alloc(0);
    message.uploadRequests = object.uploadRequests?.map((e) => UploadRequest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUploadBatchResponse(): UploadBatchResponse {
  return {};
}

export const UploadBatchResponse: MessageFns<UploadBatchResponse> = {
  encode(_: UploadBatchResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UploadBatchResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadBatchResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UploadBatchResponse {
    return {};
  },

  toJSON(_: UploadBatchResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<UploadBatchResponse>): UploadBatchResponse {
    return UploadBatchResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<UploadBatchResponse>): UploadBatchResponse {
    const message = createBaseUploadBatchResponse();
    return message;
  },
};

function createBaseUploadRequest(): UploadRequest {
  return {
    id: undefined,
    uploadOperation: 0,
    updateMask: undefined,
    createIfNotFound: false,
    invocation: undefined,
    target: undefined,
    configuration: undefined,
    configuredTarget: undefined,
    action: undefined,
    fileSet: undefined,
  };
}

export const UploadRequest: MessageFns<UploadRequest> = {
  encode(message: UploadRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      UploadRequest_Id.encode(message.id, writer.uint32(10).fork()).join();
    }
    if (message.uploadOperation !== 0) {
      writer.uint32(16).int32(message.uploadOperation);
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(26).fork()).join();
    }
    if (message.createIfNotFound !== false) {
      writer.uint32(80).bool(message.createIfNotFound);
    }
    if (message.invocation !== undefined) {
      Invocation.encode(message.invocation, writer.uint32(34).fork()).join();
    }
    if (message.target !== undefined) {
      Target.encode(message.target, writer.uint32(42).fork()).join();
    }
    if (message.configuration !== undefined) {
      Configuration.encode(message.configuration, writer.uint32(50).fork()).join();
    }
    if (message.configuredTarget !== undefined) {
      ConfiguredTarget.encode(message.configuredTarget, writer.uint32(58).fork()).join();
    }
    if (message.action !== undefined) {
      Action.encode(message.action, writer.uint32(66).fork()).join();
    }
    if (message.fileSet !== undefined) {
      FileSet.encode(message.fileSet, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UploadRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = UploadRequest_Id.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.uploadOperation = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.createIfNotFound = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.invocation = Invocation.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.target = Target.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.configuration = Configuration.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.configuredTarget = ConfiguredTarget.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.action = Action.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.fileSet = FileSet.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UploadRequest {
    return {
      id: isSet(object.id) ? UploadRequest_Id.fromJSON(object.id) : undefined,
      uploadOperation: isSet(object.uploadOperation)
        ? uploadRequest_UploadOperationFromJSON(object.uploadOperation)
        : 0,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      createIfNotFound: isSet(object.createIfNotFound) ? globalThis.Boolean(object.createIfNotFound) : false,
      invocation: isSet(object.invocation) ? Invocation.fromJSON(object.invocation) : undefined,
      target: isSet(object.target) ? Target.fromJSON(object.target) : undefined,
      configuration: isSet(object.configuration) ? Configuration.fromJSON(object.configuration) : undefined,
      configuredTarget: isSet(object.configuredTarget) ? ConfiguredTarget.fromJSON(object.configuredTarget) : undefined,
      action: isSet(object.action) ? Action.fromJSON(object.action) : undefined,
      fileSet: isSet(object.fileSet) ? FileSet.fromJSON(object.fileSet) : undefined,
    };
  },

  toJSON(message: UploadRequest): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = UploadRequest_Id.toJSON(message.id);
    }
    if (message.uploadOperation !== 0) {
      obj.uploadOperation = uploadRequest_UploadOperationToJSON(message.uploadOperation);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.createIfNotFound !== false) {
      obj.createIfNotFound = message.createIfNotFound;
    }
    if (message.invocation !== undefined) {
      obj.invocation = Invocation.toJSON(message.invocation);
    }
    if (message.target !== undefined) {
      obj.target = Target.toJSON(message.target);
    }
    if (message.configuration !== undefined) {
      obj.configuration = Configuration.toJSON(message.configuration);
    }
    if (message.configuredTarget !== undefined) {
      obj.configuredTarget = ConfiguredTarget.toJSON(message.configuredTarget);
    }
    if (message.action !== undefined) {
      obj.action = Action.toJSON(message.action);
    }
    if (message.fileSet !== undefined) {
      obj.fileSet = FileSet.toJSON(message.fileSet);
    }
    return obj;
  },

  create(base?: DeepPartial<UploadRequest>): UploadRequest {
    return UploadRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UploadRequest>): UploadRequest {
    const message = createBaseUploadRequest();
    message.id = (object.id !== undefined && object.id !== null) ? UploadRequest_Id.fromPartial(object.id) : undefined;
    message.uploadOperation = object.uploadOperation ?? 0;
    message.updateMask = object.updateMask ?? undefined;
    message.createIfNotFound = object.createIfNotFound ?? false;
    message.invocation = (object.invocation !== undefined && object.invocation !== null)
      ? Invocation.fromPartial(object.invocation)
      : undefined;
    message.target = (object.target !== undefined && object.target !== null)
      ? Target.fromPartial(object.target)
      : undefined;
    message.configuration = (object.configuration !== undefined && object.configuration !== null)
      ? Configuration.fromPartial(object.configuration)
      : undefined;
    message.configuredTarget = (object.configuredTarget !== undefined && object.configuredTarget !== null)
      ? ConfiguredTarget.fromPartial(object.configuredTarget)
      : undefined;
    message.action = (object.action !== undefined && object.action !== null)
      ? Action.fromPartial(object.action)
      : undefined;
    message.fileSet = (object.fileSet !== undefined && object.fileSet !== null)
      ? FileSet.fromPartial(object.fileSet)
      : undefined;
    return message;
  },
};

function createBaseUploadRequest_Id(): UploadRequest_Id {
  return { targetId: "", configurationId: "", actionId: "", fileSetId: "" };
}

export const UploadRequest_Id: MessageFns<UploadRequest_Id> = {
  encode(message: UploadRequest_Id, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.targetId !== "") {
      writer.uint32(10).string(message.targetId);
    }
    if (message.configurationId !== "") {
      writer.uint32(18).string(message.configurationId);
    }
    if (message.actionId !== "") {
      writer.uint32(26).string(message.actionId);
    }
    if (message.fileSetId !== "") {
      writer.uint32(34).string(message.fileSetId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UploadRequest_Id {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadRequest_Id();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.targetId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.configurationId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.actionId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.fileSetId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UploadRequest_Id {
    return {
      targetId: isSet(object.targetId) ? globalThis.String(object.targetId) : "",
      configurationId: isSet(object.configurationId) ? globalThis.String(object.configurationId) : "",
      actionId: isSet(object.actionId) ? globalThis.String(object.actionId) : "",
      fileSetId: isSet(object.fileSetId) ? globalThis.String(object.fileSetId) : "",
    };
  },

  toJSON(message: UploadRequest_Id): unknown {
    const obj: any = {};
    if (message.targetId !== "") {
      obj.targetId = message.targetId;
    }
    if (message.configurationId !== "") {
      obj.configurationId = message.configurationId;
    }
    if (message.actionId !== "") {
      obj.actionId = message.actionId;
    }
    if (message.fileSetId !== "") {
      obj.fileSetId = message.fileSetId;
    }
    return obj;
  },

  create(base?: DeepPartial<UploadRequest_Id>): UploadRequest_Id {
    return UploadRequest_Id.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UploadRequest_Id>): UploadRequest_Id {
    const message = createBaseUploadRequest_Id();
    message.targetId = object.targetId ?? "";
    message.configurationId = object.configurationId ?? "";
    message.actionId = object.actionId ?? "";
    message.fileSetId = object.fileSetId ?? "";
    return message;
  },
};

function createBaseGetInvocationUploadMetadataRequest(): GetInvocationUploadMetadataRequest {
  return { name: "", authorizationToken: "" };
}

export const GetInvocationUploadMetadataRequest: MessageFns<GetInvocationUploadMetadataRequest> = {
  encode(message: GetInvocationUploadMetadataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.authorizationToken !== "") {
      writer.uint32(18).string(message.authorizationToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInvocationUploadMetadataRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInvocationUploadMetadataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.authorizationToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInvocationUploadMetadataRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      authorizationToken: isSet(object.authorizationToken) ? globalThis.String(object.authorizationToken) : "",
    };
  },

  toJSON(message: GetInvocationUploadMetadataRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.authorizationToken !== "") {
      obj.authorizationToken = message.authorizationToken;
    }
    return obj;
  },

  create(base?: DeepPartial<GetInvocationUploadMetadataRequest>): GetInvocationUploadMetadataRequest {
    return GetInvocationUploadMetadataRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetInvocationUploadMetadataRequest>): GetInvocationUploadMetadataRequest {
    const message = createBaseGetInvocationUploadMetadataRequest();
    message.name = object.name ?? "";
    message.authorizationToken = object.authorizationToken ?? "";
    return message;
  },
};

/**
 * This is the interface used to upload information to the ResultStore database,
 * to update that information as necessary, and to make it immutable at the end.
 *
 * This interface intentionally does not support user read-modify-write
 * operations. They may corrupt data, and are too expensive. For the same
 * reason, all upload RPCs will return no resource fields except name and ID. An
 * uploader should hold as little state as possible in memory to avoid running
 * out of memory.
 */
export type ResultStoreUploadDefinition = typeof ResultStoreUploadDefinition;
export const ResultStoreUploadDefinition = {
  name: "ResultStoreUpload",
  fullName: "google.devtools.resultstore.v2.ResultStoreUpload",
  methods: {
    /**
     * Creates the given invocation.
     *
     * This is not an implicitly idempotent API, so a request id is required to
     * make it idempotent.
     *
     * Returns an empty Invocation proto with only the name and ID fields
     * populated.
     *
     * An error will be reported in the following cases:
     * - If an invocation with the same ID already exists.
     */
    createInvocation: {
      name: "CreateInvocation",
      requestType: CreateInvocationRequest,
      requestStream: false,
      responseType: Invocation,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              55,
              114,
              101,
              113,
              117,
              101,
              115,
              116,
              95,
              105,
              100,
              44,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              44,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              95,
              105,
              100,
              44,
              97,
              117,
              116,
              104,
              111,
              114,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              95,
              116,
              111,
              107,
              101,
              110,
            ]),
          ],
          578365826: [
            Buffer.from([
              29,
              58,
              10,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              34,
              15,
              47,
              118,
              50,
              47,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Applies a standard update to the invocation identified by the given proto's
     * name.  For all types of fields (primitive, message, or repeated), replaces
     * them with the given proto fields if they are under the given field mask
     * paths.  Fields that match the mask but aren't populated in the given
     * invocation are cleared. This is an implicitly idempotent API.
     *
     * Returns an empty Invocation proto with only the name and ID fields
     * populated.
     *
     * An error will be reported in the following cases:
     * - If the invocation does not exist.
     * - If the invocation is finalized.
     * - If no field mask was given.
     */
    updateInvocation: {
      name: "UpdateInvocation",
      requestType: UpdateInvocationRequest,
      requestStream: false,
      responseType: Invocation,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              42,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
              44,
              97,
              117,
              116,
              104,
              111,
              114,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              95,
              116,
              111,
              107,
              101,
              110,
            ]),
          ],
          578365826: [
            Buffer.from([
              49,
              58,
              10,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              50,
              35,
              47,
              118,
              50,
              47,
              123,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              46,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Applies a merge update to the invocation identified by the given proto's
     * name.  For primitive and message fields, replaces them with the ones in
     * the given proto if they are covered under the field mask paths.  For
     * repeated fields, merges to them with the given ones if they are covered
     * under the field mask paths. This is not an implicitly idempotent API, so a
     * request id is required to make it idempotent.
     *
     * Returns an empty Invocation proto with only the name and ID fields
     * populated.
     *
     * An error will be reported in the following cases:
     * - If the invocation does not exist.
     * - If the invocation is finalized.
     * - If no field mask was given.
     */
    mergeInvocation: {
      name: "MergeInvocation",
      requestType: MergeInvocationRequest,
      requestStream: false,
      responseType: Invocation,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              46,
              58,
              1,
              42,
              34,
              41,
              47,
              118,
              50,
              47,
              123,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              46,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              109,
              101,
              114,
              103,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Touches the invocation identified by the given proto's name.
     *
     * This is useful when you need to notify ResultStore that you haven't
     * abandoned the upload, since abandoned uploads will be automatically
     * finalized after a set period.
     *
     * An error will be reported in the following cases:
     * - If the invocation does not exist.
     * - If the invocation is finalized.
     */
    touchInvocation: {
      name: "TouchInvocation",
      requestType: TouchInvocationRequest,
      requestStream: false,
      responseType: TouchInvocationResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              35,
              58,
              1,
              42,
              34,
              30,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              116,
              111,
              117,
              99,
              104,
            ]),
          ],
        },
      },
    },
    /**
     * Declares the invocation with the given name as finalized and immutable by
     * the user. It may still be mutated by post-processing. This is an implicitly
     * idempotent API.
     *
     * If an Invocation is not updated for 24 hours, some time after that
     * this will be called automatically.
     *
     * An error will be reported in the following cases:
     * - If the invocation does not exist.
     */
    finalizeInvocation: {
      name: "FinalizeInvocation",
      requestType: FinalizeInvocationRequest,
      requestStream: false,
      responseType: FinalizeInvocationResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              38,
              58,
              1,
              42,
              34,
              33,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              102,
              105,
              110,
              97,
              108,
              105,
              122,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes an immutable invocation (permanently)
     * Note: this does not delete indirect data, e.g. files stored in other
     * services.
     *
     * An error will be reported in the following cases:
     * - If the invocation does not exist.
     * - If the invocation is not finalized.  This can be retried until it is.
     */
    deleteInvocation: {
      name: "DeleteInvocation",
      requestType: DeleteInvocationRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              26,
              42,
              24,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Creates the given target under the given parent invocation. The given
     * target ID is URL encoded, converted to the full resource name, and assigned
     * to the target's name field. This is not an implicitly idempotent API, so a
     * request id is required to make it idempotent.
     *
     * Returns an empty Target proto with only the name and ID fields populated.
     *
     * An error will be reported in the following cases:
     * - If no target ID is provided.
     * - If the parent invocation does not exist.
     * - If the parent invocation is finalized.
     * - If a target with the same name already exists.
     */
    createTarget: {
      name: "CreateTarget",
      requestType: CreateTargetRequest,
      requestStream: false,
      responseType: Target,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              54,
              114,
              101,
              113,
              117,
              101,
              115,
              116,
              95,
              105,
              100,
              44,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              116,
              97,
              114,
              103,
              101,
              116,
              44,
              116,
              97,
              114,
              103,
              101,
              116,
              95,
              105,
              100,
              44,
              97,
              117,
              116,
              104,
              111,
              114,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              95,
              116,
              111,
              107,
              101,
              110,
            ]),
          ],
          578365826: [
            Buffer.from([
              44,
              58,
              6,
              116,
              97,
              114,
              103,
              101,
              116,
              34,
              34,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              116,
              97,
              114,
              103,
              101,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Applies a standard update to the target identified by the given proto's
     * name. For all types of fields (primitive, message, or repeated), replaces
     * them with the given proto fields if they are under the given field mask
     * paths. Fields that match the mask but aren't populated in the given
     * target are cleared. This is an implicitly idempotent API.
     *
     * Returns an empty Target proto with only the name and ID fields populated.
     *
     * An error will be reported in the following cases:
     * - If the target does not exist.
     * - If the target or parent invocation is finalized.
     * - If no field mask was given.
     */
    updateTarget: {
      name: "UpdateTarget",
      requestType: UpdateTargetRequest,
      requestStream: false,
      responseType: Target,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              38,
              116,
              97,
              114,
              103,
              101,
              116,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
              44,
              97,
              117,
              116,
              104,
              111,
              114,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              95,
              116,
              111,
              107,
              101,
              110,
            ]),
          ],
          578365826: [
            Buffer.from([
              51,
              58,
              6,
              116,
              97,
              114,
              103,
              101,
              116,
              50,
              41,
              47,
              118,
              50,
              47,
              123,
              116,
              97,
              114,
              103,
              101,
              116,
              46,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              116,
              97,
              114,
              103,
              101,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Applies a merge update to the target identified by the given proto's
     * name. For primitive and message fields, replaces them with the ones in the
     * given proto if they are covered under the field mask paths.  For repeated
     * fields, merges to them with the given ones if they are covered under the
     * field mask paths. This is not an implicitly idempotent API, so a request
     * id is required to make it idempotent.
     *
     * Returns an empty Target proto with only the name and ID fields populated.
     *
     * An error will be reported in the following cases:
     * - If the target does not exist.
     * - If the target or parent invocation is finalized.
     * - If no field mask was given.
     */
    mergeTarget: {
      name: "MergeTarget",
      requestType: MergeTargetRequest,
      requestStream: false,
      responseType: Target,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              52,
              58,
              1,
              42,
              34,
              47,
              47,
              118,
              50,
              47,
              123,
              116,
              97,
              114,
              103,
              101,
              116,
              46,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              116,
              97,
              114,
              103,
              101,
              116,
              115,
              47,
              42,
              125,
              58,
              109,
              101,
              114,
              103,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Declares the target with the given name as finalized and immutable by the
     * user. It may still be mutated by post-processing. This is an implicitly
     * idempotent API.
     *
     * An error will be reported in the following cases:
     * - If the target does not exist.
     */
    finalizeTarget: {
      name: "FinalizeTarget",
      requestType: FinalizeTargetRequest,
      requestStream: false,
      responseType: FinalizeTargetResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              48,
              58,
              1,
              42,
              34,
              43,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              116,
              97,
              114,
              103,
              101,
              116,
              115,
              47,
              42,
              125,
              58,
              102,
              105,
              110,
              97,
              108,
              105,
              122,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Creates the given configured target under the given parent target.
     * The given configured target ID is URL encoded, converted to the full
     * resource name, and assigned to the configured target's name field.
     * This is not an implicitly idempotent API, so a request id is required
     * to make it idempotent.
     *
     * Returns an empty ConfiguredTarget proto with only the name and ID fields
     * populated.
     *
     * An error will be reported in the following cases:
     * - If no config ID is provided.
     * - If a configured target with the same ID already exists.
     * - If the parent target does not exist.
     * - If the parent target or invocation is finalized.
     */
    createConfiguredTarget: {
      name: "CreateConfiguredTarget",
      requestType: CreateConfiguredTargetRequest,
      requestStream: false,
      responseType: ConfiguredTarget,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              65,
              114,
              101,
              113,
              117,
              101,
              115,
              116,
              95,
              105,
              100,
              44,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              99,
              111,
              110,
              102,
              105,
              103,
              117,
              114,
              101,
              100,
              95,
              116,
              97,
              114,
              103,
              101,
              116,
              44,
              99,
              111,
              110,
              102,
              105,
              103,
              95,
              105,
              100,
              44,
              97,
              117,
              116,
              104,
              111,
              114,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              95,
              116,
              111,
              107,
              101,
              110,
            ]),
          ],
          578365826: [
            Buffer.from([
              75,
              58,
              17,
              99,
              111,
              110,
              102,
              105,
              103,
              117,
              114,
              101,
              100,
              95,
              116,
              97,
              114,
              103,
              101,
              116,
              34,
              54,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              116,
              97,
              114,
              103,
              101,
              116,
              115,
              47,
              42,
              125,
              47,
              99,
              111,
              110,
              102,
              105,
              103,
              117,
              114,
              101,
              100,
              84,
              97,
              114,
              103,
              101,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Applies a standard update to the configured target identified by the given
     * proto's name. For all types of fields (primitive, message, or repeated),
     * replaces them with the given proto fields if they are under the given
     * field mask paths. Fields that match the mask but aren't populated in the
     * given configured target are cleared. This is an implicitly idempotent API.
     *
     * Returns an empty ConfiguredTarget proto with only the name and ID fields
     * populated.
     *
     * An error will be reported in the following cases:
     * - If the configured target does not exist.
     * - If the parent target or invocation is finalized.
     * - If no field mask was given.
     */
    updateConfiguredTarget: {
      name: "UpdateConfiguredTarget",
      requestType: UpdateConfiguredTargetRequest,
      requestStream: false,
      responseType: ConfiguredTarget,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              49,
              99,
              111,
              110,
              102,
              105,
              103,
              117,
              114,
              101,
              100,
              95,
              116,
              97,
              114,
              103,
              101,
              116,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
              44,
              97,
              117,
              116,
              104,
              111,
              114,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              95,
              116,
              111,
              107,
              101,
              110,
            ]),
          ],
          578365826: [
            Buffer.from([
              93,
              58,
              17,
              99,
              111,
              110,
              102,
              105,
              103,
              117,
              114,
              101,
              100,
              95,
              116,
              97,
              114,
              103,
              101,
              116,
              50,
              72,
              47,
              118,
              50,
              47,
              123,
              99,
              111,
              110,
              102,
              105,
              103,
              117,
              114,
              101,
              100,
              95,
              116,
              97,
              114,
              103,
              101,
              116,
              46,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              116,
              97,
              114,
              103,
              101,
              116,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              102,
              105,
              103,
              117,
              114,
              101,
              100,
              84,
              97,
              114,
              103,
              101,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Applies a merge update to the configured target identified by the given
     * proto's name. For primitive and message fields, replaces them with the
     * ones in the given proto if they are covered under the field mask paths.
     * For repeated fields, merges to them with the given ones if they are
     * covered under the field mask paths. This is not an implicitly idempotent
     * API, so a request id is required to make it idempotent.
     *
     * Returns an empty ConfiguredTarget proto with only the name and ID fields
     * populated.
     *
     * An error will be reported in the following cases:
     * - If the configured target does not exist.
     * - If the parent target or invocation is finalized.
     * - If no field mask was given.
     */
    mergeConfiguredTarget: {
      name: "MergeConfiguredTarget",
      requestType: MergeConfiguredTargetRequest,
      requestStream: false,
      responseType: ConfiguredTarget,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              83,
              58,
              1,
              42,
              34,
              78,
              47,
              118,
              50,
              47,
              123,
              99,
              111,
              110,
              102,
              105,
              103,
              117,
              114,
              101,
              100,
              95,
              116,
              97,
              114,
              103,
              101,
              116,
              46,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              116,
              97,
              114,
              103,
              101,
              116,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              102,
              105,
              103,
              117,
              114,
              101,
              100,
              84,
              97,
              114,
              103,
              101,
              116,
              115,
              47,
              42,
              125,
              58,
              109,
              101,
              114,
              103,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Declares the configured target with the given name as finalized and
     * immutable by the user. It may still be mutated by post-processing. This is
     * an implicitly idempotent API.
     *
     * An error will be reported in the following cases:
     * - If the configured target does not exist.
     */
    finalizeConfiguredTarget: {
      name: "FinalizeConfiguredTarget",
      requestType: FinalizeConfiguredTargetRequest,
      requestStream: false,
      responseType: FinalizeConfiguredTargetResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              68,
              58,
              1,
              42,
              34,
              63,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              116,
              97,
              114,
              103,
              101,
              116,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              102,
              105,
              103,
              117,
              114,
              101,
              100,
              84,
              97,
              114,
              103,
              101,
              116,
              115,
              47,
              42,
              125,
              58,
              102,
              105,
              110,
              97,
              108,
              105,
              122,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Creates the given action under the given configured target. The given
     * action ID is URL encoded, converted to the full resource name, and
     * assigned to the action's name field. This is not an implicitly
     * idempotent API, so a request id is required to make it idempotent.
     *
     * Returns an empty Action proto with only the name and ID fields populated.
     *
     * An error will be reported in the following cases:
     * - If no action ID provided.
     * - If the parent configured target does not exist.
     * - If the parent target or invocation is finalized.
     * - If an action  with the same name already exists.
     */
    createAction: {
      name: "CreateAction",
      requestType: CreateActionRequest,
      requestStream: false,
      responseType: Action,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              54,
              114,
              101,
              113,
              117,
              101,
              115,
              116,
              95,
              105,
              100,
              44,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              97,
              99,
              116,
              105,
              111,
              110,
              44,
              97,
              99,
              116,
              105,
              111,
              110,
              95,
              105,
              100,
              44,
              97,
              117,
              116,
              104,
              111,
              114,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              95,
              116,
              111,
              107,
              101,
              110,
            ]),
          ],
          578365826: [
            Buffer.from([
              74,
              58,
              6,
              97,
              99,
              116,
              105,
              111,
              110,
              34,
              64,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              116,
              97,
              114,
              103,
              101,
              116,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              102,
              105,
              103,
              117,
              114,
              101,
              100,
              84,
              97,
              114,
              103,
              101,
              116,
              115,
              47,
              42,
              125,
              47,
              97,
              99,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Applies a standard update to the action identified by the given
     * proto's name.  For all types of fields (primitive, message, or repeated),
     * replaces them with the given proto fields if they are under the given
     * field mask paths.  Fields that match the mask but aren't populated in the
     * given action are cleared.  This is an implicitly idempotent API.
     *
     * Returns an empty Action proto with only the name and ID fields populated.
     *
     * An error will be reported in the following cases:
     * - If the action does not exist.
     * - If the parent target or invocation is finalized.
     * - If no field mask was given.
     */
    updateAction: {
      name: "UpdateAction",
      requestType: UpdateActionRequest,
      requestStream: false,
      responseType: Action,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              38,
              97,
              99,
              116,
              105,
              111,
              110,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
              44,
              97,
              117,
              116,
              104,
              111,
              114,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              95,
              116,
              111,
              107,
              101,
              110,
            ]),
          ],
          578365826: [
            Buffer.from([
              81,
              58,
              6,
              97,
              99,
              116,
              105,
              111,
              110,
              50,
              71,
              47,
              118,
              50,
              47,
              123,
              97,
              99,
              116,
              105,
              111,
              110,
              46,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              116,
              97,
              114,
              103,
              101,
              116,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              102,
              105,
              103,
              117,
              114,
              101,
              100,
              84,
              97,
              114,
              103,
              101,
              116,
              115,
              47,
              42,
              47,
              97,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Applies a merge update to the action identified by the given
     * proto's name.  For primitive and message fields, replaces them with the
     * ones in the given proto if they are covered under the field mask paths.
     * For repeated fields, merges to them with the given ones if they are
     * covered under the field mask paths. This is not an implicitly idempotent
     * API, so a request id is required to make it idempotent.
     *
     * Returns an empty Action proto with only the name and ID fields populated.
     *
     * An error will be reported in the following cases:
     * - If the action does not exist.
     * - If the parent target or invocation is finalized.
     * - If no field mask was given.
     */
    mergeAction: {
      name: "MergeAction",
      requestType: MergeActionRequest,
      requestStream: false,
      responseType: Action,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              82,
              58,
              1,
              42,
              34,
              77,
              47,
              118,
              50,
              47,
              123,
              97,
              99,
              116,
              105,
              111,
              110,
              46,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              116,
              97,
              114,
              103,
              101,
              116,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              102,
              105,
              103,
              117,
              114,
              101,
              100,
              84,
              97,
              114,
              103,
              101,
              116,
              115,
              47,
              42,
              47,
              97,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              109,
              101,
              114,
              103,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Creates the given configuration under the given parent invocation. The
     * given configuration ID is URL encoded, converted to the full resource name,
     * and assigned to the configuration's name field. The configuration ID of
     * "default" should be preferred for the default configuration in a
     * single-config invocation. This is not an implicitly idempotent API, so a
     * request id is required to make it idempotent.
     *
     * Returns an empty Configuration proto with only the name and ID fields
     * populated.
     *
     * An error will be reported in the following cases:
     * - If no configuration ID is provided.
     * - If the parent invocation does not exist.
     * - If the parent invocation is finalized.
     * - If a configuration with the same name already exists.
     */
    createConfiguration: {
      name: "CreateConfiguration",
      requestType: CreateConfigurationRequest,
      requestStream: false,
      responseType: Configuration,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              61,
              114,
              101,
              113,
              117,
              101,
              115,
              116,
              95,
              105,
              100,
              44,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              99,
              111,
              110,
              102,
              105,
              103,
              117,
              114,
              97,
              116,
              105,
              111,
              110,
              44,
              99,
              111,
              110,
              102,
              105,
              103,
              95,
              105,
              100,
              44,
              97,
              117,
              116,
              104,
              111,
              114,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              95,
              116,
              111,
              107,
              101,
              110,
            ]),
          ],
          578365826: [
            Buffer.from([
              51,
              58,
              13,
              99,
              111,
              110,
              102,
              105,
              103,
              117,
              114,
              97,
              116,
              105,
              111,
              110,
              34,
              34,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              99,
              111,
              110,
              102,
              105,
              103,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Applies a standard update to the configuration identified by the given
     * proto's name. For all types of fields (primitive, message, or repeated),
     * replaces them with the given proto fields if they are under the given field
     * mask paths. Fields that match the mask but aren't populated in the given
     * configuration are cleared. This is an implicitly idempotent API.
     *
     * Returns an empty Configuration proto with only the name and ID fields
     * populated.
     *
     * An error will be reported in the following cases:
     * - If the configuration does not exist.
     * - If the parent invocation is finalized.
     * - If no field mask was given.
     * - If a given field mask path is not valid.
     */
    updateConfiguration: {
      name: "UpdateConfiguration",
      requestType: UpdateConfigurationRequest,
      requestStream: false,
      responseType: Configuration,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              45,
              99,
              111,
              110,
              102,
              105,
              103,
              117,
              114,
              97,
              116,
              105,
              111,
              110,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
              44,
              97,
              117,
              116,
              104,
              111,
              114,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              95,
              116,
              111,
              107,
              101,
              110,
            ]),
          ],
          578365826: [
            Buffer.from([
              65,
              58,
              13,
              99,
              111,
              110,
              102,
              105,
              103,
              117,
              114,
              97,
              116,
              105,
              111,
              110,
              50,
              48,
              47,
              118,
              50,
              47,
              123,
              99,
              111,
              110,
              102,
              105,
              103,
              117,
              114,
              97,
              116,
              105,
              111,
              110,
              46,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Creates the given file set under the given parent invocation. The given
     * file set ID is URL encoded, converted to the full resource name, and
     * assigned to the file set's name field. This is not an implicitly idempotent
     * API, so a request id is required to make it idempotent.
     *
     * Returns an empty FileSet proto with only the name and ID fields populated.
     *
     * An error will be reported in the following cases:
     * - If no file set ID is provided.
     * - If a file set with the same name already exists.
     * - If the parent invocation does not exist.
     * - If the parent invocation is finalized.
     */
    createFileSet: {
      name: "CreateFileSet",
      requestType: CreateFileSetRequest,
      requestStream: false,
      responseType: FileSet,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              58,
              114,
              101,
              113,
              117,
              101,
              115,
              116,
              95,
              105,
              100,
              44,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              102,
              105,
              108,
              101,
              95,
              115,
              101,
              116,
              44,
              102,
              105,
              108,
              101,
              95,
              115,
              101,
              116,
              95,
              105,
              100,
              44,
              97,
              117,
              116,
              104,
              111,
              114,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              95,
              116,
              111,
              107,
              101,
              110,
            ]),
          ],
          578365826: [
            Buffer.from([
              47,
              58,
              8,
              102,
              105,
              108,
              101,
              95,
              115,
              101,
              116,
              34,
              35,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              102,
              105,
              108,
              101,
              83,
              101,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Applies a standard update to the file set identified by the given proto's
     * name. For all types of fields (primitive, message, or repeated), replaces
     * them with the given proto fields if they are under the given field mask
     * paths. Fields that match the mask but aren't populated in the given
     * configuration are cleared. This is an implicitly idempotent API.
     *
     * Returns an empty FileSet proto with only the name and ID fields populated.
     *
     * An error will be reported in the following cases:
     * - If the file set does not exist.
     * - If the parent invocation is finalized.
     * - If no field mask was given.
     * - If a given field mask path is not valid.
     */
    updateFileSet: {
      name: "UpdateFileSet",
      requestType: UpdateFileSetRequest,
      requestStream: false,
      responseType: FileSet,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              40,
              102,
              105,
              108,
              101,
              95,
              115,
              101,
              116,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
              44,
              97,
              117,
              116,
              104,
              111,
              114,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              95,
              116,
              111,
              107,
              101,
              110,
            ]),
          ],
          578365826: [
            Buffer.from([
              56,
              58,
              8,
              102,
              105,
              108,
              101,
              95,
              115,
              101,
              116,
              50,
              44,
              47,
              118,
              50,
              47,
              123,
              102,
              105,
              108,
              101,
              95,
              115,
              101,
              116,
              46,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              102,
              105,
              108,
              101,
              83,
              101,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Applies a merge update to the file set identified by the given proto's
     * name. For primitive and message fields, updates them with the ones in the
     * given proto if they are covered under the field mask paths. For repeated
     * fields, merges to them with the given ones if they are covered under the
     * field mask paths. This is not an implicitly idempotent API, so a request
     * id is required to make it idempotent.
     *
     * Returns an empty FileSet proto with only the name and ID fields populated.
     *
     * An error will be reported in the following cases:
     * - If the file set does not exist.
     * - If the parent invocation is finalized.
     * - If a given field mask path is not valid.
     * - If no field mask was given.
     */
    mergeFileSet: {
      name: "MergeFileSet",
      requestType: MergeFileSetRequest,
      requestStream: false,
      responseType: FileSet,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              55,
              58,
              1,
              42,
              34,
              50,
              47,
              118,
              50,
              47,
              123,
              102,
              105,
              108,
              101,
              95,
              115,
              101,
              116,
              46,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              102,
              105,
              108,
              101,
              83,
              101,
              116,
              115,
              47,
              42,
              125,
              58,
              109,
              101,
              114,
              103,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * This is the RPC used for batch upload. It supports uploading multiple
     * resources for an invocation in a transaction safe manner.
     *
     * To use this RPC, the CreateInvocationRequest must have been provided a
     * resume_token.
     *
     * Combining batch upload with normal upload on a single Invocation is not
     * supported. If an Invocation is created with a resume_token, all further
     * calls must be through UploadBatch. If an Invocation is created without
     * resume_token normal upload, all further upload calls must be through normal
     * upload RPCs.
     *
     * The recommend total size of UploadBatchRequest is 10 MiB. If
     * it is too large, it may be rejected.
     */
    uploadBatch: {
      name: "UploadBatch",
      requestType: UploadBatchRequest,
      requestStream: false,
      responseType: UploadBatchResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              44,
              58,
              1,
              42,
              34,
              39,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              98,
              97,
              116,
              99,
              104,
              58,
              117,
              112,
              108,
              111,
              97,
              100,
            ]),
          ],
        },
      },
    },
    /**
     * Provides a way to read the metadata for an invocation.
     * The UploadMetadata could still be retrieved by this RPC even the Invocation
     * has been finalized.
     * This API requires setting a response FieldMask via 'fields' URL query
     * parameter or X-Goog-FieldMask HTTP/gRPC header.
     *
     * An error will be reported in the following case:
     * - If the invocation does not exist.
     * - If no field mask was given.
     */
    getInvocationUploadMetadata: {
      name: "GetInvocationUploadMetadata",
      requestType: GetInvocationUploadMetadataRequest,
      requestStream: false,
      responseType: UploadMetadata,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              24,
              110,
              97,
              109,
              101,
              44,
              97,
              117,
              116,
              104,
              111,
              114,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              95,
              116,
              111,
              107,
              101,
              110,
            ]),
          ],
          578365826: [
            Buffer.from([
              41,
              18,
              39,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              117,
              112,
              108,
              111,
              97,
              100,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
              125,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface ResultStoreUploadServiceImplementation<CallContextExt = {}> {
  /**
   * Creates the given invocation.
   *
   * This is not an implicitly idempotent API, so a request id is required to
   * make it idempotent.
   *
   * Returns an empty Invocation proto with only the name and ID fields
   * populated.
   *
   * An error will be reported in the following cases:
   * - If an invocation with the same ID already exists.
   */
  createInvocation(
    request: CreateInvocationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Invocation>>;
  /**
   * Applies a standard update to the invocation identified by the given proto's
   * name.  For all types of fields (primitive, message, or repeated), replaces
   * them with the given proto fields if they are under the given field mask
   * paths.  Fields that match the mask but aren't populated in the given
   * invocation are cleared. This is an implicitly idempotent API.
   *
   * Returns an empty Invocation proto with only the name and ID fields
   * populated.
   *
   * An error will be reported in the following cases:
   * - If the invocation does not exist.
   * - If the invocation is finalized.
   * - If no field mask was given.
   */
  updateInvocation(
    request: UpdateInvocationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Invocation>>;
  /**
   * Applies a merge update to the invocation identified by the given proto's
   * name.  For primitive and message fields, replaces them with the ones in
   * the given proto if they are covered under the field mask paths.  For
   * repeated fields, merges to them with the given ones if they are covered
   * under the field mask paths. This is not an implicitly idempotent API, so a
   * request id is required to make it idempotent.
   *
   * Returns an empty Invocation proto with only the name and ID fields
   * populated.
   *
   * An error will be reported in the following cases:
   * - If the invocation does not exist.
   * - If the invocation is finalized.
   * - If no field mask was given.
   */
  mergeInvocation(
    request: MergeInvocationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Invocation>>;
  /**
   * Touches the invocation identified by the given proto's name.
   *
   * This is useful when you need to notify ResultStore that you haven't
   * abandoned the upload, since abandoned uploads will be automatically
   * finalized after a set period.
   *
   * An error will be reported in the following cases:
   * - If the invocation does not exist.
   * - If the invocation is finalized.
   */
  touchInvocation(
    request: TouchInvocationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<TouchInvocationResponse>>;
  /**
   * Declares the invocation with the given name as finalized and immutable by
   * the user. It may still be mutated by post-processing. This is an implicitly
   * idempotent API.
   *
   * If an Invocation is not updated for 24 hours, some time after that
   * this will be called automatically.
   *
   * An error will be reported in the following cases:
   * - If the invocation does not exist.
   */
  finalizeInvocation(
    request: FinalizeInvocationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<FinalizeInvocationResponse>>;
  /**
   * Deletes an immutable invocation (permanently)
   * Note: this does not delete indirect data, e.g. files stored in other
   * services.
   *
   * An error will be reported in the following cases:
   * - If the invocation does not exist.
   * - If the invocation is not finalized.  This can be retried until it is.
   */
  deleteInvocation(
    request: DeleteInvocationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /**
   * Creates the given target under the given parent invocation. The given
   * target ID is URL encoded, converted to the full resource name, and assigned
   * to the target's name field. This is not an implicitly idempotent API, so a
   * request id is required to make it idempotent.
   *
   * Returns an empty Target proto with only the name and ID fields populated.
   *
   * An error will be reported in the following cases:
   * - If no target ID is provided.
   * - If the parent invocation does not exist.
   * - If the parent invocation is finalized.
   * - If a target with the same name already exists.
   */
  createTarget(request: CreateTargetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Target>>;
  /**
   * Applies a standard update to the target identified by the given proto's
   * name. For all types of fields (primitive, message, or repeated), replaces
   * them with the given proto fields if they are under the given field mask
   * paths. Fields that match the mask but aren't populated in the given
   * target are cleared. This is an implicitly idempotent API.
   *
   * Returns an empty Target proto with only the name and ID fields populated.
   *
   * An error will be reported in the following cases:
   * - If the target does not exist.
   * - If the target or parent invocation is finalized.
   * - If no field mask was given.
   */
  updateTarget(request: UpdateTargetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Target>>;
  /**
   * Applies a merge update to the target identified by the given proto's
   * name. For primitive and message fields, replaces them with the ones in the
   * given proto if they are covered under the field mask paths.  For repeated
   * fields, merges to them with the given ones if they are covered under the
   * field mask paths. This is not an implicitly idempotent API, so a request
   * id is required to make it idempotent.
   *
   * Returns an empty Target proto with only the name and ID fields populated.
   *
   * An error will be reported in the following cases:
   * - If the target does not exist.
   * - If the target or parent invocation is finalized.
   * - If no field mask was given.
   */
  mergeTarget(request: MergeTargetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Target>>;
  /**
   * Declares the target with the given name as finalized and immutable by the
   * user. It may still be mutated by post-processing. This is an implicitly
   * idempotent API.
   *
   * An error will be reported in the following cases:
   * - If the target does not exist.
   */
  finalizeTarget(
    request: FinalizeTargetRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<FinalizeTargetResponse>>;
  /**
   * Creates the given configured target under the given parent target.
   * The given configured target ID is URL encoded, converted to the full
   * resource name, and assigned to the configured target's name field.
   * This is not an implicitly idempotent API, so a request id is required
   * to make it idempotent.
   *
   * Returns an empty ConfiguredTarget proto with only the name and ID fields
   * populated.
   *
   * An error will be reported in the following cases:
   * - If no config ID is provided.
   * - If a configured target with the same ID already exists.
   * - If the parent target does not exist.
   * - If the parent target or invocation is finalized.
   */
  createConfiguredTarget(
    request: CreateConfiguredTargetRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ConfiguredTarget>>;
  /**
   * Applies a standard update to the configured target identified by the given
   * proto's name. For all types of fields (primitive, message, or repeated),
   * replaces them with the given proto fields if they are under the given
   * field mask paths. Fields that match the mask but aren't populated in the
   * given configured target are cleared. This is an implicitly idempotent API.
   *
   * Returns an empty ConfiguredTarget proto with only the name and ID fields
   * populated.
   *
   * An error will be reported in the following cases:
   * - If the configured target does not exist.
   * - If the parent target or invocation is finalized.
   * - If no field mask was given.
   */
  updateConfiguredTarget(
    request: UpdateConfiguredTargetRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ConfiguredTarget>>;
  /**
   * Applies a merge update to the configured target identified by the given
   * proto's name. For primitive and message fields, replaces them with the
   * ones in the given proto if they are covered under the field mask paths.
   * For repeated fields, merges to them with the given ones if they are
   * covered under the field mask paths. This is not an implicitly idempotent
   * API, so a request id is required to make it idempotent.
   *
   * Returns an empty ConfiguredTarget proto with only the name and ID fields
   * populated.
   *
   * An error will be reported in the following cases:
   * - If the configured target does not exist.
   * - If the parent target or invocation is finalized.
   * - If no field mask was given.
   */
  mergeConfiguredTarget(
    request: MergeConfiguredTargetRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ConfiguredTarget>>;
  /**
   * Declares the configured target with the given name as finalized and
   * immutable by the user. It may still be mutated by post-processing. This is
   * an implicitly idempotent API.
   *
   * An error will be reported in the following cases:
   * - If the configured target does not exist.
   */
  finalizeConfiguredTarget(
    request: FinalizeConfiguredTargetRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<FinalizeConfiguredTargetResponse>>;
  /**
   * Creates the given action under the given configured target. The given
   * action ID is URL encoded, converted to the full resource name, and
   * assigned to the action's name field. This is not an implicitly
   * idempotent API, so a request id is required to make it idempotent.
   *
   * Returns an empty Action proto with only the name and ID fields populated.
   *
   * An error will be reported in the following cases:
   * - If no action ID provided.
   * - If the parent configured target does not exist.
   * - If the parent target or invocation is finalized.
   * - If an action  with the same name already exists.
   */
  createAction(request: CreateActionRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Action>>;
  /**
   * Applies a standard update to the action identified by the given
   * proto's name.  For all types of fields (primitive, message, or repeated),
   * replaces them with the given proto fields if they are under the given
   * field mask paths.  Fields that match the mask but aren't populated in the
   * given action are cleared.  This is an implicitly idempotent API.
   *
   * Returns an empty Action proto with only the name and ID fields populated.
   *
   * An error will be reported in the following cases:
   * - If the action does not exist.
   * - If the parent target or invocation is finalized.
   * - If no field mask was given.
   */
  updateAction(request: UpdateActionRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Action>>;
  /**
   * Applies a merge update to the action identified by the given
   * proto's name.  For primitive and message fields, replaces them with the
   * ones in the given proto if they are covered under the field mask paths.
   * For repeated fields, merges to them with the given ones if they are
   * covered under the field mask paths. This is not an implicitly idempotent
   * API, so a request id is required to make it idempotent.
   *
   * Returns an empty Action proto with only the name and ID fields populated.
   *
   * An error will be reported in the following cases:
   * - If the action does not exist.
   * - If the parent target or invocation is finalized.
   * - If no field mask was given.
   */
  mergeAction(request: MergeActionRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Action>>;
  /**
   * Creates the given configuration under the given parent invocation. The
   * given configuration ID is URL encoded, converted to the full resource name,
   * and assigned to the configuration's name field. The configuration ID of
   * "default" should be preferred for the default configuration in a
   * single-config invocation. This is not an implicitly idempotent API, so a
   * request id is required to make it idempotent.
   *
   * Returns an empty Configuration proto with only the name and ID fields
   * populated.
   *
   * An error will be reported in the following cases:
   * - If no configuration ID is provided.
   * - If the parent invocation does not exist.
   * - If the parent invocation is finalized.
   * - If a configuration with the same name already exists.
   */
  createConfiguration(
    request: CreateConfigurationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Configuration>>;
  /**
   * Applies a standard update to the configuration identified by the given
   * proto's name. For all types of fields (primitive, message, or repeated),
   * replaces them with the given proto fields if they are under the given field
   * mask paths. Fields that match the mask but aren't populated in the given
   * configuration are cleared. This is an implicitly idempotent API.
   *
   * Returns an empty Configuration proto with only the name and ID fields
   * populated.
   *
   * An error will be reported in the following cases:
   * - If the configuration does not exist.
   * - If the parent invocation is finalized.
   * - If no field mask was given.
   * - If a given field mask path is not valid.
   */
  updateConfiguration(
    request: UpdateConfigurationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Configuration>>;
  /**
   * Creates the given file set under the given parent invocation. The given
   * file set ID is URL encoded, converted to the full resource name, and
   * assigned to the file set's name field. This is not an implicitly idempotent
   * API, so a request id is required to make it idempotent.
   *
   * Returns an empty FileSet proto with only the name and ID fields populated.
   *
   * An error will be reported in the following cases:
   * - If no file set ID is provided.
   * - If a file set with the same name already exists.
   * - If the parent invocation does not exist.
   * - If the parent invocation is finalized.
   */
  createFileSet(request: CreateFileSetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<FileSet>>;
  /**
   * Applies a standard update to the file set identified by the given proto's
   * name. For all types of fields (primitive, message, or repeated), replaces
   * them with the given proto fields if they are under the given field mask
   * paths. Fields that match the mask but aren't populated in the given
   * configuration are cleared. This is an implicitly idempotent API.
   *
   * Returns an empty FileSet proto with only the name and ID fields populated.
   *
   * An error will be reported in the following cases:
   * - If the file set does not exist.
   * - If the parent invocation is finalized.
   * - If no field mask was given.
   * - If a given field mask path is not valid.
   */
  updateFileSet(request: UpdateFileSetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<FileSet>>;
  /**
   * Applies a merge update to the file set identified by the given proto's
   * name. For primitive and message fields, updates them with the ones in the
   * given proto if they are covered under the field mask paths. For repeated
   * fields, merges to them with the given ones if they are covered under the
   * field mask paths. This is not an implicitly idempotent API, so a request
   * id is required to make it idempotent.
   *
   * Returns an empty FileSet proto with only the name and ID fields populated.
   *
   * An error will be reported in the following cases:
   * - If the file set does not exist.
   * - If the parent invocation is finalized.
   * - If a given field mask path is not valid.
   * - If no field mask was given.
   */
  mergeFileSet(request: MergeFileSetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<FileSet>>;
  /**
   * This is the RPC used for batch upload. It supports uploading multiple
   * resources for an invocation in a transaction safe manner.
   *
   * To use this RPC, the CreateInvocationRequest must have been provided a
   * resume_token.
   *
   * Combining batch upload with normal upload on a single Invocation is not
   * supported. If an Invocation is created with a resume_token, all further
   * calls must be through UploadBatch. If an Invocation is created without
   * resume_token normal upload, all further upload calls must be through normal
   * upload RPCs.
   *
   * The recommend total size of UploadBatchRequest is 10 MiB. If
   * it is too large, it may be rejected.
   */
  uploadBatch(
    request: UploadBatchRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<UploadBatchResponse>>;
  /**
   * Provides a way to read the metadata for an invocation.
   * The UploadMetadata could still be retrieved by this RPC even the Invocation
   * has been finalized.
   * This API requires setting a response FieldMask via 'fields' URL query
   * parameter or X-Goog-FieldMask HTTP/gRPC header.
   *
   * An error will be reported in the following case:
   * - If the invocation does not exist.
   * - If no field mask was given.
   */
  getInvocationUploadMetadata(
    request: GetInvocationUploadMetadataRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<UploadMetadata>>;
}

export interface ResultStoreUploadClient<CallOptionsExt = {}> {
  /**
   * Creates the given invocation.
   *
   * This is not an implicitly idempotent API, so a request id is required to
   * make it idempotent.
   *
   * Returns an empty Invocation proto with only the name and ID fields
   * populated.
   *
   * An error will be reported in the following cases:
   * - If an invocation with the same ID already exists.
   */
  createInvocation(
    request: DeepPartial<CreateInvocationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Invocation>;
  /**
   * Applies a standard update to the invocation identified by the given proto's
   * name.  For all types of fields (primitive, message, or repeated), replaces
   * them with the given proto fields if they are under the given field mask
   * paths.  Fields that match the mask but aren't populated in the given
   * invocation are cleared. This is an implicitly idempotent API.
   *
   * Returns an empty Invocation proto with only the name and ID fields
   * populated.
   *
   * An error will be reported in the following cases:
   * - If the invocation does not exist.
   * - If the invocation is finalized.
   * - If no field mask was given.
   */
  updateInvocation(
    request: DeepPartial<UpdateInvocationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Invocation>;
  /**
   * Applies a merge update to the invocation identified by the given proto's
   * name.  For primitive and message fields, replaces them with the ones in
   * the given proto if they are covered under the field mask paths.  For
   * repeated fields, merges to them with the given ones if they are covered
   * under the field mask paths. This is not an implicitly idempotent API, so a
   * request id is required to make it idempotent.
   *
   * Returns an empty Invocation proto with only the name and ID fields
   * populated.
   *
   * An error will be reported in the following cases:
   * - If the invocation does not exist.
   * - If the invocation is finalized.
   * - If no field mask was given.
   */
  mergeInvocation(
    request: DeepPartial<MergeInvocationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Invocation>;
  /**
   * Touches the invocation identified by the given proto's name.
   *
   * This is useful when you need to notify ResultStore that you haven't
   * abandoned the upload, since abandoned uploads will be automatically
   * finalized after a set period.
   *
   * An error will be reported in the following cases:
   * - If the invocation does not exist.
   * - If the invocation is finalized.
   */
  touchInvocation(
    request: DeepPartial<TouchInvocationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<TouchInvocationResponse>;
  /**
   * Declares the invocation with the given name as finalized and immutable by
   * the user. It may still be mutated by post-processing. This is an implicitly
   * idempotent API.
   *
   * If an Invocation is not updated for 24 hours, some time after that
   * this will be called automatically.
   *
   * An error will be reported in the following cases:
   * - If the invocation does not exist.
   */
  finalizeInvocation(
    request: DeepPartial<FinalizeInvocationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<FinalizeInvocationResponse>;
  /**
   * Deletes an immutable invocation (permanently)
   * Note: this does not delete indirect data, e.g. files stored in other
   * services.
   *
   * An error will be reported in the following cases:
   * - If the invocation does not exist.
   * - If the invocation is not finalized.  This can be retried until it is.
   */
  deleteInvocation(
    request: DeepPartial<DeleteInvocationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /**
   * Creates the given target under the given parent invocation. The given
   * target ID is URL encoded, converted to the full resource name, and assigned
   * to the target's name field. This is not an implicitly idempotent API, so a
   * request id is required to make it idempotent.
   *
   * Returns an empty Target proto with only the name and ID fields populated.
   *
   * An error will be reported in the following cases:
   * - If no target ID is provided.
   * - If the parent invocation does not exist.
   * - If the parent invocation is finalized.
   * - If a target with the same name already exists.
   */
  createTarget(request: DeepPartial<CreateTargetRequest>, options?: CallOptions & CallOptionsExt): Promise<Target>;
  /**
   * Applies a standard update to the target identified by the given proto's
   * name. For all types of fields (primitive, message, or repeated), replaces
   * them with the given proto fields if they are under the given field mask
   * paths. Fields that match the mask but aren't populated in the given
   * target are cleared. This is an implicitly idempotent API.
   *
   * Returns an empty Target proto with only the name and ID fields populated.
   *
   * An error will be reported in the following cases:
   * - If the target does not exist.
   * - If the target or parent invocation is finalized.
   * - If no field mask was given.
   */
  updateTarget(request: DeepPartial<UpdateTargetRequest>, options?: CallOptions & CallOptionsExt): Promise<Target>;
  /**
   * Applies a merge update to the target identified by the given proto's
   * name. For primitive and message fields, replaces them with the ones in the
   * given proto if they are covered under the field mask paths.  For repeated
   * fields, merges to them with the given ones if they are covered under the
   * field mask paths. This is not an implicitly idempotent API, so a request
   * id is required to make it idempotent.
   *
   * Returns an empty Target proto with only the name and ID fields populated.
   *
   * An error will be reported in the following cases:
   * - If the target does not exist.
   * - If the target or parent invocation is finalized.
   * - If no field mask was given.
   */
  mergeTarget(request: DeepPartial<MergeTargetRequest>, options?: CallOptions & CallOptionsExt): Promise<Target>;
  /**
   * Declares the target with the given name as finalized and immutable by the
   * user. It may still be mutated by post-processing. This is an implicitly
   * idempotent API.
   *
   * An error will be reported in the following cases:
   * - If the target does not exist.
   */
  finalizeTarget(
    request: DeepPartial<FinalizeTargetRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<FinalizeTargetResponse>;
  /**
   * Creates the given configured target under the given parent target.
   * The given configured target ID is URL encoded, converted to the full
   * resource name, and assigned to the configured target's name field.
   * This is not an implicitly idempotent API, so a request id is required
   * to make it idempotent.
   *
   * Returns an empty ConfiguredTarget proto with only the name and ID fields
   * populated.
   *
   * An error will be reported in the following cases:
   * - If no config ID is provided.
   * - If a configured target with the same ID already exists.
   * - If the parent target does not exist.
   * - If the parent target or invocation is finalized.
   */
  createConfiguredTarget(
    request: DeepPartial<CreateConfiguredTargetRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ConfiguredTarget>;
  /**
   * Applies a standard update to the configured target identified by the given
   * proto's name. For all types of fields (primitive, message, or repeated),
   * replaces them with the given proto fields if they are under the given
   * field mask paths. Fields that match the mask but aren't populated in the
   * given configured target are cleared. This is an implicitly idempotent API.
   *
   * Returns an empty ConfiguredTarget proto with only the name and ID fields
   * populated.
   *
   * An error will be reported in the following cases:
   * - If the configured target does not exist.
   * - If the parent target or invocation is finalized.
   * - If no field mask was given.
   */
  updateConfiguredTarget(
    request: DeepPartial<UpdateConfiguredTargetRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ConfiguredTarget>;
  /**
   * Applies a merge update to the configured target identified by the given
   * proto's name. For primitive and message fields, replaces them with the
   * ones in the given proto if they are covered under the field mask paths.
   * For repeated fields, merges to them with the given ones if they are
   * covered under the field mask paths. This is not an implicitly idempotent
   * API, so a request id is required to make it idempotent.
   *
   * Returns an empty ConfiguredTarget proto with only the name and ID fields
   * populated.
   *
   * An error will be reported in the following cases:
   * - If the configured target does not exist.
   * - If the parent target or invocation is finalized.
   * - If no field mask was given.
   */
  mergeConfiguredTarget(
    request: DeepPartial<MergeConfiguredTargetRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ConfiguredTarget>;
  /**
   * Declares the configured target with the given name as finalized and
   * immutable by the user. It may still be mutated by post-processing. This is
   * an implicitly idempotent API.
   *
   * An error will be reported in the following cases:
   * - If the configured target does not exist.
   */
  finalizeConfiguredTarget(
    request: DeepPartial<FinalizeConfiguredTargetRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<FinalizeConfiguredTargetResponse>;
  /**
   * Creates the given action under the given configured target. The given
   * action ID is URL encoded, converted to the full resource name, and
   * assigned to the action's name field. This is not an implicitly
   * idempotent API, so a request id is required to make it idempotent.
   *
   * Returns an empty Action proto with only the name and ID fields populated.
   *
   * An error will be reported in the following cases:
   * - If no action ID provided.
   * - If the parent configured target does not exist.
   * - If the parent target or invocation is finalized.
   * - If an action  with the same name already exists.
   */
  createAction(request: DeepPartial<CreateActionRequest>, options?: CallOptions & CallOptionsExt): Promise<Action>;
  /**
   * Applies a standard update to the action identified by the given
   * proto's name.  For all types of fields (primitive, message, or repeated),
   * replaces them with the given proto fields if they are under the given
   * field mask paths.  Fields that match the mask but aren't populated in the
   * given action are cleared.  This is an implicitly idempotent API.
   *
   * Returns an empty Action proto with only the name and ID fields populated.
   *
   * An error will be reported in the following cases:
   * - If the action does not exist.
   * - If the parent target or invocation is finalized.
   * - If no field mask was given.
   */
  updateAction(request: DeepPartial<UpdateActionRequest>, options?: CallOptions & CallOptionsExt): Promise<Action>;
  /**
   * Applies a merge update to the action identified by the given
   * proto's name.  For primitive and message fields, replaces them with the
   * ones in the given proto if they are covered under the field mask paths.
   * For repeated fields, merges to them with the given ones if they are
   * covered under the field mask paths. This is not an implicitly idempotent
   * API, so a request id is required to make it idempotent.
   *
   * Returns an empty Action proto with only the name and ID fields populated.
   *
   * An error will be reported in the following cases:
   * - If the action does not exist.
   * - If the parent target or invocation is finalized.
   * - If no field mask was given.
   */
  mergeAction(request: DeepPartial<MergeActionRequest>, options?: CallOptions & CallOptionsExt): Promise<Action>;
  /**
   * Creates the given configuration under the given parent invocation. The
   * given configuration ID is URL encoded, converted to the full resource name,
   * and assigned to the configuration's name field. The configuration ID of
   * "default" should be preferred for the default configuration in a
   * single-config invocation. This is not an implicitly idempotent API, so a
   * request id is required to make it idempotent.
   *
   * Returns an empty Configuration proto with only the name and ID fields
   * populated.
   *
   * An error will be reported in the following cases:
   * - If no configuration ID is provided.
   * - If the parent invocation does not exist.
   * - If the parent invocation is finalized.
   * - If a configuration with the same name already exists.
   */
  createConfiguration(
    request: DeepPartial<CreateConfigurationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Configuration>;
  /**
   * Applies a standard update to the configuration identified by the given
   * proto's name. For all types of fields (primitive, message, or repeated),
   * replaces them with the given proto fields if they are under the given field
   * mask paths. Fields that match the mask but aren't populated in the given
   * configuration are cleared. This is an implicitly idempotent API.
   *
   * Returns an empty Configuration proto with only the name and ID fields
   * populated.
   *
   * An error will be reported in the following cases:
   * - If the configuration does not exist.
   * - If the parent invocation is finalized.
   * - If no field mask was given.
   * - If a given field mask path is not valid.
   */
  updateConfiguration(
    request: DeepPartial<UpdateConfigurationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Configuration>;
  /**
   * Creates the given file set under the given parent invocation. The given
   * file set ID is URL encoded, converted to the full resource name, and
   * assigned to the file set's name field. This is not an implicitly idempotent
   * API, so a request id is required to make it idempotent.
   *
   * Returns an empty FileSet proto with only the name and ID fields populated.
   *
   * An error will be reported in the following cases:
   * - If no file set ID is provided.
   * - If a file set with the same name already exists.
   * - If the parent invocation does not exist.
   * - If the parent invocation is finalized.
   */
  createFileSet(request: DeepPartial<CreateFileSetRequest>, options?: CallOptions & CallOptionsExt): Promise<FileSet>;
  /**
   * Applies a standard update to the file set identified by the given proto's
   * name. For all types of fields (primitive, message, or repeated), replaces
   * them with the given proto fields if they are under the given field mask
   * paths. Fields that match the mask but aren't populated in the given
   * configuration are cleared. This is an implicitly idempotent API.
   *
   * Returns an empty FileSet proto with only the name and ID fields populated.
   *
   * An error will be reported in the following cases:
   * - If the file set does not exist.
   * - If the parent invocation is finalized.
   * - If no field mask was given.
   * - If a given field mask path is not valid.
   */
  updateFileSet(request: DeepPartial<UpdateFileSetRequest>, options?: CallOptions & CallOptionsExt): Promise<FileSet>;
  /**
   * Applies a merge update to the file set identified by the given proto's
   * name. For primitive and message fields, updates them with the ones in the
   * given proto if they are covered under the field mask paths. For repeated
   * fields, merges to them with the given ones if they are covered under the
   * field mask paths. This is not an implicitly idempotent API, so a request
   * id is required to make it idempotent.
   *
   * Returns an empty FileSet proto with only the name and ID fields populated.
   *
   * An error will be reported in the following cases:
   * - If the file set does not exist.
   * - If the parent invocation is finalized.
   * - If a given field mask path is not valid.
   * - If no field mask was given.
   */
  mergeFileSet(request: DeepPartial<MergeFileSetRequest>, options?: CallOptions & CallOptionsExt): Promise<FileSet>;
  /**
   * This is the RPC used for batch upload. It supports uploading multiple
   * resources for an invocation in a transaction safe manner.
   *
   * To use this RPC, the CreateInvocationRequest must have been provided a
   * resume_token.
   *
   * Combining batch upload with normal upload on a single Invocation is not
   * supported. If an Invocation is created with a resume_token, all further
   * calls must be through UploadBatch. If an Invocation is created without
   * resume_token normal upload, all further upload calls must be through normal
   * upload RPCs.
   *
   * The recommend total size of UploadBatchRequest is 10 MiB. If
   * it is too large, it may be rejected.
   */
  uploadBatch(
    request: DeepPartial<UploadBatchRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<UploadBatchResponse>;
  /**
   * Provides a way to read the metadata for an invocation.
   * The UploadMetadata could still be retrieved by this RPC even the Invocation
   * has been finalized.
   * This API requires setting a response FieldMask via 'fields' URL query
   * parameter or X-Goog-FieldMask HTTP/gRPC header.
   *
   * An error will be reported in the following case:
   * - If the invocation does not exist.
   * - If no field mask was given.
   */
  getInvocationUploadMetadata(
    request: DeepPartial<GetInvocationUploadMetadataRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<UploadMetadata>;
}

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
