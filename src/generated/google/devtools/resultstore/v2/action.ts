// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/devtools/resultstore/v2/action.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../protobuf/duration.js";
import { Dependency, Property, StatusAttributes, Timing } from "./common.js";
import { ActionCoverage } from "./coverage.js";
import { File } from "./file.js";
import { FileProcessingErrors } from "./file_processing_error.js";
import { TestSuite } from "./test_suite.js";

export const protobufPackage = "google.devtools.resultstore.v2";

/** Indicates how/where this Action was executed. */
export enum ExecutionStrategy {
  /** EXECUTION_STRATEGY_UNSPECIFIED - The action did not indicate how it was executed. */
  EXECUTION_STRATEGY_UNSPECIFIED = 0,
  /** OTHER_ENVIRONMENT - The action was executed in some other form. */
  OTHER_ENVIRONMENT = 1,
  /** REMOTE_SERVICE - The action used a remote build service. */
  REMOTE_SERVICE = 2,
  /** LOCAL_PARALLEL - The action was executed locally, in parallel with other actions. */
  LOCAL_PARALLEL = 3,
  /** LOCAL_SEQUENTIAL - The action was executed locally, without parallelism. */
  LOCAL_SEQUENTIAL = 4,
  UNRECOGNIZED = -1,
}

export function executionStrategyFromJSON(object: any): ExecutionStrategy {
  switch (object) {
    case 0:
    case "EXECUTION_STRATEGY_UNSPECIFIED":
      return ExecutionStrategy.EXECUTION_STRATEGY_UNSPECIFIED;
    case 1:
    case "OTHER_ENVIRONMENT":
      return ExecutionStrategy.OTHER_ENVIRONMENT;
    case 2:
    case "REMOTE_SERVICE":
      return ExecutionStrategy.REMOTE_SERVICE;
    case 3:
    case "LOCAL_PARALLEL":
      return ExecutionStrategy.LOCAL_PARALLEL;
    case 4:
    case "LOCAL_SEQUENTIAL":
      return ExecutionStrategy.LOCAL_SEQUENTIAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ExecutionStrategy.UNRECOGNIZED;
  }
}

export function executionStrategyToJSON(object: ExecutionStrategy): string {
  switch (object) {
    case ExecutionStrategy.EXECUTION_STRATEGY_UNSPECIFIED:
      return "EXECUTION_STRATEGY_UNSPECIFIED";
    case ExecutionStrategy.OTHER_ENVIRONMENT:
      return "OTHER_ENVIRONMENT";
    case ExecutionStrategy.REMOTE_SERVICE:
      return "REMOTE_SERVICE";
    case ExecutionStrategy.LOCAL_PARALLEL:
      return "LOCAL_PARALLEL";
    case ExecutionStrategy.LOCAL_SEQUENTIAL:
      return "LOCAL_SEQUENTIAL";
    case ExecutionStrategy.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Most build systems cache build results to speed up incremental builds.
 * Some also cache test results too. This indicates whether the test results
 * were found in a cache, and where that cache was located.
 */
export enum TestCaching {
  /** TEST_CACHING_UNSPECIFIED - The implicit default enum value. Should never be set. */
  TEST_CACHING_UNSPECIFIED = 0,
  /** LOCAL_CACHE_HIT - The test result was found in a local cache, so it wasn't run again. */
  LOCAL_CACHE_HIT = 1,
  /** REMOTE_CACHE_HIT - The test result was found in a remote cache, so it wasn't run again. */
  REMOTE_CACHE_HIT = 2,
  /** CACHE_MISS - The test result was not found in any cache, so it had to be run again. */
  CACHE_MISS = 3,
  UNRECOGNIZED = -1,
}

export function testCachingFromJSON(object: any): TestCaching {
  switch (object) {
    case 0:
    case "TEST_CACHING_UNSPECIFIED":
      return TestCaching.TEST_CACHING_UNSPECIFIED;
    case 1:
    case "LOCAL_CACHE_HIT":
      return TestCaching.LOCAL_CACHE_HIT;
    case 2:
    case "REMOTE_CACHE_HIT":
      return TestCaching.REMOTE_CACHE_HIT;
    case 3:
    case "CACHE_MISS":
      return TestCaching.CACHE_MISS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TestCaching.UNRECOGNIZED;
  }
}

export function testCachingToJSON(object: TestCaching): string {
  switch (object) {
    case TestCaching.TEST_CACHING_UNSPECIFIED:
      return "TEST_CACHING_UNSPECIFIED";
    case TestCaching.LOCAL_CACHE_HIT:
      return "LOCAL_CACHE_HIT";
    case TestCaching.REMOTE_CACHE_HIT:
      return "REMOTE_CACHE_HIT";
    case TestCaching.CACHE_MISS:
      return "CACHE_MISS";
    case TestCaching.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * An action that happened as part of a configured target. This action could be
 * a build, a test, or another type of action, as specified in action_type
 * oneof.
 *
 * Each parent ConfiguredTarget resource should have at least one Action as its
 * child resource before the invocation is finalized. For a simple build, at
 * least one build action should be created to represent the build result, and
 * at least one test action should be created to represent the test result, if
 * any.
 */
export interface Action {
  /**
   * The resource name.  Its format must be:
   * invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}/configuredTargets/url_encode(${CONFIG_ID})/actions/${url_encode(ACTION_ID)}
   *
   * See CreateActionRequest proto for more information.
   */
  name: string;
  /**
   * The resource ID components that identify the Action. They must match the
   * resource name after proper encoding.
   */
  id:
    | Action_Id
    | undefined;
  /** The status of the action. */
  statusAttributes:
    | StatusAttributes
    | undefined;
  /**
   * The timing of the whole action. For TestActions, the start time may be
   * before the test actually started, and the duration may last until after the
   * test actually finished.
   */
  timing:
    | Timing
    | undefined;
  /** Used only when this action represents a build action. */
  buildAction?:
    | BuildAction
    | undefined;
  /** Only for test actions. */
  testAction?:
    | TestAction
    | undefined;
  /** General attributes of the action. */
  actionAttributes:
    | ActionAttributes
    | undefined;
  /**
   * A list of resources that this action depended upon. May be used to provide
   * the cause of a build failure in the case of a failed build action.
   */
  actionDependencies: Dependency[];
  /**
   * Arbitrary name-value pairs.
   * This is implemented as a multi-map. Multiple properties are allowed with
   * the same key. Properties will be returned in lexicographical order by key.
   */
  properties: Property[];
  /**
   * A list of file references for action level files.
   * The file IDs must be unique within this list. Duplicate file IDs will
   * result in an error. Files will be returned in lexicographical order by ID.
   *
   * Files with the following reserved file IDs cause specific post-processing
   * or have special handling. These files must be immediately available to
   * ResultStore for processing when the reference is uploaded.
   *
   * For build actions:
   * stdout: The stdout of the action
   * stderr: The stderr of the action
   * baseline.lcov: Baseline coverage file to be parsed by the server. This
   *     uses a stripped down implementation of the LCOV standard.
   *     http://ltp.sourceforge.net/coverage/lcov/geninfo.1.php
   *
   * For test actions:
   * test.xml: The test suite / test case data in XML format.
   * test.log: The combined stdout and stderr of the test process.
   * test.lcov: Coverage file to be parsed by the server. This uses a stripped
   *     down implementation of the LCOV standard.
   *     http://ltp.sourceforge.net/coverage/lcov/geninfo.1.php
   */
  files: File[];
  /**
   * List of names of file sets that are referenced from this Action.
   * Each name must point to a file set under the same Invocation. The name
   * format must be: invocations/${INVOCATION_ID}/fileSets/${FILE_SET_ID}
   */
  fileSets: string[];
  /**
   * Coverage data was collected while running the build or test action. This
   * usually includes line coverage, and may also include branch coverage.
   * For test actions, this is usually only for the source files which were
   * actually executed by that particular action.
   * For build actions, this is the baseline coverage, which captures the
   * instrumented files and lines, without any lines being executed. This
   * ensures files that are never covered at all are included.
   */
  coverage:
    | ActionCoverage
    | undefined;
  /**
   * ResultStore will read and parse Files with reserved IDs listed above. Read
   * and parse errors for all these Files are reported here.
   * This is implemented as a map, with one FileProcessingErrors for each file.
   * Typically produced when parsing Files, but may also be provided directly
   * by clients.
   */
  fileProcessingErrors: FileProcessingErrors[];
}

/** The resource ID components that identify the Action. */
export interface Action_Id {
  /** The Invocation ID. */
  invocationId: string;
  /** The Target ID. */
  targetId: string;
  /** The Configuration ID. */
  configurationId: string;
  /** The Action ID. */
  actionId: string;
}

/** A build action, such as building a java library. */
export interface BuildAction {
  /**
   * The type of the action.  This is intended to be a clue as to how the output
   * of the action should be parsed. For example "javac" for a Java compile
   * action.
   */
  type: string;
  /**
   * The "primary" input artifact processed by this action.  E.g., the .cc file
   * of a C++ compile action.  Empty string ("") if the action has no input
   * artifacts or no "primary" input artifact.
   */
  primaryInputPath: string;
  /**
   * The "primary" output artifact processed by this action.  E.g., the .o file
   * of a C++ compile action.  Empty string ("") if the action has no output
   * artifacts or no "primary" output artifact.
   */
  primaryOutputPath: string;
}

/** A test action, such as running a JUnit4 test binary. */
export interface TestAction {
  /** Timing data for execution of the test action. */
  testTiming:
    | TestTiming
    | undefined;
  /**
   * If the test is divided up into shards to improve performance, set this to
   * indicate which shard this test action is for. Value must be in interval
   * [0, total_shard_count). Defaults to 0, which is appropriate if all test
   * cases are run in the same process.
   */
  shardNumber: number;
  /**
   * If the user requested that every test be run multiple times, as is often
   * done to measure flakiness, set this to indicate which run this test action
   * is for. Value must be in interval [0, total_run_count). Defaults to 0,
   * which is appropriate if multiple runs were not requested.
   */
  runNumber: number;
  /**
   * If flaky tests are automatically retried, set this to indicate which
   * attempt this test action is for. (e.g. 0 for the first attempt, 1 for
   * second, and so on). Defaults to 0, which is appropriate if this is the only
   * attempt.
   */
  attemptNumber: number;
  /**
   * A tree of test suites and test cases that were run by this test action.
   * Each test case has its own status information, including stack traces.
   * Typically produced by parsing an XML Log, but may also be provided directly
   * by clients.
   */
  testSuite:
    | TestSuite
    | undefined;
  /** Warnings for this test action. */
  warnings: TestWarning[];
  /**
   * Estimated memory consumption of the test action, in bytes. A default value
   * of 0 means there is no memory consumption estimate specified.
   */
  estimatedMemoryBytes: Long;
}

/** General attributes of an action */
export interface ActionAttributes {
  /** Strategy used for executing the action. */
  executionStrategy: ExecutionStrategy;
  /**
   * Exit code of the process that ran the action. A non-zero value means
   * failure.
   */
  exitCode: number;
  /** Where the action was run. */
  hostname: string;
  /**
   * Information about the input files used in all actions under this configured
   * target.
   */
  inputFileInfo: InputFileInfo | undefined;
}

/** File count and size information for the input files to a configured target. */
export interface InputFileInfo {
  /** The number of input files (counting every file, even if a duplicate). */
  count: Long;
  /** The number of distinct input files. */
  distinctCount: Long;
  /**
   * The max number of input files allowed by the build system (counting every
   * file, even if a duplicate).
   */
  countLimit: Long;
  /** The total size of the distinct input files. */
  distinctBytes: Long;
  /** The max allowed total size of the distinct input files. */
  distinctByteLimit: Long;
}

/** Timing data for tests executed locally on the machine running the build. */
export interface LocalTestTiming {
  /**
   * Time taken by the test process, typically surrounded by a small wrapper
   * script.
   */
  testProcessDuration: Duration | undefined;
}

/** Timing data for one attempt to execute a test action remotely. */
export interface RemoteTestAttemptTiming {
  /** Idle period before the test process is invoked on the remote machine. */
  queueDuration:
    | Duration
    | undefined;
  /**
   * Time to upload data dependencies from the local machine to the remote
   * machine running the test, or to the distributed cache.
   */
  uploadDuration:
    | Duration
    | undefined;
  /**
   * Time to set up the remote machine.
   * Not to be confused with setup time in
   * xUnit test frameworks, which falls within the test_process_time.
   */
  machineSetupDuration:
    | Duration
    | undefined;
  /**
   * Time taken by the test process, typically surrounded by a small wrapper
   * script.
   * For Java tests, this includes JVM setup, flag parsing, class path setup,
   * parsing files to setup the suite, and finally running your test methods.
   * In many cases, only a small fraction of the test process time is spent
   * running the test methods.
   */
  testProcessDuration:
    | Duration
    | undefined;
  /**
   * Time spent retrieving test logs and any other test outputs, back to the
   * local machine.
   */
  downloadDuration: Duration | undefined;
}

/** Timing data for the part of the test execution that is done remotely. */
export interface RemoteTestTiming {
  /** Time taken locally to determine what to do. */
  localAnalysisDuration:
    | Duration
    | undefined;
  /**
   * Normally there is only one attempt, but the system may retry on internal
   * errors, leading to multiple attempts.
   */
  attempts: RemoteTestAttemptTiming[];
}

/**
 * Timing data for execution of a test action. The action may be performed
 * locally, on the machine running the build, or remotely.
 */
export interface TestTiming {
  /** Used for local test actions. */
  local?:
    | LocalTestTiming
    | undefined;
  /** Used for remote test actions. */
  remote?:
    | RemoteTestTiming
    | undefined;
  /**
   * The amount of CPU time spent by the test process executing system calls
   * within the kernel, as opposed to library code. Time the test process spent
   * blocked does not count towards this figure.
   */
  systemTimeDuration:
    | Duration
    | undefined;
  /**
   * The amount of CPU time spent by the test process executing user-mode code
   * outside the kernel, as opposed to library code. Time the test process
   * spent blocked does not count towards this figure. You can add user_time to
   * system_time to get total CPU time taken by the test process.
   */
  userTimeDuration:
    | Duration
    | undefined;
  /**
   * Most build systems cache build results to speed up incremental builds.
   * Some also cache test results too. This indicates whether the test results
   * were found in a cache, and where that cache was located.
   */
  testCaching: TestCaching;
}

/** A warning from a test execution. */
export interface TestWarning {
  /** Contains the message detailing the warning. */
  warningMessage: string;
}

function createBaseAction(): Action {
  return {
    name: "",
    id: undefined,
    statusAttributes: undefined,
    timing: undefined,
    buildAction: undefined,
    testAction: undefined,
    actionAttributes: undefined,
    actionDependencies: [],
    properties: [],
    files: [],
    fileSets: [],
    coverage: undefined,
    fileProcessingErrors: [],
  };
}

export const Action: MessageFns<Action> = {
  encode(message: Action, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.id !== undefined) {
      Action_Id.encode(message.id, writer.uint32(18).fork()).join();
    }
    if (message.statusAttributes !== undefined) {
      StatusAttributes.encode(message.statusAttributes, writer.uint32(26).fork()).join();
    }
    if (message.timing !== undefined) {
      Timing.encode(message.timing, writer.uint32(34).fork()).join();
    }
    if (message.buildAction !== undefined) {
      BuildAction.encode(message.buildAction, writer.uint32(74).fork()).join();
    }
    if (message.testAction !== undefined) {
      TestAction.encode(message.testAction, writer.uint32(82).fork()).join();
    }
    if (message.actionAttributes !== undefined) {
      ActionAttributes.encode(message.actionAttributes, writer.uint32(42).fork()).join();
    }
    for (const v of message.actionDependencies) {
      Dependency.encode(v!, writer.uint32(114).fork()).join();
    }
    for (const v of message.properties) {
      Property.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.files) {
      File.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.fileSets) {
      writer.uint32(122).string(v!);
    }
    if (message.coverage !== undefined) {
      ActionCoverage.encode(message.coverage, writer.uint32(90).fork()).join();
    }
    for (const v of message.fileProcessingErrors) {
      FileProcessingErrors.encode(v!, writer.uint32(106).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Action {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id = Action_Id.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.statusAttributes = StatusAttributes.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.timing = Timing.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.buildAction = BuildAction.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.testAction = TestAction.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.actionAttributes = ActionAttributes.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.actionDependencies.push(Dependency.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.properties.push(Property.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.files.push(File.decode(reader, reader.uint32()));
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.fileSets.push(reader.string());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.coverage = ActionCoverage.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.fileProcessingErrors.push(FileProcessingErrors.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Action {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      id: isSet(object.id) ? Action_Id.fromJSON(object.id) : undefined,
      statusAttributes: isSet(object.statusAttributes) ? StatusAttributes.fromJSON(object.statusAttributes) : undefined,
      timing: isSet(object.timing) ? Timing.fromJSON(object.timing) : undefined,
      buildAction: isSet(object.buildAction) ? BuildAction.fromJSON(object.buildAction) : undefined,
      testAction: isSet(object.testAction) ? TestAction.fromJSON(object.testAction) : undefined,
      actionAttributes: isSet(object.actionAttributes) ? ActionAttributes.fromJSON(object.actionAttributes) : undefined,
      actionDependencies: globalThis.Array.isArray(object?.actionDependencies)
        ? object.actionDependencies.map((e: any) => Dependency.fromJSON(e))
        : [],
      properties: globalThis.Array.isArray(object?.properties)
        ? object.properties.map((e: any) => Property.fromJSON(e))
        : [],
      files: globalThis.Array.isArray(object?.files) ? object.files.map((e: any) => File.fromJSON(e)) : [],
      fileSets: globalThis.Array.isArray(object?.fileSets) ? object.fileSets.map((e: any) => globalThis.String(e)) : [],
      coverage: isSet(object.coverage) ? ActionCoverage.fromJSON(object.coverage) : undefined,
      fileProcessingErrors: globalThis.Array.isArray(object?.fileProcessingErrors)
        ? object.fileProcessingErrors.map((e: any) => FileProcessingErrors.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Action): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.id !== undefined) {
      obj.id = Action_Id.toJSON(message.id);
    }
    if (message.statusAttributes !== undefined) {
      obj.statusAttributes = StatusAttributes.toJSON(message.statusAttributes);
    }
    if (message.timing !== undefined) {
      obj.timing = Timing.toJSON(message.timing);
    }
    if (message.buildAction !== undefined) {
      obj.buildAction = BuildAction.toJSON(message.buildAction);
    }
    if (message.testAction !== undefined) {
      obj.testAction = TestAction.toJSON(message.testAction);
    }
    if (message.actionAttributes !== undefined) {
      obj.actionAttributes = ActionAttributes.toJSON(message.actionAttributes);
    }
    if (message.actionDependencies?.length) {
      obj.actionDependencies = message.actionDependencies.map((e) => Dependency.toJSON(e));
    }
    if (message.properties?.length) {
      obj.properties = message.properties.map((e) => Property.toJSON(e));
    }
    if (message.files?.length) {
      obj.files = message.files.map((e) => File.toJSON(e));
    }
    if (message.fileSets?.length) {
      obj.fileSets = message.fileSets;
    }
    if (message.coverage !== undefined) {
      obj.coverage = ActionCoverage.toJSON(message.coverage);
    }
    if (message.fileProcessingErrors?.length) {
      obj.fileProcessingErrors = message.fileProcessingErrors.map((e) => FileProcessingErrors.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Action>): Action {
    return Action.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Action>): Action {
    const message = createBaseAction();
    message.name = object.name ?? "";
    message.id = (object.id !== undefined && object.id !== null) ? Action_Id.fromPartial(object.id) : undefined;
    message.statusAttributes = (object.statusAttributes !== undefined && object.statusAttributes !== null)
      ? StatusAttributes.fromPartial(object.statusAttributes)
      : undefined;
    message.timing = (object.timing !== undefined && object.timing !== null)
      ? Timing.fromPartial(object.timing)
      : undefined;
    message.buildAction = (object.buildAction !== undefined && object.buildAction !== null)
      ? BuildAction.fromPartial(object.buildAction)
      : undefined;
    message.testAction = (object.testAction !== undefined && object.testAction !== null)
      ? TestAction.fromPartial(object.testAction)
      : undefined;
    message.actionAttributes = (object.actionAttributes !== undefined && object.actionAttributes !== null)
      ? ActionAttributes.fromPartial(object.actionAttributes)
      : undefined;
    message.actionDependencies = object.actionDependencies?.map((e) => Dependency.fromPartial(e)) || [];
    message.properties = object.properties?.map((e) => Property.fromPartial(e)) || [];
    message.files = object.files?.map((e) => File.fromPartial(e)) || [];
    message.fileSets = object.fileSets?.map((e) => e) || [];
    message.coverage = (object.coverage !== undefined && object.coverage !== null)
      ? ActionCoverage.fromPartial(object.coverage)
      : undefined;
    message.fileProcessingErrors = object.fileProcessingErrors?.map((e) => FileProcessingErrors.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAction_Id(): Action_Id {
  return { invocationId: "", targetId: "", configurationId: "", actionId: "" };
}

export const Action_Id: MessageFns<Action_Id> = {
  encode(message: Action_Id, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.invocationId !== "") {
      writer.uint32(10).string(message.invocationId);
    }
    if (message.targetId !== "") {
      writer.uint32(18).string(message.targetId);
    }
    if (message.configurationId !== "") {
      writer.uint32(26).string(message.configurationId);
    }
    if (message.actionId !== "") {
      writer.uint32(34).string(message.actionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Action_Id {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAction_Id();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.invocationId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.targetId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.configurationId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.actionId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Action_Id {
    return {
      invocationId: isSet(object.invocationId) ? globalThis.String(object.invocationId) : "",
      targetId: isSet(object.targetId) ? globalThis.String(object.targetId) : "",
      configurationId: isSet(object.configurationId) ? globalThis.String(object.configurationId) : "",
      actionId: isSet(object.actionId) ? globalThis.String(object.actionId) : "",
    };
  },

  toJSON(message: Action_Id): unknown {
    const obj: any = {};
    if (message.invocationId !== "") {
      obj.invocationId = message.invocationId;
    }
    if (message.targetId !== "") {
      obj.targetId = message.targetId;
    }
    if (message.configurationId !== "") {
      obj.configurationId = message.configurationId;
    }
    if (message.actionId !== "") {
      obj.actionId = message.actionId;
    }
    return obj;
  },

  create(base?: DeepPartial<Action_Id>): Action_Id {
    return Action_Id.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Action_Id>): Action_Id {
    const message = createBaseAction_Id();
    message.invocationId = object.invocationId ?? "";
    message.targetId = object.targetId ?? "";
    message.configurationId = object.configurationId ?? "";
    message.actionId = object.actionId ?? "";
    return message;
  },
};

function createBaseBuildAction(): BuildAction {
  return { type: "", primaryInputPath: "", primaryOutputPath: "" };
}

export const BuildAction: MessageFns<BuildAction> = {
  encode(message: BuildAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.primaryInputPath !== "") {
      writer.uint32(18).string(message.primaryInputPath);
    }
    if (message.primaryOutputPath !== "") {
      writer.uint32(26).string(message.primaryOutputPath);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.primaryInputPath = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.primaryOutputPath = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildAction {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      primaryInputPath: isSet(object.primaryInputPath) ? globalThis.String(object.primaryInputPath) : "",
      primaryOutputPath: isSet(object.primaryOutputPath) ? globalThis.String(object.primaryOutputPath) : "",
    };
  },

  toJSON(message: BuildAction): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.primaryInputPath !== "") {
      obj.primaryInputPath = message.primaryInputPath;
    }
    if (message.primaryOutputPath !== "") {
      obj.primaryOutputPath = message.primaryOutputPath;
    }
    return obj;
  },

  create(base?: DeepPartial<BuildAction>): BuildAction {
    return BuildAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BuildAction>): BuildAction {
    const message = createBaseBuildAction();
    message.type = object.type ?? "";
    message.primaryInputPath = object.primaryInputPath ?? "";
    message.primaryOutputPath = object.primaryOutputPath ?? "";
    return message;
  },
};

function createBaseTestAction(): TestAction {
  return {
    testTiming: undefined,
    shardNumber: 0,
    runNumber: 0,
    attemptNumber: 0,
    testSuite: undefined,
    warnings: [],
    estimatedMemoryBytes: Long.ZERO,
  };
}

export const TestAction: MessageFns<TestAction> = {
  encode(message: TestAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.testTiming !== undefined) {
      TestTiming.encode(message.testTiming, writer.uint32(10).fork()).join();
    }
    if (message.shardNumber !== 0) {
      writer.uint32(16).int32(message.shardNumber);
    }
    if (message.runNumber !== 0) {
      writer.uint32(24).int32(message.runNumber);
    }
    if (message.attemptNumber !== 0) {
      writer.uint32(32).int32(message.attemptNumber);
    }
    if (message.testSuite !== undefined) {
      TestSuite.encode(message.testSuite, writer.uint32(42).fork()).join();
    }
    for (const v of message.warnings) {
      TestWarning.encode(v!, writer.uint32(66).fork()).join();
    }
    if (!message.estimatedMemoryBytes.equals(Long.ZERO)) {
      writer.uint32(80).int64(message.estimatedMemoryBytes.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.testTiming = TestTiming.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.shardNumber = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.runNumber = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.attemptNumber = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.testSuite = TestSuite.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.warnings.push(TestWarning.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.estimatedMemoryBytes = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestAction {
    return {
      testTiming: isSet(object.testTiming) ? TestTiming.fromJSON(object.testTiming) : undefined,
      shardNumber: isSet(object.shardNumber) ? globalThis.Number(object.shardNumber) : 0,
      runNumber: isSet(object.runNumber) ? globalThis.Number(object.runNumber) : 0,
      attemptNumber: isSet(object.attemptNumber) ? globalThis.Number(object.attemptNumber) : 0,
      testSuite: isSet(object.testSuite) ? TestSuite.fromJSON(object.testSuite) : undefined,
      warnings: globalThis.Array.isArray(object?.warnings)
        ? object.warnings.map((e: any) => TestWarning.fromJSON(e))
        : [],
      estimatedMemoryBytes: isSet(object.estimatedMemoryBytes)
        ? Long.fromValue(object.estimatedMemoryBytes)
        : Long.ZERO,
    };
  },

  toJSON(message: TestAction): unknown {
    const obj: any = {};
    if (message.testTiming !== undefined) {
      obj.testTiming = TestTiming.toJSON(message.testTiming);
    }
    if (message.shardNumber !== 0) {
      obj.shardNumber = Math.round(message.shardNumber);
    }
    if (message.runNumber !== 0) {
      obj.runNumber = Math.round(message.runNumber);
    }
    if (message.attemptNumber !== 0) {
      obj.attemptNumber = Math.round(message.attemptNumber);
    }
    if (message.testSuite !== undefined) {
      obj.testSuite = TestSuite.toJSON(message.testSuite);
    }
    if (message.warnings?.length) {
      obj.warnings = message.warnings.map((e) => TestWarning.toJSON(e));
    }
    if (!message.estimatedMemoryBytes.equals(Long.ZERO)) {
      obj.estimatedMemoryBytes = (message.estimatedMemoryBytes || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<TestAction>): TestAction {
    return TestAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TestAction>): TestAction {
    const message = createBaseTestAction();
    message.testTiming = (object.testTiming !== undefined && object.testTiming !== null)
      ? TestTiming.fromPartial(object.testTiming)
      : undefined;
    message.shardNumber = object.shardNumber ?? 0;
    message.runNumber = object.runNumber ?? 0;
    message.attemptNumber = object.attemptNumber ?? 0;
    message.testSuite = (object.testSuite !== undefined && object.testSuite !== null)
      ? TestSuite.fromPartial(object.testSuite)
      : undefined;
    message.warnings = object.warnings?.map((e) => TestWarning.fromPartial(e)) || [];
    message.estimatedMemoryBytes = (object.estimatedMemoryBytes !== undefined && object.estimatedMemoryBytes !== null)
      ? Long.fromValue(object.estimatedMemoryBytes)
      : Long.ZERO;
    return message;
  },
};

function createBaseActionAttributes(): ActionAttributes {
  return { executionStrategy: 0, exitCode: 0, hostname: "", inputFileInfo: undefined };
}

export const ActionAttributes: MessageFns<ActionAttributes> = {
  encode(message: ActionAttributes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.executionStrategy !== 0) {
      writer.uint32(8).int32(message.executionStrategy);
    }
    if (message.exitCode !== 0) {
      writer.uint32(16).int32(message.exitCode);
    }
    if (message.hostname !== "") {
      writer.uint32(26).string(message.hostname);
    }
    if (message.inputFileInfo !== undefined) {
      InputFileInfo.encode(message.inputFileInfo, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActionAttributes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActionAttributes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.executionStrategy = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.exitCode = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.hostname = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.inputFileInfo = InputFileInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActionAttributes {
    return {
      executionStrategy: isSet(object.executionStrategy) ? executionStrategyFromJSON(object.executionStrategy) : 0,
      exitCode: isSet(object.exitCode) ? globalThis.Number(object.exitCode) : 0,
      hostname: isSet(object.hostname) ? globalThis.String(object.hostname) : "",
      inputFileInfo: isSet(object.inputFileInfo) ? InputFileInfo.fromJSON(object.inputFileInfo) : undefined,
    };
  },

  toJSON(message: ActionAttributes): unknown {
    const obj: any = {};
    if (message.executionStrategy !== 0) {
      obj.executionStrategy = executionStrategyToJSON(message.executionStrategy);
    }
    if (message.exitCode !== 0) {
      obj.exitCode = Math.round(message.exitCode);
    }
    if (message.hostname !== "") {
      obj.hostname = message.hostname;
    }
    if (message.inputFileInfo !== undefined) {
      obj.inputFileInfo = InputFileInfo.toJSON(message.inputFileInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<ActionAttributes>): ActionAttributes {
    return ActionAttributes.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ActionAttributes>): ActionAttributes {
    const message = createBaseActionAttributes();
    message.executionStrategy = object.executionStrategy ?? 0;
    message.exitCode = object.exitCode ?? 0;
    message.hostname = object.hostname ?? "";
    message.inputFileInfo = (object.inputFileInfo !== undefined && object.inputFileInfo !== null)
      ? InputFileInfo.fromPartial(object.inputFileInfo)
      : undefined;
    return message;
  },
};

function createBaseInputFileInfo(): InputFileInfo {
  return {
    count: Long.ZERO,
    distinctCount: Long.ZERO,
    countLimit: Long.ZERO,
    distinctBytes: Long.ZERO,
    distinctByteLimit: Long.ZERO,
  };
}

export const InputFileInfo: MessageFns<InputFileInfo> = {
  encode(message: InputFileInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.count.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.count.toString());
    }
    if (!message.distinctCount.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.distinctCount.toString());
    }
    if (!message.countLimit.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.countLimit.toString());
    }
    if (!message.distinctBytes.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.distinctBytes.toString());
    }
    if (!message.distinctByteLimit.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.distinctByteLimit.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InputFileInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInputFileInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.count = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.distinctCount = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.countLimit = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.distinctBytes = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.distinctByteLimit = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InputFileInfo {
    return {
      count: isSet(object.count) ? Long.fromValue(object.count) : Long.ZERO,
      distinctCount: isSet(object.distinctCount) ? Long.fromValue(object.distinctCount) : Long.ZERO,
      countLimit: isSet(object.countLimit) ? Long.fromValue(object.countLimit) : Long.ZERO,
      distinctBytes: isSet(object.distinctBytes) ? Long.fromValue(object.distinctBytes) : Long.ZERO,
      distinctByteLimit: isSet(object.distinctByteLimit) ? Long.fromValue(object.distinctByteLimit) : Long.ZERO,
    };
  },

  toJSON(message: InputFileInfo): unknown {
    const obj: any = {};
    if (!message.count.equals(Long.ZERO)) {
      obj.count = (message.count || Long.ZERO).toString();
    }
    if (!message.distinctCount.equals(Long.ZERO)) {
      obj.distinctCount = (message.distinctCount || Long.ZERO).toString();
    }
    if (!message.countLimit.equals(Long.ZERO)) {
      obj.countLimit = (message.countLimit || Long.ZERO).toString();
    }
    if (!message.distinctBytes.equals(Long.ZERO)) {
      obj.distinctBytes = (message.distinctBytes || Long.ZERO).toString();
    }
    if (!message.distinctByteLimit.equals(Long.ZERO)) {
      obj.distinctByteLimit = (message.distinctByteLimit || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<InputFileInfo>): InputFileInfo {
    return InputFileInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InputFileInfo>): InputFileInfo {
    const message = createBaseInputFileInfo();
    message.count = (object.count !== undefined && object.count !== null) ? Long.fromValue(object.count) : Long.ZERO;
    message.distinctCount = (object.distinctCount !== undefined && object.distinctCount !== null)
      ? Long.fromValue(object.distinctCount)
      : Long.ZERO;
    message.countLimit = (object.countLimit !== undefined && object.countLimit !== null)
      ? Long.fromValue(object.countLimit)
      : Long.ZERO;
    message.distinctBytes = (object.distinctBytes !== undefined && object.distinctBytes !== null)
      ? Long.fromValue(object.distinctBytes)
      : Long.ZERO;
    message.distinctByteLimit = (object.distinctByteLimit !== undefined && object.distinctByteLimit !== null)
      ? Long.fromValue(object.distinctByteLimit)
      : Long.ZERO;
    return message;
  },
};

function createBaseLocalTestTiming(): LocalTestTiming {
  return { testProcessDuration: undefined };
}

export const LocalTestTiming: MessageFns<LocalTestTiming> = {
  encode(message: LocalTestTiming, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.testProcessDuration !== undefined) {
      Duration.encode(message.testProcessDuration, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LocalTestTiming {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocalTestTiming();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.testProcessDuration = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LocalTestTiming {
    return {
      testProcessDuration: isSet(object.testProcessDuration)
        ? Duration.fromJSON(object.testProcessDuration)
        : undefined,
    };
  },

  toJSON(message: LocalTestTiming): unknown {
    const obj: any = {};
    if (message.testProcessDuration !== undefined) {
      obj.testProcessDuration = Duration.toJSON(message.testProcessDuration);
    }
    return obj;
  },

  create(base?: DeepPartial<LocalTestTiming>): LocalTestTiming {
    return LocalTestTiming.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LocalTestTiming>): LocalTestTiming {
    const message = createBaseLocalTestTiming();
    message.testProcessDuration = (object.testProcessDuration !== undefined && object.testProcessDuration !== null)
      ? Duration.fromPartial(object.testProcessDuration)
      : undefined;
    return message;
  },
};

function createBaseRemoteTestAttemptTiming(): RemoteTestAttemptTiming {
  return {
    queueDuration: undefined,
    uploadDuration: undefined,
    machineSetupDuration: undefined,
    testProcessDuration: undefined,
    downloadDuration: undefined,
  };
}

export const RemoteTestAttemptTiming: MessageFns<RemoteTestAttemptTiming> = {
  encode(message: RemoteTestAttemptTiming, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.queueDuration !== undefined) {
      Duration.encode(message.queueDuration, writer.uint32(10).fork()).join();
    }
    if (message.uploadDuration !== undefined) {
      Duration.encode(message.uploadDuration, writer.uint32(18).fork()).join();
    }
    if (message.machineSetupDuration !== undefined) {
      Duration.encode(message.machineSetupDuration, writer.uint32(26).fork()).join();
    }
    if (message.testProcessDuration !== undefined) {
      Duration.encode(message.testProcessDuration, writer.uint32(34).fork()).join();
    }
    if (message.downloadDuration !== undefined) {
      Duration.encode(message.downloadDuration, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoteTestAttemptTiming {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoteTestAttemptTiming();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.queueDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uploadDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.machineSetupDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.testProcessDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.downloadDuration = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoteTestAttemptTiming {
    return {
      queueDuration: isSet(object.queueDuration) ? Duration.fromJSON(object.queueDuration) : undefined,
      uploadDuration: isSet(object.uploadDuration) ? Duration.fromJSON(object.uploadDuration) : undefined,
      machineSetupDuration: isSet(object.machineSetupDuration)
        ? Duration.fromJSON(object.machineSetupDuration)
        : undefined,
      testProcessDuration: isSet(object.testProcessDuration)
        ? Duration.fromJSON(object.testProcessDuration)
        : undefined,
      downloadDuration: isSet(object.downloadDuration) ? Duration.fromJSON(object.downloadDuration) : undefined,
    };
  },

  toJSON(message: RemoteTestAttemptTiming): unknown {
    const obj: any = {};
    if (message.queueDuration !== undefined) {
      obj.queueDuration = Duration.toJSON(message.queueDuration);
    }
    if (message.uploadDuration !== undefined) {
      obj.uploadDuration = Duration.toJSON(message.uploadDuration);
    }
    if (message.machineSetupDuration !== undefined) {
      obj.machineSetupDuration = Duration.toJSON(message.machineSetupDuration);
    }
    if (message.testProcessDuration !== undefined) {
      obj.testProcessDuration = Duration.toJSON(message.testProcessDuration);
    }
    if (message.downloadDuration !== undefined) {
      obj.downloadDuration = Duration.toJSON(message.downloadDuration);
    }
    return obj;
  },

  create(base?: DeepPartial<RemoteTestAttemptTiming>): RemoteTestAttemptTiming {
    return RemoteTestAttemptTiming.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RemoteTestAttemptTiming>): RemoteTestAttemptTiming {
    const message = createBaseRemoteTestAttemptTiming();
    message.queueDuration = (object.queueDuration !== undefined && object.queueDuration !== null)
      ? Duration.fromPartial(object.queueDuration)
      : undefined;
    message.uploadDuration = (object.uploadDuration !== undefined && object.uploadDuration !== null)
      ? Duration.fromPartial(object.uploadDuration)
      : undefined;
    message.machineSetupDuration = (object.machineSetupDuration !== undefined && object.machineSetupDuration !== null)
      ? Duration.fromPartial(object.machineSetupDuration)
      : undefined;
    message.testProcessDuration = (object.testProcessDuration !== undefined && object.testProcessDuration !== null)
      ? Duration.fromPartial(object.testProcessDuration)
      : undefined;
    message.downloadDuration = (object.downloadDuration !== undefined && object.downloadDuration !== null)
      ? Duration.fromPartial(object.downloadDuration)
      : undefined;
    return message;
  },
};

function createBaseRemoteTestTiming(): RemoteTestTiming {
  return { localAnalysisDuration: undefined, attempts: [] };
}

export const RemoteTestTiming: MessageFns<RemoteTestTiming> = {
  encode(message: RemoteTestTiming, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.localAnalysisDuration !== undefined) {
      Duration.encode(message.localAnalysisDuration, writer.uint32(10).fork()).join();
    }
    for (const v of message.attempts) {
      RemoteTestAttemptTiming.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoteTestTiming {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoteTestTiming();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.localAnalysisDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.attempts.push(RemoteTestAttemptTiming.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoteTestTiming {
    return {
      localAnalysisDuration: isSet(object.localAnalysisDuration)
        ? Duration.fromJSON(object.localAnalysisDuration)
        : undefined,
      attempts: globalThis.Array.isArray(object?.attempts)
        ? object.attempts.map((e: any) => RemoteTestAttemptTiming.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RemoteTestTiming): unknown {
    const obj: any = {};
    if (message.localAnalysisDuration !== undefined) {
      obj.localAnalysisDuration = Duration.toJSON(message.localAnalysisDuration);
    }
    if (message.attempts?.length) {
      obj.attempts = message.attempts.map((e) => RemoteTestAttemptTiming.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RemoteTestTiming>): RemoteTestTiming {
    return RemoteTestTiming.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RemoteTestTiming>): RemoteTestTiming {
    const message = createBaseRemoteTestTiming();
    message.localAnalysisDuration =
      (object.localAnalysisDuration !== undefined && object.localAnalysisDuration !== null)
        ? Duration.fromPartial(object.localAnalysisDuration)
        : undefined;
    message.attempts = object.attempts?.map((e) => RemoteTestAttemptTiming.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTestTiming(): TestTiming {
  return {
    local: undefined,
    remote: undefined,
    systemTimeDuration: undefined,
    userTimeDuration: undefined,
    testCaching: 0,
  };
}

export const TestTiming: MessageFns<TestTiming> = {
  encode(message: TestTiming, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.local !== undefined) {
      LocalTestTiming.encode(message.local, writer.uint32(10).fork()).join();
    }
    if (message.remote !== undefined) {
      RemoteTestTiming.encode(message.remote, writer.uint32(18).fork()).join();
    }
    if (message.systemTimeDuration !== undefined) {
      Duration.encode(message.systemTimeDuration, writer.uint32(26).fork()).join();
    }
    if (message.userTimeDuration !== undefined) {
      Duration.encode(message.userTimeDuration, writer.uint32(34).fork()).join();
    }
    if (message.testCaching !== 0) {
      writer.uint32(40).int32(message.testCaching);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestTiming {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestTiming();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.local = LocalTestTiming.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.remote = RemoteTestTiming.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.systemTimeDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.userTimeDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.testCaching = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestTiming {
    return {
      local: isSet(object.local) ? LocalTestTiming.fromJSON(object.local) : undefined,
      remote: isSet(object.remote) ? RemoteTestTiming.fromJSON(object.remote) : undefined,
      systemTimeDuration: isSet(object.systemTimeDuration) ? Duration.fromJSON(object.systemTimeDuration) : undefined,
      userTimeDuration: isSet(object.userTimeDuration) ? Duration.fromJSON(object.userTimeDuration) : undefined,
      testCaching: isSet(object.testCaching) ? testCachingFromJSON(object.testCaching) : 0,
    };
  },

  toJSON(message: TestTiming): unknown {
    const obj: any = {};
    if (message.local !== undefined) {
      obj.local = LocalTestTiming.toJSON(message.local);
    }
    if (message.remote !== undefined) {
      obj.remote = RemoteTestTiming.toJSON(message.remote);
    }
    if (message.systemTimeDuration !== undefined) {
      obj.systemTimeDuration = Duration.toJSON(message.systemTimeDuration);
    }
    if (message.userTimeDuration !== undefined) {
      obj.userTimeDuration = Duration.toJSON(message.userTimeDuration);
    }
    if (message.testCaching !== 0) {
      obj.testCaching = testCachingToJSON(message.testCaching);
    }
    return obj;
  },

  create(base?: DeepPartial<TestTiming>): TestTiming {
    return TestTiming.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TestTiming>): TestTiming {
    const message = createBaseTestTiming();
    message.local = (object.local !== undefined && object.local !== null)
      ? LocalTestTiming.fromPartial(object.local)
      : undefined;
    message.remote = (object.remote !== undefined && object.remote !== null)
      ? RemoteTestTiming.fromPartial(object.remote)
      : undefined;
    message.systemTimeDuration = (object.systemTimeDuration !== undefined && object.systemTimeDuration !== null)
      ? Duration.fromPartial(object.systemTimeDuration)
      : undefined;
    message.userTimeDuration = (object.userTimeDuration !== undefined && object.userTimeDuration !== null)
      ? Duration.fromPartial(object.userTimeDuration)
      : undefined;
    message.testCaching = object.testCaching ?? 0;
    return message;
  },
};

function createBaseTestWarning(): TestWarning {
  return { warningMessage: "" };
}

export const TestWarning: MessageFns<TestWarning> = {
  encode(message: TestWarning, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.warningMessage !== "") {
      writer.uint32(10).string(message.warningMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestWarning {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestWarning();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.warningMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestWarning {
    return { warningMessage: isSet(object.warningMessage) ? globalThis.String(object.warningMessage) : "" };
  },

  toJSON(message: TestWarning): unknown {
    const obj: any = {};
    if (message.warningMessage !== "") {
      obj.warningMessage = message.warningMessage;
    }
    return obj;
  },

  create(base?: DeepPartial<TestWarning>): TestWarning {
    return TestWarning.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TestWarning>): TestWarning {
    const message = createBaseTestWarning();
    message.warningMessage = object.warningMessage ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
