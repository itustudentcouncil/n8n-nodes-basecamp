// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/devtools/resultstore/v2/invocation.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Property, StatusAttributes, Timing } from "./common.js";
import { AggregateCoverage } from "./coverage.js";
import { LanguageCoverageSummary } from "./coverage_summary.js";
import { File } from "./file.js";
import { FileProcessingErrors } from "./file_processing_error.js";

export const protobufPackage = "google.devtools.resultstore.v2";

/**
 * An Invocation typically represents the result of running a tool. Each has a
 * unique ID, typically generated by the server. Target resources under each
 * Invocation contain the bulk of the data.
 */
export interface Invocation {
  /**
   * The resource name.  Its format must be:
   * invocations/${INVOCATION_ID}
   */
  name: string;
  /**
   * The resource ID components that identify the Invocation. They must match
   * the resource name after proper encoding.
   */
  id:
    | Invocation_Id
    | undefined;
  /** The aggregate status of the invocation. */
  statusAttributes:
    | StatusAttributes
    | undefined;
  /** When this invocation started and its duration. */
  timing:
    | Timing
    | undefined;
  /** Attributes of this invocation. */
  invocationAttributes:
    | InvocationAttributes
    | undefined;
  /** The workspace the tool was run in. */
  workspaceInfo:
    | WorkspaceInfo
    | undefined;
  /**
   * Arbitrary name-value pairs.
   * This is implemented as a multi-map. Multiple properties are allowed with
   * the same key. Properties will be returned in lexicographical order by key.
   */
  properties: Property[];
  /**
   * A list of file references for invocation level files.
   * The file IDs must be unique within this list. Duplicate file IDs will
   * result in an error. Files will be returned in lexicographical order by ID.
   * Use this field to specify build logs, and other invocation level logs.
   *
   * Files with the following reserved file IDs cause specific post-processing
   * or have special handling. These files must be immediately available to
   * ResultStore for processing when the reference is uploaded.
   *
   * build.log: The primary log for the Invocation.
   * coverage_report.lcov: Aggregate coverage report for the invocation.
   */
  files: File[];
  /**
   * Summary of aggregate coverage across all Actions in this Invocation.
   * If missing, this data will be populated by the server from the
   * coverage_report.lcov file or the union of all ActionCoverages under this
   * invocation (in that order).
   */
  coverageSummaries: LanguageCoverageSummary[];
  /**
   * Aggregate code coverage for all build and test Actions within this
   * Invocation. If missing, this data will be populated by the server
   * from the coverage_report.lcov file or the union of all ActionCoverages
   * under this invocation (in that order).
   */
  aggregateCoverage:
    | AggregateCoverage
    | undefined;
  /**
   * NOT IMPLEMENTED.
   * ResultStore will read and parse Files with reserved IDs listed above. Read
   * and parse errors for all these Files are reported here.
   * This is implemented as a map, with one FileProcessingErrors for each file.
   * Typically produced when parsing Files, but may also be provided directly
   * by clients.
   */
  fileProcessingErrors: FileProcessingErrors[];
}

/** The resource ID components that identify the Invocation. */
export interface Invocation_Id {
  /** The Invocation ID. */
  invocationId: string;
}

/** If known, represents the state of the user/build-system workspace. */
export interface WorkspaceContext {
}

/**
 * Describes the workspace under which the tool was invoked, this includes
 * information that was fed into the command, the source code referenced, and
 * the tool itself.
 */
export interface WorkspaceInfo {
  /** Data about the workspace that might be useful for debugging. */
  workspaceContext:
    | WorkspaceContext
    | undefined;
  /** Where the tool was invoked */
  hostname: string;
  /** The client's working directory where the build/test was run from. */
  workingDirectory: string;
  /** Tools should set tool_tag to the name of the tool or use case. */
  toolTag: string;
  /**
   * The command lines invoked. The first command line is the one typed by the
   * user, then each one after that should be an expansion of the previous
   * command line.
   */
  commandLines: CommandLine[];
}

/** The command and arguments that produced this Invocation. */
export interface CommandLine {
  /** A label describing this command line. */
  label: string;
  /** The command-line tool that is run: argv[0]. */
  tool: string;
  /** The arguments to the above tool: argv[1]...argv[N]. */
  args: string[];
  /**
   * The subcommand that was run with the tool, usually "build" or "test".
   * For example, in the Bazel command "bazel build //foo", this would be set
   * to "build". Omit if the tool doesn't accept a subcommand.  This is must
   * be a reference to one of values in args.
   */
  command: string;
}

/** Attributes that apply to all invocations. */
export interface InvocationAttributes {
  /**
   * Immutable. The Cloud Project that owns this invocation (this is different
   * than the Consumer Cloud Project that calls this API). This must be set in
   * the CreateInvocation call, and can't be changed. As input, callers can set
   * this field to a project id (string) or a stringified int64 project number.
   * As output, the API populates this field with the stringified int64 project
   * number (per https://google.aip.dev/cloud/2510).
   */
  projectId: string;
  /**
   * The list of users in the command chain.  The first user in this sequence
   * is the one who instigated the first command in the chain. For example,
   * this might contain just the user that ran a Bazel command, or a robot
   * that tested a change as part of a CI system. It could also contain the user
   * that manually triggered a CI test, then the robot that ran the test.
   */
  users: string[];
  /**
   * Labels to categorize this invocation.
   * This is implemented as a set. All labels will be unique. Any duplicate
   * labels added will be ignored. Labels will be returned in lexicographical
   * order. Labels should be a list of words describing the Invocation. Labels
   * should be short, easy to read, and you shouldn't have more than a handful.
   * Labels should not be used for unique properties such as unique IDs. Use
   * properties in cases that don't meet these conditions.
   */
  labels: string[];
  /**
   * This field describes the overall context or purpose of this invocation.
   * It will be used in the UI to give users more information about
   * how or why this invocation was run.
   */
  description: string;
  /**
   * If this Invocation was run in the context of a larger Continuous
   * Integration build or other automated system, this field may contain more
   * information about the greater context.
   */
  invocationContexts: InvocationContext[];
  /**
   * Exit code of the process that ran the invocation. A non-zero value
   * means failure. For example, the exit code of a "bazel test" command.
   */
  exitCode: number;
}

/** Describes the invocation context which includes a display name and URL. */
export interface InvocationContext {
  /** A human readable name for the context under which this Invocation was run. */
  displayName: string;
  /** A URL pointing to a UI containing more information */
  url: string;
}

function createBaseInvocation(): Invocation {
  return {
    name: "",
    id: undefined,
    statusAttributes: undefined,
    timing: undefined,
    invocationAttributes: undefined,
    workspaceInfo: undefined,
    properties: [],
    files: [],
    coverageSummaries: [],
    aggregateCoverage: undefined,
    fileProcessingErrors: [],
  };
}

export const Invocation: MessageFns<Invocation> = {
  encode(message: Invocation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.id !== undefined) {
      Invocation_Id.encode(message.id, writer.uint32(18).fork()).join();
    }
    if (message.statusAttributes !== undefined) {
      StatusAttributes.encode(message.statusAttributes, writer.uint32(26).fork()).join();
    }
    if (message.timing !== undefined) {
      Timing.encode(message.timing, writer.uint32(34).fork()).join();
    }
    if (message.invocationAttributes !== undefined) {
      InvocationAttributes.encode(message.invocationAttributes, writer.uint32(42).fork()).join();
    }
    if (message.workspaceInfo !== undefined) {
      WorkspaceInfo.encode(message.workspaceInfo, writer.uint32(50).fork()).join();
    }
    for (const v of message.properties) {
      Property.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.files) {
      File.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.coverageSummaries) {
      LanguageCoverageSummary.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.aggregateCoverage !== undefined) {
      AggregateCoverage.encode(message.aggregateCoverage, writer.uint32(82).fork()).join();
    }
    for (const v of message.fileProcessingErrors) {
      FileProcessingErrors.encode(v!, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Invocation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id = Invocation_Id.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.statusAttributes = StatusAttributes.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.timing = Timing.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.invocationAttributes = InvocationAttributes.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.workspaceInfo = WorkspaceInfo.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.properties.push(Property.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.files.push(File.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.coverageSummaries.push(LanguageCoverageSummary.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.aggregateCoverage = AggregateCoverage.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.fileProcessingErrors.push(FileProcessingErrors.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Invocation {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      id: isSet(object.id) ? Invocation_Id.fromJSON(object.id) : undefined,
      statusAttributes: isSet(object.statusAttributes) ? StatusAttributes.fromJSON(object.statusAttributes) : undefined,
      timing: isSet(object.timing) ? Timing.fromJSON(object.timing) : undefined,
      invocationAttributes: isSet(object.invocationAttributes)
        ? InvocationAttributes.fromJSON(object.invocationAttributes)
        : undefined,
      workspaceInfo: isSet(object.workspaceInfo) ? WorkspaceInfo.fromJSON(object.workspaceInfo) : undefined,
      properties: globalThis.Array.isArray(object?.properties)
        ? object.properties.map((e: any) => Property.fromJSON(e))
        : [],
      files: globalThis.Array.isArray(object?.files) ? object.files.map((e: any) => File.fromJSON(e)) : [],
      coverageSummaries: globalThis.Array.isArray(object?.coverageSummaries)
        ? object.coverageSummaries.map((e: any) => LanguageCoverageSummary.fromJSON(e))
        : [],
      aggregateCoverage: isSet(object.aggregateCoverage)
        ? AggregateCoverage.fromJSON(object.aggregateCoverage)
        : undefined,
      fileProcessingErrors: globalThis.Array.isArray(object?.fileProcessingErrors)
        ? object.fileProcessingErrors.map((e: any) => FileProcessingErrors.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Invocation): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.id !== undefined) {
      obj.id = Invocation_Id.toJSON(message.id);
    }
    if (message.statusAttributes !== undefined) {
      obj.statusAttributes = StatusAttributes.toJSON(message.statusAttributes);
    }
    if (message.timing !== undefined) {
      obj.timing = Timing.toJSON(message.timing);
    }
    if (message.invocationAttributes !== undefined) {
      obj.invocationAttributes = InvocationAttributes.toJSON(message.invocationAttributes);
    }
    if (message.workspaceInfo !== undefined) {
      obj.workspaceInfo = WorkspaceInfo.toJSON(message.workspaceInfo);
    }
    if (message.properties?.length) {
      obj.properties = message.properties.map((e) => Property.toJSON(e));
    }
    if (message.files?.length) {
      obj.files = message.files.map((e) => File.toJSON(e));
    }
    if (message.coverageSummaries?.length) {
      obj.coverageSummaries = message.coverageSummaries.map((e) => LanguageCoverageSummary.toJSON(e));
    }
    if (message.aggregateCoverage !== undefined) {
      obj.aggregateCoverage = AggregateCoverage.toJSON(message.aggregateCoverage);
    }
    if (message.fileProcessingErrors?.length) {
      obj.fileProcessingErrors = message.fileProcessingErrors.map((e) => FileProcessingErrors.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Invocation>): Invocation {
    return Invocation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Invocation>): Invocation {
    const message = createBaseInvocation();
    message.name = object.name ?? "";
    message.id = (object.id !== undefined && object.id !== null) ? Invocation_Id.fromPartial(object.id) : undefined;
    message.statusAttributes = (object.statusAttributes !== undefined && object.statusAttributes !== null)
      ? StatusAttributes.fromPartial(object.statusAttributes)
      : undefined;
    message.timing = (object.timing !== undefined && object.timing !== null)
      ? Timing.fromPartial(object.timing)
      : undefined;
    message.invocationAttributes = (object.invocationAttributes !== undefined && object.invocationAttributes !== null)
      ? InvocationAttributes.fromPartial(object.invocationAttributes)
      : undefined;
    message.workspaceInfo = (object.workspaceInfo !== undefined && object.workspaceInfo !== null)
      ? WorkspaceInfo.fromPartial(object.workspaceInfo)
      : undefined;
    message.properties = object.properties?.map((e) => Property.fromPartial(e)) || [];
    message.files = object.files?.map((e) => File.fromPartial(e)) || [];
    message.coverageSummaries = object.coverageSummaries?.map((e) => LanguageCoverageSummary.fromPartial(e)) || [];
    message.aggregateCoverage = (object.aggregateCoverage !== undefined && object.aggregateCoverage !== null)
      ? AggregateCoverage.fromPartial(object.aggregateCoverage)
      : undefined;
    message.fileProcessingErrors = object.fileProcessingErrors?.map((e) => FileProcessingErrors.fromPartial(e)) || [];
    return message;
  },
};

function createBaseInvocation_Id(): Invocation_Id {
  return { invocationId: "" };
}

export const Invocation_Id: MessageFns<Invocation_Id> = {
  encode(message: Invocation_Id, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.invocationId !== "") {
      writer.uint32(10).string(message.invocationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Invocation_Id {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvocation_Id();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.invocationId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Invocation_Id {
    return { invocationId: isSet(object.invocationId) ? globalThis.String(object.invocationId) : "" };
  },

  toJSON(message: Invocation_Id): unknown {
    const obj: any = {};
    if (message.invocationId !== "") {
      obj.invocationId = message.invocationId;
    }
    return obj;
  },

  create(base?: DeepPartial<Invocation_Id>): Invocation_Id {
    return Invocation_Id.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Invocation_Id>): Invocation_Id {
    const message = createBaseInvocation_Id();
    message.invocationId = object.invocationId ?? "";
    return message;
  },
};

function createBaseWorkspaceContext(): WorkspaceContext {
  return {};
}

export const WorkspaceContext: MessageFns<WorkspaceContext> = {
  encode(_: WorkspaceContext, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkspaceContext {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkspaceContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): WorkspaceContext {
    return {};
  },

  toJSON(_: WorkspaceContext): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<WorkspaceContext>): WorkspaceContext {
    return WorkspaceContext.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<WorkspaceContext>): WorkspaceContext {
    const message = createBaseWorkspaceContext();
    return message;
  },
};

function createBaseWorkspaceInfo(): WorkspaceInfo {
  return { workspaceContext: undefined, hostname: "", workingDirectory: "", toolTag: "", commandLines: [] };
}

export const WorkspaceInfo: MessageFns<WorkspaceInfo> = {
  encode(message: WorkspaceInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workspaceContext !== undefined) {
      WorkspaceContext.encode(message.workspaceContext, writer.uint32(10).fork()).join();
    }
    if (message.hostname !== "") {
      writer.uint32(26).string(message.hostname);
    }
    if (message.workingDirectory !== "") {
      writer.uint32(34).string(message.workingDirectory);
    }
    if (message.toolTag !== "") {
      writer.uint32(42).string(message.toolTag);
    }
    for (const v of message.commandLines) {
      CommandLine.encode(v!, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkspaceInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkspaceInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.workspaceContext = WorkspaceContext.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.hostname = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.workingDirectory = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.toolTag = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.commandLines.push(CommandLine.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkspaceInfo {
    return {
      workspaceContext: isSet(object.workspaceContext) ? WorkspaceContext.fromJSON(object.workspaceContext) : undefined,
      hostname: isSet(object.hostname) ? globalThis.String(object.hostname) : "",
      workingDirectory: isSet(object.workingDirectory) ? globalThis.String(object.workingDirectory) : "",
      toolTag: isSet(object.toolTag) ? globalThis.String(object.toolTag) : "",
      commandLines: globalThis.Array.isArray(object?.commandLines)
        ? object.commandLines.map((e: any) => CommandLine.fromJSON(e))
        : [],
    };
  },

  toJSON(message: WorkspaceInfo): unknown {
    const obj: any = {};
    if (message.workspaceContext !== undefined) {
      obj.workspaceContext = WorkspaceContext.toJSON(message.workspaceContext);
    }
    if (message.hostname !== "") {
      obj.hostname = message.hostname;
    }
    if (message.workingDirectory !== "") {
      obj.workingDirectory = message.workingDirectory;
    }
    if (message.toolTag !== "") {
      obj.toolTag = message.toolTag;
    }
    if (message.commandLines?.length) {
      obj.commandLines = message.commandLines.map((e) => CommandLine.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<WorkspaceInfo>): WorkspaceInfo {
    return WorkspaceInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkspaceInfo>): WorkspaceInfo {
    const message = createBaseWorkspaceInfo();
    message.workspaceContext = (object.workspaceContext !== undefined && object.workspaceContext !== null)
      ? WorkspaceContext.fromPartial(object.workspaceContext)
      : undefined;
    message.hostname = object.hostname ?? "";
    message.workingDirectory = object.workingDirectory ?? "";
    message.toolTag = object.toolTag ?? "";
    message.commandLines = object.commandLines?.map((e) => CommandLine.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCommandLine(): CommandLine {
  return { label: "", tool: "", args: [], command: "" };
}

export const CommandLine: MessageFns<CommandLine> = {
  encode(message: CommandLine, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.label !== "") {
      writer.uint32(10).string(message.label);
    }
    if (message.tool !== "") {
      writer.uint32(18).string(message.tool);
    }
    for (const v of message.args) {
      writer.uint32(26).string(v!);
    }
    if (message.command !== "") {
      writer.uint32(34).string(message.command);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommandLine {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommandLine();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.label = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tool = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.args.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.command = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommandLine {
    return {
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      tool: isSet(object.tool) ? globalThis.String(object.tool) : "",
      args: globalThis.Array.isArray(object?.args) ? object.args.map((e: any) => globalThis.String(e)) : [],
      command: isSet(object.command) ? globalThis.String(object.command) : "",
    };
  },

  toJSON(message: CommandLine): unknown {
    const obj: any = {};
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.tool !== "") {
      obj.tool = message.tool;
    }
    if (message.args?.length) {
      obj.args = message.args;
    }
    if (message.command !== "") {
      obj.command = message.command;
    }
    return obj;
  },

  create(base?: DeepPartial<CommandLine>): CommandLine {
    return CommandLine.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CommandLine>): CommandLine {
    const message = createBaseCommandLine();
    message.label = object.label ?? "";
    message.tool = object.tool ?? "";
    message.args = object.args?.map((e) => e) || [];
    message.command = object.command ?? "";
    return message;
  },
};

function createBaseInvocationAttributes(): InvocationAttributes {
  return { projectId: "", users: [], labels: [], description: "", invocationContexts: [], exitCode: 0 };
}

export const InvocationAttributes: MessageFns<InvocationAttributes> = {
  encode(message: InvocationAttributes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    for (const v of message.users) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.labels) {
      writer.uint32(26).string(v!);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    for (const v of message.invocationContexts) {
      InvocationContext.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.exitCode !== 0) {
      writer.uint32(56).int32(message.exitCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InvocationAttributes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvocationAttributes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.users.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.labels.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.invocationContexts.push(InvocationContext.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.exitCode = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvocationAttributes {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      users: globalThis.Array.isArray(object?.users) ? object.users.map((e: any) => globalThis.String(e)) : [],
      labels: globalThis.Array.isArray(object?.labels) ? object.labels.map((e: any) => globalThis.String(e)) : [],
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      invocationContexts: globalThis.Array.isArray(object?.invocationContexts)
        ? object.invocationContexts.map((e: any) => InvocationContext.fromJSON(e))
        : [],
      exitCode: isSet(object.exitCode) ? globalThis.Number(object.exitCode) : 0,
    };
  },

  toJSON(message: InvocationAttributes): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.users?.length) {
      obj.users = message.users;
    }
    if (message.labels?.length) {
      obj.labels = message.labels;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.invocationContexts?.length) {
      obj.invocationContexts = message.invocationContexts.map((e) => InvocationContext.toJSON(e));
    }
    if (message.exitCode !== 0) {
      obj.exitCode = Math.round(message.exitCode);
    }
    return obj;
  },

  create(base?: DeepPartial<InvocationAttributes>): InvocationAttributes {
    return InvocationAttributes.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InvocationAttributes>): InvocationAttributes {
    const message = createBaseInvocationAttributes();
    message.projectId = object.projectId ?? "";
    message.users = object.users?.map((e) => e) || [];
    message.labels = object.labels?.map((e) => e) || [];
    message.description = object.description ?? "";
    message.invocationContexts = object.invocationContexts?.map((e) => InvocationContext.fromPartial(e)) || [];
    message.exitCode = object.exitCode ?? 0;
    return message;
  },
};

function createBaseInvocationContext(): InvocationContext {
  return { displayName: "", url: "" };
}

export const InvocationContext: MessageFns<InvocationContext> = {
  encode(message: InvocationContext, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InvocationContext {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvocationContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvocationContext {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
    };
  },

  toJSON(message: InvocationContext): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    return obj;
  },

  create(base?: DeepPartial<InvocationContext>): InvocationContext {
    return InvocationContext.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InvocationContext>): InvocationContext {
    const message = createBaseInvocationContext();
    message.displayName = object.displayName ?? "";
    message.url = object.url ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
