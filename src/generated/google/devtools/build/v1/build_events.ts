// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/devtools/build/v1/build_events.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Any } from "../../../protobuf/any.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { BuildStatus } from "./build_status.js";

export const protobufPackage = "google.devtools.build.v1";

/** The type of console output stream. */
export enum ConsoleOutputStream {
  /** UNKNOWN - Unspecified or unknown. */
  UNKNOWN = 0,
  /** STDOUT - Normal output stream. */
  STDOUT = 1,
  /** STDERR - Error output stream. */
  STDERR = 2,
  UNRECOGNIZED = -1,
}

export function consoleOutputStreamFromJSON(object: any): ConsoleOutputStream {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return ConsoleOutputStream.UNKNOWN;
    case 1:
    case "STDOUT":
      return ConsoleOutputStream.STDOUT;
    case 2:
    case "STDERR":
      return ConsoleOutputStream.STDERR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ConsoleOutputStream.UNRECOGNIZED;
  }
}

export function consoleOutputStreamToJSON(object: ConsoleOutputStream): string {
  switch (object) {
    case ConsoleOutputStream.UNKNOWN:
      return "UNKNOWN";
    case ConsoleOutputStream.STDOUT:
      return "STDOUT";
    case ConsoleOutputStream.STDERR:
      return "STDERR";
    case ConsoleOutputStream.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * An event representing some state change that occurred in the build. This
 * message does not include field for uniquely identifying an event.
 */
export interface BuildEvent {
  /**
   * This should be precisely the time when this event happened, and not when
   * the event proto was created or sent.
   */
  eventTime:
    | Date
    | undefined;
  /** An invocation attempt has started. */
  invocationAttemptStarted?:
    | BuildEvent_InvocationAttemptStarted
    | undefined;
  /** An invocation attempt has finished. */
  invocationAttemptFinished?:
    | BuildEvent_InvocationAttemptFinished
    | undefined;
  /** The build is enqueued. */
  buildEnqueued?:
    | BuildEvent_BuildEnqueued
    | undefined;
  /** The build has finished. Set when the build is terminated. */
  buildFinished?:
    | BuildEvent_BuildFinished
    | undefined;
  /** An event containing printed text. */
  consoleOutput?:
    | BuildEvent_ConsoleOutput
    | undefined;
  /**
   * Indicates the end of a build event stream (with the same StreamId) from
   * a build component executing the requested build task.
   * *** This field does not indicate the WatchBuild RPC is finished. ***
   */
  componentStreamFinished?:
    | BuildEvent_BuildComponentStreamFinished
    | undefined;
  /** Structured build event generated by Bazel about its execution progress. */
  bazelEvent?:
    | Any
    | undefined;
  /**
   * An event that contains supplemental tool-specific information about
   * build execution.
   */
  buildExecutionEvent?:
    | Any
    | undefined;
  /**
   * An event that contains supplemental tool-specific information about
   * source fetching.
   */
  sourceFetchEvent?: Any | undefined;
}

/** Notification that the build system has attempted to run the build tool. */
export interface BuildEvent_InvocationAttemptStarted {
  /**
   * The number of the invocation attempt, starting at 1 and increasing by 1
   * for each new attempt. Can be used to determine if there is a later
   * invocation attempt replacing the current one a client is processing.
   */
  attemptNumber: Long;
  /** Arbitrary details about the invocation attempt. */
  details: Any | undefined;
}

/** Notification that an invocation attempt has finished. */
export interface BuildEvent_InvocationAttemptFinished {
  /** Final status of the invocation. */
  invocationStatus:
    | BuildStatus
    | undefined;
  /** Arbitrary details about the invocation attempt. */
  details: Any | undefined;
}

/** Notification that the build request is enqueued. */
export interface BuildEvent_BuildEnqueued {
  /** Additional details about the Build. */
  details: Any | undefined;
}

/**
 * Notification that the build request has finished, and no further
 * invocations will occur.  Note that this applies to the entire Build.
 * Individual invocations trigger InvocationFinished when they finish.
 */
export interface BuildEvent_BuildFinished {
  /** Final status of the build. */
  status:
    | BuildStatus
    | undefined;
  /** Additional details about the Build. */
  details: Any | undefined;
}

/** Textual output written to standard output or standard error. */
export interface BuildEvent_ConsoleOutput {
  /** The output stream type. */
  type: ConsoleOutputStream;
  /** Regular UTF-8 output; normal text. */
  textOutput?:
    | string
    | undefined;
  /** Used if the output is not UTF-8 text (for example, a binary proto). */
  binaryOutput?: Buffer | undefined;
}

/**
 * Notification of the end of a build event stream published by a build
 * component other than CONTROLLER (See StreamId.BuildComponents).
 */
export interface BuildEvent_BuildComponentStreamFinished {
  /** How the event stream finished. */
  type: BuildEvent_BuildComponentStreamFinished_FinishType;
}

/** How did the event stream finish. */
export enum BuildEvent_BuildComponentStreamFinished_FinishType {
  /** FINISH_TYPE_UNSPECIFIED - Unknown or unspecified; callers should never set this value. */
  FINISH_TYPE_UNSPECIFIED = 0,
  /**
   * FINISHED - Set by the event publisher to indicate a build event stream is
   * finished.
   */
  FINISHED = 1,
  /**
   * EXPIRED - Set by the WatchBuild RPC server when the publisher of a build event
   * stream stops publishing events without publishing a
   * BuildComponentStreamFinished event whose type equals FINISHED.
   */
  EXPIRED = 2,
  UNRECOGNIZED = -1,
}

export function buildEvent_BuildComponentStreamFinished_FinishTypeFromJSON(
  object: any,
): BuildEvent_BuildComponentStreamFinished_FinishType {
  switch (object) {
    case 0:
    case "FINISH_TYPE_UNSPECIFIED":
      return BuildEvent_BuildComponentStreamFinished_FinishType.FINISH_TYPE_UNSPECIFIED;
    case 1:
    case "FINISHED":
      return BuildEvent_BuildComponentStreamFinished_FinishType.FINISHED;
    case 2:
    case "EXPIRED":
      return BuildEvent_BuildComponentStreamFinished_FinishType.EXPIRED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BuildEvent_BuildComponentStreamFinished_FinishType.UNRECOGNIZED;
  }
}

export function buildEvent_BuildComponentStreamFinished_FinishTypeToJSON(
  object: BuildEvent_BuildComponentStreamFinished_FinishType,
): string {
  switch (object) {
    case BuildEvent_BuildComponentStreamFinished_FinishType.FINISH_TYPE_UNSPECIFIED:
      return "FINISH_TYPE_UNSPECIFIED";
    case BuildEvent_BuildComponentStreamFinished_FinishType.FINISHED:
      return "FINISHED";
    case BuildEvent_BuildComponentStreamFinished_FinishType.EXPIRED:
      return "EXPIRED";
    case BuildEvent_BuildComponentStreamFinished_FinishType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Unique identifier for a build event stream. */
export interface StreamId {
  /** The id of a Build message. */
  buildId: string;
  /**
   * The unique invocation ID within this build.
   * It should be the same as {invocation} (below) during the migration.
   */
  invocationId: string;
  /** The component that emitted this event. */
  component: StreamId_BuildComponent;
}

/**
 * Which build component generates this event stream. Each build component
 * may generate one event stream.
 */
export enum StreamId_BuildComponent {
  /** UNKNOWN_COMPONENT - Unknown or unspecified; callers should never set this value. */
  UNKNOWN_COMPONENT = 0,
  /** CONTROLLER - A component that coordinates builds. */
  CONTROLLER = 1,
  /** WORKER - A component that runs executables needed to complete a build. */
  WORKER = 2,
  /** TOOL - A component that builds something. */
  TOOL = 3,
  UNRECOGNIZED = -1,
}

export function streamId_BuildComponentFromJSON(object: any): StreamId_BuildComponent {
  switch (object) {
    case 0:
    case "UNKNOWN_COMPONENT":
      return StreamId_BuildComponent.UNKNOWN_COMPONENT;
    case 1:
    case "CONTROLLER":
      return StreamId_BuildComponent.CONTROLLER;
    case 2:
    case "WORKER":
      return StreamId_BuildComponent.WORKER;
    case 3:
    case "TOOL":
      return StreamId_BuildComponent.TOOL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StreamId_BuildComponent.UNRECOGNIZED;
  }
}

export function streamId_BuildComponentToJSON(object: StreamId_BuildComponent): string {
  switch (object) {
    case StreamId_BuildComponent.UNKNOWN_COMPONENT:
      return "UNKNOWN_COMPONENT";
    case StreamId_BuildComponent.CONTROLLER:
      return "CONTROLLER";
    case StreamId_BuildComponent.WORKER:
      return "WORKER";
    case StreamId_BuildComponent.TOOL:
      return "TOOL";
    case StreamId_BuildComponent.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseBuildEvent(): BuildEvent {
  return {
    eventTime: undefined,
    invocationAttemptStarted: undefined,
    invocationAttemptFinished: undefined,
    buildEnqueued: undefined,
    buildFinished: undefined,
    consoleOutput: undefined,
    componentStreamFinished: undefined,
    bazelEvent: undefined,
    buildExecutionEvent: undefined,
    sourceFetchEvent: undefined,
  };
}

export const BuildEvent: MessageFns<BuildEvent> = {
  encode(message: BuildEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventTime !== undefined) {
      Timestamp.encode(toTimestamp(message.eventTime), writer.uint32(10).fork()).join();
    }
    if (message.invocationAttemptStarted !== undefined) {
      BuildEvent_InvocationAttemptStarted.encode(message.invocationAttemptStarted, writer.uint32(410).fork()).join();
    }
    if (message.invocationAttemptFinished !== undefined) {
      BuildEvent_InvocationAttemptFinished.encode(message.invocationAttemptFinished, writer.uint32(418).fork()).join();
    }
    if (message.buildEnqueued !== undefined) {
      BuildEvent_BuildEnqueued.encode(message.buildEnqueued, writer.uint32(426).fork()).join();
    }
    if (message.buildFinished !== undefined) {
      BuildEvent_BuildFinished.encode(message.buildFinished, writer.uint32(442).fork()).join();
    }
    if (message.consoleOutput !== undefined) {
      BuildEvent_ConsoleOutput.encode(message.consoleOutput, writer.uint32(450).fork()).join();
    }
    if (message.componentStreamFinished !== undefined) {
      BuildEvent_BuildComponentStreamFinished.encode(message.componentStreamFinished, writer.uint32(474).fork()).join();
    }
    if (message.bazelEvent !== undefined) {
      Any.encode(message.bazelEvent, writer.uint32(482).fork()).join();
    }
    if (message.buildExecutionEvent !== undefined) {
      Any.encode(message.buildExecutionEvent, writer.uint32(490).fork()).join();
    }
    if (message.sourceFetchEvent !== undefined) {
      Any.encode(message.sourceFetchEvent, writer.uint32(498).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 51:
          if (tag !== 410) {
            break;
          }

          message.invocationAttemptStarted = BuildEvent_InvocationAttemptStarted.decode(reader, reader.uint32());
          continue;
        case 52:
          if (tag !== 418) {
            break;
          }

          message.invocationAttemptFinished = BuildEvent_InvocationAttemptFinished.decode(reader, reader.uint32());
          continue;
        case 53:
          if (tag !== 426) {
            break;
          }

          message.buildEnqueued = BuildEvent_BuildEnqueued.decode(reader, reader.uint32());
          continue;
        case 55:
          if (tag !== 442) {
            break;
          }

          message.buildFinished = BuildEvent_BuildFinished.decode(reader, reader.uint32());
          continue;
        case 56:
          if (tag !== 450) {
            break;
          }

          message.consoleOutput = BuildEvent_ConsoleOutput.decode(reader, reader.uint32());
          continue;
        case 59:
          if (tag !== 474) {
            break;
          }

          message.componentStreamFinished = BuildEvent_BuildComponentStreamFinished.decode(reader, reader.uint32());
          continue;
        case 60:
          if (tag !== 482) {
            break;
          }

          message.bazelEvent = Any.decode(reader, reader.uint32());
          continue;
        case 61:
          if (tag !== 490) {
            break;
          }

          message.buildExecutionEvent = Any.decode(reader, reader.uint32());
          continue;
        case 62:
          if (tag !== 498) {
            break;
          }

          message.sourceFetchEvent = Any.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildEvent {
    return {
      eventTime: isSet(object.eventTime) ? fromJsonTimestamp(object.eventTime) : undefined,
      invocationAttemptStarted: isSet(object.invocationAttemptStarted)
        ? BuildEvent_InvocationAttemptStarted.fromJSON(object.invocationAttemptStarted)
        : undefined,
      invocationAttemptFinished: isSet(object.invocationAttemptFinished)
        ? BuildEvent_InvocationAttemptFinished.fromJSON(object.invocationAttemptFinished)
        : undefined,
      buildEnqueued: isSet(object.buildEnqueued) ? BuildEvent_BuildEnqueued.fromJSON(object.buildEnqueued) : undefined,
      buildFinished: isSet(object.buildFinished) ? BuildEvent_BuildFinished.fromJSON(object.buildFinished) : undefined,
      consoleOutput: isSet(object.consoleOutput) ? BuildEvent_ConsoleOutput.fromJSON(object.consoleOutput) : undefined,
      componentStreamFinished: isSet(object.componentStreamFinished)
        ? BuildEvent_BuildComponentStreamFinished.fromJSON(object.componentStreamFinished)
        : undefined,
      bazelEvent: isSet(object.bazelEvent) ? Any.fromJSON(object.bazelEvent) : undefined,
      buildExecutionEvent: isSet(object.buildExecutionEvent) ? Any.fromJSON(object.buildExecutionEvent) : undefined,
      sourceFetchEvent: isSet(object.sourceFetchEvent) ? Any.fromJSON(object.sourceFetchEvent) : undefined,
    };
  },

  toJSON(message: BuildEvent): unknown {
    const obj: any = {};
    if (message.eventTime !== undefined) {
      obj.eventTime = message.eventTime.toISOString();
    }
    if (message.invocationAttemptStarted !== undefined) {
      obj.invocationAttemptStarted = BuildEvent_InvocationAttemptStarted.toJSON(message.invocationAttemptStarted);
    }
    if (message.invocationAttemptFinished !== undefined) {
      obj.invocationAttemptFinished = BuildEvent_InvocationAttemptFinished.toJSON(message.invocationAttemptFinished);
    }
    if (message.buildEnqueued !== undefined) {
      obj.buildEnqueued = BuildEvent_BuildEnqueued.toJSON(message.buildEnqueued);
    }
    if (message.buildFinished !== undefined) {
      obj.buildFinished = BuildEvent_BuildFinished.toJSON(message.buildFinished);
    }
    if (message.consoleOutput !== undefined) {
      obj.consoleOutput = BuildEvent_ConsoleOutput.toJSON(message.consoleOutput);
    }
    if (message.componentStreamFinished !== undefined) {
      obj.componentStreamFinished = BuildEvent_BuildComponentStreamFinished.toJSON(message.componentStreamFinished);
    }
    if (message.bazelEvent !== undefined) {
      obj.bazelEvent = Any.toJSON(message.bazelEvent);
    }
    if (message.buildExecutionEvent !== undefined) {
      obj.buildExecutionEvent = Any.toJSON(message.buildExecutionEvent);
    }
    if (message.sourceFetchEvent !== undefined) {
      obj.sourceFetchEvent = Any.toJSON(message.sourceFetchEvent);
    }
    return obj;
  },

  create(base?: DeepPartial<BuildEvent>): BuildEvent {
    return BuildEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BuildEvent>): BuildEvent {
    const message = createBaseBuildEvent();
    message.eventTime = object.eventTime ?? undefined;
    message.invocationAttemptStarted =
      (object.invocationAttemptStarted !== undefined && object.invocationAttemptStarted !== null)
        ? BuildEvent_InvocationAttemptStarted.fromPartial(object.invocationAttemptStarted)
        : undefined;
    message.invocationAttemptFinished =
      (object.invocationAttemptFinished !== undefined && object.invocationAttemptFinished !== null)
        ? BuildEvent_InvocationAttemptFinished.fromPartial(object.invocationAttemptFinished)
        : undefined;
    message.buildEnqueued = (object.buildEnqueued !== undefined && object.buildEnqueued !== null)
      ? BuildEvent_BuildEnqueued.fromPartial(object.buildEnqueued)
      : undefined;
    message.buildFinished = (object.buildFinished !== undefined && object.buildFinished !== null)
      ? BuildEvent_BuildFinished.fromPartial(object.buildFinished)
      : undefined;
    message.consoleOutput = (object.consoleOutput !== undefined && object.consoleOutput !== null)
      ? BuildEvent_ConsoleOutput.fromPartial(object.consoleOutput)
      : undefined;
    message.componentStreamFinished =
      (object.componentStreamFinished !== undefined && object.componentStreamFinished !== null)
        ? BuildEvent_BuildComponentStreamFinished.fromPartial(object.componentStreamFinished)
        : undefined;
    message.bazelEvent = (object.bazelEvent !== undefined && object.bazelEvent !== null)
      ? Any.fromPartial(object.bazelEvent)
      : undefined;
    message.buildExecutionEvent = (object.buildExecutionEvent !== undefined && object.buildExecutionEvent !== null)
      ? Any.fromPartial(object.buildExecutionEvent)
      : undefined;
    message.sourceFetchEvent = (object.sourceFetchEvent !== undefined && object.sourceFetchEvent !== null)
      ? Any.fromPartial(object.sourceFetchEvent)
      : undefined;
    return message;
  },
};

function createBaseBuildEvent_InvocationAttemptStarted(): BuildEvent_InvocationAttemptStarted {
  return { attemptNumber: Long.ZERO, details: undefined };
}

export const BuildEvent_InvocationAttemptStarted: MessageFns<BuildEvent_InvocationAttemptStarted> = {
  encode(message: BuildEvent_InvocationAttemptStarted, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.attemptNumber.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.attemptNumber.toString());
    }
    if (message.details !== undefined) {
      Any.encode(message.details, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildEvent_InvocationAttemptStarted {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildEvent_InvocationAttemptStarted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.attemptNumber = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.details = Any.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildEvent_InvocationAttemptStarted {
    return {
      attemptNumber: isSet(object.attemptNumber) ? Long.fromValue(object.attemptNumber) : Long.ZERO,
      details: isSet(object.details) ? Any.fromJSON(object.details) : undefined,
    };
  },

  toJSON(message: BuildEvent_InvocationAttemptStarted): unknown {
    const obj: any = {};
    if (!message.attemptNumber.equals(Long.ZERO)) {
      obj.attemptNumber = (message.attemptNumber || Long.ZERO).toString();
    }
    if (message.details !== undefined) {
      obj.details = Any.toJSON(message.details);
    }
    return obj;
  },

  create(base?: DeepPartial<BuildEvent_InvocationAttemptStarted>): BuildEvent_InvocationAttemptStarted {
    return BuildEvent_InvocationAttemptStarted.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BuildEvent_InvocationAttemptStarted>): BuildEvent_InvocationAttemptStarted {
    const message = createBaseBuildEvent_InvocationAttemptStarted();
    message.attemptNumber = (object.attemptNumber !== undefined && object.attemptNumber !== null)
      ? Long.fromValue(object.attemptNumber)
      : Long.ZERO;
    message.details = (object.details !== undefined && object.details !== null)
      ? Any.fromPartial(object.details)
      : undefined;
    return message;
  },
};

function createBaseBuildEvent_InvocationAttemptFinished(): BuildEvent_InvocationAttemptFinished {
  return { invocationStatus: undefined, details: undefined };
}

export const BuildEvent_InvocationAttemptFinished: MessageFns<BuildEvent_InvocationAttemptFinished> = {
  encode(message: BuildEvent_InvocationAttemptFinished, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.invocationStatus !== undefined) {
      BuildStatus.encode(message.invocationStatus, writer.uint32(26).fork()).join();
    }
    if (message.details !== undefined) {
      Any.encode(message.details, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildEvent_InvocationAttemptFinished {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildEvent_InvocationAttemptFinished();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.invocationStatus = BuildStatus.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.details = Any.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildEvent_InvocationAttemptFinished {
    return {
      invocationStatus: isSet(object.invocationStatus) ? BuildStatus.fromJSON(object.invocationStatus) : undefined,
      details: isSet(object.details) ? Any.fromJSON(object.details) : undefined,
    };
  },

  toJSON(message: BuildEvent_InvocationAttemptFinished): unknown {
    const obj: any = {};
    if (message.invocationStatus !== undefined) {
      obj.invocationStatus = BuildStatus.toJSON(message.invocationStatus);
    }
    if (message.details !== undefined) {
      obj.details = Any.toJSON(message.details);
    }
    return obj;
  },

  create(base?: DeepPartial<BuildEvent_InvocationAttemptFinished>): BuildEvent_InvocationAttemptFinished {
    return BuildEvent_InvocationAttemptFinished.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BuildEvent_InvocationAttemptFinished>): BuildEvent_InvocationAttemptFinished {
    const message = createBaseBuildEvent_InvocationAttemptFinished();
    message.invocationStatus = (object.invocationStatus !== undefined && object.invocationStatus !== null)
      ? BuildStatus.fromPartial(object.invocationStatus)
      : undefined;
    message.details = (object.details !== undefined && object.details !== null)
      ? Any.fromPartial(object.details)
      : undefined;
    return message;
  },
};

function createBaseBuildEvent_BuildEnqueued(): BuildEvent_BuildEnqueued {
  return { details: undefined };
}

export const BuildEvent_BuildEnqueued: MessageFns<BuildEvent_BuildEnqueued> = {
  encode(message: BuildEvent_BuildEnqueued, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.details !== undefined) {
      Any.encode(message.details, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildEvent_BuildEnqueued {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildEvent_BuildEnqueued();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.details = Any.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildEvent_BuildEnqueued {
    return { details: isSet(object.details) ? Any.fromJSON(object.details) : undefined };
  },

  toJSON(message: BuildEvent_BuildEnqueued): unknown {
    const obj: any = {};
    if (message.details !== undefined) {
      obj.details = Any.toJSON(message.details);
    }
    return obj;
  },

  create(base?: DeepPartial<BuildEvent_BuildEnqueued>): BuildEvent_BuildEnqueued {
    return BuildEvent_BuildEnqueued.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BuildEvent_BuildEnqueued>): BuildEvent_BuildEnqueued {
    const message = createBaseBuildEvent_BuildEnqueued();
    message.details = (object.details !== undefined && object.details !== null)
      ? Any.fromPartial(object.details)
      : undefined;
    return message;
  },
};

function createBaseBuildEvent_BuildFinished(): BuildEvent_BuildFinished {
  return { status: undefined, details: undefined };
}

export const BuildEvent_BuildFinished: MessageFns<BuildEvent_BuildFinished> = {
  encode(message: BuildEvent_BuildFinished, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      BuildStatus.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.details !== undefined) {
      Any.encode(message.details, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildEvent_BuildFinished {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildEvent_BuildFinished();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.status = BuildStatus.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.details = Any.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildEvent_BuildFinished {
    return {
      status: isSet(object.status) ? BuildStatus.fromJSON(object.status) : undefined,
      details: isSet(object.details) ? Any.fromJSON(object.details) : undefined,
    };
  },

  toJSON(message: BuildEvent_BuildFinished): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = BuildStatus.toJSON(message.status);
    }
    if (message.details !== undefined) {
      obj.details = Any.toJSON(message.details);
    }
    return obj;
  },

  create(base?: DeepPartial<BuildEvent_BuildFinished>): BuildEvent_BuildFinished {
    return BuildEvent_BuildFinished.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BuildEvent_BuildFinished>): BuildEvent_BuildFinished {
    const message = createBaseBuildEvent_BuildFinished();
    message.status = (object.status !== undefined && object.status !== null)
      ? BuildStatus.fromPartial(object.status)
      : undefined;
    message.details = (object.details !== undefined && object.details !== null)
      ? Any.fromPartial(object.details)
      : undefined;
    return message;
  },
};

function createBaseBuildEvent_ConsoleOutput(): BuildEvent_ConsoleOutput {
  return { type: 0, textOutput: undefined, binaryOutput: undefined };
}

export const BuildEvent_ConsoleOutput: MessageFns<BuildEvent_ConsoleOutput> = {
  encode(message: BuildEvent_ConsoleOutput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.textOutput !== undefined) {
      writer.uint32(18).string(message.textOutput);
    }
    if (message.binaryOutput !== undefined) {
      writer.uint32(26).bytes(message.binaryOutput);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildEvent_ConsoleOutput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildEvent_ConsoleOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.textOutput = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.binaryOutput = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildEvent_ConsoleOutput {
    return {
      type: isSet(object.type) ? consoleOutputStreamFromJSON(object.type) : 0,
      textOutput: isSet(object.textOutput) ? globalThis.String(object.textOutput) : undefined,
      binaryOutput: isSet(object.binaryOutput) ? Buffer.from(bytesFromBase64(object.binaryOutput)) : undefined,
    };
  },

  toJSON(message: BuildEvent_ConsoleOutput): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = consoleOutputStreamToJSON(message.type);
    }
    if (message.textOutput !== undefined) {
      obj.textOutput = message.textOutput;
    }
    if (message.binaryOutput !== undefined) {
      obj.binaryOutput = base64FromBytes(message.binaryOutput);
    }
    return obj;
  },

  create(base?: DeepPartial<BuildEvent_ConsoleOutput>): BuildEvent_ConsoleOutput {
    return BuildEvent_ConsoleOutput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BuildEvent_ConsoleOutput>): BuildEvent_ConsoleOutput {
    const message = createBaseBuildEvent_ConsoleOutput();
    message.type = object.type ?? 0;
    message.textOutput = object.textOutput ?? undefined;
    message.binaryOutput = object.binaryOutput ?? undefined;
    return message;
  },
};

function createBaseBuildEvent_BuildComponentStreamFinished(): BuildEvent_BuildComponentStreamFinished {
  return { type: 0 };
}

export const BuildEvent_BuildComponentStreamFinished: MessageFns<BuildEvent_BuildComponentStreamFinished> = {
  encode(message: BuildEvent_BuildComponentStreamFinished, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildEvent_BuildComponentStreamFinished {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildEvent_BuildComponentStreamFinished();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildEvent_BuildComponentStreamFinished {
    return { type: isSet(object.type) ? buildEvent_BuildComponentStreamFinished_FinishTypeFromJSON(object.type) : 0 };
  },

  toJSON(message: BuildEvent_BuildComponentStreamFinished): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = buildEvent_BuildComponentStreamFinished_FinishTypeToJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<BuildEvent_BuildComponentStreamFinished>): BuildEvent_BuildComponentStreamFinished {
    return BuildEvent_BuildComponentStreamFinished.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BuildEvent_BuildComponentStreamFinished>): BuildEvent_BuildComponentStreamFinished {
    const message = createBaseBuildEvent_BuildComponentStreamFinished();
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseStreamId(): StreamId {
  return { buildId: "", invocationId: "", component: 0 };
}

export const StreamId: MessageFns<StreamId> = {
  encode(message: StreamId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.buildId !== "") {
      writer.uint32(10).string(message.buildId);
    }
    if (message.invocationId !== "") {
      writer.uint32(50).string(message.invocationId);
    }
    if (message.component !== 0) {
      writer.uint32(24).int32(message.component);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.buildId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.invocationId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.component = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamId {
    return {
      buildId: isSet(object.buildId) ? globalThis.String(object.buildId) : "",
      invocationId: isSet(object.invocationId) ? globalThis.String(object.invocationId) : "",
      component: isSet(object.component) ? streamId_BuildComponentFromJSON(object.component) : 0,
    };
  },

  toJSON(message: StreamId): unknown {
    const obj: any = {};
    if (message.buildId !== "") {
      obj.buildId = message.buildId;
    }
    if (message.invocationId !== "") {
      obj.invocationId = message.invocationId;
    }
    if (message.component !== 0) {
      obj.component = streamId_BuildComponentToJSON(message.component);
    }
    return obj;
  },

  create(base?: DeepPartial<StreamId>): StreamId {
    return StreamId.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamId>): StreamId {
    const message = createBaseStreamId();
    message.buildId = object.buildId ?? "";
    message.invocationId = object.invocationId ?? "";
    message.component = object.component ?? 0;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
