// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/devtools/remoteworkers/v1test2/worker.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "google.devtools.remoteworkers.v1test2";

/**
 * Describes a worker, which is a list of one or more devices and the
 * connections between them. A device could be a computer, a phone, or even an
 * accelerator like a GPU; it's up to the farm administrator to decide how to
 * model their farm. For example, if a farm only has one type of GPU, the GPU
 * could be modelled as a "has_gpu" property on its host computer; if it has
 * many subproperties itself, it might be better to model it as a separate
 * device.
 *
 * The first device in the worker is the "primary device" - that is, the device
 * running a bot and which is responsible for actually executing commands. All
 * other devices are considered to be attached devices, and must be controllable
 * by the primary device.
 *
 * This message (and all its submessages) can be used in two contexts:
 *
 * * Status: sent by the bot to report the current capabilities of the device to
 * allow reservation matching.
 * * Request: sent by a client to request a device with certain capabilities in
 * a reservation.
 *
 * Several of the fields in this message have different semantics depending on
 * which of which of these contexts it is used. These semantics are described
 * below.
 *
 * Several messages in Worker and its submessages have the concept of keys and
 * values, such as `Worker.Property` and `Device.Property`. All keys are simple
 * strings, but certain keys are "standard" keys and should be broadly supported
 * across farms and implementations; these are listed below each relevant
 * message. Bot implementations or farm admins may add *additional* keys, but
 * these SHOULD all begin with an underscore so they do not conflict with
 * standard keys that may be added in the future.
 *
 * Keys are not context sensitive.
 *
 * See http://goo.gl/NurY8g for more information on the Worker message.
 */
export interface Worker {
  /**
   * A list of devices; the first device is the primary device. See the `Device`
   * message for more information.
   */
  devices: Device[];
  /**
   * A worker may contain "global" properties. For example, certain machines
   * might be reserved for certain types of jobs, like short-running compilation
   * versus long-running integration tests. This property is known as a "pool"
   * and is not related to any one device within the worker; rather, it applies
   * to the worker as a whole.
   *
   * The behaviour of repeated keys is identical to that of Device.Property.
   */
  properties: Worker_Property[];
  /**
   * Bots can be configured in certain ways when accepting leases. For example,
   * many leases are executed inside a Docker container. To support this, the
   * bot needs to be able to report that it has Docker installed (and knows how
   * to execute something inside a container), and the task submitter needs to
   * specify which image should be used to start the container. Similarly, a
   * lease may be able to run as one of several users on the worker; in such
   * cases, the bot needs to report what users are available, and the submitter
   * needs to choose one.
   *
   * Therefore, when this message is reported by the bot to the service, each
   * key represents a *type* of configuration that the bot knows how to set,
   * while each *value* represents a legal value for that configuration (the
   * empty string is interpretted as a wildcard, such as for Docker images).
   * When this message is sent by the server to the bot in the context of a
   * lease, it represents a command to the bot to apply the setting. Keys may
   * be repeated during reporting but not in a lease.
   */
  configs: Worker_Config[];
}

/** A global property; see the `properties` field for more information. */
export interface Worker_Property {
  /**
   * For general information on keys, see the documentation to `Worker`.
   *
   * The current set of standard keys are:
   *
   * * pool: different workers can be reserved for different purposes. For
   * example, an admin might want to segregate long-running integration tests
   * from short-running unit tests, so unit tests will always get some
   * throughput. To support this, the server can assign different values for
   * `pool` (such as "itest" and "utest") to different workers, and then have
   * jobs request workers from those pools.
   */
  key: string;
  /** The property's value. */
  value: string;
}

/**
 * A configuration request or report; see the `configs` field for more
 * information.
 */
export interface Worker_Config {
  /**
   * For general information on keys, see the documentation to `Worker`.
   *
   * The current set of standard keys are:
   *
   * * DockerImage: the image of the container. When being reported by the
   * bot, the empty value should always be included if the bot is able to pull
   * its own images; the bot may optionally *also* report images that are
   * present in its cache. When being requested in a lease, the value is the
   * URI of the image (eg `gcr.io/user/image@sha256:hash`).
   */
  key: string;
  /** The configuration's value. */
  value: string;
}

/**
 * Any device, including computers, phones, accelerators (e.g. GPUs), etc. All
 * names must be unique.
 */
export interface Device {
  /**
   * The handle can be thought of as the "name" of the device, and must be
   * unique within a Worker.
   *
   * In the Status context, the handle should be some human-understandable name,
   * perhaps corresponding to a label physically written on the device to make
   * it easy to locate. In the Request context, the name should be the
   * *logical* name expected by the task. The bot is responsible for mapping the
   * logical name expected by the task to a machine-readable name that the task
   * can actually use, such as a USB address. The method by which this mapping
   * is communicated to the task is not covered in this API.
   */
  handle: string;
  /**
   * Properties of this device that don't change based on the tasks that are
   * running on it, e.g. OS, CPU architecture, etc.
   *
   * Keys may be repeated, and have the following interpretation:
   *
   *    * Status context: the device can support *any* the listed values. For
   *    example, an "ISA" property might include "x86", "x86-64" and "sse4".
   *
   *    * Request context: the device *must* support *all* of the listed values.
   */
  properties: Device_Property[];
}

/** A device property; see `properties` for more information. */
export interface Device_Property {
  /**
   * For general information on keys, see the documentation to `Worker`.
   *
   * The current set of standard keys are:
   *
   * * os: a human-readable description of the OS. Examples include `linux`,
   * `ubuntu` and `ubuntu 14.04` (note that a bot may advertise itself as more
   * than one). This will be replaced in the future by more well-structured
   * keys and values to represent OS variants.
   *
   * * has-docker: "true" if the bot has Docker installed. This will be
   * replaced in the future by a more structured message for Docker support.
   */
  key: string;
  /** The property's value. */
  value: string;
}

function createBaseWorker(): Worker {
  return { devices: [], properties: [], configs: [] };
}

export const Worker: MessageFns<Worker> = {
  encode(message: Worker, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.devices) {
      Device.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.properties) {
      Worker_Property.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.configs) {
      Worker_Config.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Worker {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorker();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.devices.push(Device.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.properties.push(Worker_Property.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.configs.push(Worker_Config.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Worker {
    return {
      devices: globalThis.Array.isArray(object?.devices) ? object.devices.map((e: any) => Device.fromJSON(e)) : [],
      properties: globalThis.Array.isArray(object?.properties)
        ? object.properties.map((e: any) => Worker_Property.fromJSON(e))
        : [],
      configs: globalThis.Array.isArray(object?.configs)
        ? object.configs.map((e: any) => Worker_Config.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Worker): unknown {
    const obj: any = {};
    if (message.devices?.length) {
      obj.devices = message.devices.map((e) => Device.toJSON(e));
    }
    if (message.properties?.length) {
      obj.properties = message.properties.map((e) => Worker_Property.toJSON(e));
    }
    if (message.configs?.length) {
      obj.configs = message.configs.map((e) => Worker_Config.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Worker>): Worker {
    return Worker.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Worker>): Worker {
    const message = createBaseWorker();
    message.devices = object.devices?.map((e) => Device.fromPartial(e)) || [];
    message.properties = object.properties?.map((e) => Worker_Property.fromPartial(e)) || [];
    message.configs = object.configs?.map((e) => Worker_Config.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWorker_Property(): Worker_Property {
  return { key: "", value: "" };
}

export const Worker_Property: MessageFns<Worker_Property> = {
  encode(message: Worker_Property, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Worker_Property {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorker_Property();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Worker_Property {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Worker_Property): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Worker_Property>): Worker_Property {
    return Worker_Property.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Worker_Property>): Worker_Property {
    const message = createBaseWorker_Property();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseWorker_Config(): Worker_Config {
  return { key: "", value: "" };
}

export const Worker_Config: MessageFns<Worker_Config> = {
  encode(message: Worker_Config, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Worker_Config {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorker_Config();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Worker_Config {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Worker_Config): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Worker_Config>): Worker_Config {
    return Worker_Config.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Worker_Config>): Worker_Config {
    const message = createBaseWorker_Config();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseDevice(): Device {
  return { handle: "", properties: [] };
}

export const Device: MessageFns<Device> = {
  encode(message: Device, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.handle !== "") {
      writer.uint32(10).string(message.handle);
    }
    for (const v of message.properties) {
      Device_Property.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Device {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDevice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.handle = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.properties.push(Device_Property.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Device {
    return {
      handle: isSet(object.handle) ? globalThis.String(object.handle) : "",
      properties: globalThis.Array.isArray(object?.properties)
        ? object.properties.map((e: any) => Device_Property.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Device): unknown {
    const obj: any = {};
    if (message.handle !== "") {
      obj.handle = message.handle;
    }
    if (message.properties?.length) {
      obj.properties = message.properties.map((e) => Device_Property.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Device>): Device {
    return Device.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Device>): Device {
    const message = createBaseDevice();
    message.handle = object.handle ?? "";
    message.properties = object.properties?.map((e) => Device_Property.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDevice_Property(): Device_Property {
  return { key: "", value: "" };
}

export const Device_Property: MessageFns<Device_Property> = {
  encode(message: Device_Property, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Device_Property {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDevice_Property();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Device_Property {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Device_Property): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Device_Property>): Device_Property {
    return Device_Property.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Device_Property>): Device_Property {
    const message = createBaseDevice_Property();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
