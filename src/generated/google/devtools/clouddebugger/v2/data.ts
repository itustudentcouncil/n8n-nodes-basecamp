// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/devtools/clouddebugger/v2/data.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Int32Value } from "../../../protobuf/wrappers.js";
import { ExtendedSourceContext, SourceContext } from "../../source/v1/source_context.js";

export const protobufPackage = "google.devtools.clouddebugger.v2";

/** Represents a message with parameters. */
export interface FormatMessage {
  /**
   * Format template for the message. The `format` uses placeholders `$0`,
   * `$1`, etc. to reference parameters. `$$` can be used to denote the `$`
   * character.
   *
   * Examples:
   *
   * *   `Failed to load '$0' which helps debug $1 the first time it
   *     is loaded.  Again, $0 is very important.`
   * *   `Please pay $$10 to use $0 instead of $1.`
   */
  format: string;
  /** Optional parameters to be embedded into the message. */
  parameters: string[];
}

/**
 * Represents a contextual status message.
 * The message can indicate an error or informational status, and refer to
 * specific parts of the containing object.
 * For example, the `Breakpoint.status` field can indicate an error referring
 * to the `BREAKPOINT_SOURCE_LOCATION` with the message `Location not found`.
 */
export interface StatusMessage {
  /** Distinguishes errors from informational messages. */
  isError: boolean;
  /** Reference to which the message applies. */
  refersTo: StatusMessage_Reference;
  /** Status message text. */
  description: FormatMessage | undefined;
}

/** Enumerates references to which the message applies. */
export enum StatusMessage_Reference {
  /** UNSPECIFIED - Status doesn't refer to any particular input. */
  UNSPECIFIED = 0,
  /** BREAKPOINT_SOURCE_LOCATION - Status applies to the breakpoint and is related to its location. */
  BREAKPOINT_SOURCE_LOCATION = 3,
  /** BREAKPOINT_CONDITION - Status applies to the breakpoint and is related to its condition. */
  BREAKPOINT_CONDITION = 4,
  /** BREAKPOINT_EXPRESSION - Status applies to the breakpoint and is related to its expressions. */
  BREAKPOINT_EXPRESSION = 7,
  /** BREAKPOINT_AGE - Status applies to the breakpoint and is related to its age. */
  BREAKPOINT_AGE = 8,
  /** VARIABLE_NAME - Status applies to the entire variable. */
  VARIABLE_NAME = 5,
  /** VARIABLE_VALUE - Status applies to variable value (variable name is valid). */
  VARIABLE_VALUE = 6,
  UNRECOGNIZED = -1,
}

export function statusMessage_ReferenceFromJSON(object: any): StatusMessage_Reference {
  switch (object) {
    case 0:
    case "UNSPECIFIED":
      return StatusMessage_Reference.UNSPECIFIED;
    case 3:
    case "BREAKPOINT_SOURCE_LOCATION":
      return StatusMessage_Reference.BREAKPOINT_SOURCE_LOCATION;
    case 4:
    case "BREAKPOINT_CONDITION":
      return StatusMessage_Reference.BREAKPOINT_CONDITION;
    case 7:
    case "BREAKPOINT_EXPRESSION":
      return StatusMessage_Reference.BREAKPOINT_EXPRESSION;
    case 8:
    case "BREAKPOINT_AGE":
      return StatusMessage_Reference.BREAKPOINT_AGE;
    case 5:
    case "VARIABLE_NAME":
      return StatusMessage_Reference.VARIABLE_NAME;
    case 6:
    case "VARIABLE_VALUE":
      return StatusMessage_Reference.VARIABLE_VALUE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StatusMessage_Reference.UNRECOGNIZED;
  }
}

export function statusMessage_ReferenceToJSON(object: StatusMessage_Reference): string {
  switch (object) {
    case StatusMessage_Reference.UNSPECIFIED:
      return "UNSPECIFIED";
    case StatusMessage_Reference.BREAKPOINT_SOURCE_LOCATION:
      return "BREAKPOINT_SOURCE_LOCATION";
    case StatusMessage_Reference.BREAKPOINT_CONDITION:
      return "BREAKPOINT_CONDITION";
    case StatusMessage_Reference.BREAKPOINT_EXPRESSION:
      return "BREAKPOINT_EXPRESSION";
    case StatusMessage_Reference.BREAKPOINT_AGE:
      return "BREAKPOINT_AGE";
    case StatusMessage_Reference.VARIABLE_NAME:
      return "VARIABLE_NAME";
    case StatusMessage_Reference.VARIABLE_VALUE:
      return "VARIABLE_VALUE";
    case StatusMessage_Reference.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Represents a location in the source code. */
export interface SourceLocation {
  /** Path to the source file within the source context of the target binary. */
  path: string;
  /** Line inside the file. The first line in the file has the value `1`. */
  line: number;
  /**
   * Column within a line. The first column in a line as the value `1`.
   * Agents that do not support setting breakpoints on specific columns ignore
   * this field.
   */
  column: number;
}

/**
 * Represents a variable or an argument possibly of a compound object type.
 * Note how the following variables are represented:
 *
 * 1) A simple variable:
 *
 *     int x = 5
 *
 *     { name: "x", value: "5", type: "int" }  // Captured variable
 *
 * 2) A compound object:
 *
 *     struct T {
 *         int m1;
 *         int m2;
 *     };
 *     T x = { 3, 7 };
 *
 *     {  // Captured variable
 *         name: "x",
 *         type: "T",
 *         members { name: "m1", value: "3", type: "int" },
 *         members { name: "m2", value: "7", type: "int" }
 *     }
 *
 * 3) A pointer where the pointee was captured:
 *
 *     T x = { 3, 7 };
 *     T* p = &x;
 *
 *     {   // Captured variable
 *         name: "p",
 *         type: "T*",
 *         value: "0x00500500",
 *         members { name: "m1", value: "3", type: "int" },
 *         members { name: "m2", value: "7", type: "int" }
 *     }
 *
 * 4) A pointer where the pointee was not captured:
 *
 *     T* p = new T;
 *
 *     {   // Captured variable
 *         name: "p",
 *         type: "T*",
 *         value: "0x00400400"
 *         status { is_error: true, description { format: "unavailable" } }
 *     }
 *
 * The status should describe the reason for the missing value,
 * such as `<optimized out>`, `<inaccessible>`, `<pointers limit reached>`.
 *
 * Note that a null pointer should not have members.
 *
 * 5) An unnamed value:
 *
 *     int* p = new int(7);
 *
 *     {   // Captured variable
 *         name: "p",
 *         value: "0x00500500",
 *         type: "int*",
 *         members { value: "7", type: "int" } }
 *
 * 6) An unnamed pointer where the pointee was not captured:
 *
 *     int* p = new int(7);
 *     int** pp = &p;
 *
 *     {  // Captured variable
 *         name: "pp",
 *         value: "0x00500500",
 *         type: "int**",
 *         members {
 *             value: "0x00400400",
 *             type: "int*"
 *             status {
 *                 is_error: true,
 *                 description: { format: "unavailable" } }
 *             }
 *         }
 *     }
 *
 * To optimize computation, memory and network traffic, variables that
 * repeat in the output multiple times can be stored once in a shared
 * variable table and be referenced using the `var_table_index` field.  The
 * variables stored in the shared table are nameless and are essentially
 * a partition of the complete variable. To reconstruct the complete
 * variable, merge the referencing variable with the referenced variable.
 *
 * When using the shared variable table, the following variables:
 *
 *     T x = { 3, 7 };
 *     T* p = &x;
 *     T& r = x;
 *
 *     { name: "x", var_table_index: 3, type: "T" }  // Captured variables
 *     { name: "p", value "0x00500500", type="T*", var_table_index: 3 }
 *     { name: "r", type="T&", var_table_index: 3 }
 *
 *     {  // Shared variable table entry #3:
 *         members { name: "m1", value: "3", type: "int" },
 *         members { name: "m2", value: "7", type: "int" }
 *     }
 *
 * Note that the pointer address is stored with the referencing variable
 * and not with the referenced variable. This allows the referenced variable
 * to be shared between pointers and references.
 *
 * The type field is optional. The debugger agent may or may not support it.
 */
export interface Variable {
  /** Name of the variable, if any. */
  name: string;
  /** Simple value of the variable. */
  value: string;
  /**
   * Variable type (e.g. `MyClass`). If the variable is split with
   * `var_table_index`, `type` goes next to `value`. The interpretation of
   * a type is agent specific. It is recommended to include the dynamic type
   * rather than a static type of an object.
   */
  type: string;
  /** Members contained or pointed to by the variable. */
  members: Variable[];
  /**
   * Reference to a variable in the shared variable table. More than
   * one variable can reference the same variable in the table. The
   * `var_table_index` field is an index into `variable_table` in Breakpoint.
   */
  varTableIndex:
    | number
    | undefined;
  /**
   * Status associated with the variable. This field will usually stay
   * unset. A status of a single variable only applies to that variable or
   * expression. The rest of breakpoint data still remains valid. Variables
   * might be reported in error state even when breakpoint is not in final
   * state.
   *
   * The message may refer to variable name with `refers_to` set to
   * `VARIABLE_NAME`. Alternatively `refers_to` will be set to `VARIABLE_VALUE`.
   * In either case variable value and members will be unset.
   *
   * Example of error message applied to name: `Invalid expression syntax`.
   *
   * Example of information message applied to value: `Not captured`.
   *
   * Examples of error message applied to value:
   *
   * *   `Malformed string`,
   * *   `Field f not found in class C`
   * *   `Null pointer dereference`
   */
  status: StatusMessage | undefined;
}

/** Represents a stack frame context. */
export interface StackFrame {
  /** Demangled function name at the call site. */
  function: string;
  /** Source location of the call site. */
  location:
    | SourceLocation
    | undefined;
  /**
   * Set of arguments passed to this function.
   * Note that this might not be populated for all stack frames.
   */
  arguments: Variable[];
  /**
   * Set of local variables at the stack frame location.
   * Note that this might not be populated for all stack frames.
   */
  locals: Variable[];
}

/** Represents the breakpoint specification, status and results. */
export interface Breakpoint {
  /** Breakpoint identifier, unique in the scope of the debuggee. */
  id: string;
  /**
   * Action that the agent should perform when the code at the
   * breakpoint location is hit.
   */
  action: Breakpoint_Action;
  /** Breakpoint source location. */
  location:
    | SourceLocation
    | undefined;
  /**
   * Condition that triggers the breakpoint.
   * The condition is a compound boolean expression composed using expressions
   * in a programming language at the source location.
   */
  condition: string;
  /**
   * List of read-only expressions to evaluate at the breakpoint location.
   * The expressions are composed using expressions in the programming language
   * at the source location. If the breakpoint action is `LOG`, the evaluated
   * expressions are included in log statements.
   */
  expressions: string[];
  /**
   * Only relevant when action is `LOG`. Defines the message to log when
   * the breakpoint hits. The message may include parameter placeholders `$0`,
   * `$1`, etc. These placeholders are replaced with the evaluated value
   * of the appropriate expression. Expressions not referenced in
   * `log_message_format` are not logged.
   *
   * Example: `Message received, id = $0, count = $1` with
   * `expressions` = `[ message.id, message.count ]`.
   */
  logMessageFormat: string;
  /** Indicates the severity of the log. Only relevant when action is `LOG`. */
  logLevel: Breakpoint_LogLevel;
  /**
   * When true, indicates that this is a final result and the
   * breakpoint state will not change from here on.
   */
  isFinalState: boolean;
  /** Time this breakpoint was created by the server in seconds resolution. */
  createTime:
    | Date
    | undefined;
  /**
   * Time this breakpoint was finalized as seen by the server in seconds
   * resolution.
   */
  finalTime:
    | Date
    | undefined;
  /** E-mail address of the user that created this breakpoint */
  userEmail: string;
  /**
   * Breakpoint status.
   *
   * The status includes an error flag and a human readable message.
   * This field is usually unset. The message can be either
   * informational or an error message. Regardless, clients should always
   * display the text message back to the user.
   *
   * Error status indicates complete failure of the breakpoint.
   *
   * Example (non-final state): `Still loading symbols...`
   *
   * Examples (final state):
   *
   * *   `Invalid line number` referring to location
   * *   `Field f not found in class C` referring to condition
   */
  status:
    | StatusMessage
    | undefined;
  /**
   * The stack at breakpoint time, where stack_frames[0] represents the most
   * recently entered function.
   */
  stackFrames: StackFrame[];
  /**
   * Values of evaluated expressions at breakpoint time.
   * The evaluated expressions appear in exactly the same order they
   * are listed in the `expressions` field.
   * The `name` field holds the original expression text, the `value` or
   * `members` field holds the result of the evaluated expression.
   * If the expression cannot be evaluated, the `status` inside the `Variable`
   * will indicate an error and contain the error text.
   */
  evaluatedExpressions: Variable[];
  /**
   * The `variable_table` exists to aid with computation, memory and network
   * traffic optimization.  It enables storing a variable once and reference
   * it from multiple variables, including variables stored in the
   * `variable_table` itself.
   * For example, the same `this` object, which may appear at many levels of
   * the stack, can have all of its data stored once in this table.  The
   * stack frame variables then would hold only a reference to it.
   *
   * The variable `var_table_index` field is an index into this repeated field.
   * The stored objects are nameless and get their name from the referencing
   * variable. The effective variable is a merge of the referencing variable
   * and the referenced variable.
   */
  variableTable: Variable[];
  /**
   * A set of custom breakpoint properties, populated by the agent, to be
   * displayed to the user.
   */
  labels: { [key: string]: string };
}

/**
 * Actions that can be taken when a breakpoint hits.
 * Agents should reject breakpoints with unsupported or unknown action values.
 */
export enum Breakpoint_Action {
  /**
   * CAPTURE - Capture stack frame and variables and update the breakpoint.
   * The data is only captured once. After that the breakpoint is set
   * in a final state.
   */
  CAPTURE = 0,
  /**
   * LOG - Log each breakpoint hit. The breakpoint remains active until
   * deleted or expired.
   */
  LOG = 1,
  UNRECOGNIZED = -1,
}

export function breakpoint_ActionFromJSON(object: any): Breakpoint_Action {
  switch (object) {
    case 0:
    case "CAPTURE":
      return Breakpoint_Action.CAPTURE;
    case 1:
    case "LOG":
      return Breakpoint_Action.LOG;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Breakpoint_Action.UNRECOGNIZED;
  }
}

export function breakpoint_ActionToJSON(object: Breakpoint_Action): string {
  switch (object) {
    case Breakpoint_Action.CAPTURE:
      return "CAPTURE";
    case Breakpoint_Action.LOG:
      return "LOG";
    case Breakpoint_Action.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Log severity levels. */
export enum Breakpoint_LogLevel {
  /** INFO - Information log message. */
  INFO = 0,
  /** WARNING - Warning log message. */
  WARNING = 1,
  /** ERROR - Error log message. */
  ERROR = 2,
  UNRECOGNIZED = -1,
}

export function breakpoint_LogLevelFromJSON(object: any): Breakpoint_LogLevel {
  switch (object) {
    case 0:
    case "INFO":
      return Breakpoint_LogLevel.INFO;
    case 1:
    case "WARNING":
      return Breakpoint_LogLevel.WARNING;
    case 2:
    case "ERROR":
      return Breakpoint_LogLevel.ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Breakpoint_LogLevel.UNRECOGNIZED;
  }
}

export function breakpoint_LogLevelToJSON(object: Breakpoint_LogLevel): string {
  switch (object) {
    case Breakpoint_LogLevel.INFO:
      return "INFO";
    case Breakpoint_LogLevel.WARNING:
      return "WARNING";
    case Breakpoint_LogLevel.ERROR:
      return "ERROR";
    case Breakpoint_LogLevel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Breakpoint_LabelsEntry {
  key: string;
  value: string;
}

/**
 * Represents the debugged application. The application may include one or more
 * replicated processes executing the same code. Each of these processes is
 * attached with a debugger agent, carrying out the debugging commands.
 * Agents attached to the same debuggee identify themselves as such by using
 * exactly the same Debuggee message value when registering.
 */
export interface Debuggee {
  /** Unique identifier for the debuggee generated by the controller service. */
  id: string;
  /**
   * Project the debuggee is associated with.
   * Use project number or id when registering a Google Cloud Platform project.
   */
  project: string;
  /**
   * Uniquifier to further distinguish the application.
   * It is possible that different applications might have identical values in
   * the debuggee message, thus, incorrectly identified as a single application
   * by the Controller service. This field adds salt to further distinguish the
   * application. Agents should consider seeding this field with value that
   * identifies the code, binary, configuration and environment.
   */
  uniquifier: string;
  /**
   * Human readable description of the debuggee.
   * Including a human-readable project name, environment name and version
   * information is recommended.
   */
  description: string;
  /**
   * If set to `true`, indicates that Controller service does not detect any
   * activity from the debuggee agents and the application is possibly stopped.
   */
  isInactive: boolean;
  /**
   * Version ID of the agent.
   * Schema: `domain/language-platform/vmajor.minor` (for example
   * `google.com/java-gcp/v1.1`).
   */
  agentVersion: string;
  /**
   * If set to `true`, indicates that the agent should disable itself and
   * detach from the debuggee.
   */
  isDisabled: boolean;
  /**
   * Human readable message to be displayed to the user about this debuggee.
   * Absence of this field indicates no status. The message can be either
   * informational or an error status.
   */
  status:
    | StatusMessage
    | undefined;
  /**
   * References to the locations and revisions of the source code used in the
   * deployed application.
   */
  sourceContexts: SourceContext[];
  /**
   * References to the locations and revisions of the source code used in the
   * deployed application.
   *
   * @deprecated
   */
  extSourceContexts: ExtendedSourceContext[];
  /**
   * A set of custom debuggee properties, populated by the agent, to be
   * displayed to the user.
   */
  labels: { [key: string]: string };
}

export interface Debuggee_LabelsEntry {
  key: string;
  value: string;
}

function createBaseFormatMessage(): FormatMessage {
  return { format: "", parameters: [] };
}

export const FormatMessage: MessageFns<FormatMessage> = {
  encode(message: FormatMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.format !== "") {
      writer.uint32(10).string(message.format);
    }
    for (const v of message.parameters) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FormatMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFormatMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.format = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parameters.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FormatMessage {
    return {
      format: isSet(object.format) ? globalThis.String(object.format) : "",
      parameters: globalThis.Array.isArray(object?.parameters)
        ? object.parameters.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: FormatMessage): unknown {
    const obj: any = {};
    if (message.format !== "") {
      obj.format = message.format;
    }
    if (message.parameters?.length) {
      obj.parameters = message.parameters;
    }
    return obj;
  },

  create(base?: DeepPartial<FormatMessage>): FormatMessage {
    return FormatMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FormatMessage>): FormatMessage {
    const message = createBaseFormatMessage();
    message.format = object.format ?? "";
    message.parameters = object.parameters?.map((e) => e) || [];
    return message;
  },
};

function createBaseStatusMessage(): StatusMessage {
  return { isError: false, refersTo: 0, description: undefined };
}

export const StatusMessage: MessageFns<StatusMessage> = {
  encode(message: StatusMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isError !== false) {
      writer.uint32(8).bool(message.isError);
    }
    if (message.refersTo !== 0) {
      writer.uint32(16).int32(message.refersTo);
    }
    if (message.description !== undefined) {
      FormatMessage.encode(message.description, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StatusMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatusMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.isError = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.refersTo = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = FormatMessage.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StatusMessage {
    return {
      isError: isSet(object.isError) ? globalThis.Boolean(object.isError) : false,
      refersTo: isSet(object.refersTo) ? statusMessage_ReferenceFromJSON(object.refersTo) : 0,
      description: isSet(object.description) ? FormatMessage.fromJSON(object.description) : undefined,
    };
  },

  toJSON(message: StatusMessage): unknown {
    const obj: any = {};
    if (message.isError !== false) {
      obj.isError = message.isError;
    }
    if (message.refersTo !== 0) {
      obj.refersTo = statusMessage_ReferenceToJSON(message.refersTo);
    }
    if (message.description !== undefined) {
      obj.description = FormatMessage.toJSON(message.description);
    }
    return obj;
  },

  create(base?: DeepPartial<StatusMessage>): StatusMessage {
    return StatusMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StatusMessage>): StatusMessage {
    const message = createBaseStatusMessage();
    message.isError = object.isError ?? false;
    message.refersTo = object.refersTo ?? 0;
    message.description = (object.description !== undefined && object.description !== null)
      ? FormatMessage.fromPartial(object.description)
      : undefined;
    return message;
  },
};

function createBaseSourceLocation(): SourceLocation {
  return { path: "", line: 0, column: 0 };
}

export const SourceLocation: MessageFns<SourceLocation> = {
  encode(message: SourceLocation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.line !== 0) {
      writer.uint32(16).int32(message.line);
    }
    if (message.column !== 0) {
      writer.uint32(24).int32(message.column);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SourceLocation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSourceLocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.line = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.column = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SourceLocation {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      line: isSet(object.line) ? globalThis.Number(object.line) : 0,
      column: isSet(object.column) ? globalThis.Number(object.column) : 0,
    };
  },

  toJSON(message: SourceLocation): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.line !== 0) {
      obj.line = Math.round(message.line);
    }
    if (message.column !== 0) {
      obj.column = Math.round(message.column);
    }
    return obj;
  },

  create(base?: DeepPartial<SourceLocation>): SourceLocation {
    return SourceLocation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SourceLocation>): SourceLocation {
    const message = createBaseSourceLocation();
    message.path = object.path ?? "";
    message.line = object.line ?? 0;
    message.column = object.column ?? 0;
    return message;
  },
};

function createBaseVariable(): Variable {
  return { name: "", value: "", type: "", members: [], varTableIndex: undefined, status: undefined };
}

export const Variable: MessageFns<Variable> = {
  encode(message: Variable, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    if (message.type !== "") {
      writer.uint32(50).string(message.type);
    }
    for (const v of message.members) {
      Variable.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.varTableIndex !== undefined) {
      Int32Value.encode({ value: message.varTableIndex! }, writer.uint32(34).fork()).join();
    }
    if (message.status !== undefined) {
      StatusMessage.encode(message.status, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Variable {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.type = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.members.push(Variable.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.varTableIndex = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.status = StatusMessage.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Variable {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      members: globalThis.Array.isArray(object?.members) ? object.members.map((e: any) => Variable.fromJSON(e)) : [],
      varTableIndex: isSet(object.varTableIndex) ? Number(object.varTableIndex) : undefined,
      status: isSet(object.status) ? StatusMessage.fromJSON(object.status) : undefined,
    };
  },

  toJSON(message: Variable): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.members?.length) {
      obj.members = message.members.map((e) => Variable.toJSON(e));
    }
    if (message.varTableIndex !== undefined) {
      obj.varTableIndex = message.varTableIndex;
    }
    if (message.status !== undefined) {
      obj.status = StatusMessage.toJSON(message.status);
    }
    return obj;
  },

  create(base?: DeepPartial<Variable>): Variable {
    return Variable.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Variable>): Variable {
    const message = createBaseVariable();
    message.name = object.name ?? "";
    message.value = object.value ?? "";
    message.type = object.type ?? "";
    message.members = object.members?.map((e) => Variable.fromPartial(e)) || [];
    message.varTableIndex = object.varTableIndex ?? undefined;
    message.status = (object.status !== undefined && object.status !== null)
      ? StatusMessage.fromPartial(object.status)
      : undefined;
    return message;
  },
};

function createBaseStackFrame(): StackFrame {
  return { function: "", location: undefined, arguments: [], locals: [] };
}

export const StackFrame: MessageFns<StackFrame> = {
  encode(message: StackFrame, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.function !== "") {
      writer.uint32(10).string(message.function);
    }
    if (message.location !== undefined) {
      SourceLocation.encode(message.location, writer.uint32(18).fork()).join();
    }
    for (const v of message.arguments) {
      Variable.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.locals) {
      Variable.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StackFrame {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStackFrame();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.function = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.location = SourceLocation.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.arguments.push(Variable.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.locals.push(Variable.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StackFrame {
    return {
      function: isSet(object.function) ? globalThis.String(object.function) : "",
      location: isSet(object.location) ? SourceLocation.fromJSON(object.location) : undefined,
      arguments: globalThis.Array.isArray(object?.arguments)
        ? object.arguments.map((e: any) => Variable.fromJSON(e))
        : [],
      locals: globalThis.Array.isArray(object?.locals) ? object.locals.map((e: any) => Variable.fromJSON(e)) : [],
    };
  },

  toJSON(message: StackFrame): unknown {
    const obj: any = {};
    if (message.function !== "") {
      obj.function = message.function;
    }
    if (message.location !== undefined) {
      obj.location = SourceLocation.toJSON(message.location);
    }
    if (message.arguments?.length) {
      obj.arguments = message.arguments.map((e) => Variable.toJSON(e));
    }
    if (message.locals?.length) {
      obj.locals = message.locals.map((e) => Variable.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<StackFrame>): StackFrame {
    return StackFrame.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StackFrame>): StackFrame {
    const message = createBaseStackFrame();
    message.function = object.function ?? "";
    message.location = (object.location !== undefined && object.location !== null)
      ? SourceLocation.fromPartial(object.location)
      : undefined;
    message.arguments = object.arguments?.map((e) => Variable.fromPartial(e)) || [];
    message.locals = object.locals?.map((e) => Variable.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBreakpoint(): Breakpoint {
  return {
    id: "",
    action: 0,
    location: undefined,
    condition: "",
    expressions: [],
    logMessageFormat: "",
    logLevel: 0,
    isFinalState: false,
    createTime: undefined,
    finalTime: undefined,
    userEmail: "",
    status: undefined,
    stackFrames: [],
    evaluatedExpressions: [],
    variableTable: [],
    labels: {},
  };
}

export const Breakpoint: MessageFns<Breakpoint> = {
  encode(message: Breakpoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.action !== 0) {
      writer.uint32(104).int32(message.action);
    }
    if (message.location !== undefined) {
      SourceLocation.encode(message.location, writer.uint32(18).fork()).join();
    }
    if (message.condition !== "") {
      writer.uint32(26).string(message.condition);
    }
    for (const v of message.expressions) {
      writer.uint32(34).string(v!);
    }
    if (message.logMessageFormat !== "") {
      writer.uint32(114).string(message.logMessageFormat);
    }
    if (message.logLevel !== 0) {
      writer.uint32(120).int32(message.logLevel);
    }
    if (message.isFinalState !== false) {
      writer.uint32(40).bool(message.isFinalState);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(90).fork()).join();
    }
    if (message.finalTime !== undefined) {
      Timestamp.encode(toTimestamp(message.finalTime), writer.uint32(98).fork()).join();
    }
    if (message.userEmail !== "") {
      writer.uint32(130).string(message.userEmail);
    }
    if (message.status !== undefined) {
      StatusMessage.encode(message.status, writer.uint32(82).fork()).join();
    }
    for (const v of message.stackFrames) {
      StackFrame.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.evaluatedExpressions) {
      Variable.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.variableTable) {
      Variable.encode(v!, writer.uint32(74).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Breakpoint_LabelsEntry.encode({ key: key as any, value }, writer.uint32(138).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Breakpoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBreakpoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.location = SourceLocation.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.condition = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.expressions.push(reader.string());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.logMessageFormat = reader.string();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.logLevel = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.isFinalState = reader.bool();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.finalTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.userEmail = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.status = StatusMessage.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.stackFrames.push(StackFrame.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.evaluatedExpressions.push(Variable.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.variableTable.push(Variable.decode(reader, reader.uint32()));
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          const entry17 = Breakpoint_LabelsEntry.decode(reader, reader.uint32());
          if (entry17.value !== undefined) {
            message.labels[entry17.key] = entry17.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Breakpoint {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      action: isSet(object.action) ? breakpoint_ActionFromJSON(object.action) : 0,
      location: isSet(object.location) ? SourceLocation.fromJSON(object.location) : undefined,
      condition: isSet(object.condition) ? globalThis.String(object.condition) : "",
      expressions: globalThis.Array.isArray(object?.expressions)
        ? object.expressions.map((e: any) => globalThis.String(e))
        : [],
      logMessageFormat: isSet(object.logMessageFormat) ? globalThis.String(object.logMessageFormat) : "",
      logLevel: isSet(object.logLevel) ? breakpoint_LogLevelFromJSON(object.logLevel) : 0,
      isFinalState: isSet(object.isFinalState) ? globalThis.Boolean(object.isFinalState) : false,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      finalTime: isSet(object.finalTime) ? fromJsonTimestamp(object.finalTime) : undefined,
      userEmail: isSet(object.userEmail) ? globalThis.String(object.userEmail) : "",
      status: isSet(object.status) ? StatusMessage.fromJSON(object.status) : undefined,
      stackFrames: globalThis.Array.isArray(object?.stackFrames)
        ? object.stackFrames.map((e: any) => StackFrame.fromJSON(e))
        : [],
      evaluatedExpressions: globalThis.Array.isArray(object?.evaluatedExpressions)
        ? object.evaluatedExpressions.map((e: any) => Variable.fromJSON(e))
        : [],
      variableTable: globalThis.Array.isArray(object?.variableTable)
        ? object.variableTable.map((e: any) => Variable.fromJSON(e))
        : [],
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Breakpoint): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.action !== 0) {
      obj.action = breakpoint_ActionToJSON(message.action);
    }
    if (message.location !== undefined) {
      obj.location = SourceLocation.toJSON(message.location);
    }
    if (message.condition !== "") {
      obj.condition = message.condition;
    }
    if (message.expressions?.length) {
      obj.expressions = message.expressions;
    }
    if (message.logMessageFormat !== "") {
      obj.logMessageFormat = message.logMessageFormat;
    }
    if (message.logLevel !== 0) {
      obj.logLevel = breakpoint_LogLevelToJSON(message.logLevel);
    }
    if (message.isFinalState !== false) {
      obj.isFinalState = message.isFinalState;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.finalTime !== undefined) {
      obj.finalTime = message.finalTime.toISOString();
    }
    if (message.userEmail !== "") {
      obj.userEmail = message.userEmail;
    }
    if (message.status !== undefined) {
      obj.status = StatusMessage.toJSON(message.status);
    }
    if (message.stackFrames?.length) {
      obj.stackFrames = message.stackFrames.map((e) => StackFrame.toJSON(e));
    }
    if (message.evaluatedExpressions?.length) {
      obj.evaluatedExpressions = message.evaluatedExpressions.map((e) => Variable.toJSON(e));
    }
    if (message.variableTable?.length) {
      obj.variableTable = message.variableTable.map((e) => Variable.toJSON(e));
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<Breakpoint>): Breakpoint {
    return Breakpoint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Breakpoint>): Breakpoint {
    const message = createBaseBreakpoint();
    message.id = object.id ?? "";
    message.action = object.action ?? 0;
    message.location = (object.location !== undefined && object.location !== null)
      ? SourceLocation.fromPartial(object.location)
      : undefined;
    message.condition = object.condition ?? "";
    message.expressions = object.expressions?.map((e) => e) || [];
    message.logMessageFormat = object.logMessageFormat ?? "";
    message.logLevel = object.logLevel ?? 0;
    message.isFinalState = object.isFinalState ?? false;
    message.createTime = object.createTime ?? undefined;
    message.finalTime = object.finalTime ?? undefined;
    message.userEmail = object.userEmail ?? "";
    message.status = (object.status !== undefined && object.status !== null)
      ? StatusMessage.fromPartial(object.status)
      : undefined;
    message.stackFrames = object.stackFrames?.map((e) => StackFrame.fromPartial(e)) || [];
    message.evaluatedExpressions = object.evaluatedExpressions?.map((e) => Variable.fromPartial(e)) || [];
    message.variableTable = object.variableTable?.map((e) => Variable.fromPartial(e)) || [];
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseBreakpoint_LabelsEntry(): Breakpoint_LabelsEntry {
  return { key: "", value: "" };
}

export const Breakpoint_LabelsEntry: MessageFns<Breakpoint_LabelsEntry> = {
  encode(message: Breakpoint_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Breakpoint_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBreakpoint_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Breakpoint_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Breakpoint_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Breakpoint_LabelsEntry>): Breakpoint_LabelsEntry {
    return Breakpoint_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Breakpoint_LabelsEntry>): Breakpoint_LabelsEntry {
    const message = createBaseBreakpoint_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseDebuggee(): Debuggee {
  return {
    id: "",
    project: "",
    uniquifier: "",
    description: "",
    isInactive: false,
    agentVersion: "",
    isDisabled: false,
    status: undefined,
    sourceContexts: [],
    extSourceContexts: [],
    labels: {},
  };
}

export const Debuggee: MessageFns<Debuggee> = {
  encode(message: Debuggee, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.project !== "") {
      writer.uint32(18).string(message.project);
    }
    if (message.uniquifier !== "") {
      writer.uint32(26).string(message.uniquifier);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.isInactive !== false) {
      writer.uint32(40).bool(message.isInactive);
    }
    if (message.agentVersion !== "") {
      writer.uint32(50).string(message.agentVersion);
    }
    if (message.isDisabled !== false) {
      writer.uint32(56).bool(message.isDisabled);
    }
    if (message.status !== undefined) {
      StatusMessage.encode(message.status, writer.uint32(66).fork()).join();
    }
    for (const v of message.sourceContexts) {
      SourceContext.encode(v!, writer.uint32(74).fork()).join();
    }
    for (const v of message.extSourceContexts) {
      ExtendedSourceContext.encode(v!, writer.uint32(106).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Debuggee_LabelsEntry.encode({ key: key as any, value }, writer.uint32(90).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Debuggee {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDebuggee();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.project = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.uniquifier = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.isInactive = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.agentVersion = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.isDisabled = reader.bool();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.status = StatusMessage.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.sourceContexts.push(SourceContext.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.extSourceContexts.push(ExtendedSourceContext.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          const entry11 = Debuggee_LabelsEntry.decode(reader, reader.uint32());
          if (entry11.value !== undefined) {
            message.labels[entry11.key] = entry11.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Debuggee {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      project: isSet(object.project) ? globalThis.String(object.project) : "",
      uniquifier: isSet(object.uniquifier) ? globalThis.String(object.uniquifier) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      isInactive: isSet(object.isInactive) ? globalThis.Boolean(object.isInactive) : false,
      agentVersion: isSet(object.agentVersion) ? globalThis.String(object.agentVersion) : "",
      isDisabled: isSet(object.isDisabled) ? globalThis.Boolean(object.isDisabled) : false,
      status: isSet(object.status) ? StatusMessage.fromJSON(object.status) : undefined,
      sourceContexts: globalThis.Array.isArray(object?.sourceContexts)
        ? object.sourceContexts.map((e: any) => SourceContext.fromJSON(e))
        : [],
      extSourceContexts: globalThis.Array.isArray(object?.extSourceContexts)
        ? object.extSourceContexts.map((e: any) => ExtendedSourceContext.fromJSON(e))
        : [],
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Debuggee): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.project !== "") {
      obj.project = message.project;
    }
    if (message.uniquifier !== "") {
      obj.uniquifier = message.uniquifier;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.isInactive !== false) {
      obj.isInactive = message.isInactive;
    }
    if (message.agentVersion !== "") {
      obj.agentVersion = message.agentVersion;
    }
    if (message.isDisabled !== false) {
      obj.isDisabled = message.isDisabled;
    }
    if (message.status !== undefined) {
      obj.status = StatusMessage.toJSON(message.status);
    }
    if (message.sourceContexts?.length) {
      obj.sourceContexts = message.sourceContexts.map((e) => SourceContext.toJSON(e));
    }
    if (message.extSourceContexts?.length) {
      obj.extSourceContexts = message.extSourceContexts.map((e) => ExtendedSourceContext.toJSON(e));
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<Debuggee>): Debuggee {
    return Debuggee.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Debuggee>): Debuggee {
    const message = createBaseDebuggee();
    message.id = object.id ?? "";
    message.project = object.project ?? "";
    message.uniquifier = object.uniquifier ?? "";
    message.description = object.description ?? "";
    message.isInactive = object.isInactive ?? false;
    message.agentVersion = object.agentVersion ?? "";
    message.isDisabled = object.isDisabled ?? false;
    message.status = (object.status !== undefined && object.status !== null)
      ? StatusMessage.fromPartial(object.status)
      : undefined;
    message.sourceContexts = object.sourceContexts?.map((e) => SourceContext.fromPartial(e)) || [];
    message.extSourceContexts = object.extSourceContexts?.map((e) => ExtendedSourceContext.fromPartial(e)) || [];
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseDebuggee_LabelsEntry(): Debuggee_LabelsEntry {
  return { key: "", value: "" };
}

export const Debuggee_LabelsEntry: MessageFns<Debuggee_LabelsEntry> = {
  encode(message: Debuggee_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Debuggee_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDebuggee_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Debuggee_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Debuggee_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Debuggee_LabelsEntry>): Debuggee_LabelsEntry {
    return Debuggee_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Debuggee_LabelsEntry>): Debuggee_LabelsEntry {
    const message = createBaseDebuggee_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
