// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/devtools/clouddebugger/v2/debugger.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Empty } from "../../../protobuf/empty.js";
import { Breakpoint, Breakpoint_Action, breakpoint_ActionFromJSON, breakpoint_ActionToJSON, Debuggee } from "./data.js";

export const protobufPackage = "google.devtools.clouddebugger.v2";

/** Request to set a breakpoint */
export interface SetBreakpointRequest {
  /** Required. ID of the debuggee where the breakpoint is to be set. */
  debuggeeId: string;
  /**
   * Required. Breakpoint specification to set.
   * The field `location` of the breakpoint must be set.
   */
  breakpoint:
    | Breakpoint
    | undefined;
  /**
   * Required. The client version making the call.
   * Schema: `domain/type/version` (e.g., `google.com/intellij/v1`).
   */
  clientVersion: string;
}

/** Response for setting a breakpoint. */
export interface SetBreakpointResponse {
  /**
   * Breakpoint resource.
   * The field `id` is guaranteed to be set (in addition to the echoed fileds).
   */
  breakpoint: Breakpoint | undefined;
}

/** Request to get breakpoint information. */
export interface GetBreakpointRequest {
  /** Required. ID of the debuggee whose breakpoint to get. */
  debuggeeId: string;
  /** Required. ID of the breakpoint to get. */
  breakpointId: string;
  /**
   * Required. The client version making the call.
   * Schema: `domain/type/version` (e.g., `google.com/intellij/v1`).
   */
  clientVersion: string;
}

/** Response for getting breakpoint information. */
export interface GetBreakpointResponse {
  /**
   * Complete breakpoint state.
   * The fields `id` and `location` are guaranteed to be set.
   */
  breakpoint: Breakpoint | undefined;
}

/** Request to delete a breakpoint. */
export interface DeleteBreakpointRequest {
  /** Required. ID of the debuggee whose breakpoint to delete. */
  debuggeeId: string;
  /** Required. ID of the breakpoint to delete. */
  breakpointId: string;
  /**
   * Required. The client version making the call.
   * Schema: `domain/type/version` (e.g., `google.com/intellij/v1`).
   */
  clientVersion: string;
}

/** Request to list breakpoints. */
export interface ListBreakpointsRequest {
  /** Required. ID of the debuggee whose breakpoints to list. */
  debuggeeId: string;
  /**
   * When set to `true`, the response includes the list of breakpoints set by
   * any user. Otherwise, it includes only breakpoints set by the caller.
   */
  includeAllUsers: boolean;
  /**
   * When set to `true`, the response includes active and inactive
   * breakpoints. Otherwise, it includes only active breakpoints.
   */
  includeInactive: boolean;
  /** When set, the response includes only breakpoints with the specified action. */
  action:
    | ListBreakpointsRequest_BreakpointActionValue
    | undefined;
  /**
   * This field is deprecated. The following fields are always stripped out of
   * the result: `stack_frames`, `evaluated_expressions` and `variable_table`.
   *
   * @deprecated
   */
  stripResults: boolean;
  /**
   * A wait token that, if specified, blocks the call until the breakpoints
   * list has changed, or a server selected timeout has expired.  The value
   * should be set from the last response. The error code
   * `google.rpc.Code.ABORTED` (RPC) is returned on wait timeout, which
   * should be called again with the same `wait_token`.
   */
  waitToken: string;
  /**
   * Required. The client version making the call.
   * Schema: `domain/type/version` (e.g., `google.com/intellij/v1`).
   */
  clientVersion: string;
}

/**
 * Wrapper message for `Breakpoint.Action`. Defines a filter on the action
 * field of breakpoints.
 */
export interface ListBreakpointsRequest_BreakpointActionValue {
  /** Only breakpoints with the specified action will pass the filter. */
  value: Breakpoint_Action;
}

/** Response for listing breakpoints. */
export interface ListBreakpointsResponse {
  /**
   * List of breakpoints matching the request.
   * The fields `id` and `location` are guaranteed to be set on each breakpoint.
   * The fields: `stack_frames`, `evaluated_expressions` and `variable_table`
   * are cleared on each breakpoint regardless of its status.
   */
  breakpoints: Breakpoint[];
  /**
   * A wait token that can be used in the next call to `list` (REST) or
   * `ListBreakpoints` (RPC) to block until the list of breakpoints has changes.
   */
  nextWaitToken: string;
}

/** Request to list debuggees. */
export interface ListDebuggeesRequest {
  /** Required. Project number of a Google Cloud project whose debuggees to list. */
  project: string;
  /**
   * When set to `true`, the result includes all debuggees. Otherwise, the
   * result includes only debuggees that are active.
   */
  includeInactive: boolean;
  /**
   * Required. The client version making the call.
   * Schema: `domain/type/version` (e.g., `google.com/intellij/v1`).
   */
  clientVersion: string;
}

/** Response for listing debuggees. */
export interface ListDebuggeesResponse {
  /**
   * List of debuggees accessible to the calling user.
   * The fields `debuggee.id` and `description` are guaranteed to be set.
   * The `description` field is a human readable field provided by agents and
   * can be displayed to users.
   */
  debuggees: Debuggee[];
}

function createBaseSetBreakpointRequest(): SetBreakpointRequest {
  return { debuggeeId: "", breakpoint: undefined, clientVersion: "" };
}

export const SetBreakpointRequest: MessageFns<SetBreakpointRequest> = {
  encode(message: SetBreakpointRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.debuggeeId !== "") {
      writer.uint32(10).string(message.debuggeeId);
    }
    if (message.breakpoint !== undefined) {
      Breakpoint.encode(message.breakpoint, writer.uint32(18).fork()).join();
    }
    if (message.clientVersion !== "") {
      writer.uint32(34).string(message.clientVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetBreakpointRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetBreakpointRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.debuggeeId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.breakpoint = Breakpoint.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.clientVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetBreakpointRequest {
    return {
      debuggeeId: isSet(object.debuggeeId) ? globalThis.String(object.debuggeeId) : "",
      breakpoint: isSet(object.breakpoint) ? Breakpoint.fromJSON(object.breakpoint) : undefined,
      clientVersion: isSet(object.clientVersion) ? globalThis.String(object.clientVersion) : "",
    };
  },

  toJSON(message: SetBreakpointRequest): unknown {
    const obj: any = {};
    if (message.debuggeeId !== "") {
      obj.debuggeeId = message.debuggeeId;
    }
    if (message.breakpoint !== undefined) {
      obj.breakpoint = Breakpoint.toJSON(message.breakpoint);
    }
    if (message.clientVersion !== "") {
      obj.clientVersion = message.clientVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<SetBreakpointRequest>): SetBreakpointRequest {
    return SetBreakpointRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SetBreakpointRequest>): SetBreakpointRequest {
    const message = createBaseSetBreakpointRequest();
    message.debuggeeId = object.debuggeeId ?? "";
    message.breakpoint = (object.breakpoint !== undefined && object.breakpoint !== null)
      ? Breakpoint.fromPartial(object.breakpoint)
      : undefined;
    message.clientVersion = object.clientVersion ?? "";
    return message;
  },
};

function createBaseSetBreakpointResponse(): SetBreakpointResponse {
  return { breakpoint: undefined };
}

export const SetBreakpointResponse: MessageFns<SetBreakpointResponse> = {
  encode(message: SetBreakpointResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.breakpoint !== undefined) {
      Breakpoint.encode(message.breakpoint, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetBreakpointResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetBreakpointResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.breakpoint = Breakpoint.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetBreakpointResponse {
    return { breakpoint: isSet(object.breakpoint) ? Breakpoint.fromJSON(object.breakpoint) : undefined };
  },

  toJSON(message: SetBreakpointResponse): unknown {
    const obj: any = {};
    if (message.breakpoint !== undefined) {
      obj.breakpoint = Breakpoint.toJSON(message.breakpoint);
    }
    return obj;
  },

  create(base?: DeepPartial<SetBreakpointResponse>): SetBreakpointResponse {
    return SetBreakpointResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SetBreakpointResponse>): SetBreakpointResponse {
    const message = createBaseSetBreakpointResponse();
    message.breakpoint = (object.breakpoint !== undefined && object.breakpoint !== null)
      ? Breakpoint.fromPartial(object.breakpoint)
      : undefined;
    return message;
  },
};

function createBaseGetBreakpointRequest(): GetBreakpointRequest {
  return { debuggeeId: "", breakpointId: "", clientVersion: "" };
}

export const GetBreakpointRequest: MessageFns<GetBreakpointRequest> = {
  encode(message: GetBreakpointRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.debuggeeId !== "") {
      writer.uint32(10).string(message.debuggeeId);
    }
    if (message.breakpointId !== "") {
      writer.uint32(18).string(message.breakpointId);
    }
    if (message.clientVersion !== "") {
      writer.uint32(34).string(message.clientVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBreakpointRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBreakpointRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.debuggeeId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.breakpointId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.clientVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBreakpointRequest {
    return {
      debuggeeId: isSet(object.debuggeeId) ? globalThis.String(object.debuggeeId) : "",
      breakpointId: isSet(object.breakpointId) ? globalThis.String(object.breakpointId) : "",
      clientVersion: isSet(object.clientVersion) ? globalThis.String(object.clientVersion) : "",
    };
  },

  toJSON(message: GetBreakpointRequest): unknown {
    const obj: any = {};
    if (message.debuggeeId !== "") {
      obj.debuggeeId = message.debuggeeId;
    }
    if (message.breakpointId !== "") {
      obj.breakpointId = message.breakpointId;
    }
    if (message.clientVersion !== "") {
      obj.clientVersion = message.clientVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<GetBreakpointRequest>): GetBreakpointRequest {
    return GetBreakpointRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBreakpointRequest>): GetBreakpointRequest {
    const message = createBaseGetBreakpointRequest();
    message.debuggeeId = object.debuggeeId ?? "";
    message.breakpointId = object.breakpointId ?? "";
    message.clientVersion = object.clientVersion ?? "";
    return message;
  },
};

function createBaseGetBreakpointResponse(): GetBreakpointResponse {
  return { breakpoint: undefined };
}

export const GetBreakpointResponse: MessageFns<GetBreakpointResponse> = {
  encode(message: GetBreakpointResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.breakpoint !== undefined) {
      Breakpoint.encode(message.breakpoint, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBreakpointResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBreakpointResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.breakpoint = Breakpoint.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBreakpointResponse {
    return { breakpoint: isSet(object.breakpoint) ? Breakpoint.fromJSON(object.breakpoint) : undefined };
  },

  toJSON(message: GetBreakpointResponse): unknown {
    const obj: any = {};
    if (message.breakpoint !== undefined) {
      obj.breakpoint = Breakpoint.toJSON(message.breakpoint);
    }
    return obj;
  },

  create(base?: DeepPartial<GetBreakpointResponse>): GetBreakpointResponse {
    return GetBreakpointResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBreakpointResponse>): GetBreakpointResponse {
    const message = createBaseGetBreakpointResponse();
    message.breakpoint = (object.breakpoint !== undefined && object.breakpoint !== null)
      ? Breakpoint.fromPartial(object.breakpoint)
      : undefined;
    return message;
  },
};

function createBaseDeleteBreakpointRequest(): DeleteBreakpointRequest {
  return { debuggeeId: "", breakpointId: "", clientVersion: "" };
}

export const DeleteBreakpointRequest: MessageFns<DeleteBreakpointRequest> = {
  encode(message: DeleteBreakpointRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.debuggeeId !== "") {
      writer.uint32(10).string(message.debuggeeId);
    }
    if (message.breakpointId !== "") {
      writer.uint32(18).string(message.breakpointId);
    }
    if (message.clientVersion !== "") {
      writer.uint32(26).string(message.clientVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteBreakpointRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteBreakpointRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.debuggeeId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.breakpointId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clientVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteBreakpointRequest {
    return {
      debuggeeId: isSet(object.debuggeeId) ? globalThis.String(object.debuggeeId) : "",
      breakpointId: isSet(object.breakpointId) ? globalThis.String(object.breakpointId) : "",
      clientVersion: isSet(object.clientVersion) ? globalThis.String(object.clientVersion) : "",
    };
  },

  toJSON(message: DeleteBreakpointRequest): unknown {
    const obj: any = {};
    if (message.debuggeeId !== "") {
      obj.debuggeeId = message.debuggeeId;
    }
    if (message.breakpointId !== "") {
      obj.breakpointId = message.breakpointId;
    }
    if (message.clientVersion !== "") {
      obj.clientVersion = message.clientVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteBreakpointRequest>): DeleteBreakpointRequest {
    return DeleteBreakpointRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteBreakpointRequest>): DeleteBreakpointRequest {
    const message = createBaseDeleteBreakpointRequest();
    message.debuggeeId = object.debuggeeId ?? "";
    message.breakpointId = object.breakpointId ?? "";
    message.clientVersion = object.clientVersion ?? "";
    return message;
  },
};

function createBaseListBreakpointsRequest(): ListBreakpointsRequest {
  return {
    debuggeeId: "",
    includeAllUsers: false,
    includeInactive: false,
    action: undefined,
    stripResults: false,
    waitToken: "",
    clientVersion: "",
  };
}

export const ListBreakpointsRequest: MessageFns<ListBreakpointsRequest> = {
  encode(message: ListBreakpointsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.debuggeeId !== "") {
      writer.uint32(10).string(message.debuggeeId);
    }
    if (message.includeAllUsers !== false) {
      writer.uint32(16).bool(message.includeAllUsers);
    }
    if (message.includeInactive !== false) {
      writer.uint32(24).bool(message.includeInactive);
    }
    if (message.action !== undefined) {
      ListBreakpointsRequest_BreakpointActionValue.encode(message.action, writer.uint32(34).fork()).join();
    }
    if (message.stripResults !== false) {
      writer.uint32(40).bool(message.stripResults);
    }
    if (message.waitToken !== "") {
      writer.uint32(50).string(message.waitToken);
    }
    if (message.clientVersion !== "") {
      writer.uint32(66).string(message.clientVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListBreakpointsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBreakpointsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.debuggeeId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.includeAllUsers = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.includeInactive = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.action = ListBreakpointsRequest_BreakpointActionValue.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.stripResults = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.waitToken = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.clientVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBreakpointsRequest {
    return {
      debuggeeId: isSet(object.debuggeeId) ? globalThis.String(object.debuggeeId) : "",
      includeAllUsers: isSet(object.includeAllUsers) ? globalThis.Boolean(object.includeAllUsers) : false,
      includeInactive: isSet(object.includeInactive) ? globalThis.Boolean(object.includeInactive) : false,
      action: isSet(object.action) ? ListBreakpointsRequest_BreakpointActionValue.fromJSON(object.action) : undefined,
      stripResults: isSet(object.stripResults) ? globalThis.Boolean(object.stripResults) : false,
      waitToken: isSet(object.waitToken) ? globalThis.String(object.waitToken) : "",
      clientVersion: isSet(object.clientVersion) ? globalThis.String(object.clientVersion) : "",
    };
  },

  toJSON(message: ListBreakpointsRequest): unknown {
    const obj: any = {};
    if (message.debuggeeId !== "") {
      obj.debuggeeId = message.debuggeeId;
    }
    if (message.includeAllUsers !== false) {
      obj.includeAllUsers = message.includeAllUsers;
    }
    if (message.includeInactive !== false) {
      obj.includeInactive = message.includeInactive;
    }
    if (message.action !== undefined) {
      obj.action = ListBreakpointsRequest_BreakpointActionValue.toJSON(message.action);
    }
    if (message.stripResults !== false) {
      obj.stripResults = message.stripResults;
    }
    if (message.waitToken !== "") {
      obj.waitToken = message.waitToken;
    }
    if (message.clientVersion !== "") {
      obj.clientVersion = message.clientVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<ListBreakpointsRequest>): ListBreakpointsRequest {
    return ListBreakpointsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListBreakpointsRequest>): ListBreakpointsRequest {
    const message = createBaseListBreakpointsRequest();
    message.debuggeeId = object.debuggeeId ?? "";
    message.includeAllUsers = object.includeAllUsers ?? false;
    message.includeInactive = object.includeInactive ?? false;
    message.action = (object.action !== undefined && object.action !== null)
      ? ListBreakpointsRequest_BreakpointActionValue.fromPartial(object.action)
      : undefined;
    message.stripResults = object.stripResults ?? false;
    message.waitToken = object.waitToken ?? "";
    message.clientVersion = object.clientVersion ?? "";
    return message;
  },
};

function createBaseListBreakpointsRequest_BreakpointActionValue(): ListBreakpointsRequest_BreakpointActionValue {
  return { value: 0 };
}

export const ListBreakpointsRequest_BreakpointActionValue: MessageFns<ListBreakpointsRequest_BreakpointActionValue> = {
  encode(
    message: ListBreakpointsRequest_BreakpointActionValue,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.value !== 0) {
      writer.uint32(8).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListBreakpointsRequest_BreakpointActionValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBreakpointsRequest_BreakpointActionValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.value = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBreakpointsRequest_BreakpointActionValue {
    return { value: isSet(object.value) ? breakpoint_ActionFromJSON(object.value) : 0 };
  },

  toJSON(message: ListBreakpointsRequest_BreakpointActionValue): unknown {
    const obj: any = {};
    if (message.value !== 0) {
      obj.value = breakpoint_ActionToJSON(message.value);
    }
    return obj;
  },

  create(
    base?: DeepPartial<ListBreakpointsRequest_BreakpointActionValue>,
  ): ListBreakpointsRequest_BreakpointActionValue {
    return ListBreakpointsRequest_BreakpointActionValue.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ListBreakpointsRequest_BreakpointActionValue>,
  ): ListBreakpointsRequest_BreakpointActionValue {
    const message = createBaseListBreakpointsRequest_BreakpointActionValue();
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseListBreakpointsResponse(): ListBreakpointsResponse {
  return { breakpoints: [], nextWaitToken: "" };
}

export const ListBreakpointsResponse: MessageFns<ListBreakpointsResponse> = {
  encode(message: ListBreakpointsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.breakpoints) {
      Breakpoint.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextWaitToken !== "") {
      writer.uint32(18).string(message.nextWaitToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListBreakpointsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBreakpointsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.breakpoints.push(Breakpoint.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextWaitToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBreakpointsResponse {
    return {
      breakpoints: globalThis.Array.isArray(object?.breakpoints)
        ? object.breakpoints.map((e: any) => Breakpoint.fromJSON(e))
        : [],
      nextWaitToken: isSet(object.nextWaitToken) ? globalThis.String(object.nextWaitToken) : "",
    };
  },

  toJSON(message: ListBreakpointsResponse): unknown {
    const obj: any = {};
    if (message.breakpoints?.length) {
      obj.breakpoints = message.breakpoints.map((e) => Breakpoint.toJSON(e));
    }
    if (message.nextWaitToken !== "") {
      obj.nextWaitToken = message.nextWaitToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListBreakpointsResponse>): ListBreakpointsResponse {
    return ListBreakpointsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListBreakpointsResponse>): ListBreakpointsResponse {
    const message = createBaseListBreakpointsResponse();
    message.breakpoints = object.breakpoints?.map((e) => Breakpoint.fromPartial(e)) || [];
    message.nextWaitToken = object.nextWaitToken ?? "";
    return message;
  },
};

function createBaseListDebuggeesRequest(): ListDebuggeesRequest {
  return { project: "", includeInactive: false, clientVersion: "" };
}

export const ListDebuggeesRequest: MessageFns<ListDebuggeesRequest> = {
  encode(message: ListDebuggeesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.project !== "") {
      writer.uint32(18).string(message.project);
    }
    if (message.includeInactive !== false) {
      writer.uint32(24).bool(message.includeInactive);
    }
    if (message.clientVersion !== "") {
      writer.uint32(34).string(message.clientVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDebuggeesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDebuggeesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.project = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.includeInactive = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.clientVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDebuggeesRequest {
    return {
      project: isSet(object.project) ? globalThis.String(object.project) : "",
      includeInactive: isSet(object.includeInactive) ? globalThis.Boolean(object.includeInactive) : false,
      clientVersion: isSet(object.clientVersion) ? globalThis.String(object.clientVersion) : "",
    };
  },

  toJSON(message: ListDebuggeesRequest): unknown {
    const obj: any = {};
    if (message.project !== "") {
      obj.project = message.project;
    }
    if (message.includeInactive !== false) {
      obj.includeInactive = message.includeInactive;
    }
    if (message.clientVersion !== "") {
      obj.clientVersion = message.clientVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<ListDebuggeesRequest>): ListDebuggeesRequest {
    return ListDebuggeesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDebuggeesRequest>): ListDebuggeesRequest {
    const message = createBaseListDebuggeesRequest();
    message.project = object.project ?? "";
    message.includeInactive = object.includeInactive ?? false;
    message.clientVersion = object.clientVersion ?? "";
    return message;
  },
};

function createBaseListDebuggeesResponse(): ListDebuggeesResponse {
  return { debuggees: [] };
}

export const ListDebuggeesResponse: MessageFns<ListDebuggeesResponse> = {
  encode(message: ListDebuggeesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.debuggees) {
      Debuggee.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDebuggeesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDebuggeesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.debuggees.push(Debuggee.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDebuggeesResponse {
    return {
      debuggees: globalThis.Array.isArray(object?.debuggees)
        ? object.debuggees.map((e: any) => Debuggee.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListDebuggeesResponse): unknown {
    const obj: any = {};
    if (message.debuggees?.length) {
      obj.debuggees = message.debuggees.map((e) => Debuggee.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListDebuggeesResponse>): ListDebuggeesResponse {
    return ListDebuggeesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDebuggeesResponse>): ListDebuggeesResponse {
    const message = createBaseListDebuggeesResponse();
    message.debuggees = object.debuggees?.map((e) => Debuggee.fromPartial(e)) || [];
    return message;
  },
};

/**
 * The Debugger service provides the API that allows users to collect run-time
 * information from a running application, without stopping or slowing it down
 * and without modifying its state.  An application may include one or
 * more replicated processes performing the same work.
 *
 * A debugged application is represented using the Debuggee concept. The
 * Debugger service provides a way to query for available debuggees, but does
 * not provide a way to create one.  A debuggee is created using the Controller
 * service, usually by running a debugger agent with the application.
 *
 * The Debugger service enables the client to set one or more Breakpoints on a
 * Debuggee and collect the results of the set Breakpoints.
 */
export type Debugger2Definition = typeof Debugger2Definition;
export const Debugger2Definition = {
  name: "Debugger2",
  fullName: "google.devtools.clouddebugger.v2.Debugger2",
  methods: {
    /** Sets the breakpoint to the debuggee. */
    setBreakpoint: {
      name: "SetBreakpoint",
      requestType: SetBreakpointRequest,
      requestStream: false,
      responseType: SetBreakpointResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              37,
              100,
              101,
              98,
              117,
              103,
              103,
              101,
              101,
              95,
              105,
              100,
              44,
              98,
              114,
              101,
              97,
              107,
              112,
              111,
              105,
              110,
              116,
              44,
              99,
              108,
              105,
              101,
              110,
              116,
              95,
              118,
              101,
              114,
              115,
              105,
              111,
              110,
            ]),
          ],
          578365826: [
            Buffer.from([
              66,
              58,
              10,
              98,
              114,
              101,
              97,
              107,
              112,
              111,
              105,
              110,
              116,
              34,
              52,
              47,
              118,
              50,
              47,
              100,
              101,
              98,
              117,
              103,
              103,
              101,
              114,
              47,
              100,
              101,
              98,
              117,
              103,
              103,
              101,
              101,
              115,
              47,
              123,
              100,
              101,
              98,
              117,
              103,
              103,
              101,
              101,
              95,
              105,
              100,
              125,
              47,
              98,
              114,
              101,
              97,
              107,
              112,
              111,
              105,
              110,
              116,
              115,
              47,
              115,
              101,
              116,
            ]),
          ],
        },
      },
    },
    /** Gets breakpoint information. */
    getBreakpoint: {
      name: "GetBreakpoint",
      requestType: GetBreakpointRequest,
      requestStream: false,
      responseType: GetBreakpointResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              40,
              100,
              101,
              98,
              117,
              103,
              103,
              101,
              101,
              95,
              105,
              100,
              44,
              98,
              114,
              101,
              97,
              107,
              112,
              111,
              105,
              110,
              116,
              95,
              105,
              100,
              44,
              99,
              108,
              105,
              101,
              110,
              116,
              95,
              118,
              101,
              114,
              115,
              105,
              111,
              110,
            ]),
          ],
          578365826: [
            Buffer.from([
              66,
              18,
              64,
              47,
              118,
              50,
              47,
              100,
              101,
              98,
              117,
              103,
              103,
              101,
              114,
              47,
              100,
              101,
              98,
              117,
              103,
              103,
              101,
              101,
              115,
              47,
              123,
              100,
              101,
              98,
              117,
              103,
              103,
              101,
              101,
              95,
              105,
              100,
              125,
              47,
              98,
              114,
              101,
              97,
              107,
              112,
              111,
              105,
              110,
              116,
              115,
              47,
              123,
              98,
              114,
              101,
              97,
              107,
              112,
              111,
              105,
              110,
              116,
              95,
              105,
              100,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes the breakpoint from the debuggee. */
    deleteBreakpoint: {
      name: "DeleteBreakpoint",
      requestType: DeleteBreakpointRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              40,
              100,
              101,
              98,
              117,
              103,
              103,
              101,
              101,
              95,
              105,
              100,
              44,
              98,
              114,
              101,
              97,
              107,
              112,
              111,
              105,
              110,
              116,
              95,
              105,
              100,
              44,
              99,
              108,
              105,
              101,
              110,
              116,
              95,
              118,
              101,
              114,
              115,
              105,
              111,
              110,
            ]),
          ],
          578365826: [
            Buffer.from([
              66,
              42,
              64,
              47,
              118,
              50,
              47,
              100,
              101,
              98,
              117,
              103,
              103,
              101,
              114,
              47,
              100,
              101,
              98,
              117,
              103,
              103,
              101,
              101,
              115,
              47,
              123,
              100,
              101,
              98,
              117,
              103,
              103,
              101,
              101,
              95,
              105,
              100,
              125,
              47,
              98,
              114,
              101,
              97,
              107,
              112,
              111,
              105,
              110,
              116,
              115,
              47,
              123,
              98,
              114,
              101,
              97,
              107,
              112,
              111,
              105,
              110,
              116,
              95,
              105,
              100,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists all breakpoints for the debuggee. */
    listBreakpoints: {
      name: "ListBreakpoints",
      requestType: ListBreakpointsRequest,
      requestStream: false,
      responseType: ListBreakpointsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              26,
              100,
              101,
              98,
              117,
              103,
              103,
              101,
              101,
              95,
              105,
              100,
              44,
              99,
              108,
              105,
              101,
              110,
              116,
              95,
              118,
              101,
              114,
              115,
              105,
              111,
              110,
            ]),
          ],
          578365826: [
            Buffer.from([
              50,
              18,
              48,
              47,
              118,
              50,
              47,
              100,
              101,
              98,
              117,
              103,
              103,
              101,
              114,
              47,
              100,
              101,
              98,
              117,
              103,
              103,
              101,
              101,
              115,
              47,
              123,
              100,
              101,
              98,
              117,
              103,
              103,
              101,
              101,
              95,
              105,
              100,
              125,
              47,
              98,
              114,
              101,
              97,
              107,
              112,
              111,
              105,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Lists all the debuggees that the user has access to. */
    listDebuggees: {
      name: "ListDebuggees",
      requestType: ListDebuggeesRequest,
      requestStream: false,
      responseType: ListDebuggeesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              22,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              44,
              99,
              108,
              105,
              101,
              110,
              116,
              95,
              118,
              101,
              114,
              115,
              105,
              111,
              110,
            ]),
          ],
          578365826: [
            Buffer.from([
              24,
              18,
              22,
              47,
              118,
              50,
              47,
              100,
              101,
              98,
              117,
              103,
              103,
              101,
              114,
              47,
              100,
              101,
              98,
              117,
              103,
              103,
              101,
              101,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface Debugger2ServiceImplementation<CallContextExt = {}> {
  /** Sets the breakpoint to the debuggee. */
  setBreakpoint(
    request: SetBreakpointRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SetBreakpointResponse>>;
  /** Gets breakpoint information. */
  getBreakpoint(
    request: GetBreakpointRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetBreakpointResponse>>;
  /** Deletes the breakpoint from the debuggee. */
  deleteBreakpoint(
    request: DeleteBreakpointRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** Lists all breakpoints for the debuggee. */
  listBreakpoints(
    request: ListBreakpointsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListBreakpointsResponse>>;
  /** Lists all the debuggees that the user has access to. */
  listDebuggees(
    request: ListDebuggeesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListDebuggeesResponse>>;
}

export interface Debugger2Client<CallOptionsExt = {}> {
  /** Sets the breakpoint to the debuggee. */
  setBreakpoint(
    request: DeepPartial<SetBreakpointRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SetBreakpointResponse>;
  /** Gets breakpoint information. */
  getBreakpoint(
    request: DeepPartial<GetBreakpointRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetBreakpointResponse>;
  /** Deletes the breakpoint from the debuggee. */
  deleteBreakpoint(
    request: DeepPartial<DeleteBreakpointRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** Lists all breakpoints for the debuggee. */
  listBreakpoints(
    request: DeepPartial<ListBreakpointsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListBreakpointsResponse>;
  /** Lists all the debuggees that the user has access to. */
  listDebuggees(
    request: DeepPartial<ListDebuggeesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListDebuggeesResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
