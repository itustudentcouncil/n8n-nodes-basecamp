// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/devtools/clouddebugger/v2/controller.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Breakpoint, Debuggee } from "./data.js";

export const protobufPackage = "google.devtools.clouddebugger.v2";

/** Request to register a debuggee. */
export interface RegisterDebuggeeRequest {
  /**
   * Required. Debuggee information to register.
   * The fields `project`, `uniquifier`, `description` and `agent_version`
   * of the debuggee must be set.
   */
  debuggee: Debuggee | undefined;
}

/** Response for registering a debuggee. */
export interface RegisterDebuggeeResponse {
  /**
   * Debuggee resource.
   * The field `id` is guaranteed to be set (in addition to the echoed fields).
   * If the field `is_disabled` is set to `true`, the agent should disable
   * itself by removing all breakpoints and detaching from the application.
   * It should however continue to poll `RegisterDebuggee` until reenabled.
   */
  debuggee: Debuggee | undefined;
}

/** Request to list active breakpoints. */
export interface ListActiveBreakpointsRequest {
  /** Required. Identifies the debuggee. */
  debuggeeId: string;
  /**
   * A token that, if specified, blocks the method call until the list
   * of active breakpoints has changed, or a server-selected timeout has
   * expired. The value should be set from the `next_wait_token` field in
   * the last response. The initial value should be set to `"init"`.
   */
  waitToken: string;
  /**
   * If set to `true` (recommended), returns `google.rpc.Code.OK` status and
   * sets the `wait_expired` response field to `true` when the server-selected
   * timeout has expired.
   *
   * If set to `false` (deprecated), returns `google.rpc.Code.ABORTED` status
   * when the server-selected timeout has expired.
   */
  successOnTimeout: boolean;
}

/** Response for listing active breakpoints. */
export interface ListActiveBreakpointsResponse {
  /**
   * List of all active breakpoints.
   * The fields `id` and `location` are guaranteed to be set on each breakpoint.
   */
  breakpoints: Breakpoint[];
  /**
   * A token that can be used in the next method call to block until
   * the list of breakpoints changes.
   */
  nextWaitToken: string;
  /**
   * If set to `true`, indicates that there is no change to the
   * list of active breakpoints and the server-selected timeout has expired.
   * The `breakpoints` field would be empty and should be ignored.
   */
  waitExpired: boolean;
}

/** Request to update an active breakpoint. */
export interface UpdateActiveBreakpointRequest {
  /** Required. Identifies the debuggee being debugged. */
  debuggeeId: string;
  /**
   * Required. Updated breakpoint information.
   * The field `id` must be set.
   * The agent must echo all Breakpoint specification fields in the update.
   */
  breakpoint: Breakpoint | undefined;
}

/**
 * Response for updating an active breakpoint.
 * The message is defined to allow future extensions.
 */
export interface UpdateActiveBreakpointResponse {
}

function createBaseRegisterDebuggeeRequest(): RegisterDebuggeeRequest {
  return { debuggee: undefined };
}

export const RegisterDebuggeeRequest: MessageFns<RegisterDebuggeeRequest> = {
  encode(message: RegisterDebuggeeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.debuggee !== undefined) {
      Debuggee.encode(message.debuggee, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterDebuggeeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterDebuggeeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.debuggee = Debuggee.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterDebuggeeRequest {
    return { debuggee: isSet(object.debuggee) ? Debuggee.fromJSON(object.debuggee) : undefined };
  },

  toJSON(message: RegisterDebuggeeRequest): unknown {
    const obj: any = {};
    if (message.debuggee !== undefined) {
      obj.debuggee = Debuggee.toJSON(message.debuggee);
    }
    return obj;
  },

  create(base?: DeepPartial<RegisterDebuggeeRequest>): RegisterDebuggeeRequest {
    return RegisterDebuggeeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RegisterDebuggeeRequest>): RegisterDebuggeeRequest {
    const message = createBaseRegisterDebuggeeRequest();
    message.debuggee = (object.debuggee !== undefined && object.debuggee !== null)
      ? Debuggee.fromPartial(object.debuggee)
      : undefined;
    return message;
  },
};

function createBaseRegisterDebuggeeResponse(): RegisterDebuggeeResponse {
  return { debuggee: undefined };
}

export const RegisterDebuggeeResponse: MessageFns<RegisterDebuggeeResponse> = {
  encode(message: RegisterDebuggeeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.debuggee !== undefined) {
      Debuggee.encode(message.debuggee, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterDebuggeeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterDebuggeeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.debuggee = Debuggee.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterDebuggeeResponse {
    return { debuggee: isSet(object.debuggee) ? Debuggee.fromJSON(object.debuggee) : undefined };
  },

  toJSON(message: RegisterDebuggeeResponse): unknown {
    const obj: any = {};
    if (message.debuggee !== undefined) {
      obj.debuggee = Debuggee.toJSON(message.debuggee);
    }
    return obj;
  },

  create(base?: DeepPartial<RegisterDebuggeeResponse>): RegisterDebuggeeResponse {
    return RegisterDebuggeeResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RegisterDebuggeeResponse>): RegisterDebuggeeResponse {
    const message = createBaseRegisterDebuggeeResponse();
    message.debuggee = (object.debuggee !== undefined && object.debuggee !== null)
      ? Debuggee.fromPartial(object.debuggee)
      : undefined;
    return message;
  },
};

function createBaseListActiveBreakpointsRequest(): ListActiveBreakpointsRequest {
  return { debuggeeId: "", waitToken: "", successOnTimeout: false };
}

export const ListActiveBreakpointsRequest: MessageFns<ListActiveBreakpointsRequest> = {
  encode(message: ListActiveBreakpointsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.debuggeeId !== "") {
      writer.uint32(10).string(message.debuggeeId);
    }
    if (message.waitToken !== "") {
      writer.uint32(18).string(message.waitToken);
    }
    if (message.successOnTimeout !== false) {
      writer.uint32(24).bool(message.successOnTimeout);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListActiveBreakpointsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListActiveBreakpointsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.debuggeeId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.waitToken = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.successOnTimeout = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListActiveBreakpointsRequest {
    return {
      debuggeeId: isSet(object.debuggeeId) ? globalThis.String(object.debuggeeId) : "",
      waitToken: isSet(object.waitToken) ? globalThis.String(object.waitToken) : "",
      successOnTimeout: isSet(object.successOnTimeout) ? globalThis.Boolean(object.successOnTimeout) : false,
    };
  },

  toJSON(message: ListActiveBreakpointsRequest): unknown {
    const obj: any = {};
    if (message.debuggeeId !== "") {
      obj.debuggeeId = message.debuggeeId;
    }
    if (message.waitToken !== "") {
      obj.waitToken = message.waitToken;
    }
    if (message.successOnTimeout !== false) {
      obj.successOnTimeout = message.successOnTimeout;
    }
    return obj;
  },

  create(base?: DeepPartial<ListActiveBreakpointsRequest>): ListActiveBreakpointsRequest {
    return ListActiveBreakpointsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListActiveBreakpointsRequest>): ListActiveBreakpointsRequest {
    const message = createBaseListActiveBreakpointsRequest();
    message.debuggeeId = object.debuggeeId ?? "";
    message.waitToken = object.waitToken ?? "";
    message.successOnTimeout = object.successOnTimeout ?? false;
    return message;
  },
};

function createBaseListActiveBreakpointsResponse(): ListActiveBreakpointsResponse {
  return { breakpoints: [], nextWaitToken: "", waitExpired: false };
}

export const ListActiveBreakpointsResponse: MessageFns<ListActiveBreakpointsResponse> = {
  encode(message: ListActiveBreakpointsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.breakpoints) {
      Breakpoint.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextWaitToken !== "") {
      writer.uint32(18).string(message.nextWaitToken);
    }
    if (message.waitExpired !== false) {
      writer.uint32(24).bool(message.waitExpired);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListActiveBreakpointsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListActiveBreakpointsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.breakpoints.push(Breakpoint.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextWaitToken = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.waitExpired = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListActiveBreakpointsResponse {
    return {
      breakpoints: globalThis.Array.isArray(object?.breakpoints)
        ? object.breakpoints.map((e: any) => Breakpoint.fromJSON(e))
        : [],
      nextWaitToken: isSet(object.nextWaitToken) ? globalThis.String(object.nextWaitToken) : "",
      waitExpired: isSet(object.waitExpired) ? globalThis.Boolean(object.waitExpired) : false,
    };
  },

  toJSON(message: ListActiveBreakpointsResponse): unknown {
    const obj: any = {};
    if (message.breakpoints?.length) {
      obj.breakpoints = message.breakpoints.map((e) => Breakpoint.toJSON(e));
    }
    if (message.nextWaitToken !== "") {
      obj.nextWaitToken = message.nextWaitToken;
    }
    if (message.waitExpired !== false) {
      obj.waitExpired = message.waitExpired;
    }
    return obj;
  },

  create(base?: DeepPartial<ListActiveBreakpointsResponse>): ListActiveBreakpointsResponse {
    return ListActiveBreakpointsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListActiveBreakpointsResponse>): ListActiveBreakpointsResponse {
    const message = createBaseListActiveBreakpointsResponse();
    message.breakpoints = object.breakpoints?.map((e) => Breakpoint.fromPartial(e)) || [];
    message.nextWaitToken = object.nextWaitToken ?? "";
    message.waitExpired = object.waitExpired ?? false;
    return message;
  },
};

function createBaseUpdateActiveBreakpointRequest(): UpdateActiveBreakpointRequest {
  return { debuggeeId: "", breakpoint: undefined };
}

export const UpdateActiveBreakpointRequest: MessageFns<UpdateActiveBreakpointRequest> = {
  encode(message: UpdateActiveBreakpointRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.debuggeeId !== "") {
      writer.uint32(10).string(message.debuggeeId);
    }
    if (message.breakpoint !== undefined) {
      Breakpoint.encode(message.breakpoint, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateActiveBreakpointRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateActiveBreakpointRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.debuggeeId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.breakpoint = Breakpoint.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateActiveBreakpointRequest {
    return {
      debuggeeId: isSet(object.debuggeeId) ? globalThis.String(object.debuggeeId) : "",
      breakpoint: isSet(object.breakpoint) ? Breakpoint.fromJSON(object.breakpoint) : undefined,
    };
  },

  toJSON(message: UpdateActiveBreakpointRequest): unknown {
    const obj: any = {};
    if (message.debuggeeId !== "") {
      obj.debuggeeId = message.debuggeeId;
    }
    if (message.breakpoint !== undefined) {
      obj.breakpoint = Breakpoint.toJSON(message.breakpoint);
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateActiveBreakpointRequest>): UpdateActiveBreakpointRequest {
    return UpdateActiveBreakpointRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateActiveBreakpointRequest>): UpdateActiveBreakpointRequest {
    const message = createBaseUpdateActiveBreakpointRequest();
    message.debuggeeId = object.debuggeeId ?? "";
    message.breakpoint = (object.breakpoint !== undefined && object.breakpoint !== null)
      ? Breakpoint.fromPartial(object.breakpoint)
      : undefined;
    return message;
  },
};

function createBaseUpdateActiveBreakpointResponse(): UpdateActiveBreakpointResponse {
  return {};
}

export const UpdateActiveBreakpointResponse: MessageFns<UpdateActiveBreakpointResponse> = {
  encode(_: UpdateActiveBreakpointResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateActiveBreakpointResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateActiveBreakpointResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UpdateActiveBreakpointResponse {
    return {};
  },

  toJSON(_: UpdateActiveBreakpointResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<UpdateActiveBreakpointResponse>): UpdateActiveBreakpointResponse {
    return UpdateActiveBreakpointResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<UpdateActiveBreakpointResponse>): UpdateActiveBreakpointResponse {
    const message = createBaseUpdateActiveBreakpointResponse();
    return message;
  },
};

/**
 * The Controller service provides the API for orchestrating a collection of
 * debugger agents to perform debugging tasks. These agents are each attached
 * to a process of an application which may include one or more replicas.
 *
 * The debugger agents register with the Controller to identify the application
 * being debugged, the Debuggee. All agents that register with the same data,
 * represent the same Debuggee, and are assigned the same `debuggee_id`.
 *
 * The debugger agents call the Controller to retrieve  the list of active
 * Breakpoints. Agents with the same `debuggee_id` get the same breakpoints
 * list. An agent that can fulfill the breakpoint request updates the
 * Controller with the breakpoint result. The controller selects the first
 * result received and discards the rest of the results.
 * Agents that poll again for active breakpoints will no longer have
 * the completed breakpoint in the list and should remove that breakpoint from
 * their attached process.
 *
 * The Controller service does not provide a way to retrieve the results of
 * a completed breakpoint. This functionality is available using the Debugger
 * service.
 */
export type Controller2Definition = typeof Controller2Definition;
export const Controller2Definition = {
  name: "Controller2",
  fullName: "google.devtools.clouddebugger.v2.Controller2",
  methods: {
    /**
     * Registers the debuggee with the controller service.
     *
     * All agents attached to the same application must call this method with
     * exactly the same request content to get back the same stable `debuggee_id`.
     * Agents should call this method again whenever `google.rpc.Code.NOT_FOUND`
     * is returned from any controller method.
     *
     * This protocol allows the controller service to disable debuggees, recover
     * from data loss, or change the `debuggee_id` format. Agents must handle
     * `debuggee_id` value changing upon re-registration.
     */
    registerDebuggee: {
      name: "RegisterDebuggee",
      requestType: RegisterDebuggeeRequest,
      requestStream: false,
      responseType: RegisterDebuggeeResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([8, 100, 101, 98, 117, 103, 103, 101, 101])],
          578365826: [
            Buffer.from([
              38,
              58,
              1,
              42,
              34,
              33,
              47,
              118,
              50,
              47,
              99,
              111,
              110,
              116,
              114,
              111,
              108,
              108,
              101,
              114,
              47,
              100,
              101,
              98,
              117,
              103,
              103,
              101,
              101,
              115,
              47,
              114,
              101,
              103,
              105,
              115,
              116,
              101,
              114,
            ]),
          ],
        },
      },
    },
    /**
     * Returns the list of all active breakpoints for the debuggee.
     *
     * The breakpoint specification (`location`, `condition`, and `expressions`
     * fields) is semantically immutable, although the field values may
     * change. For example, an agent may update the location line number
     * to reflect the actual line where the breakpoint was set, but this
     * doesn't change the breakpoint semantics.
     *
     * This means that an agent does not need to check if a breakpoint has changed
     * when it encounters the same breakpoint on a successive call.
     * Moreover, an agent should remember the breakpoints that are completed
     * until the controller removes them from the active list to avoid
     * setting those breakpoints again.
     */
    listActiveBreakpoints: {
      name: "ListActiveBreakpoints",
      requestType: ListActiveBreakpointsRequest,
      requestStream: false,
      responseType: ListActiveBreakpointsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([11, 100, 101, 98, 117, 103, 103, 101, 101, 95, 105, 100])],
          578365826: [
            Buffer.from([
              52,
              18,
              50,
              47,
              118,
              50,
              47,
              99,
              111,
              110,
              116,
              114,
              111,
              108,
              108,
              101,
              114,
              47,
              100,
              101,
              98,
              117,
              103,
              103,
              101,
              101,
              115,
              47,
              123,
              100,
              101,
              98,
              117,
              103,
              103,
              101,
              101,
              95,
              105,
              100,
              125,
              47,
              98,
              114,
              101,
              97,
              107,
              112,
              111,
              105,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Updates the breakpoint state or mutable fields.
     * The entire Breakpoint message must be sent back to the controller service.
     *
     * Updates to active breakpoint fields are only allowed if the new value
     * does not change the breakpoint specification. Updates to the `location`,
     * `condition` and `expressions` fields should not alter the breakpoint
     * semantics. These may only make changes such as canonicalizing a value
     * or snapping the location to the correct line of code.
     */
    updateActiveBreakpoint: {
      name: "UpdateActiveBreakpoint",
      requestType: UpdateActiveBreakpointRequest,
      requestStream: false,
      responseType: UpdateActiveBreakpointResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              22,
              100,
              101,
              98,
              117,
              103,
              103,
              101,
              101,
              95,
              105,
              100,
              44,
              98,
              114,
              101,
              97,
              107,
              112,
              111,
              105,
              110,
              116,
            ]),
          ],
          578365826: [
            Buffer.from([
              71,
              58,
              1,
              42,
              26,
              66,
              47,
              118,
              50,
              47,
              99,
              111,
              110,
              116,
              114,
              111,
              108,
              108,
              101,
              114,
              47,
              100,
              101,
              98,
              117,
              103,
              103,
              101,
              101,
              115,
              47,
              123,
              100,
              101,
              98,
              117,
              103,
              103,
              101,
              101,
              95,
              105,
              100,
              125,
              47,
              98,
              114,
              101,
              97,
              107,
              112,
              111,
              105,
              110,
              116,
              115,
              47,
              123,
              98,
              114,
              101,
              97,
              107,
              112,
              111,
              105,
              110,
              116,
              46,
              105,
              100,
              125,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface Controller2ServiceImplementation<CallContextExt = {}> {
  /**
   * Registers the debuggee with the controller service.
   *
   * All agents attached to the same application must call this method with
   * exactly the same request content to get back the same stable `debuggee_id`.
   * Agents should call this method again whenever `google.rpc.Code.NOT_FOUND`
   * is returned from any controller method.
   *
   * This protocol allows the controller service to disable debuggees, recover
   * from data loss, or change the `debuggee_id` format. Agents must handle
   * `debuggee_id` value changing upon re-registration.
   */
  registerDebuggee(
    request: RegisterDebuggeeRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<RegisterDebuggeeResponse>>;
  /**
   * Returns the list of all active breakpoints for the debuggee.
   *
   * The breakpoint specification (`location`, `condition`, and `expressions`
   * fields) is semantically immutable, although the field values may
   * change. For example, an agent may update the location line number
   * to reflect the actual line where the breakpoint was set, but this
   * doesn't change the breakpoint semantics.
   *
   * This means that an agent does not need to check if a breakpoint has changed
   * when it encounters the same breakpoint on a successive call.
   * Moreover, an agent should remember the breakpoints that are completed
   * until the controller removes them from the active list to avoid
   * setting those breakpoints again.
   */
  listActiveBreakpoints(
    request: ListActiveBreakpointsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListActiveBreakpointsResponse>>;
  /**
   * Updates the breakpoint state or mutable fields.
   * The entire Breakpoint message must be sent back to the controller service.
   *
   * Updates to active breakpoint fields are only allowed if the new value
   * does not change the breakpoint specification. Updates to the `location`,
   * `condition` and `expressions` fields should not alter the breakpoint
   * semantics. These may only make changes such as canonicalizing a value
   * or snapping the location to the correct line of code.
   */
  updateActiveBreakpoint(
    request: UpdateActiveBreakpointRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<UpdateActiveBreakpointResponse>>;
}

export interface Controller2Client<CallOptionsExt = {}> {
  /**
   * Registers the debuggee with the controller service.
   *
   * All agents attached to the same application must call this method with
   * exactly the same request content to get back the same stable `debuggee_id`.
   * Agents should call this method again whenever `google.rpc.Code.NOT_FOUND`
   * is returned from any controller method.
   *
   * This protocol allows the controller service to disable debuggees, recover
   * from data loss, or change the `debuggee_id` format. Agents must handle
   * `debuggee_id` value changing upon re-registration.
   */
  registerDebuggee(
    request: DeepPartial<RegisterDebuggeeRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<RegisterDebuggeeResponse>;
  /**
   * Returns the list of all active breakpoints for the debuggee.
   *
   * The breakpoint specification (`location`, `condition`, and `expressions`
   * fields) is semantically immutable, although the field values may
   * change. For example, an agent may update the location line number
   * to reflect the actual line where the breakpoint was set, but this
   * doesn't change the breakpoint semantics.
   *
   * This means that an agent does not need to check if a breakpoint has changed
   * when it encounters the same breakpoint on a successive call.
   * Moreover, an agent should remember the breakpoints that are completed
   * until the controller removes them from the active list to avoid
   * setting those breakpoints again.
   */
  listActiveBreakpoints(
    request: DeepPartial<ListActiveBreakpointsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListActiveBreakpointsResponse>;
  /**
   * Updates the breakpoint state or mutable fields.
   * The entire Breakpoint message must be sent back to the controller service.
   *
   * Updates to active breakpoint fields are only allowed if the new value
   * does not change the breakpoint specification. Updates to the `location`,
   * `condition` and `expressions` fields should not alter the breakpoint
   * semantics. These may only make changes such as canonicalizing a value
   * or snapping the location to the correct line of code.
   */
  updateActiveBreakpoint(
    request: DeepPartial<UpdateActiveBreakpointRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<UpdateActiveBreakpointResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
