// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/devtools/containeranalysis/v1beta1/grafeas/grafeas.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Empty } from "../../../../protobuf/empty.js";
import { FieldMask } from "../../../../protobuf/field_mask.js";
import { Timestamp } from "../../../../protobuf/timestamp.js";
import { Authority, Details as Details6 } from "../attestation/attestation.js";
import { Build, Details as Details1 } from "../build/build.js";
import { NoteKind, noteKindFromJSON, noteKindToJSON, RelatedUrl } from "../common/common.js";
import { Deployable, Details as Details4 } from "../deployment/deployment.js";
import { Details as Details5, Discovery } from "../discovery/discovery.js";
import { Basis, Details as Details2 } from "../image/image.js";
import { Details as Details3, Package } from "../package/package.js";
import { Hash } from "../provenance/provenance.js";
import { Details, Severity, severityFromJSON, severityToJSON, Vulnerability } from "../vulnerability/vulnerability.js";

export const protobufPackage = "grafeas.v1beta1";

/** An instance of an analysis type that has been found on a resource. */
export interface Occurrence {
  /**
   * Output only. The name of the occurrence in the form of
   * `projects/[PROJECT_ID]/occurrences/[OCCURRENCE_ID]`.
   */
  name: string;
  /** Required. Immutable. The resource for which the occurrence applies. */
  resource:
    | Resource
    | undefined;
  /**
   * Required. Immutable. The analysis note associated with this occurrence, in
   * the form of `projects/[PROVIDER_ID]/notes/[NOTE_ID]`. This field can be
   * used as a filter in list requests.
   */
  noteName: string;
  /**
   * Output only. This explicitly denotes which of the occurrence details are
   * specified. This field can be used as a filter in list requests.
   */
  kind: NoteKind;
  /** A description of actions that can be taken to remedy the note. */
  remediation: string;
  /** Output only. The time this occurrence was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time this occurrence was last updated. */
  updateTime:
    | Date
    | undefined;
  /** Describes a security vulnerability. */
  vulnerability?:
    | Details
    | undefined;
  /** Describes a verifiable build. */
  build?:
    | Details1
    | undefined;
  /**
   * Describes how this resource derives from the basis in the associated
   * note.
   */
  derivedImage?:
    | Details2
    | undefined;
  /** Describes the installation of a package on the linked resource. */
  installation?:
    | Details3
    | undefined;
  /** Describes the deployment of an artifact on a runtime. */
  deployment?:
    | Details4
    | undefined;
  /** Describes when a resource was discovered. */
  discovered?:
    | Details5
    | undefined;
  /** Describes an attestation of an artifact. */
  attestation?: Details6 | undefined;
}

/** An entity that can have metadata. For example, a Docker image. */
export interface Resource {
  /**
   * The name of the resource. For example, the name of a Docker image -
   * "Debian".
   */
  name: string;
  /**
   * Required. The unique URI of the resource. For example,
   * `https://gcr.io/project/image@sha256:foo` for a Docker image.
   */
  uri: string;
  /** The hash of the resource content. For example, the Docker digest. */
  contentHash: Hash | undefined;
}

/** A type of analysis that can be done for a resource. */
export interface Note {
  /**
   * Output only. The name of the note in the form of
   * `projects/[PROVIDER_ID]/notes/[NOTE_ID]`.
   */
  name: string;
  /** A one sentence description of this note. */
  shortDescription: string;
  /** A detailed description of this note. */
  longDescription: string;
  /**
   * Output only. The type of analysis. This field can be used as a filter in
   * list requests.
   */
  kind: NoteKind;
  /** URLs associated with this note. */
  relatedUrl: RelatedUrl[];
  /** Time of expiration for this note. Empty if note does not expire. */
  expirationTime:
    | Date
    | undefined;
  /**
   * Output only. The time this note was created. This field can be used as a
   * filter in list requests.
   */
  createTime:
    | Date
    | undefined;
  /**
   * Output only. The time this note was last updated. This field can be used as
   * a filter in list requests.
   */
  updateTime:
    | Date
    | undefined;
  /** Other notes related to this note. */
  relatedNoteNames: string[];
  /** A note describing a package vulnerability. */
  vulnerability?:
    | Vulnerability
    | undefined;
  /** A note describing build provenance for a verifiable build. */
  build?:
    | Build
    | undefined;
  /** A note describing a base image. */
  baseImage?:
    | Basis
    | undefined;
  /** A note describing a package hosted by various package managers. */
  package?:
    | Package
    | undefined;
  /** A note describing something that can be deployed. */
  deployable?:
    | Deployable
    | undefined;
  /** A note describing the initial analysis of a resource. */
  discovery?:
    | Discovery
    | undefined;
  /** A note describing an attestation role. */
  attestationAuthority?: Authority | undefined;
}

/** Request to get an occurrence. */
export interface GetOccurrenceRequest {
  /**
   * The name of the occurrence in the form of
   * `projects/[PROJECT_ID]/occurrences/[OCCURRENCE_ID]`.
   */
  name: string;
}

/** Request to list occurrences. */
export interface ListOccurrencesRequest {
  /**
   * The name of the project to list occurrences for in the form of
   * `projects/[PROJECT_ID]`.
   */
  parent: string;
  /** The filter expression. */
  filter: string;
  /** Number of occurrences to return in the list. */
  pageSize: number;
  /** Token to provide to skip to a particular spot in the list. */
  pageToken: string;
}

/** Response for listing occurrences. */
export interface ListOccurrencesResponse {
  /** The occurrences requested. */
  occurrences: Occurrence[];
  /**
   * The next pagination token in the list response. It should be used as
   * `page_token` for the following request. An empty value means no more
   * results.
   */
  nextPageToken: string;
}

/** Request to delete a occurrence. */
export interface DeleteOccurrenceRequest {
  /**
   * The name of the occurrence in the form of
   * `projects/[PROJECT_ID]/occurrences/[OCCURRENCE_ID]`.
   */
  name: string;
}

/** Request to create a new occurrence. */
export interface CreateOccurrenceRequest {
  /**
   * The name of the project in the form of `projects/[PROJECT_ID]`, under which
   * the occurrence is to be created.
   */
  parent: string;
  /** The occurrence to create. */
  occurrence: Occurrence | undefined;
}

/** Request to update an occurrence. */
export interface UpdateOccurrenceRequest {
  /**
   * The name of the occurrence in the form of
   * `projects/[PROJECT_ID]/occurrences/[OCCURRENCE_ID]`.
   */
  name: string;
  /** The updated occurrence. */
  occurrence:
    | Occurrence
    | undefined;
  /** The fields to update. */
  updateMask: string[] | undefined;
}

/** Request to get a note. */
export interface GetNoteRequest {
  /**
   * The name of the note in the form of
   * `projects/[PROVIDER_ID]/notes/[NOTE_ID]`.
   */
  name: string;
}

/** Request to get the note to which the specified occurrence is attached. */
export interface GetOccurrenceNoteRequest {
  /**
   * The name of the occurrence in the form of
   * `projects/[PROJECT_ID]/occurrences/[OCCURRENCE_ID]`.
   */
  name: string;
}

/** Request to list notes. */
export interface ListNotesRequest {
  /**
   * The name of the project to list notes for in the form of
   * `projects/[PROJECT_ID]`.
   */
  parent: string;
  /** The filter expression. */
  filter: string;
  /** Number of notes to return in the list. */
  pageSize: number;
  /** Token to provide to skip to a particular spot in the list. */
  pageToken: string;
}

/** Response for listing notes. */
export interface ListNotesResponse {
  /** The notes requested. */
  notes: Note[];
  /**
   * The next pagination token in the list response. It should be used as
   * `page_token` for the following request. An empty value means no more
   * results.
   */
  nextPageToken: string;
}

/** Request to delete a note. */
export interface DeleteNoteRequest {
  /**
   * The name of the note in the form of
   * `projects/[PROVIDER_ID]/notes/[NOTE_ID]`.
   */
  name: string;
}

/** Request to create a new note. */
export interface CreateNoteRequest {
  /**
   * The name of the project in the form of `projects/[PROJECT_ID]`, under which
   * the note is to be created.
   */
  parent: string;
  /** The ID to use for this note. */
  noteId: string;
  /** The note to create. */
  note: Note | undefined;
}

/** Request to update a note. */
export interface UpdateNoteRequest {
  /**
   * The name of the note in the form of
   * `projects/[PROVIDER_ID]/notes/[NOTE_ID]`.
   */
  name: string;
  /** The updated note. */
  note:
    | Note
    | undefined;
  /** The fields to update. */
  updateMask: string[] | undefined;
}

/** Request to list occurrences for a note. */
export interface ListNoteOccurrencesRequest {
  /**
   * The name of the note to list occurrences for in the form of
   * `projects/[PROVIDER_ID]/notes/[NOTE_ID]`.
   */
  name: string;
  /** The filter expression. */
  filter: string;
  /** Number of occurrences to return in the list. */
  pageSize: number;
  /** Token to provide to skip to a particular spot in the list. */
  pageToken: string;
}

/** Response for listing occurrences for a note. */
export interface ListNoteOccurrencesResponse {
  /** The occurrences attached to the specified note. */
  occurrences: Occurrence[];
  /** Token to provide to skip to a particular spot in the list. */
  nextPageToken: string;
}

/** Request to create notes in batch. */
export interface BatchCreateNotesRequest {
  /**
   * The name of the project in the form of `projects/[PROJECT_ID]`, under which
   * the notes are to be created.
   */
  parent: string;
  /** The notes to create. */
  notes: { [key: string]: Note };
}

export interface BatchCreateNotesRequest_NotesEntry {
  key: string;
  value: Note | undefined;
}

/** Response for creating notes in batch. */
export interface BatchCreateNotesResponse {
  /** The notes that were created. */
  notes: Note[];
}

/** Request to create occurrences in batch. */
export interface BatchCreateOccurrencesRequest {
  /**
   * The name of the project in the form of `projects/[PROJECT_ID]`, under which
   * the occurrences are to be created.
   */
  parent: string;
  /** The occurrences to create. */
  occurrences: Occurrence[];
}

/** Response for creating occurrences in batch. */
export interface BatchCreateOccurrencesResponse {
  /** The occurrences that were created. */
  occurrences: Occurrence[];
}

/** Request to get a vulnerability summary for some set of occurrences. */
export interface GetVulnerabilityOccurrencesSummaryRequest {
  /**
   * The name of the project to get a vulnerability summary for in the form of
   * `projects/[PROJECT_ID]`.
   */
  parent: string;
  /** The filter expression. */
  filter: string;
}

/**
 * A summary of how many vulnerability occurrences there are per resource and
 * severity type.
 */
export interface VulnerabilityOccurrencesSummary {
  /** A listing by resource of the number of fixable and total vulnerabilities. */
  counts: VulnerabilityOccurrencesSummary_FixableTotalByDigest[];
}

/** Per resource and severity counts of fixable and total vulnerabilities. */
export interface VulnerabilityOccurrencesSummary_FixableTotalByDigest {
  /** The affected resource. */
  resource:
    | Resource
    | undefined;
  /**
   * The severity for this count. SEVERITY_UNSPECIFIED indicates total across
   * all severities.
   */
  severity: Severity;
  /** The number of fixable vulnerabilities associated with this resource. */
  fixableCount: Long;
  /** The total number of vulnerabilities associated with this resource. */
  totalCount: Long;
}

function createBaseOccurrence(): Occurrence {
  return {
    name: "",
    resource: undefined,
    noteName: "",
    kind: 0,
    remediation: "",
    createTime: undefined,
    updateTime: undefined,
    vulnerability: undefined,
    build: undefined,
    derivedImage: undefined,
    installation: undefined,
    deployment: undefined,
    discovered: undefined,
    attestation: undefined,
  };
}

export const Occurrence: MessageFns<Occurrence> = {
  encode(message: Occurrence, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.resource !== undefined) {
      Resource.encode(message.resource, writer.uint32(18).fork()).join();
    }
    if (message.noteName !== "") {
      writer.uint32(26).string(message.noteName);
    }
    if (message.kind !== 0) {
      writer.uint32(32).int32(message.kind);
    }
    if (message.remediation !== "") {
      writer.uint32(42).string(message.remediation);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(50).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(58).fork()).join();
    }
    if (message.vulnerability !== undefined) {
      Details.encode(message.vulnerability, writer.uint32(66).fork()).join();
    }
    if (message.build !== undefined) {
      Details1.encode(message.build, writer.uint32(74).fork()).join();
    }
    if (message.derivedImage !== undefined) {
      Details2.encode(message.derivedImage, writer.uint32(82).fork()).join();
    }
    if (message.installation !== undefined) {
      Details3.encode(message.installation, writer.uint32(90).fork()).join();
    }
    if (message.deployment !== undefined) {
      Details4.encode(message.deployment, writer.uint32(98).fork()).join();
    }
    if (message.discovered !== undefined) {
      Details5.encode(message.discovered, writer.uint32(106).fork()).join();
    }
    if (message.attestation !== undefined) {
      Details6.encode(message.attestation, writer.uint32(114).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Occurrence {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOccurrence();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.resource = Resource.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.noteName = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.kind = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.remediation = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.vulnerability = Details.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.build = Details1.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.derivedImage = Details2.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.installation = Details3.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.deployment = Details4.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.discovered = Details5.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.attestation = Details6.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Occurrence {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      resource: isSet(object.resource) ? Resource.fromJSON(object.resource) : undefined,
      noteName: isSet(object.noteName) ? globalThis.String(object.noteName) : "",
      kind: isSet(object.kind) ? noteKindFromJSON(object.kind) : 0,
      remediation: isSet(object.remediation) ? globalThis.String(object.remediation) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      vulnerability: isSet(object.vulnerability) ? Details.fromJSON(object.vulnerability) : undefined,
      build: isSet(object.build) ? Details1.fromJSON(object.build) : undefined,
      derivedImage: isSet(object.derivedImage) ? Details2.fromJSON(object.derivedImage) : undefined,
      installation: isSet(object.installation) ? Details3.fromJSON(object.installation) : undefined,
      deployment: isSet(object.deployment) ? Details4.fromJSON(object.deployment) : undefined,
      discovered: isSet(object.discovered) ? Details5.fromJSON(object.discovered) : undefined,
      attestation: isSet(object.attestation) ? Details6.fromJSON(object.attestation) : undefined,
    };
  },

  toJSON(message: Occurrence): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.resource !== undefined) {
      obj.resource = Resource.toJSON(message.resource);
    }
    if (message.noteName !== "") {
      obj.noteName = message.noteName;
    }
    if (message.kind !== 0) {
      obj.kind = noteKindToJSON(message.kind);
    }
    if (message.remediation !== "") {
      obj.remediation = message.remediation;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.vulnerability !== undefined) {
      obj.vulnerability = Details.toJSON(message.vulnerability);
    }
    if (message.build !== undefined) {
      obj.build = Details1.toJSON(message.build);
    }
    if (message.derivedImage !== undefined) {
      obj.derivedImage = Details2.toJSON(message.derivedImage);
    }
    if (message.installation !== undefined) {
      obj.installation = Details3.toJSON(message.installation);
    }
    if (message.deployment !== undefined) {
      obj.deployment = Details4.toJSON(message.deployment);
    }
    if (message.discovered !== undefined) {
      obj.discovered = Details5.toJSON(message.discovered);
    }
    if (message.attestation !== undefined) {
      obj.attestation = Details6.toJSON(message.attestation);
    }
    return obj;
  },

  create(base?: DeepPartial<Occurrence>): Occurrence {
    return Occurrence.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Occurrence>): Occurrence {
    const message = createBaseOccurrence();
    message.name = object.name ?? "";
    message.resource = (object.resource !== undefined && object.resource !== null)
      ? Resource.fromPartial(object.resource)
      : undefined;
    message.noteName = object.noteName ?? "";
    message.kind = object.kind ?? 0;
    message.remediation = object.remediation ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.vulnerability = (object.vulnerability !== undefined && object.vulnerability !== null)
      ? Details.fromPartial(object.vulnerability)
      : undefined;
    message.build = (object.build !== undefined && object.build !== null)
      ? Details1.fromPartial(object.build)
      : undefined;
    message.derivedImage = (object.derivedImage !== undefined && object.derivedImage !== null)
      ? Details2.fromPartial(object.derivedImage)
      : undefined;
    message.installation = (object.installation !== undefined && object.installation !== null)
      ? Details3.fromPartial(object.installation)
      : undefined;
    message.deployment = (object.deployment !== undefined && object.deployment !== null)
      ? Details4.fromPartial(object.deployment)
      : undefined;
    message.discovered = (object.discovered !== undefined && object.discovered !== null)
      ? Details5.fromPartial(object.discovered)
      : undefined;
    message.attestation = (object.attestation !== undefined && object.attestation !== null)
      ? Details6.fromPartial(object.attestation)
      : undefined;
    return message;
  },
};

function createBaseResource(): Resource {
  return { name: "", uri: "", contentHash: undefined };
}

export const Resource: MessageFns<Resource> = {
  encode(message: Resource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    if (message.contentHash !== undefined) {
      Hash.encode(message.contentHash, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Resource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.contentHash = Hash.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Resource {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      contentHash: isSet(object.contentHash) ? Hash.fromJSON(object.contentHash) : undefined,
    };
  },

  toJSON(message: Resource): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.contentHash !== undefined) {
      obj.contentHash = Hash.toJSON(message.contentHash);
    }
    return obj;
  },

  create(base?: DeepPartial<Resource>): Resource {
    return Resource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Resource>): Resource {
    const message = createBaseResource();
    message.name = object.name ?? "";
    message.uri = object.uri ?? "";
    message.contentHash = (object.contentHash !== undefined && object.contentHash !== null)
      ? Hash.fromPartial(object.contentHash)
      : undefined;
    return message;
  },
};

function createBaseNote(): Note {
  return {
    name: "",
    shortDescription: "",
    longDescription: "",
    kind: 0,
    relatedUrl: [],
    expirationTime: undefined,
    createTime: undefined,
    updateTime: undefined,
    relatedNoteNames: [],
    vulnerability: undefined,
    build: undefined,
    baseImage: undefined,
    package: undefined,
    deployable: undefined,
    discovery: undefined,
    attestationAuthority: undefined,
  };
}

export const Note: MessageFns<Note> = {
  encode(message: Note, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.shortDescription !== "") {
      writer.uint32(18).string(message.shortDescription);
    }
    if (message.longDescription !== "") {
      writer.uint32(26).string(message.longDescription);
    }
    if (message.kind !== 0) {
      writer.uint32(32).int32(message.kind);
    }
    for (const v of message.relatedUrl) {
      RelatedUrl.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.expirationTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expirationTime), writer.uint32(50).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(58).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(66).fork()).join();
    }
    for (const v of message.relatedNoteNames) {
      writer.uint32(74).string(v!);
    }
    if (message.vulnerability !== undefined) {
      Vulnerability.encode(message.vulnerability, writer.uint32(82).fork()).join();
    }
    if (message.build !== undefined) {
      Build.encode(message.build, writer.uint32(90).fork()).join();
    }
    if (message.baseImage !== undefined) {
      Basis.encode(message.baseImage, writer.uint32(98).fork()).join();
    }
    if (message.package !== undefined) {
      Package.encode(message.package, writer.uint32(106).fork()).join();
    }
    if (message.deployable !== undefined) {
      Deployable.encode(message.deployable, writer.uint32(114).fork()).join();
    }
    if (message.discovery !== undefined) {
      Discovery.encode(message.discovery, writer.uint32(122).fork()).join();
    }
    if (message.attestationAuthority !== undefined) {
      Authority.encode(message.attestationAuthority, writer.uint32(130).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Note {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNote();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.shortDescription = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.longDescription = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.kind = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.relatedUrl.push(RelatedUrl.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.expirationTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.relatedNoteNames.push(reader.string());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.vulnerability = Vulnerability.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.build = Build.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.baseImage = Basis.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.package = Package.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.deployable = Deployable.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.discovery = Discovery.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.attestationAuthority = Authority.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Note {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      shortDescription: isSet(object.shortDescription) ? globalThis.String(object.shortDescription) : "",
      longDescription: isSet(object.longDescription) ? globalThis.String(object.longDescription) : "",
      kind: isSet(object.kind) ? noteKindFromJSON(object.kind) : 0,
      relatedUrl: globalThis.Array.isArray(object?.relatedUrl)
        ? object.relatedUrl.map((e: any) => RelatedUrl.fromJSON(e))
        : [],
      expirationTime: isSet(object.expirationTime) ? fromJsonTimestamp(object.expirationTime) : undefined,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      relatedNoteNames: globalThis.Array.isArray(object?.relatedNoteNames)
        ? object.relatedNoteNames.map((e: any) => globalThis.String(e))
        : [],
      vulnerability: isSet(object.vulnerability) ? Vulnerability.fromJSON(object.vulnerability) : undefined,
      build: isSet(object.build) ? Build.fromJSON(object.build) : undefined,
      baseImage: isSet(object.baseImage) ? Basis.fromJSON(object.baseImage) : undefined,
      package: isSet(object.package) ? Package.fromJSON(object.package) : undefined,
      deployable: isSet(object.deployable) ? Deployable.fromJSON(object.deployable) : undefined,
      discovery: isSet(object.discovery) ? Discovery.fromJSON(object.discovery) : undefined,
      attestationAuthority: isSet(object.attestationAuthority)
        ? Authority.fromJSON(object.attestationAuthority)
        : undefined,
    };
  },

  toJSON(message: Note): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.shortDescription !== "") {
      obj.shortDescription = message.shortDescription;
    }
    if (message.longDescription !== "") {
      obj.longDescription = message.longDescription;
    }
    if (message.kind !== 0) {
      obj.kind = noteKindToJSON(message.kind);
    }
    if (message.relatedUrl?.length) {
      obj.relatedUrl = message.relatedUrl.map((e) => RelatedUrl.toJSON(e));
    }
    if (message.expirationTime !== undefined) {
      obj.expirationTime = message.expirationTime.toISOString();
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.relatedNoteNames?.length) {
      obj.relatedNoteNames = message.relatedNoteNames;
    }
    if (message.vulnerability !== undefined) {
      obj.vulnerability = Vulnerability.toJSON(message.vulnerability);
    }
    if (message.build !== undefined) {
      obj.build = Build.toJSON(message.build);
    }
    if (message.baseImage !== undefined) {
      obj.baseImage = Basis.toJSON(message.baseImage);
    }
    if (message.package !== undefined) {
      obj.package = Package.toJSON(message.package);
    }
    if (message.deployable !== undefined) {
      obj.deployable = Deployable.toJSON(message.deployable);
    }
    if (message.discovery !== undefined) {
      obj.discovery = Discovery.toJSON(message.discovery);
    }
    if (message.attestationAuthority !== undefined) {
      obj.attestationAuthority = Authority.toJSON(message.attestationAuthority);
    }
    return obj;
  },

  create(base?: DeepPartial<Note>): Note {
    return Note.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Note>): Note {
    const message = createBaseNote();
    message.name = object.name ?? "";
    message.shortDescription = object.shortDescription ?? "";
    message.longDescription = object.longDescription ?? "";
    message.kind = object.kind ?? 0;
    message.relatedUrl = object.relatedUrl?.map((e) => RelatedUrl.fromPartial(e)) || [];
    message.expirationTime = object.expirationTime ?? undefined;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.relatedNoteNames = object.relatedNoteNames?.map((e) => e) || [];
    message.vulnerability = (object.vulnerability !== undefined && object.vulnerability !== null)
      ? Vulnerability.fromPartial(object.vulnerability)
      : undefined;
    message.build = (object.build !== undefined && object.build !== null) ? Build.fromPartial(object.build) : undefined;
    message.baseImage = (object.baseImage !== undefined && object.baseImage !== null)
      ? Basis.fromPartial(object.baseImage)
      : undefined;
    message.package = (object.package !== undefined && object.package !== null)
      ? Package.fromPartial(object.package)
      : undefined;
    message.deployable = (object.deployable !== undefined && object.deployable !== null)
      ? Deployable.fromPartial(object.deployable)
      : undefined;
    message.discovery = (object.discovery !== undefined && object.discovery !== null)
      ? Discovery.fromPartial(object.discovery)
      : undefined;
    message.attestationAuthority = (object.attestationAuthority !== undefined && object.attestationAuthority !== null)
      ? Authority.fromPartial(object.attestationAuthority)
      : undefined;
    return message;
  },
};

function createBaseGetOccurrenceRequest(): GetOccurrenceRequest {
  return { name: "" };
}

export const GetOccurrenceRequest: MessageFns<GetOccurrenceRequest> = {
  encode(message: GetOccurrenceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOccurrenceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOccurrenceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOccurrenceRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetOccurrenceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetOccurrenceRequest>): GetOccurrenceRequest {
    return GetOccurrenceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetOccurrenceRequest>): GetOccurrenceRequest {
    const message = createBaseGetOccurrenceRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListOccurrencesRequest(): ListOccurrencesRequest {
  return { parent: "", filter: "", pageSize: 0, pageToken: "" };
}

export const ListOccurrencesRequest: MessageFns<ListOccurrencesRequest> = {
  encode(message: ListOccurrencesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.filter !== "") {
      writer.uint32(18).string(message.filter);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListOccurrencesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOccurrencesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListOccurrencesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListOccurrencesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListOccurrencesRequest>): ListOccurrencesRequest {
    return ListOccurrencesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListOccurrencesRequest>): ListOccurrencesRequest {
    const message = createBaseListOccurrencesRequest();
    message.parent = object.parent ?? "";
    message.filter = object.filter ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListOccurrencesResponse(): ListOccurrencesResponse {
  return { occurrences: [], nextPageToken: "" };
}

export const ListOccurrencesResponse: MessageFns<ListOccurrencesResponse> = {
  encode(message: ListOccurrencesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.occurrences) {
      Occurrence.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListOccurrencesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOccurrencesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.occurrences.push(Occurrence.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListOccurrencesResponse {
    return {
      occurrences: globalThis.Array.isArray(object?.occurrences)
        ? object.occurrences.map((e: any) => Occurrence.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListOccurrencesResponse): unknown {
    const obj: any = {};
    if (message.occurrences?.length) {
      obj.occurrences = message.occurrences.map((e) => Occurrence.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListOccurrencesResponse>): ListOccurrencesResponse {
    return ListOccurrencesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListOccurrencesResponse>): ListOccurrencesResponse {
    const message = createBaseListOccurrencesResponse();
    message.occurrences = object.occurrences?.map((e) => Occurrence.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseDeleteOccurrenceRequest(): DeleteOccurrenceRequest {
  return { name: "" };
}

export const DeleteOccurrenceRequest: MessageFns<DeleteOccurrenceRequest> = {
  encode(message: DeleteOccurrenceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteOccurrenceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteOccurrenceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteOccurrenceRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteOccurrenceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteOccurrenceRequest>): DeleteOccurrenceRequest {
    return DeleteOccurrenceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteOccurrenceRequest>): DeleteOccurrenceRequest {
    const message = createBaseDeleteOccurrenceRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateOccurrenceRequest(): CreateOccurrenceRequest {
  return { parent: "", occurrence: undefined };
}

export const CreateOccurrenceRequest: MessageFns<CreateOccurrenceRequest> = {
  encode(message: CreateOccurrenceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.occurrence !== undefined) {
      Occurrence.encode(message.occurrence, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateOccurrenceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOccurrenceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.occurrence = Occurrence.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOccurrenceRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      occurrence: isSet(object.occurrence) ? Occurrence.fromJSON(object.occurrence) : undefined,
    };
  },

  toJSON(message: CreateOccurrenceRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.occurrence !== undefined) {
      obj.occurrence = Occurrence.toJSON(message.occurrence);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOccurrenceRequest>): CreateOccurrenceRequest {
    return CreateOccurrenceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateOccurrenceRequest>): CreateOccurrenceRequest {
    const message = createBaseCreateOccurrenceRequest();
    message.parent = object.parent ?? "";
    message.occurrence = (object.occurrence !== undefined && object.occurrence !== null)
      ? Occurrence.fromPartial(object.occurrence)
      : undefined;
    return message;
  },
};

function createBaseUpdateOccurrenceRequest(): UpdateOccurrenceRequest {
  return { name: "", occurrence: undefined, updateMask: undefined };
}

export const UpdateOccurrenceRequest: MessageFns<UpdateOccurrenceRequest> = {
  encode(message: UpdateOccurrenceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.occurrence !== undefined) {
      Occurrence.encode(message.occurrence, writer.uint32(18).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateOccurrenceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateOccurrenceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.occurrence = Occurrence.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateOccurrenceRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      occurrence: isSet(object.occurrence) ? Occurrence.fromJSON(object.occurrence) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateOccurrenceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.occurrence !== undefined) {
      obj.occurrence = Occurrence.toJSON(message.occurrence);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateOccurrenceRequest>): UpdateOccurrenceRequest {
    return UpdateOccurrenceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateOccurrenceRequest>): UpdateOccurrenceRequest {
    const message = createBaseUpdateOccurrenceRequest();
    message.name = object.name ?? "";
    message.occurrence = (object.occurrence !== undefined && object.occurrence !== null)
      ? Occurrence.fromPartial(object.occurrence)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseGetNoteRequest(): GetNoteRequest {
  return { name: "" };
}

export const GetNoteRequest: MessageFns<GetNoteRequest> = {
  encode(message: GetNoteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNoteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNoteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNoteRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetNoteRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetNoteRequest>): GetNoteRequest {
    return GetNoteRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetNoteRequest>): GetNoteRequest {
    const message = createBaseGetNoteRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetOccurrenceNoteRequest(): GetOccurrenceNoteRequest {
  return { name: "" };
}

export const GetOccurrenceNoteRequest: MessageFns<GetOccurrenceNoteRequest> = {
  encode(message: GetOccurrenceNoteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOccurrenceNoteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOccurrenceNoteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOccurrenceNoteRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetOccurrenceNoteRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetOccurrenceNoteRequest>): GetOccurrenceNoteRequest {
    return GetOccurrenceNoteRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetOccurrenceNoteRequest>): GetOccurrenceNoteRequest {
    const message = createBaseGetOccurrenceNoteRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListNotesRequest(): ListNotesRequest {
  return { parent: "", filter: "", pageSize: 0, pageToken: "" };
}

export const ListNotesRequest: MessageFns<ListNotesRequest> = {
  encode(message: ListNotesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.filter !== "") {
      writer.uint32(18).string(message.filter);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNotesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNotesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNotesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListNotesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListNotesRequest>): ListNotesRequest {
    return ListNotesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListNotesRequest>): ListNotesRequest {
    const message = createBaseListNotesRequest();
    message.parent = object.parent ?? "";
    message.filter = object.filter ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListNotesResponse(): ListNotesResponse {
  return { notes: [], nextPageToken: "" };
}

export const ListNotesResponse: MessageFns<ListNotesResponse> = {
  encode(message: ListNotesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.notes) {
      Note.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNotesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNotesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.notes.push(Note.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNotesResponse {
    return {
      notes: globalThis.Array.isArray(object?.notes) ? object.notes.map((e: any) => Note.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListNotesResponse): unknown {
    const obj: any = {};
    if (message.notes?.length) {
      obj.notes = message.notes.map((e) => Note.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListNotesResponse>): ListNotesResponse {
    return ListNotesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListNotesResponse>): ListNotesResponse {
    const message = createBaseListNotesResponse();
    message.notes = object.notes?.map((e) => Note.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseDeleteNoteRequest(): DeleteNoteRequest {
  return { name: "" };
}

export const DeleteNoteRequest: MessageFns<DeleteNoteRequest> = {
  encode(message: DeleteNoteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteNoteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteNoteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteNoteRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteNoteRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteNoteRequest>): DeleteNoteRequest {
    return DeleteNoteRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteNoteRequest>): DeleteNoteRequest {
    const message = createBaseDeleteNoteRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateNoteRequest(): CreateNoteRequest {
  return { parent: "", noteId: "", note: undefined };
}

export const CreateNoteRequest: MessageFns<CreateNoteRequest> = {
  encode(message: CreateNoteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.noteId !== "") {
      writer.uint32(18).string(message.noteId);
    }
    if (message.note !== undefined) {
      Note.encode(message.note, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateNoteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateNoteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.noteId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.note = Note.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateNoteRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      noteId: isSet(object.noteId) ? globalThis.String(object.noteId) : "",
      note: isSet(object.note) ? Note.fromJSON(object.note) : undefined,
    };
  },

  toJSON(message: CreateNoteRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.noteId !== "") {
      obj.noteId = message.noteId;
    }
    if (message.note !== undefined) {
      obj.note = Note.toJSON(message.note);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateNoteRequest>): CreateNoteRequest {
    return CreateNoteRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateNoteRequest>): CreateNoteRequest {
    const message = createBaseCreateNoteRequest();
    message.parent = object.parent ?? "";
    message.noteId = object.noteId ?? "";
    message.note = (object.note !== undefined && object.note !== null) ? Note.fromPartial(object.note) : undefined;
    return message;
  },
};

function createBaseUpdateNoteRequest(): UpdateNoteRequest {
  return { name: "", note: undefined, updateMask: undefined };
}

export const UpdateNoteRequest: MessageFns<UpdateNoteRequest> = {
  encode(message: UpdateNoteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.note !== undefined) {
      Note.encode(message.note, writer.uint32(18).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateNoteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateNoteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.note = Note.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateNoteRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      note: isSet(object.note) ? Note.fromJSON(object.note) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateNoteRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.note !== undefined) {
      obj.note = Note.toJSON(message.note);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateNoteRequest>): UpdateNoteRequest {
    return UpdateNoteRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateNoteRequest>): UpdateNoteRequest {
    const message = createBaseUpdateNoteRequest();
    message.name = object.name ?? "";
    message.note = (object.note !== undefined && object.note !== null) ? Note.fromPartial(object.note) : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseListNoteOccurrencesRequest(): ListNoteOccurrencesRequest {
  return { name: "", filter: "", pageSize: 0, pageToken: "" };
}

export const ListNoteOccurrencesRequest: MessageFns<ListNoteOccurrencesRequest> = {
  encode(message: ListNoteOccurrencesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.filter !== "") {
      writer.uint32(18).string(message.filter);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNoteOccurrencesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNoteOccurrencesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNoteOccurrencesRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListNoteOccurrencesRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListNoteOccurrencesRequest>): ListNoteOccurrencesRequest {
    return ListNoteOccurrencesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListNoteOccurrencesRequest>): ListNoteOccurrencesRequest {
    const message = createBaseListNoteOccurrencesRequest();
    message.name = object.name ?? "";
    message.filter = object.filter ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListNoteOccurrencesResponse(): ListNoteOccurrencesResponse {
  return { occurrences: [], nextPageToken: "" };
}

export const ListNoteOccurrencesResponse: MessageFns<ListNoteOccurrencesResponse> = {
  encode(message: ListNoteOccurrencesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.occurrences) {
      Occurrence.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNoteOccurrencesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNoteOccurrencesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.occurrences.push(Occurrence.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNoteOccurrencesResponse {
    return {
      occurrences: globalThis.Array.isArray(object?.occurrences)
        ? object.occurrences.map((e: any) => Occurrence.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListNoteOccurrencesResponse): unknown {
    const obj: any = {};
    if (message.occurrences?.length) {
      obj.occurrences = message.occurrences.map((e) => Occurrence.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListNoteOccurrencesResponse>): ListNoteOccurrencesResponse {
    return ListNoteOccurrencesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListNoteOccurrencesResponse>): ListNoteOccurrencesResponse {
    const message = createBaseListNoteOccurrencesResponse();
    message.occurrences = object.occurrences?.map((e) => Occurrence.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseBatchCreateNotesRequest(): BatchCreateNotesRequest {
  return { parent: "", notes: {} };
}

export const BatchCreateNotesRequest: MessageFns<BatchCreateNotesRequest> = {
  encode(message: BatchCreateNotesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    Object.entries(message.notes).forEach(([key, value]) => {
      BatchCreateNotesRequest_NotesEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchCreateNotesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchCreateNotesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = BatchCreateNotesRequest_NotesEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.notes[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchCreateNotesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      notes: isObject(object.notes)
        ? Object.entries(object.notes).reduce<{ [key: string]: Note }>((acc, [key, value]) => {
          acc[key] = Note.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: BatchCreateNotesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.notes) {
      const entries = Object.entries(message.notes);
      if (entries.length > 0) {
        obj.notes = {};
        entries.forEach(([k, v]) => {
          obj.notes[k] = Note.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<BatchCreateNotesRequest>): BatchCreateNotesRequest {
    return BatchCreateNotesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchCreateNotesRequest>): BatchCreateNotesRequest {
    const message = createBaseBatchCreateNotesRequest();
    message.parent = object.parent ?? "";
    message.notes = Object.entries(object.notes ?? {}).reduce<{ [key: string]: Note }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Note.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseBatchCreateNotesRequest_NotesEntry(): BatchCreateNotesRequest_NotesEntry {
  return { key: "", value: undefined };
}

export const BatchCreateNotesRequest_NotesEntry: MessageFns<BatchCreateNotesRequest_NotesEntry> = {
  encode(message: BatchCreateNotesRequest_NotesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Note.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchCreateNotesRequest_NotesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchCreateNotesRequest_NotesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Note.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchCreateNotesRequest_NotesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Note.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: BatchCreateNotesRequest_NotesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Note.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<BatchCreateNotesRequest_NotesEntry>): BatchCreateNotesRequest_NotesEntry {
    return BatchCreateNotesRequest_NotesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchCreateNotesRequest_NotesEntry>): BatchCreateNotesRequest_NotesEntry {
    const message = createBaseBatchCreateNotesRequest_NotesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Note.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseBatchCreateNotesResponse(): BatchCreateNotesResponse {
  return { notes: [] };
}

export const BatchCreateNotesResponse: MessageFns<BatchCreateNotesResponse> = {
  encode(message: BatchCreateNotesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.notes) {
      Note.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchCreateNotesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchCreateNotesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.notes.push(Note.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchCreateNotesResponse {
    return { notes: globalThis.Array.isArray(object?.notes) ? object.notes.map((e: any) => Note.fromJSON(e)) : [] };
  },

  toJSON(message: BatchCreateNotesResponse): unknown {
    const obj: any = {};
    if (message.notes?.length) {
      obj.notes = message.notes.map((e) => Note.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchCreateNotesResponse>): BatchCreateNotesResponse {
    return BatchCreateNotesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchCreateNotesResponse>): BatchCreateNotesResponse {
    const message = createBaseBatchCreateNotesResponse();
    message.notes = object.notes?.map((e) => Note.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBatchCreateOccurrencesRequest(): BatchCreateOccurrencesRequest {
  return { parent: "", occurrences: [] };
}

export const BatchCreateOccurrencesRequest: MessageFns<BatchCreateOccurrencesRequest> = {
  encode(message: BatchCreateOccurrencesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    for (const v of message.occurrences) {
      Occurrence.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchCreateOccurrencesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchCreateOccurrencesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.occurrences.push(Occurrence.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchCreateOccurrencesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      occurrences: globalThis.Array.isArray(object?.occurrences)
        ? object.occurrences.map((e: any) => Occurrence.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchCreateOccurrencesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.occurrences?.length) {
      obj.occurrences = message.occurrences.map((e) => Occurrence.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchCreateOccurrencesRequest>): BatchCreateOccurrencesRequest {
    return BatchCreateOccurrencesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchCreateOccurrencesRequest>): BatchCreateOccurrencesRequest {
    const message = createBaseBatchCreateOccurrencesRequest();
    message.parent = object.parent ?? "";
    message.occurrences = object.occurrences?.map((e) => Occurrence.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBatchCreateOccurrencesResponse(): BatchCreateOccurrencesResponse {
  return { occurrences: [] };
}

export const BatchCreateOccurrencesResponse: MessageFns<BatchCreateOccurrencesResponse> = {
  encode(message: BatchCreateOccurrencesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.occurrences) {
      Occurrence.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchCreateOccurrencesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchCreateOccurrencesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.occurrences.push(Occurrence.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchCreateOccurrencesResponse {
    return {
      occurrences: globalThis.Array.isArray(object?.occurrences)
        ? object.occurrences.map((e: any) => Occurrence.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchCreateOccurrencesResponse): unknown {
    const obj: any = {};
    if (message.occurrences?.length) {
      obj.occurrences = message.occurrences.map((e) => Occurrence.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchCreateOccurrencesResponse>): BatchCreateOccurrencesResponse {
    return BatchCreateOccurrencesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchCreateOccurrencesResponse>): BatchCreateOccurrencesResponse {
    const message = createBaseBatchCreateOccurrencesResponse();
    message.occurrences = object.occurrences?.map((e) => Occurrence.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetVulnerabilityOccurrencesSummaryRequest(): GetVulnerabilityOccurrencesSummaryRequest {
  return { parent: "", filter: "" };
}

export const GetVulnerabilityOccurrencesSummaryRequest: MessageFns<GetVulnerabilityOccurrencesSummaryRequest> = {
  encode(message: GetVulnerabilityOccurrencesSummaryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.filter !== "") {
      writer.uint32(18).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetVulnerabilityOccurrencesSummaryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetVulnerabilityOccurrencesSummaryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetVulnerabilityOccurrencesSummaryRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: GetVulnerabilityOccurrencesSummaryRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<GetVulnerabilityOccurrencesSummaryRequest>): GetVulnerabilityOccurrencesSummaryRequest {
    return GetVulnerabilityOccurrencesSummaryRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetVulnerabilityOccurrencesSummaryRequest>,
  ): GetVulnerabilityOccurrencesSummaryRequest {
    const message = createBaseGetVulnerabilityOccurrencesSummaryRequest();
    message.parent = object.parent ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseVulnerabilityOccurrencesSummary(): VulnerabilityOccurrencesSummary {
  return { counts: [] };
}

export const VulnerabilityOccurrencesSummary: MessageFns<VulnerabilityOccurrencesSummary> = {
  encode(message: VulnerabilityOccurrencesSummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.counts) {
      VulnerabilityOccurrencesSummary_FixableTotalByDigest.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VulnerabilityOccurrencesSummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVulnerabilityOccurrencesSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.counts.push(VulnerabilityOccurrencesSummary_FixableTotalByDigest.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VulnerabilityOccurrencesSummary {
    return {
      counts: globalThis.Array.isArray(object?.counts)
        ? object.counts.map((e: any) => VulnerabilityOccurrencesSummary_FixableTotalByDigest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: VulnerabilityOccurrencesSummary): unknown {
    const obj: any = {};
    if (message.counts?.length) {
      obj.counts = message.counts.map((e) => VulnerabilityOccurrencesSummary_FixableTotalByDigest.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<VulnerabilityOccurrencesSummary>): VulnerabilityOccurrencesSummary {
    return VulnerabilityOccurrencesSummary.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VulnerabilityOccurrencesSummary>): VulnerabilityOccurrencesSummary {
    const message = createBaseVulnerabilityOccurrencesSummary();
    message.counts = object.counts?.map((e) => VulnerabilityOccurrencesSummary_FixableTotalByDigest.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseVulnerabilityOccurrencesSummary_FixableTotalByDigest(): VulnerabilityOccurrencesSummary_FixableTotalByDigest {
  return { resource: undefined, severity: 0, fixableCount: Long.ZERO, totalCount: Long.ZERO };
}

export const VulnerabilityOccurrencesSummary_FixableTotalByDigest: MessageFns<
  VulnerabilityOccurrencesSummary_FixableTotalByDigest
> = {
  encode(
    message: VulnerabilityOccurrencesSummary_FixableTotalByDigest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.resource !== undefined) {
      Resource.encode(message.resource, writer.uint32(10).fork()).join();
    }
    if (message.severity !== 0) {
      writer.uint32(16).int32(message.severity);
    }
    if (!message.fixableCount.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.fixableCount.toString());
    }
    if (!message.totalCount.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.totalCount.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VulnerabilityOccurrencesSummary_FixableTotalByDigest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVulnerabilityOccurrencesSummary_FixableTotalByDigest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resource = Resource.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.severity = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.fixableCount = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.totalCount = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VulnerabilityOccurrencesSummary_FixableTotalByDigest {
    return {
      resource: isSet(object.resource) ? Resource.fromJSON(object.resource) : undefined,
      severity: isSet(object.severity) ? severityFromJSON(object.severity) : 0,
      fixableCount: isSet(object.fixableCount) ? Long.fromValue(object.fixableCount) : Long.ZERO,
      totalCount: isSet(object.totalCount) ? Long.fromValue(object.totalCount) : Long.ZERO,
    };
  },

  toJSON(message: VulnerabilityOccurrencesSummary_FixableTotalByDigest): unknown {
    const obj: any = {};
    if (message.resource !== undefined) {
      obj.resource = Resource.toJSON(message.resource);
    }
    if (message.severity !== 0) {
      obj.severity = severityToJSON(message.severity);
    }
    if (!message.fixableCount.equals(Long.ZERO)) {
      obj.fixableCount = (message.fixableCount || Long.ZERO).toString();
    }
    if (!message.totalCount.equals(Long.ZERO)) {
      obj.totalCount = (message.totalCount || Long.ZERO).toString();
    }
    return obj;
  },

  create(
    base?: DeepPartial<VulnerabilityOccurrencesSummary_FixableTotalByDigest>,
  ): VulnerabilityOccurrencesSummary_FixableTotalByDigest {
    return VulnerabilityOccurrencesSummary_FixableTotalByDigest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<VulnerabilityOccurrencesSummary_FixableTotalByDigest>,
  ): VulnerabilityOccurrencesSummary_FixableTotalByDigest {
    const message = createBaseVulnerabilityOccurrencesSummary_FixableTotalByDigest();
    message.resource = (object.resource !== undefined && object.resource !== null)
      ? Resource.fromPartial(object.resource)
      : undefined;
    message.severity = object.severity ?? 0;
    message.fixableCount = (object.fixableCount !== undefined && object.fixableCount !== null)
      ? Long.fromValue(object.fixableCount)
      : Long.ZERO;
    message.totalCount = (object.totalCount !== undefined && object.totalCount !== null)
      ? Long.fromValue(object.totalCount)
      : Long.ZERO;
    return message;
  },
};

/**
 * [Grafeas](grafeas.io) API.
 *
 * Retrieves analysis results of Cloud components such as Docker container
 * images.
 *
 * Analysis results are stored as a series of occurrences. An `Occurrence`
 * contains information about a specific analysis instance on a resource. An
 * occurrence refers to a `Note`. A note contains details describing the
 * analysis and is generally stored in a separate project, called a `Provider`.
 * Multiple occurrences can refer to the same note.
 *
 * For example, an SSL vulnerability could affect multiple images. In this case,
 * there would be one note for the vulnerability and an occurrence for each
 * image with the vulnerability referring to that note.
 */
export type GrafeasV1Beta1Definition = typeof GrafeasV1Beta1Definition;
export const GrafeasV1Beta1Definition = {
  name: "GrafeasV1Beta1",
  fullName: "grafeas.v1beta1.GrafeasV1Beta1",
  methods: {
    /** Gets the specified occurrence. */
    getOccurrence: {
      name: "GetOccurrence",
      requestType: GetOccurrenceRequest,
      requestStream: false,
      responseType: Occurrence,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              42,
              18,
              40,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              111,
              99,
              99,
              117,
              114,
              114,
              101,
              110,
              99,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists occurrences for the specified project. */
    listOccurrences: {
      name: "ListOccurrences",
      requestType: ListOccurrencesRequest,
      requestStream: false,
      responseType: ListOccurrencesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              42,
              18,
              40,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              111,
              99,
              99,
              117,
              114,
              114,
              101,
              110,
              99,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes the specified occurrence. For example, use this method to delete an
     * occurrence when the occurrence is no longer applicable for the given
     * resource.
     */
    deleteOccurrence: {
      name: "DeleteOccurrence",
      requestType: DeleteOccurrenceRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              42,
              42,
              40,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              111,
              99,
              99,
              117,
              114,
              114,
              101,
              110,
              99,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a new occurrence. */
    createOccurrence: {
      name: "CreateOccurrence",
      requestType: CreateOccurrenceRequest,
      requestStream: false,
      responseType: Occurrence,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              54,
              58,
              10,
              111,
              99,
              99,
              117,
              114,
              114,
              101,
              110,
              99,
              101,
              34,
              40,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              111,
              99,
              99,
              117,
              114,
              114,
              101,
              110,
              99,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Creates new occurrences in batch. */
    batchCreateOccurrences: {
      name: "BatchCreateOccurrences",
      requestType: BatchCreateOccurrencesRequest,
      requestStream: false,
      responseType: BatchCreateOccurrencesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              57,
              58,
              1,
              42,
              34,
              52,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              111,
              99,
              99,
              117,
              114,
              114,
              101,
              110,
              99,
              101,
              115,
              58,
              98,
              97,
              116,
              99,
              104,
              67,
              114,
              101,
              97,
              116,
              101,
            ]),
          ],
        },
      },
    },
    /** Updates the specified occurrence. */
    updateOccurrence: {
      name: "UpdateOccurrence",
      requestType: UpdateOccurrenceRequest,
      requestStream: false,
      responseType: Occurrence,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              54,
              58,
              10,
              111,
              99,
              99,
              117,
              114,
              114,
              101,
              110,
              99,
              101,
              50,
              40,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              111,
              99,
              99,
              117,
              114,
              114,
              101,
              110,
              99,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Gets the note attached to the specified occurrence. Consumer projects can
     * use this method to get a note that belongs to a provider project.
     */
    getOccurrenceNote: {
      name: "GetOccurrenceNote",
      requestType: GetOccurrenceNoteRequest,
      requestStream: false,
      responseType: Note,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              48,
              18,
              46,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              111,
              99,
              99,
              117,
              114,
              114,
              101,
              110,
              99,
              101,
              115,
              47,
              42,
              125,
              47,
              110,
              111,
              116,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets the specified note. */
    getNote: {
      name: "GetNote",
      requestType: GetNoteRequest,
      requestStream: false,
      responseType: Note,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              36,
              18,
              34,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              110,
              111,
              116,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists notes for the specified project. */
    listNotes: {
      name: "ListNotes",
      requestType: ListNotesRequest,
      requestStream: false,
      responseType: ListNotesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              36,
              18,
              34,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              110,
              111,
              116,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Deletes the specified note. */
    deleteNote: {
      name: "DeleteNote",
      requestType: DeleteNoteRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              36,
              42,
              34,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              110,
              111,
              116,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a new note. */
    createNote: {
      name: "CreateNote",
      requestType: CreateNoteRequest,
      requestStream: false,
      responseType: Note,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              42,
              58,
              4,
              110,
              111,
              116,
              101,
              34,
              34,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              110,
              111,
              116,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Creates new notes in batch. */
    batchCreateNotes: {
      name: "BatchCreateNotes",
      requestType: BatchCreateNotesRequest,
      requestStream: false,
      responseType: BatchCreateNotesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              51,
              58,
              1,
              42,
              34,
              46,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              110,
              111,
              116,
              101,
              115,
              58,
              98,
              97,
              116,
              99,
              104,
              67,
              114,
              101,
              97,
              116,
              101,
            ]),
          ],
        },
      },
    },
    /** Updates the specified note. */
    updateNote: {
      name: "UpdateNote",
      requestType: UpdateNoteRequest,
      requestStream: false,
      responseType: Note,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              42,
              58,
              4,
              110,
              111,
              116,
              101,
              50,
              34,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              110,
              111,
              116,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Lists occurrences referencing the specified note. Provider projects can use
     * this method to get all occurrences across consumer projects referencing the
     * specified note.
     */
    listNoteOccurrences: {
      name: "ListNoteOccurrences",
      requestType: ListNoteOccurrencesRequest,
      requestStream: false,
      responseType: ListNoteOccurrencesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              48,
              18,
              46,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              110,
              111,
              116,
              101,
              115,
              47,
              42,
              125,
              47,
              111,
              99,
              99,
              117,
              114,
              114,
              101,
              110,
              99,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets a summary of the number and severity of occurrences. */
    getVulnerabilityOccurrencesSummary: {
      name: "GetVulnerabilityOccurrencesSummary",
      requestType: GetVulnerabilityOccurrencesSummaryRequest,
      requestStream: false,
      responseType: VulnerabilityOccurrencesSummary,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              63,
              18,
              61,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              111,
              99,
              99,
              117,
              114,
              114,
              101,
              110,
              99,
              101,
              115,
              58,
              118,
              117,
              108,
              110,
              101,
              114,
              97,
              98,
              105,
              108,
              105,
              116,
              121,
              83,
              117,
              109,
              109,
              97,
              114,
              121,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface GrafeasV1Beta1ServiceImplementation<CallContextExt = {}> {
  /** Gets the specified occurrence. */
  getOccurrence(request: GetOccurrenceRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Occurrence>>;
  /** Lists occurrences for the specified project. */
  listOccurrences(
    request: ListOccurrencesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListOccurrencesResponse>>;
  /**
   * Deletes the specified occurrence. For example, use this method to delete an
   * occurrence when the occurrence is no longer applicable for the given
   * resource.
   */
  deleteOccurrence(
    request: DeleteOccurrenceRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** Creates a new occurrence. */
  createOccurrence(
    request: CreateOccurrenceRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Occurrence>>;
  /** Creates new occurrences in batch. */
  batchCreateOccurrences(
    request: BatchCreateOccurrencesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<BatchCreateOccurrencesResponse>>;
  /** Updates the specified occurrence. */
  updateOccurrence(
    request: UpdateOccurrenceRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Occurrence>>;
  /**
   * Gets the note attached to the specified occurrence. Consumer projects can
   * use this method to get a note that belongs to a provider project.
   */
  getOccurrenceNote(
    request: GetOccurrenceNoteRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Note>>;
  /** Gets the specified note. */
  getNote(request: GetNoteRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Note>>;
  /** Lists notes for the specified project. */
  listNotes(request: ListNotesRequest, context: CallContext & CallContextExt): Promise<DeepPartial<ListNotesResponse>>;
  /** Deletes the specified note. */
  deleteNote(request: DeleteNoteRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** Creates a new note. */
  createNote(request: CreateNoteRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Note>>;
  /** Creates new notes in batch. */
  batchCreateNotes(
    request: BatchCreateNotesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<BatchCreateNotesResponse>>;
  /** Updates the specified note. */
  updateNote(request: UpdateNoteRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Note>>;
  /**
   * Lists occurrences referencing the specified note. Provider projects can use
   * this method to get all occurrences across consumer projects referencing the
   * specified note.
   */
  listNoteOccurrences(
    request: ListNoteOccurrencesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListNoteOccurrencesResponse>>;
  /** Gets a summary of the number and severity of occurrences. */
  getVulnerabilityOccurrencesSummary(
    request: GetVulnerabilityOccurrencesSummaryRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<VulnerabilityOccurrencesSummary>>;
}

export interface GrafeasV1Beta1Client<CallOptionsExt = {}> {
  /** Gets the specified occurrence. */
  getOccurrence(
    request: DeepPartial<GetOccurrenceRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Occurrence>;
  /** Lists occurrences for the specified project. */
  listOccurrences(
    request: DeepPartial<ListOccurrencesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListOccurrencesResponse>;
  /**
   * Deletes the specified occurrence. For example, use this method to delete an
   * occurrence when the occurrence is no longer applicable for the given
   * resource.
   */
  deleteOccurrence(
    request: DeepPartial<DeleteOccurrenceRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** Creates a new occurrence. */
  createOccurrence(
    request: DeepPartial<CreateOccurrenceRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Occurrence>;
  /** Creates new occurrences in batch. */
  batchCreateOccurrences(
    request: DeepPartial<BatchCreateOccurrencesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<BatchCreateOccurrencesResponse>;
  /** Updates the specified occurrence. */
  updateOccurrence(
    request: DeepPartial<UpdateOccurrenceRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Occurrence>;
  /**
   * Gets the note attached to the specified occurrence. Consumer projects can
   * use this method to get a note that belongs to a provider project.
   */
  getOccurrenceNote(
    request: DeepPartial<GetOccurrenceNoteRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Note>;
  /** Gets the specified note. */
  getNote(request: DeepPartial<GetNoteRequest>, options?: CallOptions & CallOptionsExt): Promise<Note>;
  /** Lists notes for the specified project. */
  listNotes(request: DeepPartial<ListNotesRequest>, options?: CallOptions & CallOptionsExt): Promise<ListNotesResponse>;
  /** Deletes the specified note. */
  deleteNote(request: DeepPartial<DeleteNoteRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** Creates a new note. */
  createNote(request: DeepPartial<CreateNoteRequest>, options?: CallOptions & CallOptionsExt): Promise<Note>;
  /** Creates new notes in batch. */
  batchCreateNotes(
    request: DeepPartial<BatchCreateNotesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<BatchCreateNotesResponse>;
  /** Updates the specified note. */
  updateNote(request: DeepPartial<UpdateNoteRequest>, options?: CallOptions & CallOptionsExt): Promise<Note>;
  /**
   * Lists occurrences referencing the specified note. Provider projects can use
   * this method to get all occurrences across consumer projects referencing the
   * specified note.
   */
  listNoteOccurrences(
    request: DeepPartial<ListNoteOccurrencesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListNoteOccurrencesResponse>;
  /** Gets a summary of the number and severity of occurrences. */
  getVulnerabilityOccurrencesSummary(
    request: DeepPartial<GetVulnerabilityOccurrencesSummaryRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<VulnerabilityOccurrencesSummary>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
