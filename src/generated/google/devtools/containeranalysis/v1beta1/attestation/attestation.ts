// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/devtools/containeranalysis/v1beta1/attestation/attestation.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Signature } from "../common/common.js";

export const protobufPackage = "grafeas.v1beta1.attestation";

/**
 * An attestation wrapper with a PGP-compatible signature. This message only
 * supports `ATTACHED` signatures, where the payload that is signed is included
 * alongside the signature itself in the same file.
 */
export interface PgpSignedAttestation {
  /**
   * Required. The raw content of the signature, as output by GNU Privacy Guard
   * (GPG) or equivalent. Since this message only supports attached signatures,
   * the payload that was signed must be attached. While the signature format
   * supported is dependent on the verification implementation, currently only
   * ASCII-armored (`--armor` to gpg), non-clearsigned (`--sign` rather than
   * `--clearsign` to gpg) are supported. Concretely, `gpg --sign --armor
   * --output=signature.gpg payload.json` will create the signature content
   * expected in this field in `signature.gpg` for the `payload.json`
   * attestation payload.
   */
  signature: string;
  /**
   * Type (for example schema) of the attestation payload that was signed.
   * The verifier must ensure that the provided type is one that the verifier
   * supports, and that the attestation payload is a valid instantiation of that
   * type (for example by validating a JSON schema).
   */
  contentType: PgpSignedAttestation_ContentType;
  /**
   * The cryptographic fingerprint of the key used to generate the signature,
   * as output by, e.g. `gpg --list-keys`. This should be the version 4, full
   * 160-bit fingerprint, expressed as a 40 character hexidecimal string. See
   * https://tools.ietf.org/html/rfc4880#section-12.2 for details.
   * Implementations may choose to acknowledge "LONG", "SHORT", or other
   * abbreviated key IDs, but only the full fingerprint is guaranteed to work.
   * In gpg, the full fingerprint can be retrieved from the `fpr` field
   * returned when calling --list-keys with --with-colons.  For example:
   * ```
   * gpg --with-colons --with-fingerprint --force-v4-certs \
   *     --list-keys attester@example.com
   * tru::1:1513631572:0:3:1:5
   * pub:...<SNIP>...
   * fpr:::::::::24FF6481B76AC91E66A00AC657A93A81EF3AE6FB:
   * ```
   * Above, the fingerprint is `24FF6481B76AC91E66A00AC657A93A81EF3AE6FB`.
   */
  pgpKeyId?: string | undefined;
}

/** Type (for example schema) of the attestation payload that was signed. */
export enum PgpSignedAttestation_ContentType {
  /** CONTENT_TYPE_UNSPECIFIED - `ContentType` is not set. */
  CONTENT_TYPE_UNSPECIFIED = 0,
  /**
   * SIMPLE_SIGNING_JSON - Atomic format attestation signature. See
   * https://github.com/containers/image/blob/8a5d2f82a6e3263290c8e0276c3e0f64e77723e7/docs/atomic-signature.md
   * The payload extracted from `signature` is a JSON blob conforming to the
   * linked schema.
   */
  SIMPLE_SIGNING_JSON = 1,
  UNRECOGNIZED = -1,
}

export function pgpSignedAttestation_ContentTypeFromJSON(object: any): PgpSignedAttestation_ContentType {
  switch (object) {
    case 0:
    case "CONTENT_TYPE_UNSPECIFIED":
      return PgpSignedAttestation_ContentType.CONTENT_TYPE_UNSPECIFIED;
    case 1:
    case "SIMPLE_SIGNING_JSON":
      return PgpSignedAttestation_ContentType.SIMPLE_SIGNING_JSON;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PgpSignedAttestation_ContentType.UNRECOGNIZED;
  }
}

export function pgpSignedAttestation_ContentTypeToJSON(object: PgpSignedAttestation_ContentType): string {
  switch (object) {
    case PgpSignedAttestation_ContentType.CONTENT_TYPE_UNSPECIFIED:
      return "CONTENT_TYPE_UNSPECIFIED";
    case PgpSignedAttestation_ContentType.SIMPLE_SIGNING_JSON:
      return "SIMPLE_SIGNING_JSON";
    case PgpSignedAttestation_ContentType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * An attestation wrapper that uses the Grafeas `Signature` message.
 * This attestation must define the `serialized_payload` that the `signatures`
 * verify and any metadata necessary to interpret that plaintext.  The
 * signatures should always be over the `serialized_payload` bytestring.
 */
export interface GenericSignedAttestation {
  /**
   * Type (for example schema) of the attestation payload that was signed.
   * The verifier must ensure that the provided type is one that the verifier
   * supports, and that the attestation payload is a valid instantiation of that
   * type (for example by validating a JSON schema).
   */
  contentType: GenericSignedAttestation_ContentType;
  /**
   * The serialized payload that is verified by one or more `signatures`.
   * The encoding and semantic meaning of this payload must match what is set in
   * `content_type`.
   */
  serializedPayload: Buffer;
  /**
   * One or more signatures over `serialized_payload`.  Verifier implementations
   * should consider this attestation message verified if at least one
   * `signature` verifies `serialized_payload`.  See `Signature` in common.proto
   * for more details on signature structure and verification.
   */
  signatures: Signature[];
}

/** Type of the attestation plaintext that was signed. */
export enum GenericSignedAttestation_ContentType {
  /** CONTENT_TYPE_UNSPECIFIED - `ContentType` is not set. */
  CONTENT_TYPE_UNSPECIFIED = 0,
  /**
   * SIMPLE_SIGNING_JSON - Atomic format attestation signature. See
   * https://github.com/containers/image/blob/8a5d2f82a6e3263290c8e0276c3e0f64e77723e7/docs/atomic-signature.md
   * The payload extracted in `plaintext` is a JSON blob conforming to the
   * linked schema.
   */
  SIMPLE_SIGNING_JSON = 1,
  UNRECOGNIZED = -1,
}

export function genericSignedAttestation_ContentTypeFromJSON(object: any): GenericSignedAttestation_ContentType {
  switch (object) {
    case 0:
    case "CONTENT_TYPE_UNSPECIFIED":
      return GenericSignedAttestation_ContentType.CONTENT_TYPE_UNSPECIFIED;
    case 1:
    case "SIMPLE_SIGNING_JSON":
      return GenericSignedAttestation_ContentType.SIMPLE_SIGNING_JSON;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GenericSignedAttestation_ContentType.UNRECOGNIZED;
  }
}

export function genericSignedAttestation_ContentTypeToJSON(object: GenericSignedAttestation_ContentType): string {
  switch (object) {
    case GenericSignedAttestation_ContentType.CONTENT_TYPE_UNSPECIFIED:
      return "CONTENT_TYPE_UNSPECIFIED";
    case GenericSignedAttestation_ContentType.SIMPLE_SIGNING_JSON:
      return "SIMPLE_SIGNING_JSON";
    case GenericSignedAttestation_ContentType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Note kind that represents a logical attestation "role" or "authority". For
 * example, an organization might have one `Authority` for "QA" and one for
 * "build". This note is intended to act strictly as a grouping mechanism for
 * the attached occurrences (Attestations). This grouping mechanism also
 * provides a security boundary, since IAM ACLs gate the ability for a principle
 * to attach an occurrence to a given note. It also provides a single point of
 * lookup to find all attached attestation occurrences, even if they don't all
 * live in the same project.
 */
export interface Authority {
  /** Hint hints at the purpose of the attestation authority. */
  hint: Authority_Hint | undefined;
}

/**
 * This submessage provides human-readable hints about the purpose of the
 * authority. Because the name of a note acts as its resource reference, it is
 * important to disambiguate the canonical name of the Note (which might be a
 * UUID for security purposes) from "readable" names more suitable for debug
 * output. Note that these hints should not be used to look up authorities in
 * security sensitive contexts, such as when looking up attestations to
 * verify.
 */
export interface Authority_Hint {
  /**
   * Required. The human readable name of this attestation authority, for
   * example "qa".
   */
  humanReadableName: string;
}

/** Details of an attestation occurrence. */
export interface Details {
  /** Required. Attestation for the resource. */
  attestation: Attestation | undefined;
}

/**
 * Occurrence that represents a single "attestation". The authenticity of an
 * attestation can be verified using the attached signature. If the verifier
 * trusts the public key of the signer, then verifying the signature is
 * sufficient to establish trust. In this circumstance, the authority to which
 * this attestation is attached is primarily useful for look-up (how to find
 * this attestation if you already know the authority and artifact to be
 * verified) and intent (which authority was this attestation intended to sign
 * for).
 */
export interface Attestation {
  /** A PGP signed attestation. */
  pgpSignedAttestation?: PgpSignedAttestation | undefined;
  genericSignedAttestation?: GenericSignedAttestation | undefined;
}

function createBasePgpSignedAttestation(): PgpSignedAttestation {
  return { signature: "", contentType: 0, pgpKeyId: undefined };
}

export const PgpSignedAttestation: MessageFns<PgpSignedAttestation> = {
  encode(message: PgpSignedAttestation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signature !== "") {
      writer.uint32(10).string(message.signature);
    }
    if (message.contentType !== 0) {
      writer.uint32(24).int32(message.contentType);
    }
    if (message.pgpKeyId !== undefined) {
      writer.uint32(18).string(message.pgpKeyId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PgpSignedAttestation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePgpSignedAttestation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.signature = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.contentType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pgpKeyId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PgpSignedAttestation {
    return {
      signature: isSet(object.signature) ? globalThis.String(object.signature) : "",
      contentType: isSet(object.contentType) ? pgpSignedAttestation_ContentTypeFromJSON(object.contentType) : 0,
      pgpKeyId: isSet(object.pgpKeyId) ? globalThis.String(object.pgpKeyId) : undefined,
    };
  },

  toJSON(message: PgpSignedAttestation): unknown {
    const obj: any = {};
    if (message.signature !== "") {
      obj.signature = message.signature;
    }
    if (message.contentType !== 0) {
      obj.contentType = pgpSignedAttestation_ContentTypeToJSON(message.contentType);
    }
    if (message.pgpKeyId !== undefined) {
      obj.pgpKeyId = message.pgpKeyId;
    }
    return obj;
  },

  create(base?: DeepPartial<PgpSignedAttestation>): PgpSignedAttestation {
    return PgpSignedAttestation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PgpSignedAttestation>): PgpSignedAttestation {
    const message = createBasePgpSignedAttestation();
    message.signature = object.signature ?? "";
    message.contentType = object.contentType ?? 0;
    message.pgpKeyId = object.pgpKeyId ?? undefined;
    return message;
  },
};

function createBaseGenericSignedAttestation(): GenericSignedAttestation {
  return { contentType: 0, serializedPayload: Buffer.alloc(0), signatures: [] };
}

export const GenericSignedAttestation: MessageFns<GenericSignedAttestation> = {
  encode(message: GenericSignedAttestation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contentType !== 0) {
      writer.uint32(8).int32(message.contentType);
    }
    if (message.serializedPayload.length !== 0) {
      writer.uint32(18).bytes(message.serializedPayload);
    }
    for (const v of message.signatures) {
      Signature.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenericSignedAttestation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenericSignedAttestation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.contentType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.serializedPayload = Buffer.from(reader.bytes());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.signatures.push(Signature.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenericSignedAttestation {
    return {
      contentType: isSet(object.contentType) ? genericSignedAttestation_ContentTypeFromJSON(object.contentType) : 0,
      serializedPayload: isSet(object.serializedPayload)
        ? Buffer.from(bytesFromBase64(object.serializedPayload))
        : Buffer.alloc(0),
      signatures: globalThis.Array.isArray(object?.signatures)
        ? object.signatures.map((e: any) => Signature.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GenericSignedAttestation): unknown {
    const obj: any = {};
    if (message.contentType !== 0) {
      obj.contentType = genericSignedAttestation_ContentTypeToJSON(message.contentType);
    }
    if (message.serializedPayload.length !== 0) {
      obj.serializedPayload = base64FromBytes(message.serializedPayload);
    }
    if (message.signatures?.length) {
      obj.signatures = message.signatures.map((e) => Signature.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GenericSignedAttestation>): GenericSignedAttestation {
    return GenericSignedAttestation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenericSignedAttestation>): GenericSignedAttestation {
    const message = createBaseGenericSignedAttestation();
    message.contentType = object.contentType ?? 0;
    message.serializedPayload = object.serializedPayload ?? Buffer.alloc(0);
    message.signatures = object.signatures?.map((e) => Signature.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAuthority(): Authority {
  return { hint: undefined };
}

export const Authority: MessageFns<Authority> = {
  encode(message: Authority, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hint !== undefined) {
      Authority_Hint.encode(message.hint, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Authority {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthority();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.hint = Authority_Hint.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Authority {
    return { hint: isSet(object.hint) ? Authority_Hint.fromJSON(object.hint) : undefined };
  },

  toJSON(message: Authority): unknown {
    const obj: any = {};
    if (message.hint !== undefined) {
      obj.hint = Authority_Hint.toJSON(message.hint);
    }
    return obj;
  },

  create(base?: DeepPartial<Authority>): Authority {
    return Authority.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Authority>): Authority {
    const message = createBaseAuthority();
    message.hint = (object.hint !== undefined && object.hint !== null)
      ? Authority_Hint.fromPartial(object.hint)
      : undefined;
    return message;
  },
};

function createBaseAuthority_Hint(): Authority_Hint {
  return { humanReadableName: "" };
}

export const Authority_Hint: MessageFns<Authority_Hint> = {
  encode(message: Authority_Hint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.humanReadableName !== "") {
      writer.uint32(10).string(message.humanReadableName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Authority_Hint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthority_Hint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.humanReadableName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Authority_Hint {
    return { humanReadableName: isSet(object.humanReadableName) ? globalThis.String(object.humanReadableName) : "" };
  },

  toJSON(message: Authority_Hint): unknown {
    const obj: any = {};
    if (message.humanReadableName !== "") {
      obj.humanReadableName = message.humanReadableName;
    }
    return obj;
  },

  create(base?: DeepPartial<Authority_Hint>): Authority_Hint {
    return Authority_Hint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Authority_Hint>): Authority_Hint {
    const message = createBaseAuthority_Hint();
    message.humanReadableName = object.humanReadableName ?? "";
    return message;
  },
};

function createBaseDetails(): Details {
  return { attestation: undefined };
}

export const Details: MessageFns<Details> = {
  encode(message: Details, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.attestation !== undefined) {
      Attestation.encode(message.attestation, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Details {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.attestation = Attestation.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Details {
    return { attestation: isSet(object.attestation) ? Attestation.fromJSON(object.attestation) : undefined };
  },

  toJSON(message: Details): unknown {
    const obj: any = {};
    if (message.attestation !== undefined) {
      obj.attestation = Attestation.toJSON(message.attestation);
    }
    return obj;
  },

  create(base?: DeepPartial<Details>): Details {
    return Details.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Details>): Details {
    const message = createBaseDetails();
    message.attestation = (object.attestation !== undefined && object.attestation !== null)
      ? Attestation.fromPartial(object.attestation)
      : undefined;
    return message;
  },
};

function createBaseAttestation(): Attestation {
  return { pgpSignedAttestation: undefined, genericSignedAttestation: undefined };
}

export const Attestation: MessageFns<Attestation> = {
  encode(message: Attestation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pgpSignedAttestation !== undefined) {
      PgpSignedAttestation.encode(message.pgpSignedAttestation, writer.uint32(10).fork()).join();
    }
    if (message.genericSignedAttestation !== undefined) {
      GenericSignedAttestation.encode(message.genericSignedAttestation, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Attestation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttestation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pgpSignedAttestation = PgpSignedAttestation.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.genericSignedAttestation = GenericSignedAttestation.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Attestation {
    return {
      pgpSignedAttestation: isSet(object.pgpSignedAttestation)
        ? PgpSignedAttestation.fromJSON(object.pgpSignedAttestation)
        : undefined,
      genericSignedAttestation: isSet(object.genericSignedAttestation)
        ? GenericSignedAttestation.fromJSON(object.genericSignedAttestation)
        : undefined,
    };
  },

  toJSON(message: Attestation): unknown {
    const obj: any = {};
    if (message.pgpSignedAttestation !== undefined) {
      obj.pgpSignedAttestation = PgpSignedAttestation.toJSON(message.pgpSignedAttestation);
    }
    if (message.genericSignedAttestation !== undefined) {
      obj.genericSignedAttestation = GenericSignedAttestation.toJSON(message.genericSignedAttestation);
    }
    return obj;
  },

  create(base?: DeepPartial<Attestation>): Attestation {
    return Attestation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Attestation>): Attestation {
    const message = createBaseAttestation();
    message.pgpSignedAttestation = (object.pgpSignedAttestation !== undefined && object.pgpSignedAttestation !== null)
      ? PgpSignedAttestation.fromPartial(object.pgpSignedAttestation)
      : undefined;
    message.genericSignedAttestation =
      (object.genericSignedAttestation !== undefined && object.genericSignedAttestation !== null)
        ? GenericSignedAttestation.fromPartial(object.genericSignedAttestation)
        : undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
