// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/pubsub/v1/schema.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Empty } from "../../protobuf/empty.js";
import { Timestamp } from "../../protobuf/timestamp.js";

export const protobufPackage = "google.pubsub.v1";

/** View of Schema object fields to be returned by GetSchema and ListSchemas. */
export enum SchemaView {
  /**
   * SCHEMA_VIEW_UNSPECIFIED - The default / unset value.
   * The API will default to the BASIC view.
   */
  SCHEMA_VIEW_UNSPECIFIED = 0,
  /** BASIC - Include the name and type of the schema, but not the definition. */
  BASIC = 1,
  /** FULL - Include all Schema object fields. */
  FULL = 2,
  UNRECOGNIZED = -1,
}

export function schemaViewFromJSON(object: any): SchemaView {
  switch (object) {
    case 0:
    case "SCHEMA_VIEW_UNSPECIFIED":
      return SchemaView.SCHEMA_VIEW_UNSPECIFIED;
    case 1:
    case "BASIC":
      return SchemaView.BASIC;
    case 2:
    case "FULL":
      return SchemaView.FULL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SchemaView.UNRECOGNIZED;
  }
}

export function schemaViewToJSON(object: SchemaView): string {
  switch (object) {
    case SchemaView.SCHEMA_VIEW_UNSPECIFIED:
      return "SCHEMA_VIEW_UNSPECIFIED";
    case SchemaView.BASIC:
      return "BASIC";
    case SchemaView.FULL:
      return "FULL";
    case SchemaView.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Possible encoding types for messages. */
export enum Encoding {
  /** ENCODING_UNSPECIFIED - Unspecified */
  ENCODING_UNSPECIFIED = 0,
  /** JSON - JSON encoding */
  JSON = 1,
  /**
   * BINARY - Binary encoding, as defined by the schema type. For some schema types,
   * binary encoding may not be available.
   */
  BINARY = 2,
  UNRECOGNIZED = -1,
}

export function encodingFromJSON(object: any): Encoding {
  switch (object) {
    case 0:
    case "ENCODING_UNSPECIFIED":
      return Encoding.ENCODING_UNSPECIFIED;
    case 1:
    case "JSON":
      return Encoding.JSON;
    case 2:
    case "BINARY":
      return Encoding.BINARY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Encoding.UNRECOGNIZED;
  }
}

export function encodingToJSON(object: Encoding): string {
  switch (object) {
    case Encoding.ENCODING_UNSPECIFIED:
      return "ENCODING_UNSPECIFIED";
    case Encoding.JSON:
      return "JSON";
    case Encoding.BINARY:
      return "BINARY";
    case Encoding.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A schema resource. */
export interface Schema {
  /**
   * Required. Name of the schema.
   * Format is `projects/{project}/schemas/{schema}`.
   */
  name: string;
  /** The type of the schema definition. */
  type: Schema_Type;
  /**
   * The definition of the schema. This should contain a string representing
   * the full definition of the schema that is a valid schema definition of
   * the type specified in `type`.
   */
  definition: string;
  /** Output only. Immutable. The revision ID of the schema. */
  revisionId: string;
  /** Output only. The timestamp that the revision was created. */
  revisionCreateTime: Date | undefined;
}

/** Possible schema definition types. */
export enum Schema_Type {
  /** TYPE_UNSPECIFIED - Default value. This value is unused. */
  TYPE_UNSPECIFIED = 0,
  /** PROTOCOL_BUFFER - A Protocol Buffer schema definition. */
  PROTOCOL_BUFFER = 1,
  /** AVRO - An Avro schema definition. */
  AVRO = 2,
  UNRECOGNIZED = -1,
}

export function schema_TypeFromJSON(object: any): Schema_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return Schema_Type.TYPE_UNSPECIFIED;
    case 1:
    case "PROTOCOL_BUFFER":
      return Schema_Type.PROTOCOL_BUFFER;
    case 2:
    case "AVRO":
      return Schema_Type.AVRO;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Schema_Type.UNRECOGNIZED;
  }
}

export function schema_TypeToJSON(object: Schema_Type): string {
  switch (object) {
    case Schema_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case Schema_Type.PROTOCOL_BUFFER:
      return "PROTOCOL_BUFFER";
    case Schema_Type.AVRO:
      return "AVRO";
    case Schema_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Request for the CreateSchema method. */
export interface CreateSchemaRequest {
  /**
   * Required. The name of the project in which to create the schema.
   * Format is `projects/{project-id}`.
   */
  parent: string;
  /**
   * Required. The schema object to create.
   *
   * This schema's `name` parameter is ignored. The schema object returned
   * by CreateSchema will have a `name` made using the given `parent` and
   * `schema_id`.
   */
  schema:
    | Schema
    | undefined;
  /**
   * The ID to use for the schema, which will become the final component of
   * the schema's resource name.
   *
   * See https://cloud.google.com/pubsub/docs/pubsub-basics#resource_names for
   * resource name constraints.
   */
  schemaId: string;
}

/** Request for the GetSchema method. */
export interface GetSchemaRequest {
  /**
   * Required. The name of the schema to get.
   * Format is `projects/{project}/schemas/{schema}`.
   */
  name: string;
  /**
   * The set of fields to return in the response. If not set, returns a Schema
   * with all fields filled out. Set to `BASIC` to omit the `definition`.
   */
  view: SchemaView;
}

/** Request for the `ListSchemas` method. */
export interface ListSchemasRequest {
  /**
   * Required. The name of the project in which to list schemas.
   * Format is `projects/{project-id}`.
   */
  parent: string;
  /**
   * The set of Schema fields to return in the response. If not set, returns
   * Schemas with `name` and `type`, but not `definition`. Set to `FULL` to
   * retrieve all fields.
   */
  view: SchemaView;
  /** Maximum number of schemas to return. */
  pageSize: number;
  /**
   * The value returned by the last `ListSchemasResponse`; indicates that
   * this is a continuation of a prior `ListSchemas` call, and that the
   * system should return the next page of data.
   */
  pageToken: string;
}

/** Response for the `ListSchemas` method. */
export interface ListSchemasResponse {
  /** The resulting schemas. */
  schemas: Schema[];
  /**
   * If not empty, indicates that there may be more schemas that match the
   * request; this value should be passed in a new `ListSchemasRequest`.
   */
  nextPageToken: string;
}

/** Request for the `ListSchemaRevisions` method. */
export interface ListSchemaRevisionsRequest {
  /** Required. The name of the schema to list revisions for. */
  name: string;
  /**
   * The set of Schema fields to return in the response. If not set, returns
   * Schemas with `name` and `type`, but not `definition`. Set to `FULL` to
   * retrieve all fields.
   */
  view: SchemaView;
  /** The maximum number of revisions to return per page. */
  pageSize: number;
  /**
   * The page token, received from a previous ListSchemaRevisions call.
   * Provide this to retrieve the subsequent page.
   */
  pageToken: string;
}

/** Response for the `ListSchemaRevisions` method. */
export interface ListSchemaRevisionsResponse {
  /** The revisions of the schema. */
  schemas: Schema[];
  /**
   * A token that can be sent as `page_token` to retrieve the next page.
   * If this field is empty, there are no subsequent pages.
   */
  nextPageToken: string;
}

/** Request for CommitSchema method. */
export interface CommitSchemaRequest {
  /**
   * Required. The name of the schema we are revising.
   * Format is `projects/{project}/schemas/{schema}`.
   */
  name: string;
  /** Required. The schema revision to commit. */
  schema: Schema | undefined;
}

/** Request for the `RollbackSchema` method. */
export interface RollbackSchemaRequest {
  /** Required. The schema being rolled back with revision id. */
  name: string;
  /**
   * Required. The revision ID to roll back to.
   * It must be a revision of the same schema.
   *
   *   Example: c7cfa2a8
   */
  revisionId: string;
}

/** Request for the `DeleteSchemaRevision` method. */
export interface DeleteSchemaRevisionRequest {
  /**
   * Required. The name of the schema revision to be deleted, with a revision ID
   * explicitly included.
   *
   * Example: `projects/123/schemas/my-schema@c7cfa2a8`
   */
  name: string;
  /**
   * Optional. This field is deprecated and should not be used for specifying
   * the revision ID. The revision ID should be specified via the `name`
   * parameter.
   *
   * @deprecated
   */
  revisionId: string;
}

/** Request for the `DeleteSchema` method. */
export interface DeleteSchemaRequest {
  /**
   * Required. Name of the schema to delete.
   * Format is `projects/{project}/schemas/{schema}`.
   */
  name: string;
}

/** Request for the `ValidateSchema` method. */
export interface ValidateSchemaRequest {
  /**
   * Required. The name of the project in which to validate schemas.
   * Format is `projects/{project-id}`.
   */
  parent: string;
  /** Required. The schema object to validate. */
  schema: Schema | undefined;
}

/**
 * Response for the `ValidateSchema` method.
 * Empty for now.
 */
export interface ValidateSchemaResponse {
}

/** Request for the `ValidateMessage` method. */
export interface ValidateMessageRequest {
  /**
   * Required. The name of the project in which to validate schemas.
   * Format is `projects/{project-id}`.
   */
  parent: string;
  /**
   * Name of the schema against which to validate.
   *
   * Format is `projects/{project}/schemas/{schema}`.
   */
  name?:
    | string
    | undefined;
  /** Ad-hoc schema against which to validate */
  schema?:
    | Schema
    | undefined;
  /** Message to validate against the provided `schema_spec`. */
  message: Buffer;
  /** The encoding expected for messages */
  encoding: Encoding;
}

/**
 * Response for the `ValidateMessage` method.
 * Empty for now.
 */
export interface ValidateMessageResponse {
}

function createBaseSchema(): Schema {
  return { name: "", type: 0, definition: "", revisionId: "", revisionCreateTime: undefined };
}

export const Schema: MessageFns<Schema> = {
  encode(message: Schema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.definition !== "") {
      writer.uint32(26).string(message.definition);
    }
    if (message.revisionId !== "") {
      writer.uint32(34).string(message.revisionId);
    }
    if (message.revisionCreateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.revisionCreateTime), writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Schema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.definition = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.revisionId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.revisionCreateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Schema {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? schema_TypeFromJSON(object.type) : 0,
      definition: isSet(object.definition) ? globalThis.String(object.definition) : "",
      revisionId: isSet(object.revisionId) ? globalThis.String(object.revisionId) : "",
      revisionCreateTime: isSet(object.revisionCreateTime) ? fromJsonTimestamp(object.revisionCreateTime) : undefined,
    };
  },

  toJSON(message: Schema): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== 0) {
      obj.type = schema_TypeToJSON(message.type);
    }
    if (message.definition !== "") {
      obj.definition = message.definition;
    }
    if (message.revisionId !== "") {
      obj.revisionId = message.revisionId;
    }
    if (message.revisionCreateTime !== undefined) {
      obj.revisionCreateTime = message.revisionCreateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<Schema>): Schema {
    return Schema.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Schema>): Schema {
    const message = createBaseSchema();
    message.name = object.name ?? "";
    message.type = object.type ?? 0;
    message.definition = object.definition ?? "";
    message.revisionId = object.revisionId ?? "";
    message.revisionCreateTime = object.revisionCreateTime ?? undefined;
    return message;
  },
};

function createBaseCreateSchemaRequest(): CreateSchemaRequest {
  return { parent: "", schema: undefined, schemaId: "" };
}

export const CreateSchemaRequest: MessageFns<CreateSchemaRequest> = {
  encode(message: CreateSchemaRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.schema !== undefined) {
      Schema.encode(message.schema, writer.uint32(18).fork()).join();
    }
    if (message.schemaId !== "") {
      writer.uint32(26).string(message.schemaId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSchemaRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSchemaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.schema = Schema.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.schemaId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSchemaRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      schema: isSet(object.schema) ? Schema.fromJSON(object.schema) : undefined,
      schemaId: isSet(object.schemaId) ? globalThis.String(object.schemaId) : "",
    };
  },

  toJSON(message: CreateSchemaRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.schema !== undefined) {
      obj.schema = Schema.toJSON(message.schema);
    }
    if (message.schemaId !== "") {
      obj.schemaId = message.schemaId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateSchemaRequest>): CreateSchemaRequest {
    return CreateSchemaRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateSchemaRequest>): CreateSchemaRequest {
    const message = createBaseCreateSchemaRequest();
    message.parent = object.parent ?? "";
    message.schema = (object.schema !== undefined && object.schema !== null)
      ? Schema.fromPartial(object.schema)
      : undefined;
    message.schemaId = object.schemaId ?? "";
    return message;
  },
};

function createBaseGetSchemaRequest(): GetSchemaRequest {
  return { name: "", view: 0 };
}

export const GetSchemaRequest: MessageFns<GetSchemaRequest> = {
  encode(message: GetSchemaRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.view !== 0) {
      writer.uint32(16).int32(message.view);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSchemaRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSchemaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSchemaRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      view: isSet(object.view) ? schemaViewFromJSON(object.view) : 0,
    };
  },

  toJSON(message: GetSchemaRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.view !== 0) {
      obj.view = schemaViewToJSON(message.view);
    }
    return obj;
  },

  create(base?: DeepPartial<GetSchemaRequest>): GetSchemaRequest {
    return GetSchemaRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSchemaRequest>): GetSchemaRequest {
    const message = createBaseGetSchemaRequest();
    message.name = object.name ?? "";
    message.view = object.view ?? 0;
    return message;
  },
};

function createBaseListSchemasRequest(): ListSchemasRequest {
  return { parent: "", view: 0, pageSize: 0, pageToken: "" };
}

export const ListSchemasRequest: MessageFns<ListSchemasRequest> = {
  encode(message: ListSchemasRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.view !== 0) {
      writer.uint32(16).int32(message.view);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSchemasRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSchemasRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSchemasRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      view: isSet(object.view) ? schemaViewFromJSON(object.view) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListSchemasRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.view !== 0) {
      obj.view = schemaViewToJSON(message.view);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSchemasRequest>): ListSchemasRequest {
    return ListSchemasRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSchemasRequest>): ListSchemasRequest {
    const message = createBaseListSchemasRequest();
    message.parent = object.parent ?? "";
    message.view = object.view ?? 0;
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListSchemasResponse(): ListSchemasResponse {
  return { schemas: [], nextPageToken: "" };
}

export const ListSchemasResponse: MessageFns<ListSchemasResponse> = {
  encode(message: ListSchemasResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.schemas) {
      Schema.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSchemasResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSchemasResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.schemas.push(Schema.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSchemasResponse {
    return {
      schemas: globalThis.Array.isArray(object?.schemas) ? object.schemas.map((e: any) => Schema.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListSchemasResponse): unknown {
    const obj: any = {};
    if (message.schemas?.length) {
      obj.schemas = message.schemas.map((e) => Schema.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSchemasResponse>): ListSchemasResponse {
    return ListSchemasResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSchemasResponse>): ListSchemasResponse {
    const message = createBaseListSchemasResponse();
    message.schemas = object.schemas?.map((e) => Schema.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseListSchemaRevisionsRequest(): ListSchemaRevisionsRequest {
  return { name: "", view: 0, pageSize: 0, pageToken: "" };
}

export const ListSchemaRevisionsRequest: MessageFns<ListSchemaRevisionsRequest> = {
  encode(message: ListSchemaRevisionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.view !== 0) {
      writer.uint32(16).int32(message.view);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSchemaRevisionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSchemaRevisionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSchemaRevisionsRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      view: isSet(object.view) ? schemaViewFromJSON(object.view) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListSchemaRevisionsRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.view !== 0) {
      obj.view = schemaViewToJSON(message.view);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSchemaRevisionsRequest>): ListSchemaRevisionsRequest {
    return ListSchemaRevisionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSchemaRevisionsRequest>): ListSchemaRevisionsRequest {
    const message = createBaseListSchemaRevisionsRequest();
    message.name = object.name ?? "";
    message.view = object.view ?? 0;
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListSchemaRevisionsResponse(): ListSchemaRevisionsResponse {
  return { schemas: [], nextPageToken: "" };
}

export const ListSchemaRevisionsResponse: MessageFns<ListSchemaRevisionsResponse> = {
  encode(message: ListSchemaRevisionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.schemas) {
      Schema.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSchemaRevisionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSchemaRevisionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.schemas.push(Schema.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSchemaRevisionsResponse {
    return {
      schemas: globalThis.Array.isArray(object?.schemas) ? object.schemas.map((e: any) => Schema.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListSchemaRevisionsResponse): unknown {
    const obj: any = {};
    if (message.schemas?.length) {
      obj.schemas = message.schemas.map((e) => Schema.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSchemaRevisionsResponse>): ListSchemaRevisionsResponse {
    return ListSchemaRevisionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSchemaRevisionsResponse>): ListSchemaRevisionsResponse {
    const message = createBaseListSchemaRevisionsResponse();
    message.schemas = object.schemas?.map((e) => Schema.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseCommitSchemaRequest(): CommitSchemaRequest {
  return { name: "", schema: undefined };
}

export const CommitSchemaRequest: MessageFns<CommitSchemaRequest> = {
  encode(message: CommitSchemaRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.schema !== undefined) {
      Schema.encode(message.schema, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommitSchemaRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommitSchemaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.schema = Schema.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommitSchemaRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      schema: isSet(object.schema) ? Schema.fromJSON(object.schema) : undefined,
    };
  },

  toJSON(message: CommitSchemaRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.schema !== undefined) {
      obj.schema = Schema.toJSON(message.schema);
    }
    return obj;
  },

  create(base?: DeepPartial<CommitSchemaRequest>): CommitSchemaRequest {
    return CommitSchemaRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CommitSchemaRequest>): CommitSchemaRequest {
    const message = createBaseCommitSchemaRequest();
    message.name = object.name ?? "";
    message.schema = (object.schema !== undefined && object.schema !== null)
      ? Schema.fromPartial(object.schema)
      : undefined;
    return message;
  },
};

function createBaseRollbackSchemaRequest(): RollbackSchemaRequest {
  return { name: "", revisionId: "" };
}

export const RollbackSchemaRequest: MessageFns<RollbackSchemaRequest> = {
  encode(message: RollbackSchemaRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.revisionId !== "") {
      writer.uint32(18).string(message.revisionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RollbackSchemaRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRollbackSchemaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.revisionId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RollbackSchemaRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      revisionId: isSet(object.revisionId) ? globalThis.String(object.revisionId) : "",
    };
  },

  toJSON(message: RollbackSchemaRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.revisionId !== "") {
      obj.revisionId = message.revisionId;
    }
    return obj;
  },

  create(base?: DeepPartial<RollbackSchemaRequest>): RollbackSchemaRequest {
    return RollbackSchemaRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RollbackSchemaRequest>): RollbackSchemaRequest {
    const message = createBaseRollbackSchemaRequest();
    message.name = object.name ?? "";
    message.revisionId = object.revisionId ?? "";
    return message;
  },
};

function createBaseDeleteSchemaRevisionRequest(): DeleteSchemaRevisionRequest {
  return { name: "", revisionId: "" };
}

export const DeleteSchemaRevisionRequest: MessageFns<DeleteSchemaRevisionRequest> = {
  encode(message: DeleteSchemaRevisionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.revisionId !== "") {
      writer.uint32(18).string(message.revisionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteSchemaRevisionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteSchemaRevisionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.revisionId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteSchemaRevisionRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      revisionId: isSet(object.revisionId) ? globalThis.String(object.revisionId) : "",
    };
  },

  toJSON(message: DeleteSchemaRevisionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.revisionId !== "") {
      obj.revisionId = message.revisionId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteSchemaRevisionRequest>): DeleteSchemaRevisionRequest {
    return DeleteSchemaRevisionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteSchemaRevisionRequest>): DeleteSchemaRevisionRequest {
    const message = createBaseDeleteSchemaRevisionRequest();
    message.name = object.name ?? "";
    message.revisionId = object.revisionId ?? "";
    return message;
  },
};

function createBaseDeleteSchemaRequest(): DeleteSchemaRequest {
  return { name: "" };
}

export const DeleteSchemaRequest: MessageFns<DeleteSchemaRequest> = {
  encode(message: DeleteSchemaRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteSchemaRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteSchemaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteSchemaRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteSchemaRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteSchemaRequest>): DeleteSchemaRequest {
    return DeleteSchemaRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteSchemaRequest>): DeleteSchemaRequest {
    const message = createBaseDeleteSchemaRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseValidateSchemaRequest(): ValidateSchemaRequest {
  return { parent: "", schema: undefined };
}

export const ValidateSchemaRequest: MessageFns<ValidateSchemaRequest> = {
  encode(message: ValidateSchemaRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.schema !== undefined) {
      Schema.encode(message.schema, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidateSchemaRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateSchemaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.schema = Schema.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidateSchemaRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      schema: isSet(object.schema) ? Schema.fromJSON(object.schema) : undefined,
    };
  },

  toJSON(message: ValidateSchemaRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.schema !== undefined) {
      obj.schema = Schema.toJSON(message.schema);
    }
    return obj;
  },

  create(base?: DeepPartial<ValidateSchemaRequest>): ValidateSchemaRequest {
    return ValidateSchemaRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ValidateSchemaRequest>): ValidateSchemaRequest {
    const message = createBaseValidateSchemaRequest();
    message.parent = object.parent ?? "";
    message.schema = (object.schema !== undefined && object.schema !== null)
      ? Schema.fromPartial(object.schema)
      : undefined;
    return message;
  },
};

function createBaseValidateSchemaResponse(): ValidateSchemaResponse {
  return {};
}

export const ValidateSchemaResponse: MessageFns<ValidateSchemaResponse> = {
  encode(_: ValidateSchemaResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidateSchemaResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateSchemaResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ValidateSchemaResponse {
    return {};
  },

  toJSON(_: ValidateSchemaResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<ValidateSchemaResponse>): ValidateSchemaResponse {
    return ValidateSchemaResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ValidateSchemaResponse>): ValidateSchemaResponse {
    const message = createBaseValidateSchemaResponse();
    return message;
  },
};

function createBaseValidateMessageRequest(): ValidateMessageRequest {
  return { parent: "", name: undefined, schema: undefined, message: Buffer.alloc(0), encoding: 0 };
}

export const ValidateMessageRequest: MessageFns<ValidateMessageRequest> = {
  encode(message: ValidateMessageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.name !== undefined) {
      writer.uint32(18).string(message.name);
    }
    if (message.schema !== undefined) {
      Schema.encode(message.schema, writer.uint32(26).fork()).join();
    }
    if (message.message.length !== 0) {
      writer.uint32(34).bytes(message.message);
    }
    if (message.encoding !== 0) {
      writer.uint32(40).int32(message.encoding);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidateMessageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateMessageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.schema = Schema.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.message = Buffer.from(reader.bytes());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.encoding = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidateMessageRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      schema: isSet(object.schema) ? Schema.fromJSON(object.schema) : undefined,
      message: isSet(object.message) ? Buffer.from(bytesFromBase64(object.message)) : Buffer.alloc(0),
      encoding: isSet(object.encoding) ? encodingFromJSON(object.encoding) : 0,
    };
  },

  toJSON(message: ValidateMessageRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.schema !== undefined) {
      obj.schema = Schema.toJSON(message.schema);
    }
    if (message.message.length !== 0) {
      obj.message = base64FromBytes(message.message);
    }
    if (message.encoding !== 0) {
      obj.encoding = encodingToJSON(message.encoding);
    }
    return obj;
  },

  create(base?: DeepPartial<ValidateMessageRequest>): ValidateMessageRequest {
    return ValidateMessageRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ValidateMessageRequest>): ValidateMessageRequest {
    const message = createBaseValidateMessageRequest();
    message.parent = object.parent ?? "";
    message.name = object.name ?? undefined;
    message.schema = (object.schema !== undefined && object.schema !== null)
      ? Schema.fromPartial(object.schema)
      : undefined;
    message.message = object.message ?? Buffer.alloc(0);
    message.encoding = object.encoding ?? 0;
    return message;
  },
};

function createBaseValidateMessageResponse(): ValidateMessageResponse {
  return {};
}

export const ValidateMessageResponse: MessageFns<ValidateMessageResponse> = {
  encode(_: ValidateMessageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidateMessageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateMessageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ValidateMessageResponse {
    return {};
  },

  toJSON(_: ValidateMessageResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<ValidateMessageResponse>): ValidateMessageResponse {
    return ValidateMessageResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ValidateMessageResponse>): ValidateMessageResponse {
    const message = createBaseValidateMessageResponse();
    return message;
  },
};

/** Service for doing schema-related operations. */
export type SchemaServiceDefinition = typeof SchemaServiceDefinition;
export const SchemaServiceDefinition = {
  name: "SchemaService",
  fullName: "google.pubsub.v1.SchemaService",
  methods: {
    /** Creates a schema. */
    createSchema: {
      name: "CreateSchema",
      requestType: CreateSchemaRequest,
      requestStream: false,
      responseType: Schema,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              23,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              115,
              99,
              104,
              101,
              109,
              97,
              44,
              115,
              99,
              104,
              101,
              109,
              97,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              41,
              58,
              6,
              115,
              99,
              104,
              101,
              109,
              97,
              34,
              31,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              115,
              99,
              104,
              101,
              109,
              97,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets a schema. */
    getSchema: {
      name: "GetSchema",
      requestType: GetSchemaRequest,
      requestStream: false,
      responseType: Schema,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              33,
              18,
              31,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              115,
              99,
              104,
              101,
              109,
              97,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists schemas in a project. */
    listSchemas: {
      name: "ListSchemas",
      requestType: ListSchemasRequest,
      requestStream: false,
      responseType: ListSchemasResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              33,
              18,
              31,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              115,
              99,
              104,
              101,
              109,
              97,
              115,
            ]),
          ],
        },
      },
    },
    /** Lists all schema revisions for the named schema. */
    listSchemaRevisions: {
      name: "ListSchemaRevisions",
      requestType: ListSchemaRevisionsRequest,
      requestStream: false,
      responseType: ListSchemaRevisionsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              47,
              18,
              45,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              115,
              99,
              104,
              101,
              109,
              97,
              115,
              47,
              42,
              125,
              58,
              108,
              105,
              115,
              116,
              82,
              101,
              118,
              105,
              115,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Commits a new schema revision to an existing schema. */
    commitSchema: {
      name: "CommitSchema",
      requestType: CommitSchemaRequest,
      requestStream: false,
      responseType: Schema,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([11, 110, 97, 109, 101, 44, 115, 99, 104, 101, 109, 97])],
          578365826: [
            Buffer.from([
              43,
              58,
              1,
              42,
              34,
              38,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              115,
              99,
              104,
              101,
              109,
              97,
              115,
              47,
              42,
              125,
              58,
              99,
              111,
              109,
              109,
              105,
              116,
            ]),
          ],
        },
      },
    },
    /** Creates a new schema revision that is a copy of the provided revision_id. */
    rollbackSchema: {
      name: "RollbackSchema",
      requestType: RollbackSchemaRequest,
      requestStream: false,
      responseType: Schema,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([16, 110, 97, 109, 101, 44, 114, 101, 118, 105, 115, 105, 111, 110, 95, 105, 100])],
          578365826: [
            Buffer.from([
              45,
              58,
              1,
              42,
              34,
              40,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              115,
              99,
              104,
              101,
              109,
              97,
              115,
              47,
              42,
              125,
              58,
              114,
              111,
              108,
              108,
              98,
              97,
              99,
              107,
            ]),
          ],
        },
      },
    },
    /** Deletes a specific schema revision. */
    deleteSchemaRevision: {
      name: "DeleteSchemaRevision",
      requestType: DeleteSchemaRevisionRequest,
      requestStream: false,
      responseType: Schema,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([16, 110, 97, 109, 101, 44, 114, 101, 118, 105, 115, 105, 111, 110, 95, 105, 100])],
          578365826: [
            Buffer.from([
              48,
              42,
              46,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              115,
              99,
              104,
              101,
              109,
              97,
              115,
              47,
              42,
              125,
              58,
              100,
              101,
              108,
              101,
              116,
              101,
              82,
              101,
              118,
              105,
              115,
              105,
              111,
              110,
            ]),
          ],
        },
      },
    },
    /** Deletes a schema. */
    deleteSchema: {
      name: "DeleteSchema",
      requestType: DeleteSchemaRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              33,
              42,
              31,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              115,
              99,
              104,
              101,
              109,
              97,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Validates a schema. */
    validateSchema: {
      name: "ValidateSchema",
      requestType: ValidateSchemaRequest,
      requestStream: false,
      responseType: ValidateSchemaResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([13, 112, 97, 114, 101, 110, 116, 44, 115, 99, 104, 101, 109, 97])],
          578365826: [
            Buffer.from([
              45,
              58,
              1,
              42,
              34,
              40,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              115,
              99,
              104,
              101,
              109,
              97,
              115,
              58,
              118,
              97,
              108,
              105,
              100,
              97,
              116,
              101,
            ]),
          ],
        },
      },
    },
    /** Validates a message against a schema. */
    validateMessage: {
      name: "ValidateMessage",
      requestType: ValidateMessageRequest,
      requestStream: false,
      responseType: ValidateMessageResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              52,
              58,
              1,
              42,
              34,
              47,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              115,
              99,
              104,
              101,
              109,
              97,
              115,
              58,
              118,
              97,
              108,
              105,
              100,
              97,
              116,
              101,
              77,
              101,
              115,
              115,
              97,
              103,
              101,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface SchemaServiceImplementation<CallContextExt = {}> {
  /** Creates a schema. */
  createSchema(request: CreateSchemaRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Schema>>;
  /** Gets a schema. */
  getSchema(request: GetSchemaRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Schema>>;
  /** Lists schemas in a project. */
  listSchemas(
    request: ListSchemasRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListSchemasResponse>>;
  /** Lists all schema revisions for the named schema. */
  listSchemaRevisions(
    request: ListSchemaRevisionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListSchemaRevisionsResponse>>;
  /** Commits a new schema revision to an existing schema. */
  commitSchema(request: CommitSchemaRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Schema>>;
  /** Creates a new schema revision that is a copy of the provided revision_id. */
  rollbackSchema(request: RollbackSchemaRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Schema>>;
  /** Deletes a specific schema revision. */
  deleteSchemaRevision(
    request: DeleteSchemaRevisionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Schema>>;
  /** Deletes a schema. */
  deleteSchema(request: DeleteSchemaRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** Validates a schema. */
  validateSchema(
    request: ValidateSchemaRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ValidateSchemaResponse>>;
  /** Validates a message against a schema. */
  validateMessage(
    request: ValidateMessageRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ValidateMessageResponse>>;
}

export interface SchemaServiceClient<CallOptionsExt = {}> {
  /** Creates a schema. */
  createSchema(request: DeepPartial<CreateSchemaRequest>, options?: CallOptions & CallOptionsExt): Promise<Schema>;
  /** Gets a schema. */
  getSchema(request: DeepPartial<GetSchemaRequest>, options?: CallOptions & CallOptionsExt): Promise<Schema>;
  /** Lists schemas in a project. */
  listSchemas(
    request: DeepPartial<ListSchemasRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListSchemasResponse>;
  /** Lists all schema revisions for the named schema. */
  listSchemaRevisions(
    request: DeepPartial<ListSchemaRevisionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListSchemaRevisionsResponse>;
  /** Commits a new schema revision to an existing schema. */
  commitSchema(request: DeepPartial<CommitSchemaRequest>, options?: CallOptions & CallOptionsExt): Promise<Schema>;
  /** Creates a new schema revision that is a copy of the provided revision_id. */
  rollbackSchema(request: DeepPartial<RollbackSchemaRequest>, options?: CallOptions & CallOptionsExt): Promise<Schema>;
  /** Deletes a specific schema revision. */
  deleteSchemaRevision(
    request: DeepPartial<DeleteSchemaRevisionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Schema>;
  /** Deletes a schema. */
  deleteSchema(request: DeepPartial<DeleteSchemaRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** Validates a schema. */
  validateSchema(
    request: DeepPartial<ValidateSchemaRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ValidateSchemaResponse>;
  /** Validates a message against a schema. */
  validateMessage(
    request: DeepPartial<ValidateMessageRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ValidateMessageResponse>;
}

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
