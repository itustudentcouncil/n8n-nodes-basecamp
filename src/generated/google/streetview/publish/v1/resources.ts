// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/streetview/publish/v1/resources.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../protobuf/duration.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { LatLng } from "../../../type/latlng.js";

export const protobufPackage = "google.streetview.publish.v1";

/**
 * The processing state of the sequence. The states move as follows:
 *
 * ```
 *      +-------------------------+
 *      |                         |
 *  +---v---+  +----------+  +----+----+
 *  |PENDING+-->PROCESSING+-->PROCESSED|
 *  +---+---+  +----+-----+  +----+----+
 *      |           |             |
 *      |        +--v---+         |
 *      +-------->FAILED<---------+
 *               +------+
 * ```
 *
 * The sequence may move to FAILED from any state. Additionally, a processed
 * sequence may be re-processed at any time.
 */
export enum ProcessingState {
  /** PROCESSING_STATE_UNSPECIFIED - The state is unspecified, this is the default value. */
  PROCESSING_STATE_UNSPECIFIED = 0,
  /** PENDING - The sequence has not yet started processing. */
  PENDING = 1,
  /** PROCESSING - The sequence is currently in processing. */
  PROCESSING = 2,
  /** PROCESSED - The sequence has finished processing including refining position. */
  PROCESSED = 3,
  /** FAILED - The sequence failed processing. See FailureReason for more details. */
  FAILED = 4,
  UNRECOGNIZED = -1,
}

export function processingStateFromJSON(object: any): ProcessingState {
  switch (object) {
    case 0:
    case "PROCESSING_STATE_UNSPECIFIED":
      return ProcessingState.PROCESSING_STATE_UNSPECIFIED;
    case 1:
    case "PENDING":
      return ProcessingState.PENDING;
    case 2:
    case "PROCESSING":
      return ProcessingState.PROCESSING;
    case 3:
    case "PROCESSED":
      return ProcessingState.PROCESSED;
    case 4:
    case "FAILED":
      return ProcessingState.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ProcessingState.UNRECOGNIZED;
  }
}

export function processingStateToJSON(object: ProcessingState): string {
  switch (object) {
    case ProcessingState.PROCESSING_STATE_UNSPECIFIED:
      return "PROCESSING_STATE_UNSPECIFIED";
    case ProcessingState.PENDING:
      return "PENDING";
    case ProcessingState.PROCESSING:
      return "PROCESSING";
    case ProcessingState.PROCESSED:
      return "PROCESSED";
    case ProcessingState.FAILED:
      return "FAILED";
    case ProcessingState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The possible reasons this [PhotoSequence]
 * [google.streetview.publish.v1.PhotoSequence] failed to process.
 */
export enum ProcessingFailureReason {
  /** PROCESSING_FAILURE_REASON_UNSPECIFIED - The failure reason is unspecified, this is the default value. */
  PROCESSING_FAILURE_REASON_UNSPECIFIED = 0,
  /** LOW_RESOLUTION - Video frame's resolution is too small. */
  LOW_RESOLUTION = 1,
  /** DUPLICATE - This video has been uploaded before. */
  DUPLICATE = 2,
  /** INSUFFICIENT_GPS - Too few GPS points. */
  INSUFFICIENT_GPS = 3,
  /**
   * NO_OVERLAP_GPS - No overlap between the time frame of GPS track and the time frame of
   * video.
   */
  NO_OVERLAP_GPS = 4,
  /** INVALID_GPS - GPS is invalid (e.x. all GPS points are at (0,0)) */
  INVALID_GPS = 5,
  /** FAILED_TO_REFINE_POSITIONS - The sequence of photos could not be accurately located in the world. */
  FAILED_TO_REFINE_POSITIONS = 6,
  /** TAKEDOWN - The sequence was taken down for policy reasons. */
  TAKEDOWN = 7,
  /** CORRUPT_VIDEO - The video file was corrupt or could not be decoded. */
  CORRUPT_VIDEO = 8,
  /** INTERNAL - A permanent failure in the underlying system occurred. */
  INTERNAL = 9,
  /** INVALID_VIDEO_FORMAT - The video format is invalid or unsupported. */
  INVALID_VIDEO_FORMAT = 10,
  /** INVALID_VIDEO_DIMENSIONS - Invalid image aspect ratio found. */
  INVALID_VIDEO_DIMENSIONS = 11,
  /** INVALID_CAPTURE_TIME - Invalid capture time. Timestamps were from the future. */
  INVALID_CAPTURE_TIME = 12,
  /** GPS_DATA_GAP - GPS data contains a gap greater than 5 seconds in duration. */
  GPS_DATA_GAP = 13,
  /** JUMPY_GPS - GPS data is too erratic to be processed. */
  JUMPY_GPS = 14,
  /**
   * INVALID_IMU - IMU (Accelerometer, Gyroscope, etc.) data are not valid. They may be
   * missing required fields (x, y, z or time), may not be formatted correctly,
   * or any other issue that prevents our systems from parsing it.
   */
  INVALID_IMU = 15,
  /** INSUFFICIENT_IMU - Too few IMU points. */
  INSUFFICIENT_IMU = 21,
  /**
   * INSUFFICIENT_OVERLAP_TIME_SERIES - Insufficient overlap in the time frame between GPS, IMU, and other time
   * series data.
   */
  INSUFFICIENT_OVERLAP_TIME_SERIES = 22,
  /**
   * IMU_DATA_GAP - IMU (Accelerometer, Gyroscope, etc.) data contain gaps greater than 0.1
   * seconds in duration.
   */
  IMU_DATA_GAP = 16,
  /** UNSUPPORTED_CAMERA - The camera is not supported. */
  UNSUPPORTED_CAMERA = 17,
  /** NOT_OUTDOORS - Some frames were indoors, which is unsupported. */
  NOT_OUTDOORS = 18,
  /** INSUFFICIENT_VIDEO_FRAMES - Not enough video frames. */
  INSUFFICIENT_VIDEO_FRAMES = 19,
  /** INSUFFICIENT_MOVEMENT - Not enough moving data. */
  INSUFFICIENT_MOVEMENT = 20,
  /** MAST_DOWN - Mast is down. */
  MAST_DOWN = 27,
  /** CAMERA_COVERED - Camera is covered. */
  CAMERA_COVERED = 28,
  UNRECOGNIZED = -1,
}

export function processingFailureReasonFromJSON(object: any): ProcessingFailureReason {
  switch (object) {
    case 0:
    case "PROCESSING_FAILURE_REASON_UNSPECIFIED":
      return ProcessingFailureReason.PROCESSING_FAILURE_REASON_UNSPECIFIED;
    case 1:
    case "LOW_RESOLUTION":
      return ProcessingFailureReason.LOW_RESOLUTION;
    case 2:
    case "DUPLICATE":
      return ProcessingFailureReason.DUPLICATE;
    case 3:
    case "INSUFFICIENT_GPS":
      return ProcessingFailureReason.INSUFFICIENT_GPS;
    case 4:
    case "NO_OVERLAP_GPS":
      return ProcessingFailureReason.NO_OVERLAP_GPS;
    case 5:
    case "INVALID_GPS":
      return ProcessingFailureReason.INVALID_GPS;
    case 6:
    case "FAILED_TO_REFINE_POSITIONS":
      return ProcessingFailureReason.FAILED_TO_REFINE_POSITIONS;
    case 7:
    case "TAKEDOWN":
      return ProcessingFailureReason.TAKEDOWN;
    case 8:
    case "CORRUPT_VIDEO":
      return ProcessingFailureReason.CORRUPT_VIDEO;
    case 9:
    case "INTERNAL":
      return ProcessingFailureReason.INTERNAL;
    case 10:
    case "INVALID_VIDEO_FORMAT":
      return ProcessingFailureReason.INVALID_VIDEO_FORMAT;
    case 11:
    case "INVALID_VIDEO_DIMENSIONS":
      return ProcessingFailureReason.INVALID_VIDEO_DIMENSIONS;
    case 12:
    case "INVALID_CAPTURE_TIME":
      return ProcessingFailureReason.INVALID_CAPTURE_TIME;
    case 13:
    case "GPS_DATA_GAP":
      return ProcessingFailureReason.GPS_DATA_GAP;
    case 14:
    case "JUMPY_GPS":
      return ProcessingFailureReason.JUMPY_GPS;
    case 15:
    case "INVALID_IMU":
      return ProcessingFailureReason.INVALID_IMU;
    case 21:
    case "INSUFFICIENT_IMU":
      return ProcessingFailureReason.INSUFFICIENT_IMU;
    case 22:
    case "INSUFFICIENT_OVERLAP_TIME_SERIES":
      return ProcessingFailureReason.INSUFFICIENT_OVERLAP_TIME_SERIES;
    case 16:
    case "IMU_DATA_GAP":
      return ProcessingFailureReason.IMU_DATA_GAP;
    case 17:
    case "UNSUPPORTED_CAMERA":
      return ProcessingFailureReason.UNSUPPORTED_CAMERA;
    case 18:
    case "NOT_OUTDOORS":
      return ProcessingFailureReason.NOT_OUTDOORS;
    case 19:
    case "INSUFFICIENT_VIDEO_FRAMES":
      return ProcessingFailureReason.INSUFFICIENT_VIDEO_FRAMES;
    case 20:
    case "INSUFFICIENT_MOVEMENT":
      return ProcessingFailureReason.INSUFFICIENT_MOVEMENT;
    case 27:
    case "MAST_DOWN":
      return ProcessingFailureReason.MAST_DOWN;
    case 28:
    case "CAMERA_COVERED":
      return ProcessingFailureReason.CAMERA_COVERED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ProcessingFailureReason.UNRECOGNIZED;
  }
}

export function processingFailureReasonToJSON(object: ProcessingFailureReason): string {
  switch (object) {
    case ProcessingFailureReason.PROCESSING_FAILURE_REASON_UNSPECIFIED:
      return "PROCESSING_FAILURE_REASON_UNSPECIFIED";
    case ProcessingFailureReason.LOW_RESOLUTION:
      return "LOW_RESOLUTION";
    case ProcessingFailureReason.DUPLICATE:
      return "DUPLICATE";
    case ProcessingFailureReason.INSUFFICIENT_GPS:
      return "INSUFFICIENT_GPS";
    case ProcessingFailureReason.NO_OVERLAP_GPS:
      return "NO_OVERLAP_GPS";
    case ProcessingFailureReason.INVALID_GPS:
      return "INVALID_GPS";
    case ProcessingFailureReason.FAILED_TO_REFINE_POSITIONS:
      return "FAILED_TO_REFINE_POSITIONS";
    case ProcessingFailureReason.TAKEDOWN:
      return "TAKEDOWN";
    case ProcessingFailureReason.CORRUPT_VIDEO:
      return "CORRUPT_VIDEO";
    case ProcessingFailureReason.INTERNAL:
      return "INTERNAL";
    case ProcessingFailureReason.INVALID_VIDEO_FORMAT:
      return "INVALID_VIDEO_FORMAT";
    case ProcessingFailureReason.INVALID_VIDEO_DIMENSIONS:
      return "INVALID_VIDEO_DIMENSIONS";
    case ProcessingFailureReason.INVALID_CAPTURE_TIME:
      return "INVALID_CAPTURE_TIME";
    case ProcessingFailureReason.GPS_DATA_GAP:
      return "GPS_DATA_GAP";
    case ProcessingFailureReason.JUMPY_GPS:
      return "JUMPY_GPS";
    case ProcessingFailureReason.INVALID_IMU:
      return "INVALID_IMU";
    case ProcessingFailureReason.INSUFFICIENT_IMU:
      return "INSUFFICIENT_IMU";
    case ProcessingFailureReason.INSUFFICIENT_OVERLAP_TIME_SERIES:
      return "INSUFFICIENT_OVERLAP_TIME_SERIES";
    case ProcessingFailureReason.IMU_DATA_GAP:
      return "IMU_DATA_GAP";
    case ProcessingFailureReason.UNSUPPORTED_CAMERA:
      return "UNSUPPORTED_CAMERA";
    case ProcessingFailureReason.NOT_OUTDOORS:
      return "NOT_OUTDOORS";
    case ProcessingFailureReason.INSUFFICIENT_VIDEO_FRAMES:
      return "INSUFFICIENT_VIDEO_FRAMES";
    case ProcessingFailureReason.INSUFFICIENT_MOVEMENT:
      return "INSUFFICIENT_MOVEMENT";
    case ProcessingFailureReason.MAST_DOWN:
      return "MAST_DOWN";
    case ProcessingFailureReason.CAMERA_COVERED:
      return "CAMERA_COVERED";
    case ProcessingFailureReason.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Upload reference for media files. */
export interface UploadRef {
  /**
   * An upload reference should be unique for each user. It follows
   * the form:
   * "https://streetviewpublish.googleapis.com/media/user/{account_id}/photo/{upload_reference}"
   */
  uploadUrl?: string | undefined;
}

/** Identifier for a [Photo][google.streetview.publish.v1.Photo]. */
export interface PhotoId {
  /** A unique identifier for a photo. */
  id: string;
}

/** Level information containing level number and its corresponding name. */
export interface Level {
  /**
   * Optional. Floor number, used for ordering. 0 indicates the ground level, 1
   * indicates the first level above ground level, -1 indicates the first level
   * under ground level. Non-integer values are OK.
   */
  number: number;
  /**
   * Required. A name assigned to this Level, restricted to 3 characters.
   * Consider how the elevator buttons would be labeled for this level if there
   * was an elevator.
   */
  name: string;
}

/** Raw pose measurement for an entity. */
export interface Pose {
  /**
   * Latitude and longitude pair of the pose, as explained here:
   * https://cloud.google.com/datastore/docs/reference/rest/Shared.Types/LatLng
   * When creating a [Photo][google.streetview.publish.v1.Photo], if the
   * latitude and longitude pair are not provided, the geolocation from the
   * exif header is used. A latitude and longitude pair not provided in the
   * photo or exif header causes the photo process to fail.
   */
  latLngPair:
    | LatLng
    | undefined;
  /**
   * Altitude of the pose in meters above WGS84 ellipsoid.
   * NaN indicates an unmeasured quantity.
   */
  altitude: number;
  /**
   * The following pose parameters pertain to the center of the photo. They
   * match https://developers.google.com/streetview/spherical-metadata.
   * Compass heading, measured at the center of the photo in degrees clockwise
   * from North. Value must be >=0 and <360. NaN indicates an unmeasured
   * quantity.
   */
  heading: number;
  /**
   * Pitch, measured at the center of the photo in degrees. Value must be >=-90
   * and <= 90. A value of -90 means looking directly down, and a value of 90
   * means looking directly up.
   * NaN indicates an unmeasured quantity.
   */
  pitch: number;
  /**
   * Roll, measured in degrees. Value must be >= 0 and <360. A value of 0
   * means level with the horizon.
   * NaN indicates an unmeasured quantity.
   */
  roll: number;
  /** Time of the GPS record since UTC epoch. */
  gpsRecordTimestampUnixEpoch:
    | Date
    | undefined;
  /** Level (the floor in a building) used to configure vertical navigation. */
  level:
    | Level
    | undefined;
  /**
   * The estimated horizontal accuracy of this pose in meters with 68%
   * confidence (one standard deviation). For example, on Android, this value is
   * available from this method:
   * https://developer.android.com/reference/android/location/Location#getAccuracy().
   * Other platforms have different methods of obtaining similar accuracy
   * estimations.
   */
  accuracyMeters: number;
}

/** IMU data from the device sensors. */
export interface Imu {
  /**
   * The accelerometer measurements in meters/sec^2 with increasing timestamps
   * from devices.
   */
  accelMpsps: Imu_Measurement3d[];
  /**
   * The gyroscope measurements in radians/sec with increasing timestamps from
   * devices.
   */
  gyroRps: Imu_Measurement3d[];
  /**
   * The magnetometer measurements of the magnetic field in microtesla (uT) with
   * increasing timestamps from devices.
   */
  magUt: Imu_Measurement3d[];
}

/** A Generic 3d measurement sample. */
export interface Imu_Measurement3d {
  /** The timestamp of the IMU measurement. */
  captureTime:
    | Date
    | undefined;
  /** The sensor measurement in the x axis. */
  x: number;
  /** The sensor measurement in the y axis. */
  y: number;
  /** The sensor measurement in the z axis. */
  z: number;
}

/** Place metadata for an entity. */
export interface Place {
  /**
   * Place identifier, as described in
   * https://developers.google.com/places/place-id.
   */
  placeId: string;
  /** Output only. The name of the place, localized to the language_code. */
  name: string;
  /**
   * Output only. The language_code that the name is localized with. This should
   * be the language_code specified in the request, but may be a fallback.
   */
  languageCode: string;
}

/** A connection is the link from a source photo to a destination photo. */
export interface Connection {
  /**
   * Required. The destination of the connection from the containing photo to
   * another photo.
   */
  target: PhotoId | undefined;
}

/** Photo is used to store 360 photos along with photo metadata. */
export interface Photo {
  /**
   * Required. Output only. Required when updating a photo. Output only when
   * creating a photo. Identifier for the photo, which is unique among all
   * photos in Google.
   */
  photoId:
    | PhotoId
    | undefined;
  /**
   * Input only. Required when creating a photo. Input only. The resource URL
   * where the photo bytes are uploaded to.
   */
  uploadReference:
    | UploadRef
    | undefined;
  /**
   * Output only. The download URL for the photo bytes. This field is set only
   * when
   * [GetPhotoRequest.view][google.streetview.publish.v1.GetPhotoRequest.view]
   * is set to
   * [PhotoView.INCLUDE_DOWNLOAD_URL][google.streetview.publish.v1.PhotoView.INCLUDE_DOWNLOAD_URL].
   */
  downloadUrl: string;
  /** Output only. The thumbnail URL for showing a preview of the given photo. */
  thumbnailUrl: string;
  /** Output only. The share link for the photo. */
  shareLink: string;
  /** Optional. Pose of the photo. */
  pose:
    | Pose
    | undefined;
  /**
   * Optional. Connections to other photos. A connection represents the link
   * from this photo to another photo.
   */
  connections: Connection[];
  /**
   * Optional. Absolute time when the photo was captured.
   * When the photo has no exif timestamp, this is used to set a timestamp in
   * the photo metadata.
   */
  captureTime:
    | Date
    | undefined;
  /** Output only. Time when the image was uploaded. */
  uploadTime:
    | Date
    | undefined;
  /** Optional. Places where this photo belongs. */
  places: Place[];
  /** Output only. View count of the photo. */
  viewCount: Long;
  /** Output only. Status of rights transfer on this photo. */
  transferStatus: Photo_TransferStatus;
  /**
   * Output only. Status in Google Maps, whether this photo was published or
   * rejected.
   */
  mapsPublishStatus: Photo_MapsPublishStatus;
}

/** Status of rights transfer. */
export enum Photo_TransferStatus {
  /** TRANSFER_STATUS_UNKNOWN - The status of this transfer is unspecified. */
  TRANSFER_STATUS_UNKNOWN = 0,
  /** NEVER_TRANSFERRED - This photo has never been in a transfer. */
  NEVER_TRANSFERRED = 1,
  /**
   * PENDING - This photo transfer has been initiated, but the receiver has not yet
   * responded.
   */
  PENDING = 2,
  /**
   * COMPLETED - The photo transfer has been completed, and this photo has been
   * transferred to the recipient.
   */
  COMPLETED = 3,
  /** REJECTED - The recipient rejected this photo transfer. */
  REJECTED = 4,
  /** EXPIRED - The photo transfer expired before the recipient took any action. */
  EXPIRED = 5,
  /** CANCELLED - The sender cancelled this photo transfer. */
  CANCELLED = 6,
  /** RECEIVED_VIA_TRANSFER - The recipient owns this photo due to a rights transfer. */
  RECEIVED_VIA_TRANSFER = 7,
  UNRECOGNIZED = -1,
}

export function photo_TransferStatusFromJSON(object: any): Photo_TransferStatus {
  switch (object) {
    case 0:
    case "TRANSFER_STATUS_UNKNOWN":
      return Photo_TransferStatus.TRANSFER_STATUS_UNKNOWN;
    case 1:
    case "NEVER_TRANSFERRED":
      return Photo_TransferStatus.NEVER_TRANSFERRED;
    case 2:
    case "PENDING":
      return Photo_TransferStatus.PENDING;
    case 3:
    case "COMPLETED":
      return Photo_TransferStatus.COMPLETED;
    case 4:
    case "REJECTED":
      return Photo_TransferStatus.REJECTED;
    case 5:
    case "EXPIRED":
      return Photo_TransferStatus.EXPIRED;
    case 6:
    case "CANCELLED":
      return Photo_TransferStatus.CANCELLED;
    case 7:
    case "RECEIVED_VIA_TRANSFER":
      return Photo_TransferStatus.RECEIVED_VIA_TRANSFER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Photo_TransferStatus.UNRECOGNIZED;
  }
}

export function photo_TransferStatusToJSON(object: Photo_TransferStatus): string {
  switch (object) {
    case Photo_TransferStatus.TRANSFER_STATUS_UNKNOWN:
      return "TRANSFER_STATUS_UNKNOWN";
    case Photo_TransferStatus.NEVER_TRANSFERRED:
      return "NEVER_TRANSFERRED";
    case Photo_TransferStatus.PENDING:
      return "PENDING";
    case Photo_TransferStatus.COMPLETED:
      return "COMPLETED";
    case Photo_TransferStatus.REJECTED:
      return "REJECTED";
    case Photo_TransferStatus.EXPIRED:
      return "EXPIRED";
    case Photo_TransferStatus.CANCELLED:
      return "CANCELLED";
    case Photo_TransferStatus.RECEIVED_VIA_TRANSFER:
      return "RECEIVED_VIA_TRANSFER";
    case Photo_TransferStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Publication status of the photo in Google Maps. */
export enum Photo_MapsPublishStatus {
  /** UNSPECIFIED_MAPS_PUBLISH_STATUS - The status of the photo is unknown. */
  UNSPECIFIED_MAPS_PUBLISH_STATUS = 0,
  /** PUBLISHED - The photo is published to the public through Google Maps. */
  PUBLISHED = 1,
  /** REJECTED_UNKNOWN - The photo has been rejected for an unknown reason. */
  REJECTED_UNKNOWN = 2,
  UNRECOGNIZED = -1,
}

export function photo_MapsPublishStatusFromJSON(object: any): Photo_MapsPublishStatus {
  switch (object) {
    case 0:
    case "UNSPECIFIED_MAPS_PUBLISH_STATUS":
      return Photo_MapsPublishStatus.UNSPECIFIED_MAPS_PUBLISH_STATUS;
    case 1:
    case "PUBLISHED":
      return Photo_MapsPublishStatus.PUBLISHED;
    case 2:
    case "REJECTED_UNKNOWN":
      return Photo_MapsPublishStatus.REJECTED_UNKNOWN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Photo_MapsPublishStatus.UNRECOGNIZED;
  }
}

export function photo_MapsPublishStatusToJSON(object: Photo_MapsPublishStatus): string {
  switch (object) {
    case Photo_MapsPublishStatus.UNSPECIFIED_MAPS_PUBLISH_STATUS:
      return "UNSPECIFIED_MAPS_PUBLISH_STATUS";
    case Photo_MapsPublishStatus.PUBLISHED:
      return "PUBLISHED";
    case Photo_MapsPublishStatus.REJECTED_UNKNOWN:
      return "REJECTED_UNKNOWN";
    case Photo_MapsPublishStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A sequence of 360 photos along with metadata. */
export interface PhotoSequence {
  /**
   * Output only. Unique identifier for the photo sequence.
   * This also acts as a long running operation ID if uploading is performed
   * asynchronously.
   */
  id: string;
  /** Output only. Photos with increasing timestamps. */
  photos: Photo[];
  /**
   * Input only. Required when creating photo sequence. The resource name
   * where the bytes of the photo sequence (in the form of video) are uploaded.
   */
  uploadReference:
    | UploadRef
    | undefined;
  /**
   * Optional. Absolute time when the photo sequence starts to be captured.
   * If the photo sequence is a video, this is the start time of the video.
   * If this field is populated in input, it overrides the capture time in the
   * video or XDM file.
   */
  captureTimeOverride:
    | Date
    | undefined;
  /** Output only. The time this photo sequence was created in uSV Store service. */
  uploadTime:
    | Date
    | undefined;
  /**
   * Input only. Raw GPS measurements with increasing timestamps from the device
   * that aren't time synced with each photo. These raw measurements will be
   * used to infer the pose of each frame. Required in input when InputType is
   * VIDEO and raw GPS measurements are not in Camera Motion Metadata Track
   * (CAMM). User can indicate which takes precedence using gps_source if raw
   * GPS measurements are provided in both raw_gps_timeline and Camera Motion
   * Metadata Track (CAMM).
   */
  rawGpsTimeline: Pose[];
  /**
   * Input only. If both raw_gps_timeline and
   * the Camera Motion Metadata Track (CAMM) contain GPS measurements,
   * indicate which takes precedence.
   */
  gpsSource: PhotoSequence_GpsSource;
  /**
   * Input only. Three axis IMU data for the collection.
   * If this data is too large to put in the request, then it should be put in
   * the CAMM track for the video. This data always takes precedence over the
   * equivalent CAMM data, if it exists.
   */
  imu:
    | Imu
    | undefined;
  /** Output only. The processing state of this sequence. */
  processingState: ProcessingState;
  /**
   * Output only. If this sequence has processing_state = FAILED, this will
   * contain the reason why it failed. If the processing_state is any other
   * value, this field will be unset.
   */
  failureReason: ProcessingFailureReason;
  /**
   * Output only. If this sequence has `failure_reason` set, this may contain
   * additional details about the failure.
   */
  failureDetails:
    | ProcessingFailureDetails
    | undefined;
  /** Output only. The computed distance of the photo sequence in meters. */
  distanceMeters: number;
  /**
   * Output only. A rectangular box that encapsulates every image in this photo
   * sequence.
   */
  sequenceBounds:
    | LatLngBounds
    | undefined;
  /**
   * Output only. The total number of views that all the published images in
   * this PhotoSequence have received.
   */
  viewCount: Long;
  /**
   * Output only. The filename of the upload. Does not include the directory
   * path. Only available if the sequence was uploaded on a platform that
   * provides the filename.
   */
  filename: string;
}

/** Primary source of GPS measurements. */
export enum PhotoSequence_GpsSource {
  /** PHOTO_SEQUENCE - GPS in raw_gps_timeline takes precedence if it exists. */
  PHOTO_SEQUENCE = 0,
  /** CAMERA_MOTION_METADATA_TRACK - GPS in Camera Motion Metadata Track (CAMM) takes precedence if it exists. */
  CAMERA_MOTION_METADATA_TRACK = 1,
  UNRECOGNIZED = -1,
}

export function photoSequence_GpsSourceFromJSON(object: any): PhotoSequence_GpsSource {
  switch (object) {
    case 0:
    case "PHOTO_SEQUENCE":
      return PhotoSequence_GpsSource.PHOTO_SEQUENCE;
    case 1:
    case "CAMERA_MOTION_METADATA_TRACK":
      return PhotoSequence_GpsSource.CAMERA_MOTION_METADATA_TRACK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PhotoSequence_GpsSource.UNRECOGNIZED;
  }
}

export function photoSequence_GpsSourceToJSON(object: PhotoSequence_GpsSource): string {
  switch (object) {
    case PhotoSequence_GpsSource.PHOTO_SEQUENCE:
      return "PHOTO_SEQUENCE";
    case PhotoSequence_GpsSource.CAMERA_MOTION_METADATA_TRACK:
      return "CAMERA_MOTION_METADATA_TRACK";
    case PhotoSequence_GpsSource.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A rectangle in geographical coordinates. */
export interface LatLngBounds {
  /** The southwest corner of these bounds. */
  southwest:
    | LatLng
    | undefined;
  /** The northeast corner of these bounds. */
  northeast: LatLng | undefined;
}

/**
 * Additional details to accompany the ProcessingFailureReason enum.
 * This message is always expected to be used in conjunction with
 * ProcessingFailureReason, and the oneof value set in this message should match
 * the FailureReason.
 */
export interface ProcessingFailureDetails {
  /** See InsufficientGpsFailureDetails. */
  insufficientGpsDetails?:
    | InsufficientGpsFailureDetails
    | undefined;
  /** See GpsDataGapFailureDetails. */
  gpsDataGapDetails?:
    | GpsDataGapFailureDetails
    | undefined;
  /** See ImuDataGapFailureDetails. */
  imuDataGapDetails?:
    | ImuDataGapFailureDetails
    | undefined;
  /** See NotOutdoorsFailureDetails. */
  notOutdoorsDetails?:
    | NotOutdoorsFailureDetails
    | undefined;
  /** See NoOverlapGpsFailureDetails. */
  noOverlapGpsDetails?: NoOverlapGpsFailureDetails | undefined;
}

/** Details related to ProcessingFailureReason#INSUFFICIENT_GPS. */
export interface InsufficientGpsFailureDetails {
  /** The number of GPS points that were found in the video. */
  gpsPointsFound?: number | undefined;
}

/**
 * Details related to ProcessingFailureReason#GPS_DATA_GAP.
 * If there are multiple GPS data gaps, only the one with the largest duration
 * is reported here.
 */
export interface GpsDataGapFailureDetails {
  /** The duration of the gap in GPS data that was found. */
  gapDuration?:
    | Duration
    | undefined;
  /** Relative time (from the start of the video stream) when the gap started. */
  gapStartTime?: Duration | undefined;
}

/**
 * Details related to ProcessingFailureReason#IMU_DATA_GAP.
 * If there are multiple IMU data gaps, only the one with the largest duration
 * is reported here.
 */
export interface ImuDataGapFailureDetails {
  /** The duration of the gap in IMU data that was found. */
  gapDuration?:
    | Duration
    | undefined;
  /** Relative time (from the start of the video stream) when the gap started. */
  gapStartTime?: Duration | undefined;
}

/**
 * Details related to ProcessingFailureReason#NOT_OUTDOORS.
 * If there are multiple indoor frames found, the first frame is recorded here.
 */
export interface NotOutdoorsFailureDetails {
  /**
   * Relative time (from the start of the video stream) when an indoor frame was
   * found.
   */
  startTime?: Duration | undefined;
}

/** Details related to PhotoSequenceProcessingFailureReason#NO_OVERLAP_GPS. */
export interface NoOverlapGpsFailureDetails {
  /** Time of first recorded GPS point. */
  gpsStartTime?:
    | Date
    | undefined;
  /** Time of last recorded GPS point. */
  gpsEndTime?:
    | Date
    | undefined;
  /** Start time of video. */
  videoStartTime?:
    | Date
    | undefined;
  /** End time of video. */
  videoEndTime?: Date | undefined;
}

function createBaseUploadRef(): UploadRef {
  return { uploadUrl: undefined };
}

export const UploadRef: MessageFns<UploadRef> = {
  encode(message: UploadRef, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uploadUrl !== undefined) {
      writer.uint32(10).string(message.uploadUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UploadRef {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadRef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uploadUrl = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UploadRef {
    return { uploadUrl: isSet(object.uploadUrl) ? globalThis.String(object.uploadUrl) : undefined };
  },

  toJSON(message: UploadRef): unknown {
    const obj: any = {};
    if (message.uploadUrl !== undefined) {
      obj.uploadUrl = message.uploadUrl;
    }
    return obj;
  },

  create(base?: DeepPartial<UploadRef>): UploadRef {
    return UploadRef.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UploadRef>): UploadRef {
    const message = createBaseUploadRef();
    message.uploadUrl = object.uploadUrl ?? undefined;
    return message;
  },
};

function createBasePhotoId(): PhotoId {
  return { id: "" };
}

export const PhotoId: MessageFns<PhotoId> = {
  encode(message: PhotoId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PhotoId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePhotoId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PhotoId {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: PhotoId): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create(base?: DeepPartial<PhotoId>): PhotoId {
    return PhotoId.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PhotoId>): PhotoId {
    const message = createBasePhotoId();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseLevel(): Level {
  return { number: 0, name: "" };
}

export const Level: MessageFns<Level> = {
  encode(message: Level, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.number !== 0) {
      writer.uint32(9).double(message.number);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Level {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLevel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.number = reader.double();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Level {
    return {
      number: isSet(object.number) ? globalThis.Number(object.number) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: Level): unknown {
    const obj: any = {};
    if (message.number !== 0) {
      obj.number = message.number;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<Level>): Level {
    return Level.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Level>): Level {
    const message = createBaseLevel();
    message.number = object.number ?? 0;
    message.name = object.name ?? "";
    return message;
  },
};

function createBasePose(): Pose {
  return {
    latLngPair: undefined,
    altitude: 0,
    heading: 0,
    pitch: 0,
    roll: 0,
    gpsRecordTimestampUnixEpoch: undefined,
    level: undefined,
    accuracyMeters: 0,
  };
}

export const Pose: MessageFns<Pose> = {
  encode(message: Pose, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.latLngPair !== undefined) {
      LatLng.encode(message.latLngPair, writer.uint32(10).fork()).join();
    }
    if (message.altitude !== 0) {
      writer.uint32(17).double(message.altitude);
    }
    if (message.heading !== 0) {
      writer.uint32(25).double(message.heading);
    }
    if (message.pitch !== 0) {
      writer.uint32(33).double(message.pitch);
    }
    if (message.roll !== 0) {
      writer.uint32(41).double(message.roll);
    }
    if (message.gpsRecordTimestampUnixEpoch !== undefined) {
      Timestamp.encode(toTimestamp(message.gpsRecordTimestampUnixEpoch), writer.uint32(50).fork()).join();
    }
    if (message.level !== undefined) {
      Level.encode(message.level, writer.uint32(58).fork()).join();
    }
    if (message.accuracyMeters !== 0) {
      writer.uint32(77).float(message.accuracyMeters);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Pose {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePose();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.latLngPair = LatLng.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.altitude = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.heading = reader.double();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.pitch = reader.double();
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.roll = reader.double();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.gpsRecordTimestampUnixEpoch = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.level = Level.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 77) {
            break;
          }

          message.accuracyMeters = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Pose {
    return {
      latLngPair: isSet(object.latLngPair) ? LatLng.fromJSON(object.latLngPair) : undefined,
      altitude: isSet(object.altitude) ? globalThis.Number(object.altitude) : 0,
      heading: isSet(object.heading) ? globalThis.Number(object.heading) : 0,
      pitch: isSet(object.pitch) ? globalThis.Number(object.pitch) : 0,
      roll: isSet(object.roll) ? globalThis.Number(object.roll) : 0,
      gpsRecordTimestampUnixEpoch: isSet(object.gpsRecordTimestampUnixEpoch)
        ? fromJsonTimestamp(object.gpsRecordTimestampUnixEpoch)
        : undefined,
      level: isSet(object.level) ? Level.fromJSON(object.level) : undefined,
      accuracyMeters: isSet(object.accuracyMeters) ? globalThis.Number(object.accuracyMeters) : 0,
    };
  },

  toJSON(message: Pose): unknown {
    const obj: any = {};
    if (message.latLngPair !== undefined) {
      obj.latLngPair = LatLng.toJSON(message.latLngPair);
    }
    if (message.altitude !== 0) {
      obj.altitude = message.altitude;
    }
    if (message.heading !== 0) {
      obj.heading = message.heading;
    }
    if (message.pitch !== 0) {
      obj.pitch = message.pitch;
    }
    if (message.roll !== 0) {
      obj.roll = message.roll;
    }
    if (message.gpsRecordTimestampUnixEpoch !== undefined) {
      obj.gpsRecordTimestampUnixEpoch = message.gpsRecordTimestampUnixEpoch.toISOString();
    }
    if (message.level !== undefined) {
      obj.level = Level.toJSON(message.level);
    }
    if (message.accuracyMeters !== 0) {
      obj.accuracyMeters = message.accuracyMeters;
    }
    return obj;
  },

  create(base?: DeepPartial<Pose>): Pose {
    return Pose.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Pose>): Pose {
    const message = createBasePose();
    message.latLngPair = (object.latLngPair !== undefined && object.latLngPair !== null)
      ? LatLng.fromPartial(object.latLngPair)
      : undefined;
    message.altitude = object.altitude ?? 0;
    message.heading = object.heading ?? 0;
    message.pitch = object.pitch ?? 0;
    message.roll = object.roll ?? 0;
    message.gpsRecordTimestampUnixEpoch = object.gpsRecordTimestampUnixEpoch ?? undefined;
    message.level = (object.level !== undefined && object.level !== null) ? Level.fromPartial(object.level) : undefined;
    message.accuracyMeters = object.accuracyMeters ?? 0;
    return message;
  },
};

function createBaseImu(): Imu {
  return { accelMpsps: [], gyroRps: [], magUt: [] };
}

export const Imu: MessageFns<Imu> = {
  encode(message: Imu, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.accelMpsps) {
      Imu_Measurement3d.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.gyroRps) {
      Imu_Measurement3d.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.magUt) {
      Imu_Measurement3d.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Imu {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImu();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accelMpsps.push(Imu_Measurement3d.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.gyroRps.push(Imu_Measurement3d.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.magUt.push(Imu_Measurement3d.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Imu {
    return {
      accelMpsps: globalThis.Array.isArray(object?.accelMpsps)
        ? object.accelMpsps.map((e: any) => Imu_Measurement3d.fromJSON(e))
        : [],
      gyroRps: globalThis.Array.isArray(object?.gyroRps)
        ? object.gyroRps.map((e: any) => Imu_Measurement3d.fromJSON(e))
        : [],
      magUt: globalThis.Array.isArray(object?.magUt) ? object.magUt.map((e: any) => Imu_Measurement3d.fromJSON(e)) : [],
    };
  },

  toJSON(message: Imu): unknown {
    const obj: any = {};
    if (message.accelMpsps?.length) {
      obj.accelMpsps = message.accelMpsps.map((e) => Imu_Measurement3d.toJSON(e));
    }
    if (message.gyroRps?.length) {
      obj.gyroRps = message.gyroRps.map((e) => Imu_Measurement3d.toJSON(e));
    }
    if (message.magUt?.length) {
      obj.magUt = message.magUt.map((e) => Imu_Measurement3d.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Imu>): Imu {
    return Imu.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Imu>): Imu {
    const message = createBaseImu();
    message.accelMpsps = object.accelMpsps?.map((e) => Imu_Measurement3d.fromPartial(e)) || [];
    message.gyroRps = object.gyroRps?.map((e) => Imu_Measurement3d.fromPartial(e)) || [];
    message.magUt = object.magUt?.map((e) => Imu_Measurement3d.fromPartial(e)) || [];
    return message;
  },
};

function createBaseImu_Measurement3d(): Imu_Measurement3d {
  return { captureTime: undefined, x: 0, y: 0, z: 0 };
}

export const Imu_Measurement3d: MessageFns<Imu_Measurement3d> = {
  encode(message: Imu_Measurement3d, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.captureTime !== undefined) {
      Timestamp.encode(toTimestamp(message.captureTime), writer.uint32(10).fork()).join();
    }
    if (message.x !== 0) {
      writer.uint32(21).float(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(29).float(message.y);
    }
    if (message.z !== 0) {
      writer.uint32(37).float(message.z);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Imu_Measurement3d {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImu_Measurement3d();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.captureTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.x = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.y = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.z = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Imu_Measurement3d {
    return {
      captureTime: isSet(object.captureTime) ? fromJsonTimestamp(object.captureTime) : undefined,
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      z: isSet(object.z) ? globalThis.Number(object.z) : 0,
    };
  },

  toJSON(message: Imu_Measurement3d): unknown {
    const obj: any = {};
    if (message.captureTime !== undefined) {
      obj.captureTime = message.captureTime.toISOString();
    }
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    if (message.z !== 0) {
      obj.z = message.z;
    }
    return obj;
  },

  create(base?: DeepPartial<Imu_Measurement3d>): Imu_Measurement3d {
    return Imu_Measurement3d.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Imu_Measurement3d>): Imu_Measurement3d {
    const message = createBaseImu_Measurement3d();
    message.captureTime = object.captureTime ?? undefined;
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.z = object.z ?? 0;
    return message;
  },
};

function createBasePlace(): Place {
  return { placeId: "", name: "", languageCode: "" };
}

export const Place: MessageFns<Place> = {
  encode(message: Place, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.placeId !== "") {
      writer.uint32(10).string(message.placeId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.languageCode !== "") {
      writer.uint32(26).string(message.languageCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Place {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlace();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.placeId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.languageCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Place {
    return {
      placeId: isSet(object.placeId) ? globalThis.String(object.placeId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
    };
  },

  toJSON(message: Place): unknown {
    const obj: any = {};
    if (message.placeId !== "") {
      obj.placeId = message.placeId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    return obj;
  },

  create(base?: DeepPartial<Place>): Place {
    return Place.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Place>): Place {
    const message = createBasePlace();
    message.placeId = object.placeId ?? "";
    message.name = object.name ?? "";
    message.languageCode = object.languageCode ?? "";
    return message;
  },
};

function createBaseConnection(): Connection {
  return { target: undefined };
}

export const Connection: MessageFns<Connection> = {
  encode(message: Connection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.target !== undefined) {
      PhotoId.encode(message.target, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Connection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.target = PhotoId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Connection {
    return { target: isSet(object.target) ? PhotoId.fromJSON(object.target) : undefined };
  },

  toJSON(message: Connection): unknown {
    const obj: any = {};
    if (message.target !== undefined) {
      obj.target = PhotoId.toJSON(message.target);
    }
    return obj;
  },

  create(base?: DeepPartial<Connection>): Connection {
    return Connection.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Connection>): Connection {
    const message = createBaseConnection();
    message.target = (object.target !== undefined && object.target !== null)
      ? PhotoId.fromPartial(object.target)
      : undefined;
    return message;
  },
};

function createBasePhoto(): Photo {
  return {
    photoId: undefined,
    uploadReference: undefined,
    downloadUrl: "",
    thumbnailUrl: "",
    shareLink: "",
    pose: undefined,
    connections: [],
    captureTime: undefined,
    uploadTime: undefined,
    places: [],
    viewCount: Long.ZERO,
    transferStatus: 0,
    mapsPublishStatus: 0,
  };
}

export const Photo: MessageFns<Photo> = {
  encode(message: Photo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.photoId !== undefined) {
      PhotoId.encode(message.photoId, writer.uint32(10).fork()).join();
    }
    if (message.uploadReference !== undefined) {
      UploadRef.encode(message.uploadReference, writer.uint32(18).fork()).join();
    }
    if (message.downloadUrl !== "") {
      writer.uint32(26).string(message.downloadUrl);
    }
    if (message.thumbnailUrl !== "") {
      writer.uint32(74).string(message.thumbnailUrl);
    }
    if (message.shareLink !== "") {
      writer.uint32(90).string(message.shareLink);
    }
    if (message.pose !== undefined) {
      Pose.encode(message.pose, writer.uint32(34).fork()).join();
    }
    for (const v of message.connections) {
      Connection.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.captureTime !== undefined) {
      Timestamp.encode(toTimestamp(message.captureTime), writer.uint32(50).fork()).join();
    }
    if (message.uploadTime !== undefined) {
      Timestamp.encode(toTimestamp(message.uploadTime), writer.uint32(114).fork()).join();
    }
    for (const v of message.places) {
      Place.encode(v!, writer.uint32(58).fork()).join();
    }
    if (!message.viewCount.equals(Long.ZERO)) {
      writer.uint32(80).int64(message.viewCount.toString());
    }
    if (message.transferStatus !== 0) {
      writer.uint32(96).int32(message.transferStatus);
    }
    if (message.mapsPublishStatus !== 0) {
      writer.uint32(104).int32(message.mapsPublishStatus);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Photo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePhoto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.photoId = PhotoId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uploadReference = UploadRef.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.downloadUrl = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.thumbnailUrl = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.shareLink = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pose = Pose.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.connections.push(Connection.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.captureTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.uploadTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.places.push(Place.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.viewCount = Long.fromString(reader.int64().toString());
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.transferStatus = reader.int32() as any;
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.mapsPublishStatus = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Photo {
    return {
      photoId: isSet(object.photoId) ? PhotoId.fromJSON(object.photoId) : undefined,
      uploadReference: isSet(object.uploadReference) ? UploadRef.fromJSON(object.uploadReference) : undefined,
      downloadUrl: isSet(object.downloadUrl) ? globalThis.String(object.downloadUrl) : "",
      thumbnailUrl: isSet(object.thumbnailUrl) ? globalThis.String(object.thumbnailUrl) : "",
      shareLink: isSet(object.shareLink) ? globalThis.String(object.shareLink) : "",
      pose: isSet(object.pose) ? Pose.fromJSON(object.pose) : undefined,
      connections: globalThis.Array.isArray(object?.connections)
        ? object.connections.map((e: any) => Connection.fromJSON(e))
        : [],
      captureTime: isSet(object.captureTime) ? fromJsonTimestamp(object.captureTime) : undefined,
      uploadTime: isSet(object.uploadTime) ? fromJsonTimestamp(object.uploadTime) : undefined,
      places: globalThis.Array.isArray(object?.places) ? object.places.map((e: any) => Place.fromJSON(e)) : [],
      viewCount: isSet(object.viewCount) ? Long.fromValue(object.viewCount) : Long.ZERO,
      transferStatus: isSet(object.transferStatus) ? photo_TransferStatusFromJSON(object.transferStatus) : 0,
      mapsPublishStatus: isSet(object.mapsPublishStatus)
        ? photo_MapsPublishStatusFromJSON(object.mapsPublishStatus)
        : 0,
    };
  },

  toJSON(message: Photo): unknown {
    const obj: any = {};
    if (message.photoId !== undefined) {
      obj.photoId = PhotoId.toJSON(message.photoId);
    }
    if (message.uploadReference !== undefined) {
      obj.uploadReference = UploadRef.toJSON(message.uploadReference);
    }
    if (message.downloadUrl !== "") {
      obj.downloadUrl = message.downloadUrl;
    }
    if (message.thumbnailUrl !== "") {
      obj.thumbnailUrl = message.thumbnailUrl;
    }
    if (message.shareLink !== "") {
      obj.shareLink = message.shareLink;
    }
    if (message.pose !== undefined) {
      obj.pose = Pose.toJSON(message.pose);
    }
    if (message.connections?.length) {
      obj.connections = message.connections.map((e) => Connection.toJSON(e));
    }
    if (message.captureTime !== undefined) {
      obj.captureTime = message.captureTime.toISOString();
    }
    if (message.uploadTime !== undefined) {
      obj.uploadTime = message.uploadTime.toISOString();
    }
    if (message.places?.length) {
      obj.places = message.places.map((e) => Place.toJSON(e));
    }
    if (!message.viewCount.equals(Long.ZERO)) {
      obj.viewCount = (message.viewCount || Long.ZERO).toString();
    }
    if (message.transferStatus !== 0) {
      obj.transferStatus = photo_TransferStatusToJSON(message.transferStatus);
    }
    if (message.mapsPublishStatus !== 0) {
      obj.mapsPublishStatus = photo_MapsPublishStatusToJSON(message.mapsPublishStatus);
    }
    return obj;
  },

  create(base?: DeepPartial<Photo>): Photo {
    return Photo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Photo>): Photo {
    const message = createBasePhoto();
    message.photoId = (object.photoId !== undefined && object.photoId !== null)
      ? PhotoId.fromPartial(object.photoId)
      : undefined;
    message.uploadReference = (object.uploadReference !== undefined && object.uploadReference !== null)
      ? UploadRef.fromPartial(object.uploadReference)
      : undefined;
    message.downloadUrl = object.downloadUrl ?? "";
    message.thumbnailUrl = object.thumbnailUrl ?? "";
    message.shareLink = object.shareLink ?? "";
    message.pose = (object.pose !== undefined && object.pose !== null) ? Pose.fromPartial(object.pose) : undefined;
    message.connections = object.connections?.map((e) => Connection.fromPartial(e)) || [];
    message.captureTime = object.captureTime ?? undefined;
    message.uploadTime = object.uploadTime ?? undefined;
    message.places = object.places?.map((e) => Place.fromPartial(e)) || [];
    message.viewCount = (object.viewCount !== undefined && object.viewCount !== null)
      ? Long.fromValue(object.viewCount)
      : Long.ZERO;
    message.transferStatus = object.transferStatus ?? 0;
    message.mapsPublishStatus = object.mapsPublishStatus ?? 0;
    return message;
  },
};

function createBasePhotoSequence(): PhotoSequence {
  return {
    id: "",
    photos: [],
    uploadReference: undefined,
    captureTimeOverride: undefined,
    uploadTime: undefined,
    rawGpsTimeline: [],
    gpsSource: 0,
    imu: undefined,
    processingState: 0,
    failureReason: 0,
    failureDetails: undefined,
    distanceMeters: 0,
    sequenceBounds: undefined,
    viewCount: Long.ZERO,
    filename: "",
  };
}

export const PhotoSequence: MessageFns<PhotoSequence> = {
  encode(message: PhotoSequence, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    for (const v of message.photos) {
      Photo.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.uploadReference !== undefined) {
      UploadRef.encode(message.uploadReference, writer.uint32(26).fork()).join();
    }
    if (message.captureTimeOverride !== undefined) {
      Timestamp.encode(toTimestamp(message.captureTimeOverride), writer.uint32(34).fork()).join();
    }
    if (message.uploadTime !== undefined) {
      Timestamp.encode(toTimestamp(message.uploadTime), writer.uint32(146).fork()).join();
    }
    for (const v of message.rawGpsTimeline) {
      Pose.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.gpsSource !== 0) {
      writer.uint32(64).int32(message.gpsSource);
    }
    if (message.imu !== undefined) {
      Imu.encode(message.imu, writer.uint32(90).fork()).join();
    }
    if (message.processingState !== 0) {
      writer.uint32(96).int32(message.processingState);
    }
    if (message.failureReason !== 0) {
      writer.uint32(104).int32(message.failureReason);
    }
    if (message.failureDetails !== undefined) {
      ProcessingFailureDetails.encode(message.failureDetails, writer.uint32(186).fork()).join();
    }
    if (message.distanceMeters !== 0) {
      writer.uint32(129).double(message.distanceMeters);
    }
    if (message.sequenceBounds !== undefined) {
      LatLngBounds.encode(message.sequenceBounds, writer.uint32(162).fork()).join();
    }
    if (!message.viewCount.equals(Long.ZERO)) {
      writer.uint32(168).int64(message.viewCount.toString());
    }
    if (message.filename !== "") {
      writer.uint32(178).string(message.filename);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PhotoSequence {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePhotoSequence();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.photos.push(Photo.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.uploadReference = UploadRef.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.captureTimeOverride = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.uploadTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.rawGpsTimeline.push(Pose.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.gpsSource = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.imu = Imu.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.processingState = reader.int32() as any;
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.failureReason = reader.int32() as any;
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.failureDetails = ProcessingFailureDetails.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 129) {
            break;
          }

          message.distanceMeters = reader.double();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.sequenceBounds = LatLngBounds.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.viewCount = Long.fromString(reader.int64().toString());
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.filename = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PhotoSequence {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      photos: globalThis.Array.isArray(object?.photos) ? object.photos.map((e: any) => Photo.fromJSON(e)) : [],
      uploadReference: isSet(object.uploadReference) ? UploadRef.fromJSON(object.uploadReference) : undefined,
      captureTimeOverride: isSet(object.captureTimeOverride)
        ? fromJsonTimestamp(object.captureTimeOverride)
        : undefined,
      uploadTime: isSet(object.uploadTime) ? fromJsonTimestamp(object.uploadTime) : undefined,
      rawGpsTimeline: globalThis.Array.isArray(object?.rawGpsTimeline)
        ? object.rawGpsTimeline.map((e: any) => Pose.fromJSON(e))
        : [],
      gpsSource: isSet(object.gpsSource) ? photoSequence_GpsSourceFromJSON(object.gpsSource) : 0,
      imu: isSet(object.imu) ? Imu.fromJSON(object.imu) : undefined,
      processingState: isSet(object.processingState) ? processingStateFromJSON(object.processingState) : 0,
      failureReason: isSet(object.failureReason) ? processingFailureReasonFromJSON(object.failureReason) : 0,
      failureDetails: isSet(object.failureDetails)
        ? ProcessingFailureDetails.fromJSON(object.failureDetails)
        : undefined,
      distanceMeters: isSet(object.distanceMeters) ? globalThis.Number(object.distanceMeters) : 0,
      sequenceBounds: isSet(object.sequenceBounds) ? LatLngBounds.fromJSON(object.sequenceBounds) : undefined,
      viewCount: isSet(object.viewCount) ? Long.fromValue(object.viewCount) : Long.ZERO,
      filename: isSet(object.filename) ? globalThis.String(object.filename) : "",
    };
  },

  toJSON(message: PhotoSequence): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.photos?.length) {
      obj.photos = message.photos.map((e) => Photo.toJSON(e));
    }
    if (message.uploadReference !== undefined) {
      obj.uploadReference = UploadRef.toJSON(message.uploadReference);
    }
    if (message.captureTimeOverride !== undefined) {
      obj.captureTimeOverride = message.captureTimeOverride.toISOString();
    }
    if (message.uploadTime !== undefined) {
      obj.uploadTime = message.uploadTime.toISOString();
    }
    if (message.rawGpsTimeline?.length) {
      obj.rawGpsTimeline = message.rawGpsTimeline.map((e) => Pose.toJSON(e));
    }
    if (message.gpsSource !== 0) {
      obj.gpsSource = photoSequence_GpsSourceToJSON(message.gpsSource);
    }
    if (message.imu !== undefined) {
      obj.imu = Imu.toJSON(message.imu);
    }
    if (message.processingState !== 0) {
      obj.processingState = processingStateToJSON(message.processingState);
    }
    if (message.failureReason !== 0) {
      obj.failureReason = processingFailureReasonToJSON(message.failureReason);
    }
    if (message.failureDetails !== undefined) {
      obj.failureDetails = ProcessingFailureDetails.toJSON(message.failureDetails);
    }
    if (message.distanceMeters !== 0) {
      obj.distanceMeters = message.distanceMeters;
    }
    if (message.sequenceBounds !== undefined) {
      obj.sequenceBounds = LatLngBounds.toJSON(message.sequenceBounds);
    }
    if (!message.viewCount.equals(Long.ZERO)) {
      obj.viewCount = (message.viewCount || Long.ZERO).toString();
    }
    if (message.filename !== "") {
      obj.filename = message.filename;
    }
    return obj;
  },

  create(base?: DeepPartial<PhotoSequence>): PhotoSequence {
    return PhotoSequence.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PhotoSequence>): PhotoSequence {
    const message = createBasePhotoSequence();
    message.id = object.id ?? "";
    message.photos = object.photos?.map((e) => Photo.fromPartial(e)) || [];
    message.uploadReference = (object.uploadReference !== undefined && object.uploadReference !== null)
      ? UploadRef.fromPartial(object.uploadReference)
      : undefined;
    message.captureTimeOverride = object.captureTimeOverride ?? undefined;
    message.uploadTime = object.uploadTime ?? undefined;
    message.rawGpsTimeline = object.rawGpsTimeline?.map((e) => Pose.fromPartial(e)) || [];
    message.gpsSource = object.gpsSource ?? 0;
    message.imu = (object.imu !== undefined && object.imu !== null) ? Imu.fromPartial(object.imu) : undefined;
    message.processingState = object.processingState ?? 0;
    message.failureReason = object.failureReason ?? 0;
    message.failureDetails = (object.failureDetails !== undefined && object.failureDetails !== null)
      ? ProcessingFailureDetails.fromPartial(object.failureDetails)
      : undefined;
    message.distanceMeters = object.distanceMeters ?? 0;
    message.sequenceBounds = (object.sequenceBounds !== undefined && object.sequenceBounds !== null)
      ? LatLngBounds.fromPartial(object.sequenceBounds)
      : undefined;
    message.viewCount = (object.viewCount !== undefined && object.viewCount !== null)
      ? Long.fromValue(object.viewCount)
      : Long.ZERO;
    message.filename = object.filename ?? "";
    return message;
  },
};

function createBaseLatLngBounds(): LatLngBounds {
  return { southwest: undefined, northeast: undefined };
}

export const LatLngBounds: MessageFns<LatLngBounds> = {
  encode(message: LatLngBounds, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.southwest !== undefined) {
      LatLng.encode(message.southwest, writer.uint32(10).fork()).join();
    }
    if (message.northeast !== undefined) {
      LatLng.encode(message.northeast, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LatLngBounds {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLatLngBounds();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.southwest = LatLng.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.northeast = LatLng.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LatLngBounds {
    return {
      southwest: isSet(object.southwest) ? LatLng.fromJSON(object.southwest) : undefined,
      northeast: isSet(object.northeast) ? LatLng.fromJSON(object.northeast) : undefined,
    };
  },

  toJSON(message: LatLngBounds): unknown {
    const obj: any = {};
    if (message.southwest !== undefined) {
      obj.southwest = LatLng.toJSON(message.southwest);
    }
    if (message.northeast !== undefined) {
      obj.northeast = LatLng.toJSON(message.northeast);
    }
    return obj;
  },

  create(base?: DeepPartial<LatLngBounds>): LatLngBounds {
    return LatLngBounds.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LatLngBounds>): LatLngBounds {
    const message = createBaseLatLngBounds();
    message.southwest = (object.southwest !== undefined && object.southwest !== null)
      ? LatLng.fromPartial(object.southwest)
      : undefined;
    message.northeast = (object.northeast !== undefined && object.northeast !== null)
      ? LatLng.fromPartial(object.northeast)
      : undefined;
    return message;
  },
};

function createBaseProcessingFailureDetails(): ProcessingFailureDetails {
  return {
    insufficientGpsDetails: undefined,
    gpsDataGapDetails: undefined,
    imuDataGapDetails: undefined,
    notOutdoorsDetails: undefined,
    noOverlapGpsDetails: undefined,
  };
}

export const ProcessingFailureDetails: MessageFns<ProcessingFailureDetails> = {
  encode(message: ProcessingFailureDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.insufficientGpsDetails !== undefined) {
      InsufficientGpsFailureDetails.encode(message.insufficientGpsDetails, writer.uint32(10).fork()).join();
    }
    if (message.gpsDataGapDetails !== undefined) {
      GpsDataGapFailureDetails.encode(message.gpsDataGapDetails, writer.uint32(18).fork()).join();
    }
    if (message.imuDataGapDetails !== undefined) {
      ImuDataGapFailureDetails.encode(message.imuDataGapDetails, writer.uint32(26).fork()).join();
    }
    if (message.notOutdoorsDetails !== undefined) {
      NotOutdoorsFailureDetails.encode(message.notOutdoorsDetails, writer.uint32(34).fork()).join();
    }
    if (message.noOverlapGpsDetails !== undefined) {
      NoOverlapGpsFailureDetails.encode(message.noOverlapGpsDetails, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessingFailureDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessingFailureDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.insufficientGpsDetails = InsufficientGpsFailureDetails.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.gpsDataGapDetails = GpsDataGapFailureDetails.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.imuDataGapDetails = ImuDataGapFailureDetails.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.notOutdoorsDetails = NotOutdoorsFailureDetails.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.noOverlapGpsDetails = NoOverlapGpsFailureDetails.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessingFailureDetails {
    return {
      insufficientGpsDetails: isSet(object.insufficientGpsDetails)
        ? InsufficientGpsFailureDetails.fromJSON(object.insufficientGpsDetails)
        : undefined,
      gpsDataGapDetails: isSet(object.gpsDataGapDetails)
        ? GpsDataGapFailureDetails.fromJSON(object.gpsDataGapDetails)
        : undefined,
      imuDataGapDetails: isSet(object.imuDataGapDetails)
        ? ImuDataGapFailureDetails.fromJSON(object.imuDataGapDetails)
        : undefined,
      notOutdoorsDetails: isSet(object.notOutdoorsDetails)
        ? NotOutdoorsFailureDetails.fromJSON(object.notOutdoorsDetails)
        : undefined,
      noOverlapGpsDetails: isSet(object.noOverlapGpsDetails)
        ? NoOverlapGpsFailureDetails.fromJSON(object.noOverlapGpsDetails)
        : undefined,
    };
  },

  toJSON(message: ProcessingFailureDetails): unknown {
    const obj: any = {};
    if (message.insufficientGpsDetails !== undefined) {
      obj.insufficientGpsDetails = InsufficientGpsFailureDetails.toJSON(message.insufficientGpsDetails);
    }
    if (message.gpsDataGapDetails !== undefined) {
      obj.gpsDataGapDetails = GpsDataGapFailureDetails.toJSON(message.gpsDataGapDetails);
    }
    if (message.imuDataGapDetails !== undefined) {
      obj.imuDataGapDetails = ImuDataGapFailureDetails.toJSON(message.imuDataGapDetails);
    }
    if (message.notOutdoorsDetails !== undefined) {
      obj.notOutdoorsDetails = NotOutdoorsFailureDetails.toJSON(message.notOutdoorsDetails);
    }
    if (message.noOverlapGpsDetails !== undefined) {
      obj.noOverlapGpsDetails = NoOverlapGpsFailureDetails.toJSON(message.noOverlapGpsDetails);
    }
    return obj;
  },

  create(base?: DeepPartial<ProcessingFailureDetails>): ProcessingFailureDetails {
    return ProcessingFailureDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProcessingFailureDetails>): ProcessingFailureDetails {
    const message = createBaseProcessingFailureDetails();
    message.insufficientGpsDetails =
      (object.insufficientGpsDetails !== undefined && object.insufficientGpsDetails !== null)
        ? InsufficientGpsFailureDetails.fromPartial(object.insufficientGpsDetails)
        : undefined;
    message.gpsDataGapDetails = (object.gpsDataGapDetails !== undefined && object.gpsDataGapDetails !== null)
      ? GpsDataGapFailureDetails.fromPartial(object.gpsDataGapDetails)
      : undefined;
    message.imuDataGapDetails = (object.imuDataGapDetails !== undefined && object.imuDataGapDetails !== null)
      ? ImuDataGapFailureDetails.fromPartial(object.imuDataGapDetails)
      : undefined;
    message.notOutdoorsDetails = (object.notOutdoorsDetails !== undefined && object.notOutdoorsDetails !== null)
      ? NotOutdoorsFailureDetails.fromPartial(object.notOutdoorsDetails)
      : undefined;
    message.noOverlapGpsDetails = (object.noOverlapGpsDetails !== undefined && object.noOverlapGpsDetails !== null)
      ? NoOverlapGpsFailureDetails.fromPartial(object.noOverlapGpsDetails)
      : undefined;
    return message;
  },
};

function createBaseInsufficientGpsFailureDetails(): InsufficientGpsFailureDetails {
  return { gpsPointsFound: undefined };
}

export const InsufficientGpsFailureDetails: MessageFns<InsufficientGpsFailureDetails> = {
  encode(message: InsufficientGpsFailureDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gpsPointsFound !== undefined) {
      writer.uint32(8).int32(message.gpsPointsFound);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InsufficientGpsFailureDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInsufficientGpsFailureDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.gpsPointsFound = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InsufficientGpsFailureDetails {
    return { gpsPointsFound: isSet(object.gpsPointsFound) ? globalThis.Number(object.gpsPointsFound) : undefined };
  },

  toJSON(message: InsufficientGpsFailureDetails): unknown {
    const obj: any = {};
    if (message.gpsPointsFound !== undefined) {
      obj.gpsPointsFound = Math.round(message.gpsPointsFound);
    }
    return obj;
  },

  create(base?: DeepPartial<InsufficientGpsFailureDetails>): InsufficientGpsFailureDetails {
    return InsufficientGpsFailureDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InsufficientGpsFailureDetails>): InsufficientGpsFailureDetails {
    const message = createBaseInsufficientGpsFailureDetails();
    message.gpsPointsFound = object.gpsPointsFound ?? undefined;
    return message;
  },
};

function createBaseGpsDataGapFailureDetails(): GpsDataGapFailureDetails {
  return { gapDuration: undefined, gapStartTime: undefined };
}

export const GpsDataGapFailureDetails: MessageFns<GpsDataGapFailureDetails> = {
  encode(message: GpsDataGapFailureDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gapDuration !== undefined) {
      Duration.encode(message.gapDuration, writer.uint32(10).fork()).join();
    }
    if (message.gapStartTime !== undefined) {
      Duration.encode(message.gapStartTime, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GpsDataGapFailureDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGpsDataGapFailureDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gapDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.gapStartTime = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GpsDataGapFailureDetails {
    return {
      gapDuration: isSet(object.gapDuration) ? Duration.fromJSON(object.gapDuration) : undefined,
      gapStartTime: isSet(object.gapStartTime) ? Duration.fromJSON(object.gapStartTime) : undefined,
    };
  },

  toJSON(message: GpsDataGapFailureDetails): unknown {
    const obj: any = {};
    if (message.gapDuration !== undefined) {
      obj.gapDuration = Duration.toJSON(message.gapDuration);
    }
    if (message.gapStartTime !== undefined) {
      obj.gapStartTime = Duration.toJSON(message.gapStartTime);
    }
    return obj;
  },

  create(base?: DeepPartial<GpsDataGapFailureDetails>): GpsDataGapFailureDetails {
    return GpsDataGapFailureDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GpsDataGapFailureDetails>): GpsDataGapFailureDetails {
    const message = createBaseGpsDataGapFailureDetails();
    message.gapDuration = (object.gapDuration !== undefined && object.gapDuration !== null)
      ? Duration.fromPartial(object.gapDuration)
      : undefined;
    message.gapStartTime = (object.gapStartTime !== undefined && object.gapStartTime !== null)
      ? Duration.fromPartial(object.gapStartTime)
      : undefined;
    return message;
  },
};

function createBaseImuDataGapFailureDetails(): ImuDataGapFailureDetails {
  return { gapDuration: undefined, gapStartTime: undefined };
}

export const ImuDataGapFailureDetails: MessageFns<ImuDataGapFailureDetails> = {
  encode(message: ImuDataGapFailureDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gapDuration !== undefined) {
      Duration.encode(message.gapDuration, writer.uint32(10).fork()).join();
    }
    if (message.gapStartTime !== undefined) {
      Duration.encode(message.gapStartTime, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImuDataGapFailureDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImuDataGapFailureDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gapDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.gapStartTime = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImuDataGapFailureDetails {
    return {
      gapDuration: isSet(object.gapDuration) ? Duration.fromJSON(object.gapDuration) : undefined,
      gapStartTime: isSet(object.gapStartTime) ? Duration.fromJSON(object.gapStartTime) : undefined,
    };
  },

  toJSON(message: ImuDataGapFailureDetails): unknown {
    const obj: any = {};
    if (message.gapDuration !== undefined) {
      obj.gapDuration = Duration.toJSON(message.gapDuration);
    }
    if (message.gapStartTime !== undefined) {
      obj.gapStartTime = Duration.toJSON(message.gapStartTime);
    }
    return obj;
  },

  create(base?: DeepPartial<ImuDataGapFailureDetails>): ImuDataGapFailureDetails {
    return ImuDataGapFailureDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImuDataGapFailureDetails>): ImuDataGapFailureDetails {
    const message = createBaseImuDataGapFailureDetails();
    message.gapDuration = (object.gapDuration !== undefined && object.gapDuration !== null)
      ? Duration.fromPartial(object.gapDuration)
      : undefined;
    message.gapStartTime = (object.gapStartTime !== undefined && object.gapStartTime !== null)
      ? Duration.fromPartial(object.gapStartTime)
      : undefined;
    return message;
  },
};

function createBaseNotOutdoorsFailureDetails(): NotOutdoorsFailureDetails {
  return { startTime: undefined };
}

export const NotOutdoorsFailureDetails: MessageFns<NotOutdoorsFailureDetails> = {
  encode(message: NotOutdoorsFailureDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startTime !== undefined) {
      Duration.encode(message.startTime, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotOutdoorsFailureDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotOutdoorsFailureDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startTime = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotOutdoorsFailureDetails {
    return { startTime: isSet(object.startTime) ? Duration.fromJSON(object.startTime) : undefined };
  },

  toJSON(message: NotOutdoorsFailureDetails): unknown {
    const obj: any = {};
    if (message.startTime !== undefined) {
      obj.startTime = Duration.toJSON(message.startTime);
    }
    return obj;
  },

  create(base?: DeepPartial<NotOutdoorsFailureDetails>): NotOutdoorsFailureDetails {
    return NotOutdoorsFailureDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NotOutdoorsFailureDetails>): NotOutdoorsFailureDetails {
    const message = createBaseNotOutdoorsFailureDetails();
    message.startTime = (object.startTime !== undefined && object.startTime !== null)
      ? Duration.fromPartial(object.startTime)
      : undefined;
    return message;
  },
};

function createBaseNoOverlapGpsFailureDetails(): NoOverlapGpsFailureDetails {
  return { gpsStartTime: undefined, gpsEndTime: undefined, videoStartTime: undefined, videoEndTime: undefined };
}

export const NoOverlapGpsFailureDetails: MessageFns<NoOverlapGpsFailureDetails> = {
  encode(message: NoOverlapGpsFailureDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gpsStartTime !== undefined) {
      Timestamp.encode(toTimestamp(message.gpsStartTime), writer.uint32(10).fork()).join();
    }
    if (message.gpsEndTime !== undefined) {
      Timestamp.encode(toTimestamp(message.gpsEndTime), writer.uint32(18).fork()).join();
    }
    if (message.videoStartTime !== undefined) {
      Timestamp.encode(toTimestamp(message.videoStartTime), writer.uint32(26).fork()).join();
    }
    if (message.videoEndTime !== undefined) {
      Timestamp.encode(toTimestamp(message.videoEndTime), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NoOverlapGpsFailureDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNoOverlapGpsFailureDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gpsStartTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.gpsEndTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.videoStartTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.videoEndTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NoOverlapGpsFailureDetails {
    return {
      gpsStartTime: isSet(object.gpsStartTime) ? fromJsonTimestamp(object.gpsStartTime) : undefined,
      gpsEndTime: isSet(object.gpsEndTime) ? fromJsonTimestamp(object.gpsEndTime) : undefined,
      videoStartTime: isSet(object.videoStartTime) ? fromJsonTimestamp(object.videoStartTime) : undefined,
      videoEndTime: isSet(object.videoEndTime) ? fromJsonTimestamp(object.videoEndTime) : undefined,
    };
  },

  toJSON(message: NoOverlapGpsFailureDetails): unknown {
    const obj: any = {};
    if (message.gpsStartTime !== undefined) {
      obj.gpsStartTime = message.gpsStartTime.toISOString();
    }
    if (message.gpsEndTime !== undefined) {
      obj.gpsEndTime = message.gpsEndTime.toISOString();
    }
    if (message.videoStartTime !== undefined) {
      obj.videoStartTime = message.videoStartTime.toISOString();
    }
    if (message.videoEndTime !== undefined) {
      obj.videoEndTime = message.videoEndTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<NoOverlapGpsFailureDetails>): NoOverlapGpsFailureDetails {
    return NoOverlapGpsFailureDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NoOverlapGpsFailureDetails>): NoOverlapGpsFailureDetails {
    const message = createBaseNoOverlapGpsFailureDetails();
    message.gpsStartTime = object.gpsStartTime ?? undefined;
    message.gpsEndTime = object.gpsEndTime ?? undefined;
    message.videoStartTime = object.videoStartTime ?? undefined;
    message.videoEndTime = object.videoEndTime ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
