// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/chromeos/moblab/v1beta1/build_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../longrunning/operations.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Build, BuildArtifact, BuildTarget, Model } from "./resources.js";

export const protobufPackage = "google.chromeos.moblab.v1beta1";

/**
 * Request message for finding the most stable build.
 * -- NEXT_TAG: 2 --
 */
export interface FindMostStableBuildRequest {
  /**
   * Required. The full resource name of the build target.
   * For example,
   * 'buildTargets/octopus'.
   */
  buildTarget: string;
}

/**
 * Response message for finding the most stable build.
 * -- NEXT_TAG: 2 --
 */
export interface FindMostStableBuildResponse {
  /** The most stable build. */
  build: Build | undefined;
}

/**
 * Request message for listing build targets.
 * -- NEXT_TAG: 3 --
 */
export interface ListBuildTargetsRequest {
  /** Optional. The number of build targets to return in a page. */
  pageSize: number;
  /**
   * Optional. A page token, received from a previous `ListBuildTargets` call.
   * Provide this to retrieve the subsequent page.
   */
  pageToken: string;
}

/**
 * Response message for listing build targets.
 * -- NEXT_TAG: 4 --
 */
export interface ListBuildTargetsResponse {
  /** The list of build targets. */
  buildTargets: BuildTarget[];
  /**
   * Token to retrieve the next page of build targets. If this field is omitted,
   * there are no subsequent pages.
   */
  nextPageToken: string;
  /** Total number of build targets. */
  totalSize: number;
}

/**
 * Request message for listing models.
 * -- NEXT_TAG: 4 --
 */
export interface ListModelsRequest {
  /** Required. The full resource name of build target. */
  parent: string;
  /** Optional. The number of models to return in a page. */
  pageSize: number;
  /**
   * Optional. A page token, received from a previous `ListModels` call. Provide
   * this to retrieve the subsequent page.
   */
  pageToken: string;
}

/**
 * Response message for listing models.
 * -- NEXT_TAG: 4 --
 */
export interface ListModelsResponse {
  /** The list of models. */
  models: Model[];
  /**
   * Token to retrieve the next page of models. If this field is omitted, there
   * are no subsequent pages.
   */
  nextPageToken: string;
  /** Total number of models. */
  totalSize: number;
}

/**
 * Request message for listing builds.
 * -- NEXT_TAG: 7 --
 */
export interface ListBuildsRequest {
  /**
   * Required. The full resource name of the model. The model id is the same as
   * the build target id for non-unified builds.
   * For example,
   * 'buildTargets/octopus/models/bobba'.
   */
  parent: string;
  /** Optional. The number of builds to return in a page. */
  pageSize: number;
  /**
   * Optional. A page token, received from a previous `ListBuilds` call. Provide
   * this to retrieve the subsequent page.
   */
  pageToken: string;
  /**
   * Optional. Filter that specifies value constraints of fields. For example,
   * the filter can be set as "filter='milestone=milestones/80'" to only select
   * builds in milestone 80.
   */
  filter: string;
  /**
   * Optional. Read mask that specifies which Build fields to return. If empty,
   * all Build fields will be returned. Valid fields: name, milestone,
   * build_version. For example, if the read_mask is set as
   * "read_mask='milestone'", the ListBuilds will return a list of Builds object
   * with only the milestone field.
   */
  readMask:
    | string[]
    | undefined;
  /**
   * Optional. The operation that groups by all the Build fields specified in
   * the read mask. The group_by field should be the same as the read_mask field
   * in convention of SQL.
   */
  groupBy: string[] | undefined;
}

/**
 * Response message for listing builds.
 * -- NEXT_TAG: 4 --
 */
export interface ListBuildsResponse {
  /** The list of builds. */
  builds: Build[];
  /**
   * Token to retrieve the next page of builds. If this field is omitted, there
   * are no subsequent pages.
   */
  nextPageToken: string;
  /** Total number of builds. */
  totalSize: number;
}

/**
 * Request message for checking if the build artifact is staged.
 * -- NEXT_TAG: 3 --
 */
export interface CheckBuildStageStatusRequest {
  /**
   * Required. The full resource name of the build artifact.
   * For example,
   * 'buildTargets/octopus/models/bobba/builds/12607.6.0/artifacts/chromeos-moblab-peng-staging'.
   */
  name: string;
  /**
   * Optional. Filter that specifies value constraints of fields. For example,
   * the filter can be set as "filter='type=release'" to only check the release
   * builds.
   */
  filter: string;
}

/**
 * Response message for checking the stage status of a build artifact.
 * -- NEXT_TAG: 4 --
 */
export interface CheckBuildStageStatusResponse {
  /** The status to represent if the build is staged or not. */
  isBuildStaged: boolean;
  /** The staged build artifact in the destination bucket. */
  stagedBuildArtifact:
    | BuildArtifact
    | undefined;
  /** The source build artifact in the source bucket. */
  sourceBuildArtifact: BuildArtifact | undefined;
}

/**
 * Request message for staging a build artifact.
 * -- NEXT_TAG: 3 --
 */
export interface StageBuildRequest {
  /**
   * Required. The full resource name of the build artifact.
   * For example,
   * 'buildTargets/octopus/models/bobba/builds/12607.6.0/artifacts/chromeos-moblab-peng-staging'.
   */
  name: string;
  /**
   * Optional. Filter that specifies value constraints of fields. For example,
   * the filter can be set as "filter='type=release'" to only check the release
   * builds.
   */
  filter: string;
}

/**
 * Response message for staging a build artifact.
 * -- NEXT_TAG: 2 --
 */
export interface StageBuildResponse {
  /** The staged build in the destination bucket. */
  stagedBuildArtifact: BuildArtifact | undefined;
}

/**
 * Metadata message for staging a build artifact.
 * -- NEXT_TAG: 4 --
 */
export interface StageBuildMetadata {
  /** Approximate percentage of progress, e.g. "50" means 50%. */
  progressPercent: number;
  /** Build stage start time. */
  startTime:
    | Date
    | undefined;
  /** Build stage end time. */
  endTime: Date | undefined;
}

function createBaseFindMostStableBuildRequest(): FindMostStableBuildRequest {
  return { buildTarget: "" };
}

export const FindMostStableBuildRequest: MessageFns<FindMostStableBuildRequest> = {
  encode(message: FindMostStableBuildRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.buildTarget !== "") {
      writer.uint32(10).string(message.buildTarget);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FindMostStableBuildRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFindMostStableBuildRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.buildTarget = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FindMostStableBuildRequest {
    return { buildTarget: isSet(object.buildTarget) ? globalThis.String(object.buildTarget) : "" };
  },

  toJSON(message: FindMostStableBuildRequest): unknown {
    const obj: any = {};
    if (message.buildTarget !== "") {
      obj.buildTarget = message.buildTarget;
    }
    return obj;
  },

  create(base?: DeepPartial<FindMostStableBuildRequest>): FindMostStableBuildRequest {
    return FindMostStableBuildRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FindMostStableBuildRequest>): FindMostStableBuildRequest {
    const message = createBaseFindMostStableBuildRequest();
    message.buildTarget = object.buildTarget ?? "";
    return message;
  },
};

function createBaseFindMostStableBuildResponse(): FindMostStableBuildResponse {
  return { build: undefined };
}

export const FindMostStableBuildResponse: MessageFns<FindMostStableBuildResponse> = {
  encode(message: FindMostStableBuildResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.build !== undefined) {
      Build.encode(message.build, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FindMostStableBuildResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFindMostStableBuildResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.build = Build.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FindMostStableBuildResponse {
    return { build: isSet(object.build) ? Build.fromJSON(object.build) : undefined };
  },

  toJSON(message: FindMostStableBuildResponse): unknown {
    const obj: any = {};
    if (message.build !== undefined) {
      obj.build = Build.toJSON(message.build);
    }
    return obj;
  },

  create(base?: DeepPartial<FindMostStableBuildResponse>): FindMostStableBuildResponse {
    return FindMostStableBuildResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FindMostStableBuildResponse>): FindMostStableBuildResponse {
    const message = createBaseFindMostStableBuildResponse();
    message.build = (object.build !== undefined && object.build !== null) ? Build.fromPartial(object.build) : undefined;
    return message;
  },
};

function createBaseListBuildTargetsRequest(): ListBuildTargetsRequest {
  return { pageSize: 0, pageToken: "" };
}

export const ListBuildTargetsRequest: MessageFns<ListBuildTargetsRequest> = {
  encode(message: ListBuildTargetsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListBuildTargetsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBuildTargetsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBuildTargetsRequest {
    return {
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListBuildTargetsRequest): unknown {
    const obj: any = {};
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListBuildTargetsRequest>): ListBuildTargetsRequest {
    return ListBuildTargetsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListBuildTargetsRequest>): ListBuildTargetsRequest {
    const message = createBaseListBuildTargetsRequest();
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListBuildTargetsResponse(): ListBuildTargetsResponse {
  return { buildTargets: [], nextPageToken: "", totalSize: 0 };
}

export const ListBuildTargetsResponse: MessageFns<ListBuildTargetsResponse> = {
  encode(message: ListBuildTargetsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.buildTargets) {
      BuildTarget.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    if (message.totalSize !== 0) {
      writer.uint32(24).int32(message.totalSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListBuildTargetsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBuildTargetsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.buildTargets.push(BuildTarget.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBuildTargetsResponse {
    return {
      buildTargets: globalThis.Array.isArray(object?.buildTargets)
        ? object.buildTargets.map((e: any) => BuildTarget.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      totalSize: isSet(object.totalSize) ? globalThis.Number(object.totalSize) : 0,
    };
  },

  toJSON(message: ListBuildTargetsResponse): unknown {
    const obj: any = {};
    if (message.buildTargets?.length) {
      obj.buildTargets = message.buildTargets.map((e) => BuildTarget.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.totalSize !== 0) {
      obj.totalSize = Math.round(message.totalSize);
    }
    return obj;
  },

  create(base?: DeepPartial<ListBuildTargetsResponse>): ListBuildTargetsResponse {
    return ListBuildTargetsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListBuildTargetsResponse>): ListBuildTargetsResponse {
    const message = createBaseListBuildTargetsResponse();
    message.buildTargets = object.buildTargets?.map((e) => BuildTarget.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.totalSize = object.totalSize ?? 0;
    return message;
  },
};

function createBaseListModelsRequest(): ListModelsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListModelsRequest: MessageFns<ListModelsRequest> = {
  encode(message: ListModelsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListModelsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListModelsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListModelsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListModelsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListModelsRequest>): ListModelsRequest {
    return ListModelsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListModelsRequest>): ListModelsRequest {
    const message = createBaseListModelsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListModelsResponse(): ListModelsResponse {
  return { models: [], nextPageToken: "", totalSize: 0 };
}

export const ListModelsResponse: MessageFns<ListModelsResponse> = {
  encode(message: ListModelsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.models) {
      Model.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    if (message.totalSize !== 0) {
      writer.uint32(24).int32(message.totalSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListModelsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListModelsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.models.push(Model.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListModelsResponse {
    return {
      models: globalThis.Array.isArray(object?.models) ? object.models.map((e: any) => Model.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      totalSize: isSet(object.totalSize) ? globalThis.Number(object.totalSize) : 0,
    };
  },

  toJSON(message: ListModelsResponse): unknown {
    const obj: any = {};
    if (message.models?.length) {
      obj.models = message.models.map((e) => Model.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.totalSize !== 0) {
      obj.totalSize = Math.round(message.totalSize);
    }
    return obj;
  },

  create(base?: DeepPartial<ListModelsResponse>): ListModelsResponse {
    return ListModelsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListModelsResponse>): ListModelsResponse {
    const message = createBaseListModelsResponse();
    message.models = object.models?.map((e) => Model.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.totalSize = object.totalSize ?? 0;
    return message;
  },
};

function createBaseListBuildsRequest(): ListBuildsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", readMask: undefined, groupBy: undefined };
}

export const ListBuildsRequest: MessageFns<ListBuildsRequest> = {
  encode(message: ListBuildsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.readMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.readMask), writer.uint32(42).fork()).join();
    }
    if (message.groupBy !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.groupBy), writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListBuildsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBuildsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.readMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.groupBy = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBuildsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      readMask: isSet(object.readMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.readMask)) : undefined,
      groupBy: isSet(object.groupBy) ? FieldMask.unwrap(FieldMask.fromJSON(object.groupBy)) : undefined,
    };
  },

  toJSON(message: ListBuildsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.readMask !== undefined) {
      obj.readMask = FieldMask.toJSON(FieldMask.wrap(message.readMask));
    }
    if (message.groupBy !== undefined) {
      obj.groupBy = FieldMask.toJSON(FieldMask.wrap(message.groupBy));
    }
    return obj;
  },

  create(base?: DeepPartial<ListBuildsRequest>): ListBuildsRequest {
    return ListBuildsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListBuildsRequest>): ListBuildsRequest {
    const message = createBaseListBuildsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.readMask = object.readMask ?? undefined;
    message.groupBy = object.groupBy ?? undefined;
    return message;
  },
};

function createBaseListBuildsResponse(): ListBuildsResponse {
  return { builds: [], nextPageToken: "", totalSize: 0 };
}

export const ListBuildsResponse: MessageFns<ListBuildsResponse> = {
  encode(message: ListBuildsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.builds) {
      Build.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    if (message.totalSize !== 0) {
      writer.uint32(24).int32(message.totalSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListBuildsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBuildsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.builds.push(Build.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBuildsResponse {
    return {
      builds: globalThis.Array.isArray(object?.builds) ? object.builds.map((e: any) => Build.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      totalSize: isSet(object.totalSize) ? globalThis.Number(object.totalSize) : 0,
    };
  },

  toJSON(message: ListBuildsResponse): unknown {
    const obj: any = {};
    if (message.builds?.length) {
      obj.builds = message.builds.map((e) => Build.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.totalSize !== 0) {
      obj.totalSize = Math.round(message.totalSize);
    }
    return obj;
  },

  create(base?: DeepPartial<ListBuildsResponse>): ListBuildsResponse {
    return ListBuildsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListBuildsResponse>): ListBuildsResponse {
    const message = createBaseListBuildsResponse();
    message.builds = object.builds?.map((e) => Build.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.totalSize = object.totalSize ?? 0;
    return message;
  },
};

function createBaseCheckBuildStageStatusRequest(): CheckBuildStageStatusRequest {
  return { name: "", filter: "" };
}

export const CheckBuildStageStatusRequest: MessageFns<CheckBuildStageStatusRequest> = {
  encode(message: CheckBuildStageStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.filter !== "") {
      writer.uint32(18).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckBuildStageStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckBuildStageStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckBuildStageStatusRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: CheckBuildStageStatusRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<CheckBuildStageStatusRequest>): CheckBuildStageStatusRequest {
    return CheckBuildStageStatusRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CheckBuildStageStatusRequest>): CheckBuildStageStatusRequest {
    const message = createBaseCheckBuildStageStatusRequest();
    message.name = object.name ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseCheckBuildStageStatusResponse(): CheckBuildStageStatusResponse {
  return { isBuildStaged: false, stagedBuildArtifact: undefined, sourceBuildArtifact: undefined };
}

export const CheckBuildStageStatusResponse: MessageFns<CheckBuildStageStatusResponse> = {
  encode(message: CheckBuildStageStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isBuildStaged !== false) {
      writer.uint32(8).bool(message.isBuildStaged);
    }
    if (message.stagedBuildArtifact !== undefined) {
      BuildArtifact.encode(message.stagedBuildArtifact, writer.uint32(18).fork()).join();
    }
    if (message.sourceBuildArtifact !== undefined) {
      BuildArtifact.encode(message.sourceBuildArtifact, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckBuildStageStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckBuildStageStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.isBuildStaged = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stagedBuildArtifact = BuildArtifact.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sourceBuildArtifact = BuildArtifact.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckBuildStageStatusResponse {
    return {
      isBuildStaged: isSet(object.isBuildStaged) ? globalThis.Boolean(object.isBuildStaged) : false,
      stagedBuildArtifact: isSet(object.stagedBuildArtifact)
        ? BuildArtifact.fromJSON(object.stagedBuildArtifact)
        : undefined,
      sourceBuildArtifact: isSet(object.sourceBuildArtifact)
        ? BuildArtifact.fromJSON(object.sourceBuildArtifact)
        : undefined,
    };
  },

  toJSON(message: CheckBuildStageStatusResponse): unknown {
    const obj: any = {};
    if (message.isBuildStaged !== false) {
      obj.isBuildStaged = message.isBuildStaged;
    }
    if (message.stagedBuildArtifact !== undefined) {
      obj.stagedBuildArtifact = BuildArtifact.toJSON(message.stagedBuildArtifact);
    }
    if (message.sourceBuildArtifact !== undefined) {
      obj.sourceBuildArtifact = BuildArtifact.toJSON(message.sourceBuildArtifact);
    }
    return obj;
  },

  create(base?: DeepPartial<CheckBuildStageStatusResponse>): CheckBuildStageStatusResponse {
    return CheckBuildStageStatusResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CheckBuildStageStatusResponse>): CheckBuildStageStatusResponse {
    const message = createBaseCheckBuildStageStatusResponse();
    message.isBuildStaged = object.isBuildStaged ?? false;
    message.stagedBuildArtifact = (object.stagedBuildArtifact !== undefined && object.stagedBuildArtifact !== null)
      ? BuildArtifact.fromPartial(object.stagedBuildArtifact)
      : undefined;
    message.sourceBuildArtifact = (object.sourceBuildArtifact !== undefined && object.sourceBuildArtifact !== null)
      ? BuildArtifact.fromPartial(object.sourceBuildArtifact)
      : undefined;
    return message;
  },
};

function createBaseStageBuildRequest(): StageBuildRequest {
  return { name: "", filter: "" };
}

export const StageBuildRequest: MessageFns<StageBuildRequest> = {
  encode(message: StageBuildRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.filter !== "") {
      writer.uint32(18).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StageBuildRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStageBuildRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StageBuildRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: StageBuildRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<StageBuildRequest>): StageBuildRequest {
    return StageBuildRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StageBuildRequest>): StageBuildRequest {
    const message = createBaseStageBuildRequest();
    message.name = object.name ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseStageBuildResponse(): StageBuildResponse {
  return { stagedBuildArtifact: undefined };
}

export const StageBuildResponse: MessageFns<StageBuildResponse> = {
  encode(message: StageBuildResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stagedBuildArtifact !== undefined) {
      BuildArtifact.encode(message.stagedBuildArtifact, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StageBuildResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStageBuildResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.stagedBuildArtifact = BuildArtifact.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StageBuildResponse {
    return {
      stagedBuildArtifact: isSet(object.stagedBuildArtifact)
        ? BuildArtifact.fromJSON(object.stagedBuildArtifact)
        : undefined,
    };
  },

  toJSON(message: StageBuildResponse): unknown {
    const obj: any = {};
    if (message.stagedBuildArtifact !== undefined) {
      obj.stagedBuildArtifact = BuildArtifact.toJSON(message.stagedBuildArtifact);
    }
    return obj;
  },

  create(base?: DeepPartial<StageBuildResponse>): StageBuildResponse {
    return StageBuildResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StageBuildResponse>): StageBuildResponse {
    const message = createBaseStageBuildResponse();
    message.stagedBuildArtifact = (object.stagedBuildArtifact !== undefined && object.stagedBuildArtifact !== null)
      ? BuildArtifact.fromPartial(object.stagedBuildArtifact)
      : undefined;
    return message;
  },
};

function createBaseStageBuildMetadata(): StageBuildMetadata {
  return { progressPercent: 0, startTime: undefined, endTime: undefined };
}

export const StageBuildMetadata: MessageFns<StageBuildMetadata> = {
  encode(message: StageBuildMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.progressPercent !== 0) {
      writer.uint32(13).float(message.progressPercent);
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(18).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StageBuildMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStageBuildMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.progressPercent = reader.float();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StageBuildMetadata {
    return {
      progressPercent: isSet(object.progressPercent) ? globalThis.Number(object.progressPercent) : 0,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: StageBuildMetadata): unknown {
    const obj: any = {};
    if (message.progressPercent !== 0) {
      obj.progressPercent = message.progressPercent;
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<StageBuildMetadata>): StageBuildMetadata {
    return StageBuildMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StageBuildMetadata>): StageBuildMetadata {
    const message = createBaseStageBuildMetadata();
    message.progressPercent = object.progressPercent ?? 0;
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

/** Manages Chrome OS build services. */
export type BuildServiceDefinition = typeof BuildServiceDefinition;
export const BuildServiceDefinition = {
  name: "BuildService",
  fullName: "google.chromeos.moblab.v1beta1.BuildService",
  methods: {
    /** Lists all build targets that a user has access to. */
    listBuildTargets: {
      name: "ListBuildTargets",
      requestType: ListBuildTargetsRequest,
      requestStream: false,
      responseType: ListBuildTargetsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              23,
              18,
              21,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              98,
              117,
              105,
              108,
              100,
              84,
              97,
              114,
              103,
              101,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Lists all models for the given build target. */
    listModels: {
      name: "ListModels",
      requestType: ListModelsRequest,
      requestStream: false,
      responseType: ListModelsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              41,
              18,
              39,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              98,
              117,
              105,
              108,
              100,
              84,
              97,
              114,
              103,
              101,
              116,
              115,
              47,
              42,
              125,
              47,
              109,
              111,
              100,
              101,
              108,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Lists all builds for the given build target and model in descending order
     * for the milestones and build versions.
     */
    listBuilds: {
      name: "ListBuilds",
      requestType: ListBuildsRequest,
      requestStream: false,
      responseType: ListBuildsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              50,
              18,
              48,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              98,
              117,
              105,
              108,
              100,
              84,
              97,
              114,
              103,
              101,
              116,
              115,
              47,
              42,
              47,
              109,
              111,
              100,
              101,
              108,
              115,
              47,
              42,
              125,
              47,
              98,
              117,
              105,
              108,
              100,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Checks the stage status for a given build artifact in a partner Google
     * Cloud Storage bucket.
     */
    checkBuildStageStatus: {
      name: "CheckBuildStageStatus",
      requestType: CheckBuildStageStatusRequest,
      requestStream: false,
      responseType: CheckBuildStageStatusResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              68,
              18,
              66,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              98,
              117,
              105,
              108,
              100,
              84,
              97,
              114,
              103,
              101,
              116,
              115,
              47,
              42,
              47,
              109,
              111,
              100,
              101,
              108,
              115,
              47,
              42,
              47,
              98,
              117,
              105,
              108,
              100,
              115,
              47,
              42,
              47,
              97,
              114,
              116,
              105,
              102,
              97,
              99,
              116,
              115,
              47,
              42,
              125,
              58,
              99,
              104,
              101,
              99,
              107,
            ]),
          ],
        },
      },
    },
    /**
     * Stages a given build artifact from a internal Google Cloud Storage bucket
     * to a partner Google Cloud Storage bucket. The stage will be skipped if all
     * the objects in the partner bucket are the same as in the internal bucket.
     * Operation
     * <response:[StageBuildResponse][google.chromeos.moblab.v1beta1.StageBuildResponse],
     *            metadata:
     *           [StageBuildMetadata][google.chromeos.moblab.v1beta1.StageBuildMetadata]>
     */
    stageBuild: {
      name: "StageBuild",
      requestType: StageBuildRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              40,
              10,
              18,
              83,
              116,
              97,
              103,
              101,
              66,
              117,
              105,
              108,
              100,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              18,
              83,
              116,
              97,
              103,
              101,
              66,
              117,
              105,
              108,
              100,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              71,
              58,
              1,
              42,
              34,
              66,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              98,
              117,
              105,
              108,
              100,
              84,
              97,
              114,
              103,
              101,
              116,
              115,
              47,
              42,
              47,
              109,
              111,
              100,
              101,
              108,
              115,
              47,
              42,
              47,
              98,
              117,
              105,
              108,
              100,
              115,
              47,
              42,
              47,
              97,
              114,
              116,
              105,
              102,
              97,
              99,
              116,
              115,
              47,
              42,
              125,
              58,
              115,
              116,
              97,
              103,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Finds the most stable build for the given build target. The definition of
     * the most stable build is determined by evaluating the following rule in
     * order until one is true. If none are true, then there is no stable build
     * and it will return an empty response.
     *
     * Evaluation rules:
     *   1. Stable channel build with label Live
     *   2. Beta channel build with label Live
     *   3. Dev channel build with label Live
     *   4. Most recent stable channel build with build status Pass
     *   5. Most recent beta channel build with build status Pass
     *   6. Most recent dev channel build with build status Pass
     */
    findMostStableBuild: {
      name: "FindMostStableBuild",
      requestType: FindMostStableBuildRequest,
      requestStream: false,
      responseType: FindMostStableBuildResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([12, 98, 117, 105, 108, 100, 95, 116, 97, 114, 103, 101, 116])],
          578365826: [
            Buffer.from([
              60,
              18,
              58,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              98,
              117,
              105,
              108,
              100,
              95,
              116,
              97,
              114,
              103,
              101,
              116,
              61,
              98,
              117,
              105,
              108,
              100,
              84,
              97,
              114,
              103,
              101,
              116,
              115,
              47,
              42,
              125,
              58,
              102,
              105,
              110,
              100,
              77,
              111,
              115,
              116,
              83,
              116,
              97,
              98,
              108,
              101,
              66,
              117,
              105,
              108,
              100,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface BuildServiceImplementation<CallContextExt = {}> {
  /** Lists all build targets that a user has access to. */
  listBuildTargets(
    request: ListBuildTargetsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListBuildTargetsResponse>>;
  /** Lists all models for the given build target. */
  listModels(
    request: ListModelsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListModelsResponse>>;
  /**
   * Lists all builds for the given build target and model in descending order
   * for the milestones and build versions.
   */
  listBuilds(
    request: ListBuildsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListBuildsResponse>>;
  /**
   * Checks the stage status for a given build artifact in a partner Google
   * Cloud Storage bucket.
   */
  checkBuildStageStatus(
    request: CheckBuildStageStatusRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CheckBuildStageStatusResponse>>;
  /**
   * Stages a given build artifact from a internal Google Cloud Storage bucket
   * to a partner Google Cloud Storage bucket. The stage will be skipped if all
   * the objects in the partner bucket are the same as in the internal bucket.
   * Operation
   * <response:[StageBuildResponse][google.chromeos.moblab.v1beta1.StageBuildResponse],
   *            metadata:
   *           [StageBuildMetadata][google.chromeos.moblab.v1beta1.StageBuildMetadata]>
   */
  stageBuild(request: StageBuildRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /**
   * Finds the most stable build for the given build target. The definition of
   * the most stable build is determined by evaluating the following rule in
   * order until one is true. If none are true, then there is no stable build
   * and it will return an empty response.
   *
   * Evaluation rules:
   *   1. Stable channel build with label Live
   *   2. Beta channel build with label Live
   *   3. Dev channel build with label Live
   *   4. Most recent stable channel build with build status Pass
   *   5. Most recent beta channel build with build status Pass
   *   6. Most recent dev channel build with build status Pass
   */
  findMostStableBuild(
    request: FindMostStableBuildRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<FindMostStableBuildResponse>>;
}

export interface BuildServiceClient<CallOptionsExt = {}> {
  /** Lists all build targets that a user has access to. */
  listBuildTargets(
    request: DeepPartial<ListBuildTargetsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListBuildTargetsResponse>;
  /** Lists all models for the given build target. */
  listModels(
    request: DeepPartial<ListModelsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListModelsResponse>;
  /**
   * Lists all builds for the given build target and model in descending order
   * for the milestones and build versions.
   */
  listBuilds(
    request: DeepPartial<ListBuildsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListBuildsResponse>;
  /**
   * Checks the stage status for a given build artifact in a partner Google
   * Cloud Storage bucket.
   */
  checkBuildStageStatus(
    request: DeepPartial<CheckBuildStageStatusRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CheckBuildStageStatusResponse>;
  /**
   * Stages a given build artifact from a internal Google Cloud Storage bucket
   * to a partner Google Cloud Storage bucket. The stage will be skipped if all
   * the objects in the partner bucket are the same as in the internal bucket.
   * Operation
   * <response:[StageBuildResponse][google.chromeos.moblab.v1beta1.StageBuildResponse],
   *            metadata:
   *           [StageBuildMetadata][google.chromeos.moblab.v1beta1.StageBuildMetadata]>
   */
  stageBuild(request: DeepPartial<StageBuildRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /**
   * Finds the most stable build for the given build target. The definition of
   * the most stable build is determined by evaluating the following rule in
   * order until one is true. If none are true, then there is no stable build
   * and it will return an empty response.
   *
   * Evaluation rules:
   *   1. Stable channel build with label Live
   *   2. Beta channel build with label Live
   *   3. Dev channel build with label Live
   *   4. Most recent stable channel build with build status Pass
   *   5. Most recent beta channel build with build status Pass
   *   6. Most recent dev channel build with build status Pass
   */
  findMostStableBuild(
    request: DeepPartial<FindMostStableBuildRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<FindMostStableBuildResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
