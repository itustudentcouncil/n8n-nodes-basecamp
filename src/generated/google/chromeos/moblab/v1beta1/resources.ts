// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/chromeos/moblab/v1beta1/resources.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "google.chromeos.moblab.v1beta1";

/**
 * Resource that represents a build target.
 * -- NEXT_TAG: 2 --
 */
export interface BuildTarget {
  /**
   * The resource name of the build target.
   * Format: buildTargets/{build_target}
   */
  name: string;
}

/**
 * Resource that represents a model. Each model belongs to a build target. For
 * non-unified build, the model name is the same as its build target name.
 * -- NEXT_TAG: 2 --
 */
export interface Model {
  /**
   * The resource name of the model.
   * Format: buildTargets/{build_target}/models/{model}
   */
  name: string;
}

/**
 * Resource that represents a chrome OS milestone.
 * -- NEXT_TAG: 2 --
 */
export interface Milestone {
  /**
   * The resource name of the milestone.
   * Format: milestones/{milestone}
   */
  name: string;
}

/**
 * Resource that represents a build for the given build target, model, milestone
 * and build version.
 * -- NEXT_TAG: 9 --
 */
export interface Build {
  /**
   * The resource name of the build.
   * Format: buildTargets/{build_target}/models/{model}/builds/{build}
   * Example: buildTargets/octopus/models/bobba/builds/1234.0.0
   */
  name: string;
  /**
   * The milestone that owns the build.
   * Format: milestones/{milestone}
   */
  milestone: string;
  /** The build version of the build, e.g. 1234.0.0. */
  buildVersion: string;
  /** The status of the build. */
  status: Build_BuildStatus;
  /** The type of the build. */
  type: Build_BuildType;
  /** The branch of the build. */
  branch: string;
  /**
   * The firmware version of the software that is flashed to the chip on the
   * Chrome OS device.
   */
  rwFirmwareVersion: string;
  /** The labels of the build. */
  labels: string[];
}

/** The build status types. */
export enum Build_BuildStatus {
  /** BUILD_STATUS_UNSPECIFIED - No build status is specified. */
  BUILD_STATUS_UNSPECIFIED = 0,
  /** PASS - Complete Status: The build passed. */
  PASS = 1,
  /** FAIL - Complete Status: The build failed. */
  FAIL = 2,
  /** RUNNING - Intermediate Status: The build is still running. */
  RUNNING = 3,
  /** ABORTED - Complete Status: The build was aborted. */
  ABORTED = 4,
  UNRECOGNIZED = -1,
}

export function build_BuildStatusFromJSON(object: any): Build_BuildStatus {
  switch (object) {
    case 0:
    case "BUILD_STATUS_UNSPECIFIED":
      return Build_BuildStatus.BUILD_STATUS_UNSPECIFIED;
    case 1:
    case "PASS":
      return Build_BuildStatus.PASS;
    case 2:
    case "FAIL":
      return Build_BuildStatus.FAIL;
    case 3:
    case "RUNNING":
      return Build_BuildStatus.RUNNING;
    case 4:
    case "ABORTED":
      return Build_BuildStatus.ABORTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Build_BuildStatus.UNRECOGNIZED;
  }
}

export function build_BuildStatusToJSON(object: Build_BuildStatus): string {
  switch (object) {
    case Build_BuildStatus.BUILD_STATUS_UNSPECIFIED:
      return "BUILD_STATUS_UNSPECIFIED";
    case Build_BuildStatus.PASS:
      return "PASS";
    case Build_BuildStatus.FAIL:
      return "FAIL";
    case Build_BuildStatus.RUNNING:
      return "RUNNING";
    case Build_BuildStatus.ABORTED:
      return "ABORTED";
    case Build_BuildStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The build types. */
export enum Build_BuildType {
  /** BUILD_TYPE_UNSPECIFIED - Invalid build type. */
  BUILD_TYPE_UNSPECIFIED = 0,
  /** RELEASE - The release build. */
  RELEASE = 1,
  /** FIRMWARE - The firmware build. */
  FIRMWARE = 2,
  UNRECOGNIZED = -1,
}

export function build_BuildTypeFromJSON(object: any): Build_BuildType {
  switch (object) {
    case 0:
    case "BUILD_TYPE_UNSPECIFIED":
      return Build_BuildType.BUILD_TYPE_UNSPECIFIED;
    case 1:
    case "RELEASE":
      return Build_BuildType.RELEASE;
    case 2:
    case "FIRMWARE":
      return Build_BuildType.FIRMWARE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Build_BuildType.UNRECOGNIZED;
  }
}

export function build_BuildTypeToJSON(object: Build_BuildType): string {
  switch (object) {
    case Build_BuildType.BUILD_TYPE_UNSPECIFIED:
      return "BUILD_TYPE_UNSPECIFIED";
    case Build_BuildType.RELEASE:
      return "RELEASE";
    case Build_BuildType.FIRMWARE:
      return "FIRMWARE";
    case Build_BuildType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Resource that represents a build artifact stored in Google Cloud Storage for
 * the given build target, model, build version and bucket.
 * -- NEXT_TAG: 6 --
 */
export interface BuildArtifact {
  /**
   * The resource name of the build artifact.
   * Format:
   * buildTargets/{build_target}/models/{model}/builds/{build}/artifacts/{artifact}
   * Example:
   * buildTargets/octopus/models/bobba/builds/1234.0.0/artifacts/chromeos-moblab-peng-staging
   */
  name: string;
  /** The build metadata of the build artifact. */
  build: string;
  /** The bucket that stores the build artifact. */
  bucket: string;
  /** The path of the build artifact in the bucket. */
  path: string;
  /**
   * The number of objects in the build artifact folder. The object number can
   * be used to calculated the stage progress by comparing the source build
   * artifact with the destination build artifact.
   */
  objectCount: number;
}

function createBaseBuildTarget(): BuildTarget {
  return { name: "" };
}

export const BuildTarget: MessageFns<BuildTarget> = {
  encode(message: BuildTarget, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildTarget {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildTarget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildTarget {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: BuildTarget): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<BuildTarget>): BuildTarget {
    return BuildTarget.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BuildTarget>): BuildTarget {
    const message = createBaseBuildTarget();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseModel(): Model {
  return { name: "" };
}

export const Model: MessageFns<Model> = {
  encode(message: Model, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Model {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Model {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: Model): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<Model>): Model {
    return Model.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Model>): Model {
    const message = createBaseModel();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseMilestone(): Milestone {
  return { name: "" };
}

export const Milestone: MessageFns<Milestone> = {
  encode(message: Milestone, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Milestone {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMilestone();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Milestone {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: Milestone): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<Milestone>): Milestone {
    return Milestone.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Milestone>): Milestone {
    const message = createBaseMilestone();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseBuild(): Build {
  return {
    name: "",
    milestone: "",
    buildVersion: "",
    status: 0,
    type: 0,
    branch: "",
    rwFirmwareVersion: "",
    labels: [],
  };
}

export const Build: MessageFns<Build> = {
  encode(message: Build, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.milestone !== "") {
      writer.uint32(18).string(message.milestone);
    }
    if (message.buildVersion !== "") {
      writer.uint32(26).string(message.buildVersion);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    if (message.type !== 0) {
      writer.uint32(40).int32(message.type);
    }
    if (message.branch !== "") {
      writer.uint32(50).string(message.branch);
    }
    if (message.rwFirmwareVersion !== "") {
      writer.uint32(58).string(message.rwFirmwareVersion);
    }
    for (const v of message.labels) {
      writer.uint32(66).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Build {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuild();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.milestone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.buildVersion = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.branch = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.rwFirmwareVersion = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.labels.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Build {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      milestone: isSet(object.milestone) ? globalThis.String(object.milestone) : "",
      buildVersion: isSet(object.buildVersion) ? globalThis.String(object.buildVersion) : "",
      status: isSet(object.status) ? build_BuildStatusFromJSON(object.status) : 0,
      type: isSet(object.type) ? build_BuildTypeFromJSON(object.type) : 0,
      branch: isSet(object.branch) ? globalThis.String(object.branch) : "",
      rwFirmwareVersion: isSet(object.rwFirmwareVersion) ? globalThis.String(object.rwFirmwareVersion) : "",
      labels: globalThis.Array.isArray(object?.labels) ? object.labels.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: Build): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.milestone !== "") {
      obj.milestone = message.milestone;
    }
    if (message.buildVersion !== "") {
      obj.buildVersion = message.buildVersion;
    }
    if (message.status !== 0) {
      obj.status = build_BuildStatusToJSON(message.status);
    }
    if (message.type !== 0) {
      obj.type = build_BuildTypeToJSON(message.type);
    }
    if (message.branch !== "") {
      obj.branch = message.branch;
    }
    if (message.rwFirmwareVersion !== "") {
      obj.rwFirmwareVersion = message.rwFirmwareVersion;
    }
    if (message.labels?.length) {
      obj.labels = message.labels;
    }
    return obj;
  },

  create(base?: DeepPartial<Build>): Build {
    return Build.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Build>): Build {
    const message = createBaseBuild();
    message.name = object.name ?? "";
    message.milestone = object.milestone ?? "";
    message.buildVersion = object.buildVersion ?? "";
    message.status = object.status ?? 0;
    message.type = object.type ?? 0;
    message.branch = object.branch ?? "";
    message.rwFirmwareVersion = object.rwFirmwareVersion ?? "";
    message.labels = object.labels?.map((e) => e) || [];
    return message;
  },
};

function createBaseBuildArtifact(): BuildArtifact {
  return { name: "", build: "", bucket: "", path: "", objectCount: 0 };
}

export const BuildArtifact: MessageFns<BuildArtifact> = {
  encode(message: BuildArtifact, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.build !== "") {
      writer.uint32(18).string(message.build);
    }
    if (message.bucket !== "") {
      writer.uint32(26).string(message.bucket);
    }
    if (message.path !== "") {
      writer.uint32(34).string(message.path);
    }
    if (message.objectCount !== 0) {
      writer.uint32(40).uint32(message.objectCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildArtifact {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildArtifact();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.build = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.bucket = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.path = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.objectCount = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildArtifact {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      build: isSet(object.build) ? globalThis.String(object.build) : "",
      bucket: isSet(object.bucket) ? globalThis.String(object.bucket) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      objectCount: isSet(object.objectCount) ? globalThis.Number(object.objectCount) : 0,
    };
  },

  toJSON(message: BuildArtifact): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.build !== "") {
      obj.build = message.build;
    }
    if (message.bucket !== "") {
      obj.bucket = message.bucket;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.objectCount !== 0) {
      obj.objectCount = Math.round(message.objectCount);
    }
    return obj;
  },

  create(base?: DeepPartial<BuildArtifact>): BuildArtifact {
    return BuildArtifact.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BuildArtifact>): BuildArtifact {
    const message = createBaseBuildArtifact();
    message.name = object.name ?? "";
    message.build = object.build ?? "";
    message.bucket = object.bucket ?? "";
    message.path = object.path ?? "";
    message.objectCount = object.objectCount ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
