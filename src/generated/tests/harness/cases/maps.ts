// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: tests/harness/cases/maps.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "tests.harness.cases";

export interface MapNone {
  val: { [key: number]: boolean };
}

export interface MapNone_ValEntry {
  key: number;
  value: boolean;
}

export interface MapMin {
  val: { [key: number]: number };
}

export interface MapMin_ValEntry {
  key: number;
  value: number;
}

export interface MapMax {
  val: Map<Long, number>;
}

export interface MapMax_ValEntry {
  key: Long;
  value: number;
}

export interface MapMinMax {
  val: { [key: string]: boolean };
}

export interface MapMinMax_ValEntry {
  key: string;
  value: boolean;
}

export interface MapExact {
  val: Map<Long, string>;
}

export interface MapExact_ValEntry {
  key: Long;
  value: string;
}

export interface MapNoSparse {
  val: { [key: number]: MapNoSparse_Msg };
}

export interface MapNoSparse_ValEntry {
  key: number;
  value: MapNoSparse_Msg | undefined;
}

export interface MapNoSparse_Msg {
}

export interface MapKeys {
  val: Map<Long, string>;
}

export interface MapKeys_ValEntry {
  key: Long;
  value: string;
}

export interface MapValues {
  val: { [key: string]: string };
}

export interface MapValues_ValEntry {
  key: string;
  value: string;
}

export interface MapKeysPattern {
  val: { [key: string]: string };
}

export interface MapKeysPattern_ValEntry {
  key: string;
  value: string;
}

export interface MapValuesPattern {
  val: { [key: string]: string };
}

export interface MapValuesPattern_ValEntry {
  key: string;
  value: string;
}

export interface MapRecursive {
  val: { [key: number]: MapRecursive_Msg };
}

export interface MapRecursive_ValEntry {
  key: number;
  value: MapRecursive_Msg | undefined;
}

export interface MapRecursive_Msg {
  val: string;
}

export interface MapExactIgnore {
  val: Map<Long, string>;
}

export interface MapExactIgnore_ValEntry {
  key: Long;
  value: string;
}

export interface MultipleMaps {
  first: { [key: number]: string };
  second: { [key: number]: boolean };
  third: { [key: number]: boolean };
}

export interface MultipleMaps_FirstEntry {
  key: number;
  value: string;
}

export interface MultipleMaps_SecondEntry {
  key: number;
  value: boolean;
}

export interface MultipleMaps_ThirdEntry {
  key: number;
  value: boolean;
}

export interface MapKeysIn {
  val: { [key: string]: string };
}

export interface MapKeysIn_ValEntry {
  key: string;
  value: string;
}

export interface MapKeysNotIn {
  val: { [key: string]: string };
}

export interface MapKeysNotIn_ValEntry {
  key: string;
  value: string;
}

function createBaseMapNone(): MapNone {
  return { val: {} };
}

export const MapNone: MessageFns<MapNone> = {
  encode(message: MapNone, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.val).forEach(([key, value]) => {
      MapNone_ValEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapNone {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapNone();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = MapNone_ValEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.val[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapNone {
    return {
      val: isObject(object.val)
        ? Object.entries(object.val).reduce<{ [key: number]: boolean }>((acc, [key, value]) => {
          acc[globalThis.Number(key)] = Boolean(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: MapNone): unknown {
    const obj: any = {};
    if (message.val) {
      const entries = Object.entries(message.val);
      if (entries.length > 0) {
        obj.val = {};
        entries.forEach(([k, v]) => {
          obj.val[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<MapNone>): MapNone {
    return MapNone.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MapNone>): MapNone {
    const message = createBaseMapNone();
    message.val = Object.entries(object.val ?? {}).reduce<{ [key: number]: boolean }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[globalThis.Number(key)] = globalThis.Boolean(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseMapNone_ValEntry(): MapNone_ValEntry {
  return { key: 0, value: false };
}

export const MapNone_ValEntry: MessageFns<MapNone_ValEntry> = {
  encode(message: MapNone_ValEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== 0) {
      writer.uint32(8).uint32(message.key);
    }
    if (message.value !== false) {
      writer.uint32(16).bool(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapNone_ValEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapNone_ValEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.key = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapNone_ValEntry {
    return {
      key: isSet(object.key) ? globalThis.Number(object.key) : 0,
      value: isSet(object.value) ? globalThis.Boolean(object.value) : false,
    };
  },

  toJSON(message: MapNone_ValEntry): unknown {
    const obj: any = {};
    if (message.key !== 0) {
      obj.key = Math.round(message.key);
    }
    if (message.value !== false) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<MapNone_ValEntry>): MapNone_ValEntry {
    return MapNone_ValEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MapNone_ValEntry>): MapNone_ValEntry {
    const message = createBaseMapNone_ValEntry();
    message.key = object.key ?? 0;
    message.value = object.value ?? false;
    return message;
  },
};

function createBaseMapMin(): MapMin {
  return { val: {} };
}

export const MapMin: MessageFns<MapMin> = {
  encode(message: MapMin, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.val).forEach(([key, value]) => {
      MapMin_ValEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapMin {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapMin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = MapMin_ValEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.val[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapMin {
    return {
      val: isObject(object.val)
        ? Object.entries(object.val).reduce<{ [key: number]: number }>((acc, [key, value]) => {
          acc[globalThis.Number(key)] = Number(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: MapMin): unknown {
    const obj: any = {};
    if (message.val) {
      const entries = Object.entries(message.val);
      if (entries.length > 0) {
        obj.val = {};
        entries.forEach(([k, v]) => {
          obj.val[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<MapMin>): MapMin {
    return MapMin.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MapMin>): MapMin {
    const message = createBaseMapMin();
    message.val = Object.entries(object.val ?? {}).reduce<{ [key: number]: number }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[globalThis.Number(key)] = globalThis.Number(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseMapMin_ValEntry(): MapMin_ValEntry {
  return { key: 0, value: 0 };
}

export const MapMin_ValEntry: MessageFns<MapMin_ValEntry> = {
  encode(message: MapMin_ValEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== 0) {
      writer.uint32(8).int32(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(21).float(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapMin_ValEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapMin_ValEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.key = reader.int32();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.value = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapMin_ValEntry {
    return {
      key: isSet(object.key) ? globalThis.Number(object.key) : 0,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: MapMin_ValEntry): unknown {
    const obj: any = {};
    if (message.key !== 0) {
      obj.key = Math.round(message.key);
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<MapMin_ValEntry>): MapMin_ValEntry {
    return MapMin_ValEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MapMin_ValEntry>): MapMin_ValEntry {
    const message = createBaseMapMin_ValEntry();
    message.key = object.key ?? 0;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseMapMax(): MapMax {
  return { val: new Map() };
}

export const MapMax: MessageFns<MapMax> = {
  encode(message: MapMax, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    message.val.forEach((value, key) => {
      MapMax_ValEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapMax {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapMax();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = MapMax_ValEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.val.set(entry1.key, entry1.value);
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapMax {
    return {
      val: isObject(object.val)
        ? Object.entries(object.val).reduce<Map<Long, number>>((acc, [key, value]) => {
          acc.set(Long.fromValue(key), Number(value));
          return acc;
        }, new Map())
        : new Map(),
    };
  },

  toJSON(message: MapMax): unknown {
    const obj: any = {};
    if (message.val?.size) {
      obj.val = {};
      message.val.forEach((v, k) => {
        obj.val[longToNumber(k)] = v;
      });
    }
    return obj;
  },

  create(base?: DeepPartial<MapMax>): MapMax {
    return MapMax.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MapMax>): MapMax {
    const message = createBaseMapMax();
    message.val = (() => {
      const m = new Map();
      (object.val as Map<Long, number> ?? new Map()).forEach((value, key) => {
        if (value !== undefined) {
          m.set(key, globalThis.Number(value));
        }
      });
      return m;
    })();
    return message;
  },
};

function createBaseMapMax_ValEntry(): MapMax_ValEntry {
  return { key: Long.ZERO, value: 0 };
}

export const MapMax_ValEntry: MessageFns<MapMax_ValEntry> = {
  encode(message: MapMax_ValEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.key.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.key.toString());
    }
    if (message.value !== 0) {
      writer.uint32(17).double(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapMax_ValEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapMax_ValEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.key = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.value = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapMax_ValEntry {
    return {
      key: isSet(object.key) ? Long.fromValue(object.key) : Long.ZERO,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: MapMax_ValEntry): unknown {
    const obj: any = {};
    if (!message.key.equals(Long.ZERO)) {
      obj.key = (message.key || Long.ZERO).toString();
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<MapMax_ValEntry>): MapMax_ValEntry {
    return MapMax_ValEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MapMax_ValEntry>): MapMax_ValEntry {
    const message = createBaseMapMax_ValEntry();
    message.key = (object.key !== undefined && object.key !== null) ? Long.fromValue(object.key) : Long.ZERO;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseMapMinMax(): MapMinMax {
  return { val: {} };
}

export const MapMinMax: MessageFns<MapMinMax> = {
  encode(message: MapMinMax, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.val).forEach(([key, value]) => {
      MapMinMax_ValEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapMinMax {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapMinMax();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = MapMinMax_ValEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.val[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapMinMax {
    return {
      val: isObject(object.val)
        ? Object.entries(object.val).reduce<{ [key: string]: boolean }>((acc, [key, value]) => {
          acc[key] = Boolean(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: MapMinMax): unknown {
    const obj: any = {};
    if (message.val) {
      const entries = Object.entries(message.val);
      if (entries.length > 0) {
        obj.val = {};
        entries.forEach(([k, v]) => {
          obj.val[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<MapMinMax>): MapMinMax {
    return MapMinMax.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MapMinMax>): MapMinMax {
    const message = createBaseMapMinMax();
    message.val = Object.entries(object.val ?? {}).reduce<{ [key: string]: boolean }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.Boolean(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseMapMinMax_ValEntry(): MapMinMax_ValEntry {
  return { key: "", value: false };
}

export const MapMinMax_ValEntry: MessageFns<MapMinMax_ValEntry> = {
  encode(message: MapMinMax_ValEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== false) {
      writer.uint32(16).bool(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapMinMax_ValEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapMinMax_ValEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapMinMax_ValEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Boolean(object.value) : false,
    };
  },

  toJSON(message: MapMinMax_ValEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== false) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<MapMinMax_ValEntry>): MapMinMax_ValEntry {
    return MapMinMax_ValEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MapMinMax_ValEntry>): MapMinMax_ValEntry {
    const message = createBaseMapMinMax_ValEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? false;
    return message;
  },
};

function createBaseMapExact(): MapExact {
  return { val: new Map() };
}

export const MapExact: MessageFns<MapExact> = {
  encode(message: MapExact, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    message.val.forEach((value, key) => {
      MapExact_ValEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapExact {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapExact();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = MapExact_ValEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.val.set(entry1.key, entry1.value);
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapExact {
    return {
      val: isObject(object.val)
        ? Object.entries(object.val).reduce<Map<Long, string>>((acc, [key, value]) => {
          acc.set(Long.fromValue(key), String(value));
          return acc;
        }, new Map())
        : new Map(),
    };
  },

  toJSON(message: MapExact): unknown {
    const obj: any = {};
    if (message.val?.size) {
      obj.val = {};
      message.val.forEach((v, k) => {
        obj.val[longToNumber(k)] = v;
      });
    }
    return obj;
  },

  create(base?: DeepPartial<MapExact>): MapExact {
    return MapExact.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MapExact>): MapExact {
    const message = createBaseMapExact();
    message.val = (() => {
      const m = new Map();
      (object.val as Map<Long, string> ?? new Map()).forEach((value, key) => {
        if (value !== undefined) {
          m.set(key, globalThis.String(value));
        }
      });
      return m;
    })();
    return message;
  },
};

function createBaseMapExact_ValEntry(): MapExact_ValEntry {
  return { key: Long.UZERO, value: "" };
}

export const MapExact_ValEntry: MessageFns<MapExact_ValEntry> = {
  encode(message: MapExact_ValEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.key.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.key.toString());
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapExact_ValEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapExact_ValEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.key = Long.fromString(reader.uint64().toString(), true);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapExact_ValEntry {
    return {
      key: isSet(object.key) ? Long.fromValue(object.key) : Long.UZERO,
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: MapExact_ValEntry): unknown {
    const obj: any = {};
    if (!message.key.equals(Long.UZERO)) {
      obj.key = (message.key || Long.UZERO).toString();
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<MapExact_ValEntry>): MapExact_ValEntry {
    return MapExact_ValEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MapExact_ValEntry>): MapExact_ValEntry {
    const message = createBaseMapExact_ValEntry();
    message.key = (object.key !== undefined && object.key !== null) ? Long.fromValue(object.key) : Long.UZERO;
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseMapNoSparse(): MapNoSparse {
  return { val: {} };
}

export const MapNoSparse: MessageFns<MapNoSparse> = {
  encode(message: MapNoSparse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.val).forEach(([key, value]) => {
      MapNoSparse_ValEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapNoSparse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapNoSparse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = MapNoSparse_ValEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.val[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapNoSparse {
    return {
      val: isObject(object.val)
        ? Object.entries(object.val).reduce<{ [key: number]: MapNoSparse_Msg }>((acc, [key, value]) => {
          acc[globalThis.Number(key)] = MapNoSparse_Msg.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: MapNoSparse): unknown {
    const obj: any = {};
    if (message.val) {
      const entries = Object.entries(message.val);
      if (entries.length > 0) {
        obj.val = {};
        entries.forEach(([k, v]) => {
          obj.val[k] = MapNoSparse_Msg.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<MapNoSparse>): MapNoSparse {
    return MapNoSparse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MapNoSparse>): MapNoSparse {
    const message = createBaseMapNoSparse();
    message.val = Object.entries(object.val ?? {}).reduce<{ [key: number]: MapNoSparse_Msg }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[globalThis.Number(key)] = MapNoSparse_Msg.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseMapNoSparse_ValEntry(): MapNoSparse_ValEntry {
  return { key: 0, value: undefined };
}

export const MapNoSparse_ValEntry: MessageFns<MapNoSparse_ValEntry> = {
  encode(message: MapNoSparse_ValEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== 0) {
      writer.uint32(8).uint32(message.key);
    }
    if (message.value !== undefined) {
      MapNoSparse_Msg.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapNoSparse_ValEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapNoSparse_ValEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.key = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = MapNoSparse_Msg.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapNoSparse_ValEntry {
    return {
      key: isSet(object.key) ? globalThis.Number(object.key) : 0,
      value: isSet(object.value) ? MapNoSparse_Msg.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: MapNoSparse_ValEntry): unknown {
    const obj: any = {};
    if (message.key !== 0) {
      obj.key = Math.round(message.key);
    }
    if (message.value !== undefined) {
      obj.value = MapNoSparse_Msg.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<MapNoSparse_ValEntry>): MapNoSparse_ValEntry {
    return MapNoSparse_ValEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MapNoSparse_ValEntry>): MapNoSparse_ValEntry {
    const message = createBaseMapNoSparse_ValEntry();
    message.key = object.key ?? 0;
    message.value = (object.value !== undefined && object.value !== null)
      ? MapNoSparse_Msg.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseMapNoSparse_Msg(): MapNoSparse_Msg {
  return {};
}

export const MapNoSparse_Msg: MessageFns<MapNoSparse_Msg> = {
  encode(_: MapNoSparse_Msg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapNoSparse_Msg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapNoSparse_Msg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MapNoSparse_Msg {
    return {};
  },

  toJSON(_: MapNoSparse_Msg): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MapNoSparse_Msg>): MapNoSparse_Msg {
    return MapNoSparse_Msg.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MapNoSparse_Msg>): MapNoSparse_Msg {
    const message = createBaseMapNoSparse_Msg();
    return message;
  },
};

function createBaseMapKeys(): MapKeys {
  return { val: new Map() };
}

export const MapKeys: MessageFns<MapKeys> = {
  encode(message: MapKeys, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    message.val.forEach((value, key) => {
      MapKeys_ValEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapKeys {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapKeys();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = MapKeys_ValEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.val.set(entry1.key, entry1.value);
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapKeys {
    return {
      val: isObject(object.val)
        ? Object.entries(object.val).reduce<Map<Long, string>>((acc, [key, value]) => {
          acc.set(Long.fromValue(key), String(value));
          return acc;
        }, new Map())
        : new Map(),
    };
  },

  toJSON(message: MapKeys): unknown {
    const obj: any = {};
    if (message.val?.size) {
      obj.val = {};
      message.val.forEach((v, k) => {
        obj.val[longToNumber(k)] = v;
      });
    }
    return obj;
  },

  create(base?: DeepPartial<MapKeys>): MapKeys {
    return MapKeys.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MapKeys>): MapKeys {
    const message = createBaseMapKeys();
    message.val = (() => {
      const m = new Map();
      (object.val as Map<Long, string> ?? new Map()).forEach((value, key) => {
        if (value !== undefined) {
          m.set(key, globalThis.String(value));
        }
      });
      return m;
    })();
    return message;
  },
};

function createBaseMapKeys_ValEntry(): MapKeys_ValEntry {
  return { key: Long.ZERO, value: "" };
}

export const MapKeys_ValEntry: MessageFns<MapKeys_ValEntry> = {
  encode(message: MapKeys_ValEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.key.equals(Long.ZERO)) {
      writer.uint32(8).sint64(message.key.toString());
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapKeys_ValEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapKeys_ValEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.key = Long.fromString(reader.sint64().toString());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapKeys_ValEntry {
    return {
      key: isSet(object.key) ? Long.fromValue(object.key) : Long.ZERO,
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: MapKeys_ValEntry): unknown {
    const obj: any = {};
    if (!message.key.equals(Long.ZERO)) {
      obj.key = (message.key || Long.ZERO).toString();
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<MapKeys_ValEntry>): MapKeys_ValEntry {
    return MapKeys_ValEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MapKeys_ValEntry>): MapKeys_ValEntry {
    const message = createBaseMapKeys_ValEntry();
    message.key = (object.key !== undefined && object.key !== null) ? Long.fromValue(object.key) : Long.ZERO;
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseMapValues(): MapValues {
  return { val: {} };
}

export const MapValues: MessageFns<MapValues> = {
  encode(message: MapValues, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.val).forEach(([key, value]) => {
      MapValues_ValEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapValues {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapValues();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = MapValues_ValEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.val[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapValues {
    return {
      val: isObject(object.val)
        ? Object.entries(object.val).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: MapValues): unknown {
    const obj: any = {};
    if (message.val) {
      const entries = Object.entries(message.val);
      if (entries.length > 0) {
        obj.val = {};
        entries.forEach(([k, v]) => {
          obj.val[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<MapValues>): MapValues {
    return MapValues.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MapValues>): MapValues {
    const message = createBaseMapValues();
    message.val = Object.entries(object.val ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseMapValues_ValEntry(): MapValues_ValEntry {
  return { key: "", value: "" };
}

export const MapValues_ValEntry: MessageFns<MapValues_ValEntry> = {
  encode(message: MapValues_ValEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapValues_ValEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapValues_ValEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapValues_ValEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: MapValues_ValEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<MapValues_ValEntry>): MapValues_ValEntry {
    return MapValues_ValEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MapValues_ValEntry>): MapValues_ValEntry {
    const message = createBaseMapValues_ValEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseMapKeysPattern(): MapKeysPattern {
  return { val: {} };
}

export const MapKeysPattern: MessageFns<MapKeysPattern> = {
  encode(message: MapKeysPattern, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.val).forEach(([key, value]) => {
      MapKeysPattern_ValEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapKeysPattern {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapKeysPattern();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = MapKeysPattern_ValEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.val[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapKeysPattern {
    return {
      val: isObject(object.val)
        ? Object.entries(object.val).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: MapKeysPattern): unknown {
    const obj: any = {};
    if (message.val) {
      const entries = Object.entries(message.val);
      if (entries.length > 0) {
        obj.val = {};
        entries.forEach(([k, v]) => {
          obj.val[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<MapKeysPattern>): MapKeysPattern {
    return MapKeysPattern.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MapKeysPattern>): MapKeysPattern {
    const message = createBaseMapKeysPattern();
    message.val = Object.entries(object.val ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseMapKeysPattern_ValEntry(): MapKeysPattern_ValEntry {
  return { key: "", value: "" };
}

export const MapKeysPattern_ValEntry: MessageFns<MapKeysPattern_ValEntry> = {
  encode(message: MapKeysPattern_ValEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapKeysPattern_ValEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapKeysPattern_ValEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapKeysPattern_ValEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: MapKeysPattern_ValEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<MapKeysPattern_ValEntry>): MapKeysPattern_ValEntry {
    return MapKeysPattern_ValEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MapKeysPattern_ValEntry>): MapKeysPattern_ValEntry {
    const message = createBaseMapKeysPattern_ValEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseMapValuesPattern(): MapValuesPattern {
  return { val: {} };
}

export const MapValuesPattern: MessageFns<MapValuesPattern> = {
  encode(message: MapValuesPattern, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.val).forEach(([key, value]) => {
      MapValuesPattern_ValEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapValuesPattern {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapValuesPattern();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = MapValuesPattern_ValEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.val[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapValuesPattern {
    return {
      val: isObject(object.val)
        ? Object.entries(object.val).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: MapValuesPattern): unknown {
    const obj: any = {};
    if (message.val) {
      const entries = Object.entries(message.val);
      if (entries.length > 0) {
        obj.val = {};
        entries.forEach(([k, v]) => {
          obj.val[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<MapValuesPattern>): MapValuesPattern {
    return MapValuesPattern.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MapValuesPattern>): MapValuesPattern {
    const message = createBaseMapValuesPattern();
    message.val = Object.entries(object.val ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseMapValuesPattern_ValEntry(): MapValuesPattern_ValEntry {
  return { key: "", value: "" };
}

export const MapValuesPattern_ValEntry: MessageFns<MapValuesPattern_ValEntry> = {
  encode(message: MapValuesPattern_ValEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapValuesPattern_ValEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapValuesPattern_ValEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapValuesPattern_ValEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: MapValuesPattern_ValEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<MapValuesPattern_ValEntry>): MapValuesPattern_ValEntry {
    return MapValuesPattern_ValEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MapValuesPattern_ValEntry>): MapValuesPattern_ValEntry {
    const message = createBaseMapValuesPattern_ValEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseMapRecursive(): MapRecursive {
  return { val: {} };
}

export const MapRecursive: MessageFns<MapRecursive> = {
  encode(message: MapRecursive, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.val).forEach(([key, value]) => {
      MapRecursive_ValEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapRecursive {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapRecursive();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = MapRecursive_ValEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.val[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapRecursive {
    return {
      val: isObject(object.val)
        ? Object.entries(object.val).reduce<{ [key: number]: MapRecursive_Msg }>((acc, [key, value]) => {
          acc[globalThis.Number(key)] = MapRecursive_Msg.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: MapRecursive): unknown {
    const obj: any = {};
    if (message.val) {
      const entries = Object.entries(message.val);
      if (entries.length > 0) {
        obj.val = {};
        entries.forEach(([k, v]) => {
          obj.val[k] = MapRecursive_Msg.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<MapRecursive>): MapRecursive {
    return MapRecursive.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MapRecursive>): MapRecursive {
    const message = createBaseMapRecursive();
    message.val = Object.entries(object.val ?? {}).reduce<{ [key: number]: MapRecursive_Msg }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[globalThis.Number(key)] = MapRecursive_Msg.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseMapRecursive_ValEntry(): MapRecursive_ValEntry {
  return { key: 0, value: undefined };
}

export const MapRecursive_ValEntry: MessageFns<MapRecursive_ValEntry> = {
  encode(message: MapRecursive_ValEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== 0) {
      writer.uint32(8).uint32(message.key);
    }
    if (message.value !== undefined) {
      MapRecursive_Msg.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapRecursive_ValEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapRecursive_ValEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.key = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = MapRecursive_Msg.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapRecursive_ValEntry {
    return {
      key: isSet(object.key) ? globalThis.Number(object.key) : 0,
      value: isSet(object.value) ? MapRecursive_Msg.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: MapRecursive_ValEntry): unknown {
    const obj: any = {};
    if (message.key !== 0) {
      obj.key = Math.round(message.key);
    }
    if (message.value !== undefined) {
      obj.value = MapRecursive_Msg.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<MapRecursive_ValEntry>): MapRecursive_ValEntry {
    return MapRecursive_ValEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MapRecursive_ValEntry>): MapRecursive_ValEntry {
    const message = createBaseMapRecursive_ValEntry();
    message.key = object.key ?? 0;
    message.value = (object.value !== undefined && object.value !== null)
      ? MapRecursive_Msg.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseMapRecursive_Msg(): MapRecursive_Msg {
  return { val: "" };
}

export const MapRecursive_Msg: MessageFns<MapRecursive_Msg> = {
  encode(message: MapRecursive_Msg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== "") {
      writer.uint32(10).string(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapRecursive_Msg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapRecursive_Msg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapRecursive_Msg {
    return { val: isSet(object.val) ? globalThis.String(object.val) : "" };
  },

  toJSON(message: MapRecursive_Msg): unknown {
    const obj: any = {};
    if (message.val !== "") {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<MapRecursive_Msg>): MapRecursive_Msg {
    return MapRecursive_Msg.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MapRecursive_Msg>): MapRecursive_Msg {
    const message = createBaseMapRecursive_Msg();
    message.val = object.val ?? "";
    return message;
  },
};

function createBaseMapExactIgnore(): MapExactIgnore {
  return { val: new Map() };
}

export const MapExactIgnore: MessageFns<MapExactIgnore> = {
  encode(message: MapExactIgnore, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    message.val.forEach((value, key) => {
      MapExactIgnore_ValEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapExactIgnore {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapExactIgnore();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = MapExactIgnore_ValEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.val.set(entry1.key, entry1.value);
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapExactIgnore {
    return {
      val: isObject(object.val)
        ? Object.entries(object.val).reduce<Map<Long, string>>((acc, [key, value]) => {
          acc.set(Long.fromValue(key), String(value));
          return acc;
        }, new Map())
        : new Map(),
    };
  },

  toJSON(message: MapExactIgnore): unknown {
    const obj: any = {};
    if (message.val?.size) {
      obj.val = {};
      message.val.forEach((v, k) => {
        obj.val[longToNumber(k)] = v;
      });
    }
    return obj;
  },

  create(base?: DeepPartial<MapExactIgnore>): MapExactIgnore {
    return MapExactIgnore.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MapExactIgnore>): MapExactIgnore {
    const message = createBaseMapExactIgnore();
    message.val = (() => {
      const m = new Map();
      (object.val as Map<Long, string> ?? new Map()).forEach((value, key) => {
        if (value !== undefined) {
          m.set(key, globalThis.String(value));
        }
      });
      return m;
    })();
    return message;
  },
};

function createBaseMapExactIgnore_ValEntry(): MapExactIgnore_ValEntry {
  return { key: Long.UZERO, value: "" };
}

export const MapExactIgnore_ValEntry: MessageFns<MapExactIgnore_ValEntry> = {
  encode(message: MapExactIgnore_ValEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.key.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.key.toString());
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapExactIgnore_ValEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapExactIgnore_ValEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.key = Long.fromString(reader.uint64().toString(), true);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapExactIgnore_ValEntry {
    return {
      key: isSet(object.key) ? Long.fromValue(object.key) : Long.UZERO,
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: MapExactIgnore_ValEntry): unknown {
    const obj: any = {};
    if (!message.key.equals(Long.UZERO)) {
      obj.key = (message.key || Long.UZERO).toString();
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<MapExactIgnore_ValEntry>): MapExactIgnore_ValEntry {
    return MapExactIgnore_ValEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MapExactIgnore_ValEntry>): MapExactIgnore_ValEntry {
    const message = createBaseMapExactIgnore_ValEntry();
    message.key = (object.key !== undefined && object.key !== null) ? Long.fromValue(object.key) : Long.UZERO;
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseMultipleMaps(): MultipleMaps {
  return { first: {}, second: {}, third: {} };
}

export const MultipleMaps: MessageFns<MultipleMaps> = {
  encode(message: MultipleMaps, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.first).forEach(([key, value]) => {
      MultipleMaps_FirstEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    Object.entries(message.second).forEach(([key, value]) => {
      MultipleMaps_SecondEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    Object.entries(message.third).forEach(([key, value]) => {
      MultipleMaps_ThirdEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultipleMaps {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultipleMaps();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = MultipleMaps_FirstEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.first[entry1.key] = entry1.value;
          }
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = MultipleMaps_SecondEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.second[entry2.key] = entry2.value;
          }
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = MultipleMaps_ThirdEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.third[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultipleMaps {
    return {
      first: isObject(object.first)
        ? Object.entries(object.first).reduce<{ [key: number]: string }>((acc, [key, value]) => {
          acc[globalThis.Number(key)] = String(value);
          return acc;
        }, {})
        : {},
      second: isObject(object.second)
        ? Object.entries(object.second).reduce<{ [key: number]: boolean }>((acc, [key, value]) => {
          acc[globalThis.Number(key)] = Boolean(value);
          return acc;
        }, {})
        : {},
      third: isObject(object.third)
        ? Object.entries(object.third).reduce<{ [key: number]: boolean }>((acc, [key, value]) => {
          acc[globalThis.Number(key)] = Boolean(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: MultipleMaps): unknown {
    const obj: any = {};
    if (message.first) {
      const entries = Object.entries(message.first);
      if (entries.length > 0) {
        obj.first = {};
        entries.forEach(([k, v]) => {
          obj.first[k] = v;
        });
      }
    }
    if (message.second) {
      const entries = Object.entries(message.second);
      if (entries.length > 0) {
        obj.second = {};
        entries.forEach(([k, v]) => {
          obj.second[k] = v;
        });
      }
    }
    if (message.third) {
      const entries = Object.entries(message.third);
      if (entries.length > 0) {
        obj.third = {};
        entries.forEach(([k, v]) => {
          obj.third[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<MultipleMaps>): MultipleMaps {
    return MultipleMaps.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MultipleMaps>): MultipleMaps {
    const message = createBaseMultipleMaps();
    message.first = Object.entries(object.first ?? {}).reduce<{ [key: number]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[globalThis.Number(key)] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.second = Object.entries(object.second ?? {}).reduce<{ [key: number]: boolean }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[globalThis.Number(key)] = globalThis.Boolean(value);
      }
      return acc;
    }, {});
    message.third = Object.entries(object.third ?? {}).reduce<{ [key: number]: boolean }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[globalThis.Number(key)] = globalThis.Boolean(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseMultipleMaps_FirstEntry(): MultipleMaps_FirstEntry {
  return { key: 0, value: "" };
}

export const MultipleMaps_FirstEntry: MessageFns<MultipleMaps_FirstEntry> = {
  encode(message: MultipleMaps_FirstEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== 0) {
      writer.uint32(8).uint32(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultipleMaps_FirstEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultipleMaps_FirstEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.key = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultipleMaps_FirstEntry {
    return {
      key: isSet(object.key) ? globalThis.Number(object.key) : 0,
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: MultipleMaps_FirstEntry): unknown {
    const obj: any = {};
    if (message.key !== 0) {
      obj.key = Math.round(message.key);
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<MultipleMaps_FirstEntry>): MultipleMaps_FirstEntry {
    return MultipleMaps_FirstEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MultipleMaps_FirstEntry>): MultipleMaps_FirstEntry {
    const message = createBaseMultipleMaps_FirstEntry();
    message.key = object.key ?? 0;
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseMultipleMaps_SecondEntry(): MultipleMaps_SecondEntry {
  return { key: 0, value: false };
}

export const MultipleMaps_SecondEntry: MessageFns<MultipleMaps_SecondEntry> = {
  encode(message: MultipleMaps_SecondEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== 0) {
      writer.uint32(8).int32(message.key);
    }
    if (message.value !== false) {
      writer.uint32(16).bool(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultipleMaps_SecondEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultipleMaps_SecondEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.key = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultipleMaps_SecondEntry {
    return {
      key: isSet(object.key) ? globalThis.Number(object.key) : 0,
      value: isSet(object.value) ? globalThis.Boolean(object.value) : false,
    };
  },

  toJSON(message: MultipleMaps_SecondEntry): unknown {
    const obj: any = {};
    if (message.key !== 0) {
      obj.key = Math.round(message.key);
    }
    if (message.value !== false) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<MultipleMaps_SecondEntry>): MultipleMaps_SecondEntry {
    return MultipleMaps_SecondEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MultipleMaps_SecondEntry>): MultipleMaps_SecondEntry {
    const message = createBaseMultipleMaps_SecondEntry();
    message.key = object.key ?? 0;
    message.value = object.value ?? false;
    return message;
  },
};

function createBaseMultipleMaps_ThirdEntry(): MultipleMaps_ThirdEntry {
  return { key: 0, value: false };
}

export const MultipleMaps_ThirdEntry: MessageFns<MultipleMaps_ThirdEntry> = {
  encode(message: MultipleMaps_ThirdEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== 0) {
      writer.uint32(8).int32(message.key);
    }
    if (message.value !== false) {
      writer.uint32(16).bool(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultipleMaps_ThirdEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultipleMaps_ThirdEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.key = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultipleMaps_ThirdEntry {
    return {
      key: isSet(object.key) ? globalThis.Number(object.key) : 0,
      value: isSet(object.value) ? globalThis.Boolean(object.value) : false,
    };
  },

  toJSON(message: MultipleMaps_ThirdEntry): unknown {
    const obj: any = {};
    if (message.key !== 0) {
      obj.key = Math.round(message.key);
    }
    if (message.value !== false) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<MultipleMaps_ThirdEntry>): MultipleMaps_ThirdEntry {
    return MultipleMaps_ThirdEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MultipleMaps_ThirdEntry>): MultipleMaps_ThirdEntry {
    const message = createBaseMultipleMaps_ThirdEntry();
    message.key = object.key ?? 0;
    message.value = object.value ?? false;
    return message;
  },
};

function createBaseMapKeysIn(): MapKeysIn {
  return { val: {} };
}

export const MapKeysIn: MessageFns<MapKeysIn> = {
  encode(message: MapKeysIn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.val).forEach(([key, value]) => {
      MapKeysIn_ValEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapKeysIn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapKeysIn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = MapKeysIn_ValEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.val[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapKeysIn {
    return {
      val: isObject(object.val)
        ? Object.entries(object.val).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: MapKeysIn): unknown {
    const obj: any = {};
    if (message.val) {
      const entries = Object.entries(message.val);
      if (entries.length > 0) {
        obj.val = {};
        entries.forEach(([k, v]) => {
          obj.val[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<MapKeysIn>): MapKeysIn {
    return MapKeysIn.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MapKeysIn>): MapKeysIn {
    const message = createBaseMapKeysIn();
    message.val = Object.entries(object.val ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseMapKeysIn_ValEntry(): MapKeysIn_ValEntry {
  return { key: "", value: "" };
}

export const MapKeysIn_ValEntry: MessageFns<MapKeysIn_ValEntry> = {
  encode(message: MapKeysIn_ValEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapKeysIn_ValEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapKeysIn_ValEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapKeysIn_ValEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: MapKeysIn_ValEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<MapKeysIn_ValEntry>): MapKeysIn_ValEntry {
    return MapKeysIn_ValEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MapKeysIn_ValEntry>): MapKeysIn_ValEntry {
    const message = createBaseMapKeysIn_ValEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseMapKeysNotIn(): MapKeysNotIn {
  return { val: {} };
}

export const MapKeysNotIn: MessageFns<MapKeysNotIn> = {
  encode(message: MapKeysNotIn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.val).forEach(([key, value]) => {
      MapKeysNotIn_ValEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapKeysNotIn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapKeysNotIn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = MapKeysNotIn_ValEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.val[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapKeysNotIn {
    return {
      val: isObject(object.val)
        ? Object.entries(object.val).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: MapKeysNotIn): unknown {
    const obj: any = {};
    if (message.val) {
      const entries = Object.entries(message.val);
      if (entries.length > 0) {
        obj.val = {};
        entries.forEach(([k, v]) => {
          obj.val[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<MapKeysNotIn>): MapKeysNotIn {
    return MapKeysNotIn.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MapKeysNotIn>): MapKeysNotIn {
    const message = createBaseMapKeysNotIn();
    message.val = Object.entries(object.val ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseMapKeysNotIn_ValEntry(): MapKeysNotIn_ValEntry {
  return { key: "", value: "" };
}

export const MapKeysNotIn_ValEntry: MessageFns<MapKeysNotIn_ValEntry> = {
  encode(message: MapKeysNotIn_ValEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapKeysNotIn_ValEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapKeysNotIn_ValEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapKeysNotIn_ValEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: MapKeysNotIn_ValEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<MapKeysNotIn_ValEntry>): MapKeysNotIn_ValEntry {
    return MapKeysNotIn_ValEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MapKeysNotIn_ValEntry>): MapKeysNotIn_ValEntry {
    const message = createBaseMapKeysNotIn_ValEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
