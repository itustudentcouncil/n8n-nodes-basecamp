// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: tests/harness/cases/wkt_duration.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../google/protobuf/duration.js";

export const protobufPackage = "tests.harness.cases";

export interface DurationNone {
  val: Duration | undefined;
}

export interface DurationRequired {
  val: Duration | undefined;
}

/**
 * TODO(htuch): Add a very large duration, e.g. {seconds: 315576000000}, once
 * #34 is resolved.
 */
export interface DurationConst {
  val: Duration | undefined;
}

export interface DurationIn {
  val: Duration | undefined;
}

export interface DurationNotIn {
  val: Duration | undefined;
}

export interface DurationLT {
  val: Duration | undefined;
}

export interface DurationLTE {
  val: Duration | undefined;
}

export interface DurationGT {
  val: Duration | undefined;
}

export interface DurationGTE {
  val: Duration | undefined;
}

export interface DurationGTLT {
  val: Duration | undefined;
}

export interface DurationExLTGT {
  val: Duration | undefined;
}

export interface DurationGTELTE {
  val: Duration | undefined;
}

export interface DurationExGTELTE {
  val: Duration | undefined;
}

/**
 * Regression for earlier bug where missing Duration field would short circuit
 * evaluation in C++.
 */
export interface DurationFieldWithOtherFields {
  durationVal: Duration | undefined;
  intVal: number;
}

function createBaseDurationNone(): DurationNone {
  return { val: undefined };
}

export const DurationNone: MessageFns<DurationNone> = {
  encode(message: DurationNone, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== undefined) {
      Duration.encode(message.val, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DurationNone {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDurationNone();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DurationNone {
    return { val: isSet(object.val) ? Duration.fromJSON(object.val) : undefined };
  },

  toJSON(message: DurationNone): unknown {
    const obj: any = {};
    if (message.val !== undefined) {
      obj.val = Duration.toJSON(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<DurationNone>): DurationNone {
    return DurationNone.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DurationNone>): DurationNone {
    const message = createBaseDurationNone();
    message.val = (object.val !== undefined && object.val !== null) ? Duration.fromPartial(object.val) : undefined;
    return message;
  },
};

function createBaseDurationRequired(): DurationRequired {
  return { val: undefined };
}

export const DurationRequired: MessageFns<DurationRequired> = {
  encode(message: DurationRequired, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== undefined) {
      Duration.encode(message.val, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DurationRequired {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDurationRequired();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DurationRequired {
    return { val: isSet(object.val) ? Duration.fromJSON(object.val) : undefined };
  },

  toJSON(message: DurationRequired): unknown {
    const obj: any = {};
    if (message.val !== undefined) {
      obj.val = Duration.toJSON(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<DurationRequired>): DurationRequired {
    return DurationRequired.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DurationRequired>): DurationRequired {
    const message = createBaseDurationRequired();
    message.val = (object.val !== undefined && object.val !== null) ? Duration.fromPartial(object.val) : undefined;
    return message;
  },
};

function createBaseDurationConst(): DurationConst {
  return { val: undefined };
}

export const DurationConst: MessageFns<DurationConst> = {
  encode(message: DurationConst, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== undefined) {
      Duration.encode(message.val, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DurationConst {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDurationConst();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DurationConst {
    return { val: isSet(object.val) ? Duration.fromJSON(object.val) : undefined };
  },

  toJSON(message: DurationConst): unknown {
    const obj: any = {};
    if (message.val !== undefined) {
      obj.val = Duration.toJSON(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<DurationConst>): DurationConst {
    return DurationConst.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DurationConst>): DurationConst {
    const message = createBaseDurationConst();
    message.val = (object.val !== undefined && object.val !== null) ? Duration.fromPartial(object.val) : undefined;
    return message;
  },
};

function createBaseDurationIn(): DurationIn {
  return { val: undefined };
}

export const DurationIn: MessageFns<DurationIn> = {
  encode(message: DurationIn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== undefined) {
      Duration.encode(message.val, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DurationIn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDurationIn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DurationIn {
    return { val: isSet(object.val) ? Duration.fromJSON(object.val) : undefined };
  },

  toJSON(message: DurationIn): unknown {
    const obj: any = {};
    if (message.val !== undefined) {
      obj.val = Duration.toJSON(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<DurationIn>): DurationIn {
    return DurationIn.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DurationIn>): DurationIn {
    const message = createBaseDurationIn();
    message.val = (object.val !== undefined && object.val !== null) ? Duration.fromPartial(object.val) : undefined;
    return message;
  },
};

function createBaseDurationNotIn(): DurationNotIn {
  return { val: undefined };
}

export const DurationNotIn: MessageFns<DurationNotIn> = {
  encode(message: DurationNotIn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== undefined) {
      Duration.encode(message.val, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DurationNotIn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDurationNotIn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DurationNotIn {
    return { val: isSet(object.val) ? Duration.fromJSON(object.val) : undefined };
  },

  toJSON(message: DurationNotIn): unknown {
    const obj: any = {};
    if (message.val !== undefined) {
      obj.val = Duration.toJSON(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<DurationNotIn>): DurationNotIn {
    return DurationNotIn.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DurationNotIn>): DurationNotIn {
    const message = createBaseDurationNotIn();
    message.val = (object.val !== undefined && object.val !== null) ? Duration.fromPartial(object.val) : undefined;
    return message;
  },
};

function createBaseDurationLT(): DurationLT {
  return { val: undefined };
}

export const DurationLT: MessageFns<DurationLT> = {
  encode(message: DurationLT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== undefined) {
      Duration.encode(message.val, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DurationLT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDurationLT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DurationLT {
    return { val: isSet(object.val) ? Duration.fromJSON(object.val) : undefined };
  },

  toJSON(message: DurationLT): unknown {
    const obj: any = {};
    if (message.val !== undefined) {
      obj.val = Duration.toJSON(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<DurationLT>): DurationLT {
    return DurationLT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DurationLT>): DurationLT {
    const message = createBaseDurationLT();
    message.val = (object.val !== undefined && object.val !== null) ? Duration.fromPartial(object.val) : undefined;
    return message;
  },
};

function createBaseDurationLTE(): DurationLTE {
  return { val: undefined };
}

export const DurationLTE: MessageFns<DurationLTE> = {
  encode(message: DurationLTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== undefined) {
      Duration.encode(message.val, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DurationLTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDurationLTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DurationLTE {
    return { val: isSet(object.val) ? Duration.fromJSON(object.val) : undefined };
  },

  toJSON(message: DurationLTE): unknown {
    const obj: any = {};
    if (message.val !== undefined) {
      obj.val = Duration.toJSON(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<DurationLTE>): DurationLTE {
    return DurationLTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DurationLTE>): DurationLTE {
    const message = createBaseDurationLTE();
    message.val = (object.val !== undefined && object.val !== null) ? Duration.fromPartial(object.val) : undefined;
    return message;
  },
};

function createBaseDurationGT(): DurationGT {
  return { val: undefined };
}

export const DurationGT: MessageFns<DurationGT> = {
  encode(message: DurationGT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== undefined) {
      Duration.encode(message.val, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DurationGT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDurationGT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DurationGT {
    return { val: isSet(object.val) ? Duration.fromJSON(object.val) : undefined };
  },

  toJSON(message: DurationGT): unknown {
    const obj: any = {};
    if (message.val !== undefined) {
      obj.val = Duration.toJSON(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<DurationGT>): DurationGT {
    return DurationGT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DurationGT>): DurationGT {
    const message = createBaseDurationGT();
    message.val = (object.val !== undefined && object.val !== null) ? Duration.fromPartial(object.val) : undefined;
    return message;
  },
};

function createBaseDurationGTE(): DurationGTE {
  return { val: undefined };
}

export const DurationGTE: MessageFns<DurationGTE> = {
  encode(message: DurationGTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== undefined) {
      Duration.encode(message.val, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DurationGTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDurationGTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DurationGTE {
    return { val: isSet(object.val) ? Duration.fromJSON(object.val) : undefined };
  },

  toJSON(message: DurationGTE): unknown {
    const obj: any = {};
    if (message.val !== undefined) {
      obj.val = Duration.toJSON(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<DurationGTE>): DurationGTE {
    return DurationGTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DurationGTE>): DurationGTE {
    const message = createBaseDurationGTE();
    message.val = (object.val !== undefined && object.val !== null) ? Duration.fromPartial(object.val) : undefined;
    return message;
  },
};

function createBaseDurationGTLT(): DurationGTLT {
  return { val: undefined };
}

export const DurationGTLT: MessageFns<DurationGTLT> = {
  encode(message: DurationGTLT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== undefined) {
      Duration.encode(message.val, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DurationGTLT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDurationGTLT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DurationGTLT {
    return { val: isSet(object.val) ? Duration.fromJSON(object.val) : undefined };
  },

  toJSON(message: DurationGTLT): unknown {
    const obj: any = {};
    if (message.val !== undefined) {
      obj.val = Duration.toJSON(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<DurationGTLT>): DurationGTLT {
    return DurationGTLT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DurationGTLT>): DurationGTLT {
    const message = createBaseDurationGTLT();
    message.val = (object.val !== undefined && object.val !== null) ? Duration.fromPartial(object.val) : undefined;
    return message;
  },
};

function createBaseDurationExLTGT(): DurationExLTGT {
  return { val: undefined };
}

export const DurationExLTGT: MessageFns<DurationExLTGT> = {
  encode(message: DurationExLTGT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== undefined) {
      Duration.encode(message.val, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DurationExLTGT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDurationExLTGT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DurationExLTGT {
    return { val: isSet(object.val) ? Duration.fromJSON(object.val) : undefined };
  },

  toJSON(message: DurationExLTGT): unknown {
    const obj: any = {};
    if (message.val !== undefined) {
      obj.val = Duration.toJSON(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<DurationExLTGT>): DurationExLTGT {
    return DurationExLTGT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DurationExLTGT>): DurationExLTGT {
    const message = createBaseDurationExLTGT();
    message.val = (object.val !== undefined && object.val !== null) ? Duration.fromPartial(object.val) : undefined;
    return message;
  },
};

function createBaseDurationGTELTE(): DurationGTELTE {
  return { val: undefined };
}

export const DurationGTELTE: MessageFns<DurationGTELTE> = {
  encode(message: DurationGTELTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== undefined) {
      Duration.encode(message.val, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DurationGTELTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDurationGTELTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DurationGTELTE {
    return { val: isSet(object.val) ? Duration.fromJSON(object.val) : undefined };
  },

  toJSON(message: DurationGTELTE): unknown {
    const obj: any = {};
    if (message.val !== undefined) {
      obj.val = Duration.toJSON(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<DurationGTELTE>): DurationGTELTE {
    return DurationGTELTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DurationGTELTE>): DurationGTELTE {
    const message = createBaseDurationGTELTE();
    message.val = (object.val !== undefined && object.val !== null) ? Duration.fromPartial(object.val) : undefined;
    return message;
  },
};

function createBaseDurationExGTELTE(): DurationExGTELTE {
  return { val: undefined };
}

export const DurationExGTELTE: MessageFns<DurationExGTELTE> = {
  encode(message: DurationExGTELTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== undefined) {
      Duration.encode(message.val, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DurationExGTELTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDurationExGTELTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DurationExGTELTE {
    return { val: isSet(object.val) ? Duration.fromJSON(object.val) : undefined };
  },

  toJSON(message: DurationExGTELTE): unknown {
    const obj: any = {};
    if (message.val !== undefined) {
      obj.val = Duration.toJSON(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<DurationExGTELTE>): DurationExGTELTE {
    return DurationExGTELTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DurationExGTELTE>): DurationExGTELTE {
    const message = createBaseDurationExGTELTE();
    message.val = (object.val !== undefined && object.val !== null) ? Duration.fromPartial(object.val) : undefined;
    return message;
  },
};

function createBaseDurationFieldWithOtherFields(): DurationFieldWithOtherFields {
  return { durationVal: undefined, intVal: 0 };
}

export const DurationFieldWithOtherFields: MessageFns<DurationFieldWithOtherFields> = {
  encode(message: DurationFieldWithOtherFields, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.durationVal !== undefined) {
      Duration.encode(message.durationVal, writer.uint32(10).fork()).join();
    }
    if (message.intVal !== 0) {
      writer.uint32(16).int32(message.intVal);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DurationFieldWithOtherFields {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDurationFieldWithOtherFields();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.durationVal = Duration.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.intVal = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DurationFieldWithOtherFields {
    return {
      durationVal: isSet(object.durationVal) ? Duration.fromJSON(object.durationVal) : undefined,
      intVal: isSet(object.intVal) ? globalThis.Number(object.intVal) : 0,
    };
  },

  toJSON(message: DurationFieldWithOtherFields): unknown {
    const obj: any = {};
    if (message.durationVal !== undefined) {
      obj.durationVal = Duration.toJSON(message.durationVal);
    }
    if (message.intVal !== 0) {
      obj.intVal = Math.round(message.intVal);
    }
    return obj;
  },

  create(base?: DeepPartial<DurationFieldWithOtherFields>): DurationFieldWithOtherFields {
    return DurationFieldWithOtherFields.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DurationFieldWithOtherFields>): DurationFieldWithOtherFields {
    const message = createBaseDurationFieldWithOtherFields();
    message.durationVal = (object.durationVal !== undefined && object.durationVal !== null)
      ? Duration.fromPartial(object.durationVal)
      : undefined;
    message.intVal = object.intVal ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
