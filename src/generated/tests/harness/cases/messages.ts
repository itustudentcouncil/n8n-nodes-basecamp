// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: tests/harness/cases/messages.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Embed } from "./other_package/embed.js";

export const protobufPackage = "tests.harness.cases";

export interface TestMsg {
  const: string;
  nested: TestMsg | undefined;
}

export interface MessageNone {
  val: MessageNone_NoneMsg | undefined;
}

export interface MessageNone_NoneMsg {
}

export interface MessageDisabled {
  val: Long;
}

export interface MessageIgnored {
  val: Long;
}

export interface Message {
  val: TestMsg | undefined;
}

export interface MessageCrossPackage {
  val: Embed | undefined;
}

export interface MessageSkip {
  val: TestMsg | undefined;
}

export interface MessageRequired {
  val: TestMsg | undefined;
}

export interface MessageRequiredButOptional {
  val?: TestMsg | undefined;
}

export interface MessageRequiredOneof {
  val?: TestMsg | undefined;
}

export interface MessageWith3dInside {
}

function createBaseTestMsg(): TestMsg {
  return { const: "", nested: undefined };
}

export const TestMsg: MessageFns<TestMsg> = {
  encode(message: TestMsg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.const !== "") {
      writer.uint32(10).string(message.const);
    }
    if (message.nested !== undefined) {
      TestMsg.encode(message.nested, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestMsg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.const = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nested = TestMsg.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestMsg {
    return {
      const: isSet(object.const) ? globalThis.String(object.const) : "",
      nested: isSet(object.nested) ? TestMsg.fromJSON(object.nested) : undefined,
    };
  },

  toJSON(message: TestMsg): unknown {
    const obj: any = {};
    if (message.const !== "") {
      obj.const = message.const;
    }
    if (message.nested !== undefined) {
      obj.nested = TestMsg.toJSON(message.nested);
    }
    return obj;
  },

  create(base?: DeepPartial<TestMsg>): TestMsg {
    return TestMsg.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TestMsg>): TestMsg {
    const message = createBaseTestMsg();
    message.const = object.const ?? "";
    message.nested = (object.nested !== undefined && object.nested !== null)
      ? TestMsg.fromPartial(object.nested)
      : undefined;
    return message;
  },
};

function createBaseMessageNone(): MessageNone {
  return { val: undefined };
}

export const MessageNone: MessageFns<MessageNone> = {
  encode(message: MessageNone, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== undefined) {
      MessageNone_NoneMsg.encode(message.val, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageNone {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageNone();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = MessageNone_NoneMsg.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageNone {
    return { val: isSet(object.val) ? MessageNone_NoneMsg.fromJSON(object.val) : undefined };
  },

  toJSON(message: MessageNone): unknown {
    const obj: any = {};
    if (message.val !== undefined) {
      obj.val = MessageNone_NoneMsg.toJSON(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<MessageNone>): MessageNone {
    return MessageNone.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MessageNone>): MessageNone {
    const message = createBaseMessageNone();
    message.val = (object.val !== undefined && object.val !== null)
      ? MessageNone_NoneMsg.fromPartial(object.val)
      : undefined;
    return message;
  },
};

function createBaseMessageNone_NoneMsg(): MessageNone_NoneMsg {
  return {};
}

export const MessageNone_NoneMsg: MessageFns<MessageNone_NoneMsg> = {
  encode(_: MessageNone_NoneMsg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageNone_NoneMsg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageNone_NoneMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MessageNone_NoneMsg {
    return {};
  },

  toJSON(_: MessageNone_NoneMsg): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MessageNone_NoneMsg>): MessageNone_NoneMsg {
    return MessageNone_NoneMsg.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MessageNone_NoneMsg>): MessageNone_NoneMsg {
    const message = createBaseMessageNone_NoneMsg();
    return message;
  },
};

function createBaseMessageDisabled(): MessageDisabled {
  return { val: Long.UZERO };
}

export const MessageDisabled: MessageFns<MessageDisabled> = {
  encode(message: MessageDisabled, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageDisabled {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageDisabled();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = Long.fromString(reader.uint64().toString(), true);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageDisabled {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.UZERO };
  },

  toJSON(message: MessageDisabled): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.UZERO)) {
      obj.val = (message.val || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<MessageDisabled>): MessageDisabled {
    return MessageDisabled.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MessageDisabled>): MessageDisabled {
    const message = createBaseMessageDisabled();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.UZERO;
    return message;
  },
};

function createBaseMessageIgnored(): MessageIgnored {
  return { val: Long.UZERO };
}

export const MessageIgnored: MessageFns<MessageIgnored> = {
  encode(message: MessageIgnored, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageIgnored {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageIgnored();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = Long.fromString(reader.uint64().toString(), true);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageIgnored {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.UZERO };
  },

  toJSON(message: MessageIgnored): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.UZERO)) {
      obj.val = (message.val || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<MessageIgnored>): MessageIgnored {
    return MessageIgnored.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MessageIgnored>): MessageIgnored {
    const message = createBaseMessageIgnored();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.UZERO;
    return message;
  },
};

function createBaseMessage(): Message {
  return { val: undefined };
}

export const Message: MessageFns<Message> = {
  encode(message: Message, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== undefined) {
      TestMsg.encode(message.val, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Message {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = TestMsg.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Message {
    return { val: isSet(object.val) ? TestMsg.fromJSON(object.val) : undefined };
  },

  toJSON(message: Message): unknown {
    const obj: any = {};
    if (message.val !== undefined) {
      obj.val = TestMsg.toJSON(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<Message>): Message {
    return Message.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Message>): Message {
    const message = createBaseMessage();
    message.val = (object.val !== undefined && object.val !== null) ? TestMsg.fromPartial(object.val) : undefined;
    return message;
  },
};

function createBaseMessageCrossPackage(): MessageCrossPackage {
  return { val: undefined };
}

export const MessageCrossPackage: MessageFns<MessageCrossPackage> = {
  encode(message: MessageCrossPackage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== undefined) {
      Embed.encode(message.val, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageCrossPackage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageCrossPackage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = Embed.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageCrossPackage {
    return { val: isSet(object.val) ? Embed.fromJSON(object.val) : undefined };
  },

  toJSON(message: MessageCrossPackage): unknown {
    const obj: any = {};
    if (message.val !== undefined) {
      obj.val = Embed.toJSON(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<MessageCrossPackage>): MessageCrossPackage {
    return MessageCrossPackage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MessageCrossPackage>): MessageCrossPackage {
    const message = createBaseMessageCrossPackage();
    message.val = (object.val !== undefined && object.val !== null) ? Embed.fromPartial(object.val) : undefined;
    return message;
  },
};

function createBaseMessageSkip(): MessageSkip {
  return { val: undefined };
}

export const MessageSkip: MessageFns<MessageSkip> = {
  encode(message: MessageSkip, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== undefined) {
      TestMsg.encode(message.val, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageSkip {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageSkip();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = TestMsg.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageSkip {
    return { val: isSet(object.val) ? TestMsg.fromJSON(object.val) : undefined };
  },

  toJSON(message: MessageSkip): unknown {
    const obj: any = {};
    if (message.val !== undefined) {
      obj.val = TestMsg.toJSON(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<MessageSkip>): MessageSkip {
    return MessageSkip.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MessageSkip>): MessageSkip {
    const message = createBaseMessageSkip();
    message.val = (object.val !== undefined && object.val !== null) ? TestMsg.fromPartial(object.val) : undefined;
    return message;
  },
};

function createBaseMessageRequired(): MessageRequired {
  return { val: undefined };
}

export const MessageRequired: MessageFns<MessageRequired> = {
  encode(message: MessageRequired, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== undefined) {
      TestMsg.encode(message.val, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageRequired {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageRequired();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = TestMsg.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageRequired {
    return { val: isSet(object.val) ? TestMsg.fromJSON(object.val) : undefined };
  },

  toJSON(message: MessageRequired): unknown {
    const obj: any = {};
    if (message.val !== undefined) {
      obj.val = TestMsg.toJSON(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<MessageRequired>): MessageRequired {
    return MessageRequired.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MessageRequired>): MessageRequired {
    const message = createBaseMessageRequired();
    message.val = (object.val !== undefined && object.val !== null) ? TestMsg.fromPartial(object.val) : undefined;
    return message;
  },
};

function createBaseMessageRequiredButOptional(): MessageRequiredButOptional {
  return { val: undefined };
}

export const MessageRequiredButOptional: MessageFns<MessageRequiredButOptional> = {
  encode(message: MessageRequiredButOptional, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== undefined) {
      TestMsg.encode(message.val, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageRequiredButOptional {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageRequiredButOptional();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = TestMsg.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageRequiredButOptional {
    return { val: isSet(object.val) ? TestMsg.fromJSON(object.val) : undefined };
  },

  toJSON(message: MessageRequiredButOptional): unknown {
    const obj: any = {};
    if (message.val !== undefined) {
      obj.val = TestMsg.toJSON(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<MessageRequiredButOptional>): MessageRequiredButOptional {
    return MessageRequiredButOptional.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MessageRequiredButOptional>): MessageRequiredButOptional {
    const message = createBaseMessageRequiredButOptional();
    message.val = (object.val !== undefined && object.val !== null) ? TestMsg.fromPartial(object.val) : undefined;
    return message;
  },
};

function createBaseMessageRequiredOneof(): MessageRequiredOneof {
  return { val: undefined };
}

export const MessageRequiredOneof: MessageFns<MessageRequiredOneof> = {
  encode(message: MessageRequiredOneof, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== undefined) {
      TestMsg.encode(message.val, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageRequiredOneof {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageRequiredOneof();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = TestMsg.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageRequiredOneof {
    return { val: isSet(object.val) ? TestMsg.fromJSON(object.val) : undefined };
  },

  toJSON(message: MessageRequiredOneof): unknown {
    const obj: any = {};
    if (message.val !== undefined) {
      obj.val = TestMsg.toJSON(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<MessageRequiredOneof>): MessageRequiredOneof {
    return MessageRequiredOneof.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MessageRequiredOneof>): MessageRequiredOneof {
    const message = createBaseMessageRequiredOneof();
    message.val = (object.val !== undefined && object.val !== null) ? TestMsg.fromPartial(object.val) : undefined;
    return message;
  },
};

function createBaseMessageWith3dInside(): MessageWith3dInside {
  return {};
}

export const MessageWith3dInside: MessageFns<MessageWith3dInside> = {
  encode(_: MessageWith3dInside, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageWith3dInside {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageWith3dInside();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MessageWith3dInside {
    return {};
  },

  toJSON(_: MessageWith3dInside): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MessageWith3dInside>): MessageWith3dInside {
    return MessageWith3dInside.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MessageWith3dInside>): MessageWith3dInside {
    const message = createBaseMessageWith3dInside();
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
