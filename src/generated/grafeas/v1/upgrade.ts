// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: grafeas/v1/upgrade.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../google/protobuf/timestamp.js";
import { Version } from "./package.js";

export const protobufPackage = "grafeas.v1";

/**
 * An Upgrade Note represents a potential upgrade of a package to a given
 * version. For each package version combination (i.e. bash 4.0, bash 4.1,
 * bash 4.1.2), there will be an Upgrade Note. For Windows, windows_update field
 * represents the information related to the update.
 */
export interface UpgradeNote {
  /** Required for non-Windows OS. The package this Upgrade is for. */
  package: string;
  /**
   * Required for non-Windows OS. The version of the package in machine + human
   * readable form.
   */
  version:
    | Version
    | undefined;
  /** Metadata about the upgrade for each specific operating system. */
  distributions: UpgradeDistribution[];
  /** Required for Windows OS. Represents the metadata about the Windows update. */
  windowsUpdate: WindowsUpdate | undefined;
}

/**
 * The Upgrade Distribution represents metadata about the Upgrade for each
 * operating system (CPE). Some distributions have additional metadata around
 * updates, classifying them into various categories and severities.
 */
export interface UpgradeDistribution {
  /**
   * Required - The specific operating system this metadata applies to. See
   * https://cpe.mitre.org/specification/.
   */
  cpeUri: string;
  /**
   * The operating system classification of this Upgrade, as specified by the
   * upstream operating system upgrade feed. For Windows the classification is
   * one of the category_ids listed at
   * https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ff357803(v=vs.85)
   */
  classification: string;
  /** The severity as specified by the upstream operating system. */
  severity: string;
  /** The cve tied to this Upgrade. */
  cve: string[];
}

/**
 * Windows Update represents the metadata about the update for the Windows
 * operating system. The fields in this message come from the Windows Update API
 * documented at
 * https://docs.microsoft.com/en-us/windows/win32/api/wuapi/nn-wuapi-iupdate.
 */
export interface WindowsUpdate {
  /** Required - The unique identifier for the update. */
  identity:
    | WindowsUpdate_Identity
    | undefined;
  /** The localized title of the update. */
  title: string;
  /** The localized description of the update. */
  description: string;
  /** The list of categories to which the update belongs. */
  categories: WindowsUpdate_Category[];
  /**
   * The Microsoft Knowledge Base article IDs that are associated with the
   * update.
   */
  kbArticleIds: string[];
  /** The hyperlink to the support information for the update. */
  supportUrl: string;
  /** The last published timestamp of the update. */
  lastPublishedTimestamp: Date | undefined;
}

/** The unique identifier of the update. */
export interface WindowsUpdate_Identity {
  /** The revision independent identifier of the update. */
  updateId: string;
  /** The revision number of the update. */
  revision: number;
}

/** The category to which the update belongs. */
export interface WindowsUpdate_Category {
  /** The identifier of the category. */
  categoryId: string;
  /** The localized name of the category. */
  name: string;
}

/**
 * An Upgrade Occurrence represents that a specific resource_url could install a
 * specific upgrade. This presence is supplied via local sources (i.e. it is
 * present in the mirror and the running system has noticed its availability).
 * For Windows, both distribution and windows_update contain information for the
 * Windows update.
 */
export interface UpgradeOccurrence {
  /** Required for non-Windows OS. The package this Upgrade is for. */
  package: string;
  /**
   * Required for non-Windows OS. The version of the package in a machine +
   * human readable form.
   */
  parsedVersion:
    | Version
    | undefined;
  /**
   * Metadata about the upgrade for available for the specific operating system
   * for the resource_url. This allows efficient filtering, as well as
   * making it easier to use the occurrence.
   */
  distribution:
    | UpgradeDistribution
    | undefined;
  /** Required for Windows OS. Represents the metadata about the Windows update. */
  windowsUpdate: WindowsUpdate | undefined;
}

function createBaseUpgradeNote(): UpgradeNote {
  return { package: "", version: undefined, distributions: [], windowsUpdate: undefined };
}

export const UpgradeNote: MessageFns<UpgradeNote> = {
  encode(message: UpgradeNote, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.package !== "") {
      writer.uint32(10).string(message.package);
    }
    if (message.version !== undefined) {
      Version.encode(message.version, writer.uint32(18).fork()).join();
    }
    for (const v of message.distributions) {
      UpgradeDistribution.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.windowsUpdate !== undefined) {
      WindowsUpdate.encode(message.windowsUpdate, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpgradeNote {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpgradeNote();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.package = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.version = Version.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.distributions.push(UpgradeDistribution.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.windowsUpdate = WindowsUpdate.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpgradeNote {
    return {
      package: isSet(object.package) ? globalThis.String(object.package) : "",
      version: isSet(object.version) ? Version.fromJSON(object.version) : undefined,
      distributions: globalThis.Array.isArray(object?.distributions)
        ? object.distributions.map((e: any) => UpgradeDistribution.fromJSON(e))
        : [],
      windowsUpdate: isSet(object.windowsUpdate) ? WindowsUpdate.fromJSON(object.windowsUpdate) : undefined,
    };
  },

  toJSON(message: UpgradeNote): unknown {
    const obj: any = {};
    if (message.package !== "") {
      obj.package = message.package;
    }
    if (message.version !== undefined) {
      obj.version = Version.toJSON(message.version);
    }
    if (message.distributions?.length) {
      obj.distributions = message.distributions.map((e) => UpgradeDistribution.toJSON(e));
    }
    if (message.windowsUpdate !== undefined) {
      obj.windowsUpdate = WindowsUpdate.toJSON(message.windowsUpdate);
    }
    return obj;
  },

  create(base?: DeepPartial<UpgradeNote>): UpgradeNote {
    return UpgradeNote.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpgradeNote>): UpgradeNote {
    const message = createBaseUpgradeNote();
    message.package = object.package ?? "";
    message.version = (object.version !== undefined && object.version !== null)
      ? Version.fromPartial(object.version)
      : undefined;
    message.distributions = object.distributions?.map((e) => UpgradeDistribution.fromPartial(e)) || [];
    message.windowsUpdate = (object.windowsUpdate !== undefined && object.windowsUpdate !== null)
      ? WindowsUpdate.fromPartial(object.windowsUpdate)
      : undefined;
    return message;
  },
};

function createBaseUpgradeDistribution(): UpgradeDistribution {
  return { cpeUri: "", classification: "", severity: "", cve: [] };
}

export const UpgradeDistribution: MessageFns<UpgradeDistribution> = {
  encode(message: UpgradeDistribution, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cpeUri !== "") {
      writer.uint32(10).string(message.cpeUri);
    }
    if (message.classification !== "") {
      writer.uint32(18).string(message.classification);
    }
    if (message.severity !== "") {
      writer.uint32(26).string(message.severity);
    }
    for (const v of message.cve) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpgradeDistribution {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpgradeDistribution();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cpeUri = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.classification = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.severity = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.cve.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpgradeDistribution {
    return {
      cpeUri: isSet(object.cpeUri) ? globalThis.String(object.cpeUri) : "",
      classification: isSet(object.classification) ? globalThis.String(object.classification) : "",
      severity: isSet(object.severity) ? globalThis.String(object.severity) : "",
      cve: globalThis.Array.isArray(object?.cve) ? object.cve.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: UpgradeDistribution): unknown {
    const obj: any = {};
    if (message.cpeUri !== "") {
      obj.cpeUri = message.cpeUri;
    }
    if (message.classification !== "") {
      obj.classification = message.classification;
    }
    if (message.severity !== "") {
      obj.severity = message.severity;
    }
    if (message.cve?.length) {
      obj.cve = message.cve;
    }
    return obj;
  },

  create(base?: DeepPartial<UpgradeDistribution>): UpgradeDistribution {
    return UpgradeDistribution.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpgradeDistribution>): UpgradeDistribution {
    const message = createBaseUpgradeDistribution();
    message.cpeUri = object.cpeUri ?? "";
    message.classification = object.classification ?? "";
    message.severity = object.severity ?? "";
    message.cve = object.cve?.map((e) => e) || [];
    return message;
  },
};

function createBaseWindowsUpdate(): WindowsUpdate {
  return {
    identity: undefined,
    title: "",
    description: "",
    categories: [],
    kbArticleIds: [],
    supportUrl: "",
    lastPublishedTimestamp: undefined,
  };
}

export const WindowsUpdate: MessageFns<WindowsUpdate> = {
  encode(message: WindowsUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.identity !== undefined) {
      WindowsUpdate_Identity.encode(message.identity, writer.uint32(10).fork()).join();
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    for (const v of message.categories) {
      WindowsUpdate_Category.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.kbArticleIds) {
      writer.uint32(42).string(v!);
    }
    if (message.supportUrl !== "") {
      writer.uint32(50).string(message.supportUrl);
    }
    if (message.lastPublishedTimestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.lastPublishedTimestamp), writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WindowsUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWindowsUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.identity = WindowsUpdate_Identity.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.categories.push(WindowsUpdate_Category.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.kbArticleIds.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.supportUrl = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.lastPublishedTimestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WindowsUpdate {
    return {
      identity: isSet(object.identity) ? WindowsUpdate_Identity.fromJSON(object.identity) : undefined,
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      categories: globalThis.Array.isArray(object?.categories)
        ? object.categories.map((e: any) => WindowsUpdate_Category.fromJSON(e))
        : [],
      kbArticleIds: globalThis.Array.isArray(object?.kbArticleIds)
        ? object.kbArticleIds.map((e: any) => globalThis.String(e))
        : [],
      supportUrl: isSet(object.supportUrl) ? globalThis.String(object.supportUrl) : "",
      lastPublishedTimestamp: isSet(object.lastPublishedTimestamp)
        ? fromJsonTimestamp(object.lastPublishedTimestamp)
        : undefined,
    };
  },

  toJSON(message: WindowsUpdate): unknown {
    const obj: any = {};
    if (message.identity !== undefined) {
      obj.identity = WindowsUpdate_Identity.toJSON(message.identity);
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.categories?.length) {
      obj.categories = message.categories.map((e) => WindowsUpdate_Category.toJSON(e));
    }
    if (message.kbArticleIds?.length) {
      obj.kbArticleIds = message.kbArticleIds;
    }
    if (message.supportUrl !== "") {
      obj.supportUrl = message.supportUrl;
    }
    if (message.lastPublishedTimestamp !== undefined) {
      obj.lastPublishedTimestamp = message.lastPublishedTimestamp.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<WindowsUpdate>): WindowsUpdate {
    return WindowsUpdate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WindowsUpdate>): WindowsUpdate {
    const message = createBaseWindowsUpdate();
    message.identity = (object.identity !== undefined && object.identity !== null)
      ? WindowsUpdate_Identity.fromPartial(object.identity)
      : undefined;
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.categories = object.categories?.map((e) => WindowsUpdate_Category.fromPartial(e)) || [];
    message.kbArticleIds = object.kbArticleIds?.map((e) => e) || [];
    message.supportUrl = object.supportUrl ?? "";
    message.lastPublishedTimestamp = object.lastPublishedTimestamp ?? undefined;
    return message;
  },
};

function createBaseWindowsUpdate_Identity(): WindowsUpdate_Identity {
  return { updateId: "", revision: 0 };
}

export const WindowsUpdate_Identity: MessageFns<WindowsUpdate_Identity> = {
  encode(message: WindowsUpdate_Identity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateId !== "") {
      writer.uint32(10).string(message.updateId);
    }
    if (message.revision !== 0) {
      writer.uint32(16).int32(message.revision);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WindowsUpdate_Identity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWindowsUpdate_Identity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.revision = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WindowsUpdate_Identity {
    return {
      updateId: isSet(object.updateId) ? globalThis.String(object.updateId) : "",
      revision: isSet(object.revision) ? globalThis.Number(object.revision) : 0,
    };
  },

  toJSON(message: WindowsUpdate_Identity): unknown {
    const obj: any = {};
    if (message.updateId !== "") {
      obj.updateId = message.updateId;
    }
    if (message.revision !== 0) {
      obj.revision = Math.round(message.revision);
    }
    return obj;
  },

  create(base?: DeepPartial<WindowsUpdate_Identity>): WindowsUpdate_Identity {
    return WindowsUpdate_Identity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WindowsUpdate_Identity>): WindowsUpdate_Identity {
    const message = createBaseWindowsUpdate_Identity();
    message.updateId = object.updateId ?? "";
    message.revision = object.revision ?? 0;
    return message;
  },
};

function createBaseWindowsUpdate_Category(): WindowsUpdate_Category {
  return { categoryId: "", name: "" };
}

export const WindowsUpdate_Category: MessageFns<WindowsUpdate_Category> = {
  encode(message: WindowsUpdate_Category, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.categoryId !== "") {
      writer.uint32(10).string(message.categoryId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WindowsUpdate_Category {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWindowsUpdate_Category();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.categoryId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WindowsUpdate_Category {
    return {
      categoryId: isSet(object.categoryId) ? globalThis.String(object.categoryId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: WindowsUpdate_Category): unknown {
    const obj: any = {};
    if (message.categoryId !== "") {
      obj.categoryId = message.categoryId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<WindowsUpdate_Category>): WindowsUpdate_Category {
    return WindowsUpdate_Category.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WindowsUpdate_Category>): WindowsUpdate_Category {
    const message = createBaseWindowsUpdate_Category();
    message.categoryId = object.categoryId ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpgradeOccurrence(): UpgradeOccurrence {
  return { package: "", parsedVersion: undefined, distribution: undefined, windowsUpdate: undefined };
}

export const UpgradeOccurrence: MessageFns<UpgradeOccurrence> = {
  encode(message: UpgradeOccurrence, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.package !== "") {
      writer.uint32(10).string(message.package);
    }
    if (message.parsedVersion !== undefined) {
      Version.encode(message.parsedVersion, writer.uint32(26).fork()).join();
    }
    if (message.distribution !== undefined) {
      UpgradeDistribution.encode(message.distribution, writer.uint32(34).fork()).join();
    }
    if (message.windowsUpdate !== undefined) {
      WindowsUpdate.encode(message.windowsUpdate, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpgradeOccurrence {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpgradeOccurrence();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.package = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.parsedVersion = Version.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.distribution = UpgradeDistribution.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.windowsUpdate = WindowsUpdate.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpgradeOccurrence {
    return {
      package: isSet(object.package) ? globalThis.String(object.package) : "",
      parsedVersion: isSet(object.parsedVersion) ? Version.fromJSON(object.parsedVersion) : undefined,
      distribution: isSet(object.distribution) ? UpgradeDistribution.fromJSON(object.distribution) : undefined,
      windowsUpdate: isSet(object.windowsUpdate) ? WindowsUpdate.fromJSON(object.windowsUpdate) : undefined,
    };
  },

  toJSON(message: UpgradeOccurrence): unknown {
    const obj: any = {};
    if (message.package !== "") {
      obj.package = message.package;
    }
    if (message.parsedVersion !== undefined) {
      obj.parsedVersion = Version.toJSON(message.parsedVersion);
    }
    if (message.distribution !== undefined) {
      obj.distribution = UpgradeDistribution.toJSON(message.distribution);
    }
    if (message.windowsUpdate !== undefined) {
      obj.windowsUpdate = WindowsUpdate.toJSON(message.windowsUpdate);
    }
    return obj;
  },

  create(base?: DeepPartial<UpgradeOccurrence>): UpgradeOccurrence {
    return UpgradeOccurrence.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpgradeOccurrence>): UpgradeOccurrence {
    const message = createBaseUpgradeOccurrence();
    message.package = object.package ?? "";
    message.parsedVersion = (object.parsedVersion !== undefined && object.parsedVersion !== null)
      ? Version.fromPartial(object.parsedVersion)
      : undefined;
    message.distribution = (object.distribution !== undefined && object.distribution !== null)
      ? UpgradeDistribution.fromPartial(object.distribution)
      : undefined;
    message.windowsUpdate = (object.windowsUpdate !== undefined && object.windowsUpdate !== null)
      ? WindowsUpdate.fromPartial(object.windowsUpdate)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
