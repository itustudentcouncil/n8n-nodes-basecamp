// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: grafeas/v1/dsse_attestation.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Envelope } from "./common.js";
import { InTotoStatement } from "./intoto_statement.js";

export const protobufPackage = "grafeas.v1";

/**
 * Copyright 2021 The Grafeas Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export interface DSSEAttestationNote {
  /** DSSEHint hints at the purpose of the attestation authority. */
  hint: DSSEAttestationNote_DSSEHint | undefined;
}

/**
 * This submessage provides human-readable hints about the purpose of the
 * authority. Because the name of a note acts as its resource reference, it is
 * important to disambiguate the canonical name of the Note (which might be a
 * UUID for security purposes) from "readable" names more suitable for debug
 * output. Note that these hints should not be used to look up authorities in
 * security sensitive contexts, such as when looking up attestations to
 * verify.
 */
export interface DSSEAttestationNote_DSSEHint {
  /**
   * Required. The human readable name of this attestation authority, for
   * example "cloudbuild-prod".
   */
  humanReadableName: string;
}

/**
 * Deprecated. Prefer to use a regular Occurrence, and populate the
 * Envelope at the top level of the Occurrence.
 */
export interface DSSEAttestationOccurrence {
  /**
   * If doing something security critical, make sure to verify the signatures in
   * this metadata.
   */
  envelope: Envelope | undefined;
  statement?: InTotoStatement | undefined;
}

function createBaseDSSEAttestationNote(): DSSEAttestationNote {
  return { hint: undefined };
}

export const DSSEAttestationNote: MessageFns<DSSEAttestationNote> = {
  encode(message: DSSEAttestationNote, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hint !== undefined) {
      DSSEAttestationNote_DSSEHint.encode(message.hint, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DSSEAttestationNote {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDSSEAttestationNote();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.hint = DSSEAttestationNote_DSSEHint.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DSSEAttestationNote {
    return { hint: isSet(object.hint) ? DSSEAttestationNote_DSSEHint.fromJSON(object.hint) : undefined };
  },

  toJSON(message: DSSEAttestationNote): unknown {
    const obj: any = {};
    if (message.hint !== undefined) {
      obj.hint = DSSEAttestationNote_DSSEHint.toJSON(message.hint);
    }
    return obj;
  },

  create(base?: DeepPartial<DSSEAttestationNote>): DSSEAttestationNote {
    return DSSEAttestationNote.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DSSEAttestationNote>): DSSEAttestationNote {
    const message = createBaseDSSEAttestationNote();
    message.hint = (object.hint !== undefined && object.hint !== null)
      ? DSSEAttestationNote_DSSEHint.fromPartial(object.hint)
      : undefined;
    return message;
  },
};

function createBaseDSSEAttestationNote_DSSEHint(): DSSEAttestationNote_DSSEHint {
  return { humanReadableName: "" };
}

export const DSSEAttestationNote_DSSEHint: MessageFns<DSSEAttestationNote_DSSEHint> = {
  encode(message: DSSEAttestationNote_DSSEHint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.humanReadableName !== "") {
      writer.uint32(10).string(message.humanReadableName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DSSEAttestationNote_DSSEHint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDSSEAttestationNote_DSSEHint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.humanReadableName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DSSEAttestationNote_DSSEHint {
    return { humanReadableName: isSet(object.humanReadableName) ? globalThis.String(object.humanReadableName) : "" };
  },

  toJSON(message: DSSEAttestationNote_DSSEHint): unknown {
    const obj: any = {};
    if (message.humanReadableName !== "") {
      obj.humanReadableName = message.humanReadableName;
    }
    return obj;
  },

  create(base?: DeepPartial<DSSEAttestationNote_DSSEHint>): DSSEAttestationNote_DSSEHint {
    return DSSEAttestationNote_DSSEHint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DSSEAttestationNote_DSSEHint>): DSSEAttestationNote_DSSEHint {
    const message = createBaseDSSEAttestationNote_DSSEHint();
    message.humanReadableName = object.humanReadableName ?? "";
    return message;
  },
};

function createBaseDSSEAttestationOccurrence(): DSSEAttestationOccurrence {
  return { envelope: undefined, statement: undefined };
}

export const DSSEAttestationOccurrence: MessageFns<DSSEAttestationOccurrence> = {
  encode(message: DSSEAttestationOccurrence, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.envelope !== undefined) {
      Envelope.encode(message.envelope, writer.uint32(10).fork()).join();
    }
    if (message.statement !== undefined) {
      InTotoStatement.encode(message.statement, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DSSEAttestationOccurrence {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDSSEAttestationOccurrence();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.envelope = Envelope.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.statement = InTotoStatement.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DSSEAttestationOccurrence {
    return {
      envelope: isSet(object.envelope) ? Envelope.fromJSON(object.envelope) : undefined,
      statement: isSet(object.statement) ? InTotoStatement.fromJSON(object.statement) : undefined,
    };
  },

  toJSON(message: DSSEAttestationOccurrence): unknown {
    const obj: any = {};
    if (message.envelope !== undefined) {
      obj.envelope = Envelope.toJSON(message.envelope);
    }
    if (message.statement !== undefined) {
      obj.statement = InTotoStatement.toJSON(message.statement);
    }
    return obj;
  },

  create(base?: DeepPartial<DSSEAttestationOccurrence>): DSSEAttestationOccurrence {
    return DSSEAttestationOccurrence.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DSSEAttestationOccurrence>): DSSEAttestationOccurrence {
    const message = createBaseDSSEAttestationOccurrence();
    message.envelope = (object.envelope !== undefined && object.envelope !== null)
      ? Envelope.fromPartial(object.envelope)
      : undefined;
    message.statement = (object.statement !== undefined && object.statement !== null)
      ? InTotoStatement.fromPartial(object.statement)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
