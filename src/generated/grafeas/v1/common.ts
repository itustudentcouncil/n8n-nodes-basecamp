// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: grafeas/v1/common.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "grafeas.v1";

/** Kind represents the kinds of notes supported. */
export enum NoteKind {
  /** NOTE_KIND_UNSPECIFIED - Default value. This value is unused. */
  NOTE_KIND_UNSPECIFIED = 0,
  /** VULNERABILITY - The note and occurrence represent a package vulnerability. */
  VULNERABILITY = 1,
  /** BUILD - The note and occurrence assert build provenance. */
  BUILD = 2,
  /** IMAGE - This represents an image basis relationship. */
  IMAGE = 3,
  /** PACKAGE - This represents a package installed via a package manager. */
  PACKAGE = 4,
  /** DEPLOYMENT - The note and occurrence track deployment events. */
  DEPLOYMENT = 5,
  /** DISCOVERY - The note and occurrence track the initial discovery status of a resource. */
  DISCOVERY = 6,
  /** ATTESTATION - This represents a logical "role" that can attest to artifacts. */
  ATTESTATION = 7,
  /** UPGRADE - This represents an available package upgrade. */
  UPGRADE = 8,
  /** COMPLIANCE - This represents a Compliance Note */
  COMPLIANCE = 9,
  /** DSSE_ATTESTATION - This represents a DSSE attestation Note */
  DSSE_ATTESTATION = 10,
  /** VULNERABILITY_ASSESSMENT - This represents a Vulnerability Assessment. */
  VULNERABILITY_ASSESSMENT = 11,
  /** SBOM_REFERENCE - This represents an SBOM Reference. */
  SBOM_REFERENCE = 12,
  UNRECOGNIZED = -1,
}

export function noteKindFromJSON(object: any): NoteKind {
  switch (object) {
    case 0:
    case "NOTE_KIND_UNSPECIFIED":
      return NoteKind.NOTE_KIND_UNSPECIFIED;
    case 1:
    case "VULNERABILITY":
      return NoteKind.VULNERABILITY;
    case 2:
    case "BUILD":
      return NoteKind.BUILD;
    case 3:
    case "IMAGE":
      return NoteKind.IMAGE;
    case 4:
    case "PACKAGE":
      return NoteKind.PACKAGE;
    case 5:
    case "DEPLOYMENT":
      return NoteKind.DEPLOYMENT;
    case 6:
    case "DISCOVERY":
      return NoteKind.DISCOVERY;
    case 7:
    case "ATTESTATION":
      return NoteKind.ATTESTATION;
    case 8:
    case "UPGRADE":
      return NoteKind.UPGRADE;
    case 9:
    case "COMPLIANCE":
      return NoteKind.COMPLIANCE;
    case 10:
    case "DSSE_ATTESTATION":
      return NoteKind.DSSE_ATTESTATION;
    case 11:
    case "VULNERABILITY_ASSESSMENT":
      return NoteKind.VULNERABILITY_ASSESSMENT;
    case 12:
    case "SBOM_REFERENCE":
      return NoteKind.SBOM_REFERENCE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NoteKind.UNRECOGNIZED;
  }
}

export function noteKindToJSON(object: NoteKind): string {
  switch (object) {
    case NoteKind.NOTE_KIND_UNSPECIFIED:
      return "NOTE_KIND_UNSPECIFIED";
    case NoteKind.VULNERABILITY:
      return "VULNERABILITY";
    case NoteKind.BUILD:
      return "BUILD";
    case NoteKind.IMAGE:
      return "IMAGE";
    case NoteKind.PACKAGE:
      return "PACKAGE";
    case NoteKind.DEPLOYMENT:
      return "DEPLOYMENT";
    case NoteKind.DISCOVERY:
      return "DISCOVERY";
    case NoteKind.ATTESTATION:
      return "ATTESTATION";
    case NoteKind.UPGRADE:
      return "UPGRADE";
    case NoteKind.COMPLIANCE:
      return "COMPLIANCE";
    case NoteKind.DSSE_ATTESTATION:
      return "DSSE_ATTESTATION";
    case NoteKind.VULNERABILITY_ASSESSMENT:
      return "VULNERABILITY_ASSESSMENT";
    case NoteKind.SBOM_REFERENCE:
      return "SBOM_REFERENCE";
    case NoteKind.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Metadata for any related URL information. */
export interface RelatedUrl {
  /** Specific URL associated with the resource. */
  url: string;
  /** Label to describe usage of the URL. */
  label: string;
}

/**
 * Verifiers (e.g. Kritis implementations) MUST verify signatures
 * with respect to the trust anchors defined in policy (e.g. a Kritis policy).
 * Typically this means that the verifier has been configured with a map from
 * `public_key_id` to public key material (and any required parameters, e.g.
 * signing algorithm).
 *
 * In particular, verification implementations MUST NOT treat the signature
 * `public_key_id` as anything more than a key lookup hint. The `public_key_id`
 * DOES NOT validate or authenticate a public key; it only provides a mechanism
 * for quickly selecting a public key ALREADY CONFIGURED on the verifier through
 * a trusted channel. Verification implementations MUST reject signatures in any
 * of the following circumstances:
 *   * The `public_key_id` is not recognized by the verifier.
 *   * The public key that `public_key_id` refers to does not verify the
 *     signature with respect to the payload.
 *
 * The `signature` contents SHOULD NOT be "attached" (where the payload is
 * included with the serialized `signature` bytes). Verifiers MUST ignore any
 * "attached" payload and only verify signatures with respect to explicitly
 * provided payload (e.g. a `payload` field on the proto message that holds
 * this Signature, or the canonical serialization of the proto message that
 * holds this signature).
 */
export interface Signature {
  /**
   * The content of the signature, an opaque bytestring.
   * The payload that this signature verifies MUST be unambiguously provided
   * with the Signature during verification. A wrapper message might provide
   * the payload explicitly. Alternatively, a message might have a canonical
   * serialization that can always be unambiguously computed to derive the
   * payload.
   */
  signature: Buffer;
  /**
   * The identifier for the public key that verifies this signature.
   *   * The `public_key_id` is required.
   *   * The `public_key_id` SHOULD be an RFC3986 conformant URI.
   *   * When possible, the `public_key_id` SHOULD be an immutable reference,
   *     such as a cryptographic digest.
   *
   * Examples of valid `public_key_id`s:
   *
   * OpenPGP V4 public key fingerprint:
   *   * "openpgp4fpr:74FAF3B861BDA0870C7B6DEF607E48D2A663AEEA"
   * See https://www.iana.org/assignments/uri-schemes/prov/openpgp4fpr for more
   * details on this scheme.
   *
   * RFC6920 digest-named SubjectPublicKeyInfo (digest of the DER
   * serialization):
   *   * "ni:///sha-256;cD9o9Cq6LG3jD0iKXqEi_vdjJGecm_iXkbqVoScViaU"
   *   * "nih:///sha-256;703f68f42aba2c6de30f488a5ea122fef76324679c9bf89791ba95a1271589a5"
   */
  publicKeyId: string;
}

/**
 * MUST match
 * https://github.com/secure-systems-lab/dsse/blob/master/envelope.proto. An
 * authenticated message of arbitrary type.
 */
export interface Envelope {
  payload: Buffer;
  payloadType: string;
  signatures: EnvelopeSignature[];
}

export interface EnvelopeSignature {
  sig: Buffer;
  keyid: string;
}

/** Indicates the location at which a package was found. */
export interface FileLocation {
  /**
   * For jars that are contained inside .war files, this filepath
   * can indicate the path to war file combined with the path to jar file.
   */
  filePath: string;
}

/** License information. */
export interface License {
  /**
   * Often a single license can be used to represent the licensing terms.
   * Sometimes it is necessary to include a choice of one or more licenses
   * or some combination of license identifiers.
   * Examples: "LGPL-2.1-only OR MIT", "LGPL-2.1-only AND MIT",
   * "GPL-2.0-or-later WITH Bison-exception-2.2".
   */
  expression: string;
  /** Comments */
  comments: string;
}

/** Digest information. */
export interface Digest {
  /** `SHA1`, `SHA512` etc. */
  algo: string;
  /** Value of the digest. */
  digestBytes: Buffer;
}

function createBaseRelatedUrl(): RelatedUrl {
  return { url: "", label: "" };
}

export const RelatedUrl: MessageFns<RelatedUrl> = {
  encode(message: RelatedUrl, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.label !== "") {
      writer.uint32(18).string(message.label);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RelatedUrl {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRelatedUrl();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.label = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RelatedUrl {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      label: isSet(object.label) ? globalThis.String(object.label) : "",
    };
  },

  toJSON(message: RelatedUrl): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    return obj;
  },

  create(base?: DeepPartial<RelatedUrl>): RelatedUrl {
    return RelatedUrl.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RelatedUrl>): RelatedUrl {
    const message = createBaseRelatedUrl();
    message.url = object.url ?? "";
    message.label = object.label ?? "";
    return message;
  },
};

function createBaseSignature(): Signature {
  return { signature: Buffer.alloc(0), publicKeyId: "" };
}

export const Signature: MessageFns<Signature> = {
  encode(message: Signature, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signature.length !== 0) {
      writer.uint32(10).bytes(message.signature);
    }
    if (message.publicKeyId !== "") {
      writer.uint32(18).string(message.publicKeyId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Signature {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.signature = Buffer.from(reader.bytes());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.publicKeyId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Signature {
    return {
      signature: isSet(object.signature) ? Buffer.from(bytesFromBase64(object.signature)) : Buffer.alloc(0),
      publicKeyId: isSet(object.publicKeyId) ? globalThis.String(object.publicKeyId) : "",
    };
  },

  toJSON(message: Signature): unknown {
    const obj: any = {};
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    if (message.publicKeyId !== "") {
      obj.publicKeyId = message.publicKeyId;
    }
    return obj;
  },

  create(base?: DeepPartial<Signature>): Signature {
    return Signature.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Signature>): Signature {
    const message = createBaseSignature();
    message.signature = object.signature ?? Buffer.alloc(0);
    message.publicKeyId = object.publicKeyId ?? "";
    return message;
  },
};

function createBaseEnvelope(): Envelope {
  return { payload: Buffer.alloc(0), payloadType: "", signatures: [] };
}

export const Envelope: MessageFns<Envelope> = {
  encode(message: Envelope, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload.length !== 0) {
      writer.uint32(10).bytes(message.payload);
    }
    if (message.payloadType !== "") {
      writer.uint32(18).string(message.payloadType);
    }
    for (const v of message.signatures) {
      EnvelopeSignature.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Envelope {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnvelope();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.payload = Buffer.from(reader.bytes());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.payloadType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.signatures.push(EnvelopeSignature.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Envelope {
    return {
      payload: isSet(object.payload) ? Buffer.from(bytesFromBase64(object.payload)) : Buffer.alloc(0),
      payloadType: isSet(object.payloadType) ? globalThis.String(object.payloadType) : "",
      signatures: globalThis.Array.isArray(object?.signatures)
        ? object.signatures.map((e: any) => EnvelopeSignature.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Envelope): unknown {
    const obj: any = {};
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    if (message.payloadType !== "") {
      obj.payloadType = message.payloadType;
    }
    if (message.signatures?.length) {
      obj.signatures = message.signatures.map((e) => EnvelopeSignature.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Envelope>): Envelope {
    return Envelope.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Envelope>): Envelope {
    const message = createBaseEnvelope();
    message.payload = object.payload ?? Buffer.alloc(0);
    message.payloadType = object.payloadType ?? "";
    message.signatures = object.signatures?.map((e) => EnvelopeSignature.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEnvelopeSignature(): EnvelopeSignature {
  return { sig: Buffer.alloc(0), keyid: "" };
}

export const EnvelopeSignature: MessageFns<EnvelopeSignature> = {
  encode(message: EnvelopeSignature, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sig.length !== 0) {
      writer.uint32(10).bytes(message.sig);
    }
    if (message.keyid !== "") {
      writer.uint32(18).string(message.keyid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnvelopeSignature {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnvelopeSignature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sig = Buffer.from(reader.bytes());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.keyid = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnvelopeSignature {
    return {
      sig: isSet(object.sig) ? Buffer.from(bytesFromBase64(object.sig)) : Buffer.alloc(0),
      keyid: isSet(object.keyid) ? globalThis.String(object.keyid) : "",
    };
  },

  toJSON(message: EnvelopeSignature): unknown {
    const obj: any = {};
    if (message.sig.length !== 0) {
      obj.sig = base64FromBytes(message.sig);
    }
    if (message.keyid !== "") {
      obj.keyid = message.keyid;
    }
    return obj;
  },

  create(base?: DeepPartial<EnvelopeSignature>): EnvelopeSignature {
    return EnvelopeSignature.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EnvelopeSignature>): EnvelopeSignature {
    const message = createBaseEnvelopeSignature();
    message.sig = object.sig ?? Buffer.alloc(0);
    message.keyid = object.keyid ?? "";
    return message;
  },
};

function createBaseFileLocation(): FileLocation {
  return { filePath: "" };
}

export const FileLocation: MessageFns<FileLocation> = {
  encode(message: FileLocation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filePath !== "") {
      writer.uint32(10).string(message.filePath);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileLocation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileLocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.filePath = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileLocation {
    return { filePath: isSet(object.filePath) ? globalThis.String(object.filePath) : "" };
  },

  toJSON(message: FileLocation): unknown {
    const obj: any = {};
    if (message.filePath !== "") {
      obj.filePath = message.filePath;
    }
    return obj;
  },

  create(base?: DeepPartial<FileLocation>): FileLocation {
    return FileLocation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FileLocation>): FileLocation {
    const message = createBaseFileLocation();
    message.filePath = object.filePath ?? "";
    return message;
  },
};

function createBaseLicense(): License {
  return { expression: "", comments: "" };
}

export const License: MessageFns<License> = {
  encode(message: License, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.expression !== "") {
      writer.uint32(10).string(message.expression);
    }
    if (message.comments !== "") {
      writer.uint32(18).string(message.comments);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): License {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLicense();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.expression = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.comments = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): License {
    return {
      expression: isSet(object.expression) ? globalThis.String(object.expression) : "",
      comments: isSet(object.comments) ? globalThis.String(object.comments) : "",
    };
  },

  toJSON(message: License): unknown {
    const obj: any = {};
    if (message.expression !== "") {
      obj.expression = message.expression;
    }
    if (message.comments !== "") {
      obj.comments = message.comments;
    }
    return obj;
  },

  create(base?: DeepPartial<License>): License {
    return License.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<License>): License {
    const message = createBaseLicense();
    message.expression = object.expression ?? "";
    message.comments = object.comments ?? "";
    return message;
  },
};

function createBaseDigest(): Digest {
  return { algo: "", digestBytes: Buffer.alloc(0) };
}

export const Digest: MessageFns<Digest> = {
  encode(message: Digest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.algo !== "") {
      writer.uint32(10).string(message.algo);
    }
    if (message.digestBytes.length !== 0) {
      writer.uint32(18).bytes(message.digestBytes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Digest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDigest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.algo = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.digestBytes = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Digest {
    return {
      algo: isSet(object.algo) ? globalThis.String(object.algo) : "",
      digestBytes: isSet(object.digestBytes) ? Buffer.from(bytesFromBase64(object.digestBytes)) : Buffer.alloc(0),
    };
  },

  toJSON(message: Digest): unknown {
    const obj: any = {};
    if (message.algo !== "") {
      obj.algo = message.algo;
    }
    if (message.digestBytes.length !== 0) {
      obj.digestBytes = base64FromBytes(message.digestBytes);
    }
    return obj;
  },

  create(base?: DeepPartial<Digest>): Digest {
    return Digest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Digest>): Digest {
    const message = createBaseDigest();
    message.algo = object.algo ?? "";
    message.digestBytes = object.digestBytes ?? Buffer.alloc(0);
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
