// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: grafeas/v1/vulnerability.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../google/protobuf/timestamp.js";
import { FileLocation, RelatedUrl } from "./common.js";
import { CVSS, CVSSv3, CVSSVersion, cVSSVersionFromJSON, cVSSVersionToJSON } from "./cvss.js";
import { Version } from "./package.js";
import { Severity, severityFromJSON, severityToJSON } from "./severity.js";
import {
  VulnerabilityAssessmentNote_Assessment_Justification,
  VulnerabilityAssessmentNote_Assessment_Remediation,
  VulnerabilityAssessmentNote_Assessment_State,
  vulnerabilityAssessmentNote_Assessment_StateFromJSON,
  vulnerabilityAssessmentNote_Assessment_StateToJSON,
} from "./vex.js";

export const protobufPackage = "grafeas.v1";

/** A security vulnerability that can be found in resources. */
export interface VulnerabilityNote {
  /**
   * The CVSS score of this vulnerability. CVSS score is on a scale of 0 - 10
   * where 0 indicates low severity and 10 indicates high severity.
   */
  cvssScore: number;
  /** The note provider assigned severity of this vulnerability. */
  severity: Severity;
  /** Details of all known distros and packages affected by this vulnerability. */
  details: VulnerabilityNote_Detail[];
  /** The full description of the CVSSv3 for this vulnerability. */
  cvssV3:
    | CVSSv3
    | undefined;
  /**
   * Windows details get their own format because the information format and
   * model don't match a normal detail. Specifically Windows updates are done as
   * patches, thus Windows vulnerabilities really are a missing package, rather
   * than a package being at an incorrect version.
   */
  windowsDetails: VulnerabilityNote_WindowsDetail[];
  /**
   * The time this information was last changed at the source. This is an
   * upstream timestamp from the underlying information source - e.g. Ubuntu
   * security tracker.
   */
  sourceUpdateTime:
    | Date
    | undefined;
  /** CVSS version used to populate cvss_score and severity. */
  cvssVersion: CVSSVersion;
  /** The full description of the v2 CVSS for this vulnerability. */
  cvssV2: CVSS | undefined;
}

/**
 * A detail for a distro and package affected by this vulnerability and its
 * associated fix (if one is available).
 */
export interface VulnerabilityNote_Detail {
  /** The distro assigned severity of this vulnerability. */
  severityName: string;
  /** A vendor-specific description of this vulnerability. */
  description: string;
  /**
   * The type of package; whether native or non native (e.g., ruby gems,
   * node.js packages, etc.).
   */
  packageType: string;
  /**
   * Required. The [CPE URI](https://cpe.mitre.org/specification/) this
   * vulnerability affects.
   */
  affectedCpeUri: string;
  /** Required. The package this vulnerability affects. */
  affectedPackage: string;
  /**
   * The version number at the start of an interval in which this
   * vulnerability exists. A vulnerability can affect a package between
   * version numbers that are disjoint sets of intervals (example:
   * [1.0.0-1.1.0], [2.4.6-2.4.8] and [4.5.6-4.6.8]) each of which will be
   * represented in its own Detail. If a specific affected version is provided
   * by a vulnerability database, affected_version_start and
   * affected_version_end will be the same in that Detail.
   */
  affectedVersionStart:
    | Version
    | undefined;
  /**
   * The version number at the end of an interval in which this vulnerability
   * exists. A vulnerability can affect a package between version numbers
   * that are disjoint sets of intervals (example: [1.0.0-1.1.0],
   * [2.4.6-2.4.8] and [4.5.6-4.6.8]) each of which will be represented in its
   * own Detail. If a specific affected version is provided by a vulnerability
   * database, affected_version_start and affected_version_end will be the
   * same in that Detail.
   */
  affectedVersionEnd:
    | Version
    | undefined;
  /**
   * The distro recommended [CPE URI](https://cpe.mitre.org/specification/)
   * to update to that contains a fix for this vulnerability. It is possible
   * for this to be different from the affected_cpe_uri.
   */
  fixedCpeUri: string;
  /**
   * The distro recommended package to update to that contains a fix for this
   * vulnerability. It is possible for this to be different from the
   * affected_package.
   */
  fixedPackage: string;
  /**
   * The distro recommended version to update to that contains a
   * fix for this vulnerability. Setting this to VersionKind.MAXIMUM means no
   * such version is yet available.
   */
  fixedVersion:
    | Version
    | undefined;
  /**
   * Whether this detail is obsolete. Occurrences are expected not to point to
   * obsolete details.
   */
  isObsolete: boolean;
  /**
   * The time this information was last changed at the source. This is an
   * upstream timestamp from the underlying information source - e.g. Ubuntu
   * security tracker.
   */
  sourceUpdateTime:
    | Date
    | undefined;
  /** The source from which the information in this Detail was obtained. */
  source: string;
  /** The name of the vendor of the product. */
  vendor: string;
}

export interface VulnerabilityNote_WindowsDetail {
  /**
   * Required. The [CPE URI](https://cpe.mitre.org/specification/) this
   * vulnerability affects.
   */
  cpeUri: string;
  /** Required. The name of this vulnerability. */
  name: string;
  /** The description of this vulnerability. */
  description: string;
  /**
   * Required. The names of the KBs which have hotfixes to mitigate this
   * vulnerability. Note that there may be multiple hotfixes (and thus
   * multiple KBs) that mitigate a given vulnerability. Currently any listed
   * KBs presence is considered a fix.
   */
  fixingKbs: VulnerabilityNote_WindowsDetail_KnowledgeBase[];
}

export interface VulnerabilityNote_WindowsDetail_KnowledgeBase {
  /** The KB name (generally of the form KB[0-9]+ (e.g., KB123456)). */
  name: string;
  /**
   * A link to the KB in the [Windows update catalog]
   * (https://www.catalog.update.microsoft.com/).
   */
  url: string;
}

/** An occurrence of a severity vulnerability on a resource. */
export interface VulnerabilityOccurrence {
  /**
   * The type of package; whether native or non native (e.g., ruby gems, node.js
   * packages, etc.).
   */
  type: string;
  /** Output only. The note provider assigned severity of this vulnerability. */
  severity: Severity;
  /**
   * Output only. The CVSS score of this vulnerability. CVSS score is on a
   * scale of 0 - 10 where 0 indicates low severity and 10 indicates high
   * severity.
   */
  cvssScore: number;
  /** The cvss v3 score for the vulnerability. */
  cvssv3:
    | CVSS
    | undefined;
  /**
   * Required. The set of affected locations and their fixes (if available)
   * within the associated resource.
   */
  packageIssue: VulnerabilityOccurrence_PackageIssue[];
  /** Output only. A one sentence description of this vulnerability. */
  shortDescription: string;
  /** Output only. A detailed description of this vulnerability. */
  longDescription: string;
  /** Output only. URLs related to this vulnerability. */
  relatedUrls: RelatedUrl[];
  /**
   * The distro assigned severity for this vulnerability when it is available,
   * otherwise this is the note provider assigned severity.
   *
   * When there are multiple PackageIssues for this vulnerability, they can have
   * different effective severities because some might be provided by the distro
   * while others are provided by the language ecosystem for a language pack.
   * For this reason, it is advised to use the effective severity on the
   * PackageIssue level. In the case where multiple PackageIssues have differing
   * effective severities, this field should be the highest severity for any of
   * the PackageIssues.
   */
  effectiveSeverity: Severity;
  /**
   * Output only. Whether at least one of the affected packages has a fix
   * available.
   */
  fixAvailable: boolean;
  /** Output only. CVSS version used to populate cvss_score and severity. */
  cvssVersion: CVSSVersion;
  /** The cvss v2 score for the vulnerability. */
  cvssV2: CVSS | undefined;
  vexAssessment:
    | VulnerabilityOccurrence_VexAssessment
    | undefined;
  /** Occurrence-specific extra details about the vulnerability. */
  extraDetails: string;
}

/**
 * A detail for a distro and package this vulnerability occurrence was found
 * in and its associated fix (if one is available).
 */
export interface VulnerabilityOccurrence_PackageIssue {
  /**
   * Required. The [CPE URI](https://cpe.mitre.org/specification/) this
   * vulnerability was found in.
   */
  affectedCpeUri: string;
  /** Required. The package this vulnerability was found in. */
  affectedPackage: string;
  /**
   * Required. The version of the package that is installed on the resource
   * affected by this vulnerability.
   */
  affectedVersion:
    | Version
    | undefined;
  /**
   * The [CPE URI](https://cpe.mitre.org/specification/) this vulnerability
   * was fixed in. It is possible for this to be different from the
   * affected_cpe_uri.
   */
  fixedCpeUri: string;
  /**
   * The package this vulnerability was fixed in. It is possible for this to
   * be different from the affected_package.
   */
  fixedPackage: string;
  /**
   * Required. The version of the package this vulnerability was fixed in.
   * Setting this to VersionKind.MAXIMUM means no fix is yet available.
   */
  fixedVersion:
    | Version
    | undefined;
  /** Output only. Whether a fix is available for this package. */
  fixAvailable: boolean;
  /** The type of package (e.g. OS, MAVEN, GO). */
  packageType: string;
  /**
   * The distro or language system assigned severity for this vulnerability
   * when that is available and note provider assigned severity when it is not
   * available.
   */
  effectiveSeverity: Severity;
  /** The location at which this package was found. */
  fileLocation: FileLocation[];
}

/**
 * VexAssessment provides all publisher provided Vex information that is
 * related to this vulnerability.
 */
export interface VulnerabilityOccurrence_VexAssessment {
  /**
   * Holds the MITRE standard Common Vulnerabilities and Exposures (CVE)
   * tracking number for the vulnerability.
   * Deprecated: Use vulnerability_id instead to denote CVEs.
   *
   * @deprecated
   */
  cve: string;
  /**
   * The vulnerability identifier for this Assessment. Will hold one of
   * common identifiers e.g. CVE, GHSA etc.
   */
  vulnerabilityId: string;
  /**
   * Holds a list of references associated with this vulnerability item and
   * assessment.
   */
  relatedUris: RelatedUrl[];
  /**
   * The VulnerabilityAssessment note from which this VexAssessment was
   * generated.
   * This will be of the form: `projects/[PROJECT_ID]/notes/[NOTE_ID]`.
   * (-- api-linter: core::0122::name-suffix=disabled
   *     aip.dev/not-precedent: The suffix is kept for consistency. --)
   */
  noteName: string;
  /** Provides the state of this Vulnerability assessment. */
  state: VulnerabilityAssessmentNote_Assessment_State;
  /**
   * Contains information about the impact of this vulnerability,
   * this will change with time.
   */
  impacts: string[];
  /** Specifies details on how to handle (and presumably, fix) a vulnerability. */
  remediations: VulnerabilityAssessmentNote_Assessment_Remediation[];
  /**
   * Justification provides the justification when the state of the
   * assessment if NOT_AFFECTED.
   */
  justification: VulnerabilityAssessmentNote_Assessment_Justification | undefined;
}

function createBaseVulnerabilityNote(): VulnerabilityNote {
  return {
    cvssScore: 0,
    severity: 0,
    details: [],
    cvssV3: undefined,
    windowsDetails: [],
    sourceUpdateTime: undefined,
    cvssVersion: 0,
    cvssV2: undefined,
  };
}

export const VulnerabilityNote: MessageFns<VulnerabilityNote> = {
  encode(message: VulnerabilityNote, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cvssScore !== 0) {
      writer.uint32(13).float(message.cvssScore);
    }
    if (message.severity !== 0) {
      writer.uint32(16).int32(message.severity);
    }
    for (const v of message.details) {
      VulnerabilityNote_Detail.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.cvssV3 !== undefined) {
      CVSSv3.encode(message.cvssV3, writer.uint32(34).fork()).join();
    }
    for (const v of message.windowsDetails) {
      VulnerabilityNote_WindowsDetail.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.sourceUpdateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.sourceUpdateTime), writer.uint32(50).fork()).join();
    }
    if (message.cvssVersion !== 0) {
      writer.uint32(56).int32(message.cvssVersion);
    }
    if (message.cvssV2 !== undefined) {
      CVSS.encode(message.cvssV2, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VulnerabilityNote {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVulnerabilityNote();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.cvssScore = reader.float();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.severity = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.details.push(VulnerabilityNote_Detail.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.cvssV3 = CVSSv3.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.windowsDetails.push(VulnerabilityNote_WindowsDetail.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.sourceUpdateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.cvssVersion = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.cvssV2 = CVSS.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VulnerabilityNote {
    return {
      cvssScore: isSet(object.cvssScore) ? globalThis.Number(object.cvssScore) : 0,
      severity: isSet(object.severity) ? severityFromJSON(object.severity) : 0,
      details: globalThis.Array.isArray(object?.details)
        ? object.details.map((e: any) => VulnerabilityNote_Detail.fromJSON(e))
        : [],
      cvssV3: isSet(object.cvssV3) ? CVSSv3.fromJSON(object.cvssV3) : undefined,
      windowsDetails: globalThis.Array.isArray(object?.windowsDetails)
        ? object.windowsDetails.map((e: any) => VulnerabilityNote_WindowsDetail.fromJSON(e))
        : [],
      sourceUpdateTime: isSet(object.sourceUpdateTime) ? fromJsonTimestamp(object.sourceUpdateTime) : undefined,
      cvssVersion: isSet(object.cvssVersion) ? cVSSVersionFromJSON(object.cvssVersion) : 0,
      cvssV2: isSet(object.cvssV2) ? CVSS.fromJSON(object.cvssV2) : undefined,
    };
  },

  toJSON(message: VulnerabilityNote): unknown {
    const obj: any = {};
    if (message.cvssScore !== 0) {
      obj.cvssScore = message.cvssScore;
    }
    if (message.severity !== 0) {
      obj.severity = severityToJSON(message.severity);
    }
    if (message.details?.length) {
      obj.details = message.details.map((e) => VulnerabilityNote_Detail.toJSON(e));
    }
    if (message.cvssV3 !== undefined) {
      obj.cvssV3 = CVSSv3.toJSON(message.cvssV3);
    }
    if (message.windowsDetails?.length) {
      obj.windowsDetails = message.windowsDetails.map((e) => VulnerabilityNote_WindowsDetail.toJSON(e));
    }
    if (message.sourceUpdateTime !== undefined) {
      obj.sourceUpdateTime = message.sourceUpdateTime.toISOString();
    }
    if (message.cvssVersion !== 0) {
      obj.cvssVersion = cVSSVersionToJSON(message.cvssVersion);
    }
    if (message.cvssV2 !== undefined) {
      obj.cvssV2 = CVSS.toJSON(message.cvssV2);
    }
    return obj;
  },

  create(base?: DeepPartial<VulnerabilityNote>): VulnerabilityNote {
    return VulnerabilityNote.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VulnerabilityNote>): VulnerabilityNote {
    const message = createBaseVulnerabilityNote();
    message.cvssScore = object.cvssScore ?? 0;
    message.severity = object.severity ?? 0;
    message.details = object.details?.map((e) => VulnerabilityNote_Detail.fromPartial(e)) || [];
    message.cvssV3 = (object.cvssV3 !== undefined && object.cvssV3 !== null)
      ? CVSSv3.fromPartial(object.cvssV3)
      : undefined;
    message.windowsDetails = object.windowsDetails?.map((e) => VulnerabilityNote_WindowsDetail.fromPartial(e)) || [];
    message.sourceUpdateTime = object.sourceUpdateTime ?? undefined;
    message.cvssVersion = object.cvssVersion ?? 0;
    message.cvssV2 = (object.cvssV2 !== undefined && object.cvssV2 !== null)
      ? CVSS.fromPartial(object.cvssV2)
      : undefined;
    return message;
  },
};

function createBaseVulnerabilityNote_Detail(): VulnerabilityNote_Detail {
  return {
    severityName: "",
    description: "",
    packageType: "",
    affectedCpeUri: "",
    affectedPackage: "",
    affectedVersionStart: undefined,
    affectedVersionEnd: undefined,
    fixedCpeUri: "",
    fixedPackage: "",
    fixedVersion: undefined,
    isObsolete: false,
    sourceUpdateTime: undefined,
    source: "",
    vendor: "",
  };
}

export const VulnerabilityNote_Detail: MessageFns<VulnerabilityNote_Detail> = {
  encode(message: VulnerabilityNote_Detail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.severityName !== "") {
      writer.uint32(10).string(message.severityName);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.packageType !== "") {
      writer.uint32(26).string(message.packageType);
    }
    if (message.affectedCpeUri !== "") {
      writer.uint32(34).string(message.affectedCpeUri);
    }
    if (message.affectedPackage !== "") {
      writer.uint32(42).string(message.affectedPackage);
    }
    if (message.affectedVersionStart !== undefined) {
      Version.encode(message.affectedVersionStart, writer.uint32(50).fork()).join();
    }
    if (message.affectedVersionEnd !== undefined) {
      Version.encode(message.affectedVersionEnd, writer.uint32(58).fork()).join();
    }
    if (message.fixedCpeUri !== "") {
      writer.uint32(66).string(message.fixedCpeUri);
    }
    if (message.fixedPackage !== "") {
      writer.uint32(74).string(message.fixedPackage);
    }
    if (message.fixedVersion !== undefined) {
      Version.encode(message.fixedVersion, writer.uint32(82).fork()).join();
    }
    if (message.isObsolete !== false) {
      writer.uint32(88).bool(message.isObsolete);
    }
    if (message.sourceUpdateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.sourceUpdateTime), writer.uint32(98).fork()).join();
    }
    if (message.source !== "") {
      writer.uint32(106).string(message.source);
    }
    if (message.vendor !== "") {
      writer.uint32(114).string(message.vendor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VulnerabilityNote_Detail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVulnerabilityNote_Detail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.severityName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.packageType = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.affectedCpeUri = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.affectedPackage = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.affectedVersionStart = Version.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.affectedVersionEnd = Version.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.fixedCpeUri = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.fixedPackage = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.fixedVersion = Version.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.isObsolete = reader.bool();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.sourceUpdateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.source = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.vendor = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VulnerabilityNote_Detail {
    return {
      severityName: isSet(object.severityName) ? globalThis.String(object.severityName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      packageType: isSet(object.packageType) ? globalThis.String(object.packageType) : "",
      affectedCpeUri: isSet(object.affectedCpeUri) ? globalThis.String(object.affectedCpeUri) : "",
      affectedPackage: isSet(object.affectedPackage) ? globalThis.String(object.affectedPackage) : "",
      affectedVersionStart: isSet(object.affectedVersionStart)
        ? Version.fromJSON(object.affectedVersionStart)
        : undefined,
      affectedVersionEnd: isSet(object.affectedVersionEnd) ? Version.fromJSON(object.affectedVersionEnd) : undefined,
      fixedCpeUri: isSet(object.fixedCpeUri) ? globalThis.String(object.fixedCpeUri) : "",
      fixedPackage: isSet(object.fixedPackage) ? globalThis.String(object.fixedPackage) : "",
      fixedVersion: isSet(object.fixedVersion) ? Version.fromJSON(object.fixedVersion) : undefined,
      isObsolete: isSet(object.isObsolete) ? globalThis.Boolean(object.isObsolete) : false,
      sourceUpdateTime: isSet(object.sourceUpdateTime) ? fromJsonTimestamp(object.sourceUpdateTime) : undefined,
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      vendor: isSet(object.vendor) ? globalThis.String(object.vendor) : "",
    };
  },

  toJSON(message: VulnerabilityNote_Detail): unknown {
    const obj: any = {};
    if (message.severityName !== "") {
      obj.severityName = message.severityName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.packageType !== "") {
      obj.packageType = message.packageType;
    }
    if (message.affectedCpeUri !== "") {
      obj.affectedCpeUri = message.affectedCpeUri;
    }
    if (message.affectedPackage !== "") {
      obj.affectedPackage = message.affectedPackage;
    }
    if (message.affectedVersionStart !== undefined) {
      obj.affectedVersionStart = Version.toJSON(message.affectedVersionStart);
    }
    if (message.affectedVersionEnd !== undefined) {
      obj.affectedVersionEnd = Version.toJSON(message.affectedVersionEnd);
    }
    if (message.fixedCpeUri !== "") {
      obj.fixedCpeUri = message.fixedCpeUri;
    }
    if (message.fixedPackage !== "") {
      obj.fixedPackage = message.fixedPackage;
    }
    if (message.fixedVersion !== undefined) {
      obj.fixedVersion = Version.toJSON(message.fixedVersion);
    }
    if (message.isObsolete !== false) {
      obj.isObsolete = message.isObsolete;
    }
    if (message.sourceUpdateTime !== undefined) {
      obj.sourceUpdateTime = message.sourceUpdateTime.toISOString();
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.vendor !== "") {
      obj.vendor = message.vendor;
    }
    return obj;
  },

  create(base?: DeepPartial<VulnerabilityNote_Detail>): VulnerabilityNote_Detail {
    return VulnerabilityNote_Detail.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VulnerabilityNote_Detail>): VulnerabilityNote_Detail {
    const message = createBaseVulnerabilityNote_Detail();
    message.severityName = object.severityName ?? "";
    message.description = object.description ?? "";
    message.packageType = object.packageType ?? "";
    message.affectedCpeUri = object.affectedCpeUri ?? "";
    message.affectedPackage = object.affectedPackage ?? "";
    message.affectedVersionStart = (object.affectedVersionStart !== undefined && object.affectedVersionStart !== null)
      ? Version.fromPartial(object.affectedVersionStart)
      : undefined;
    message.affectedVersionEnd = (object.affectedVersionEnd !== undefined && object.affectedVersionEnd !== null)
      ? Version.fromPartial(object.affectedVersionEnd)
      : undefined;
    message.fixedCpeUri = object.fixedCpeUri ?? "";
    message.fixedPackage = object.fixedPackage ?? "";
    message.fixedVersion = (object.fixedVersion !== undefined && object.fixedVersion !== null)
      ? Version.fromPartial(object.fixedVersion)
      : undefined;
    message.isObsolete = object.isObsolete ?? false;
    message.sourceUpdateTime = object.sourceUpdateTime ?? undefined;
    message.source = object.source ?? "";
    message.vendor = object.vendor ?? "";
    return message;
  },
};

function createBaseVulnerabilityNote_WindowsDetail(): VulnerabilityNote_WindowsDetail {
  return { cpeUri: "", name: "", description: "", fixingKbs: [] };
}

export const VulnerabilityNote_WindowsDetail: MessageFns<VulnerabilityNote_WindowsDetail> = {
  encode(message: VulnerabilityNote_WindowsDetail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cpeUri !== "") {
      writer.uint32(10).string(message.cpeUri);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    for (const v of message.fixingKbs) {
      VulnerabilityNote_WindowsDetail_KnowledgeBase.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VulnerabilityNote_WindowsDetail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVulnerabilityNote_WindowsDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cpeUri = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.fixingKbs.push(VulnerabilityNote_WindowsDetail_KnowledgeBase.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VulnerabilityNote_WindowsDetail {
    return {
      cpeUri: isSet(object.cpeUri) ? globalThis.String(object.cpeUri) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      fixingKbs: globalThis.Array.isArray(object?.fixingKbs)
        ? object.fixingKbs.map((e: any) => VulnerabilityNote_WindowsDetail_KnowledgeBase.fromJSON(e))
        : [],
    };
  },

  toJSON(message: VulnerabilityNote_WindowsDetail): unknown {
    const obj: any = {};
    if (message.cpeUri !== "") {
      obj.cpeUri = message.cpeUri;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.fixingKbs?.length) {
      obj.fixingKbs = message.fixingKbs.map((e) => VulnerabilityNote_WindowsDetail_KnowledgeBase.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<VulnerabilityNote_WindowsDetail>): VulnerabilityNote_WindowsDetail {
    return VulnerabilityNote_WindowsDetail.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VulnerabilityNote_WindowsDetail>): VulnerabilityNote_WindowsDetail {
    const message = createBaseVulnerabilityNote_WindowsDetail();
    message.cpeUri = object.cpeUri ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.fixingKbs = object.fixingKbs?.map((e) => VulnerabilityNote_WindowsDetail_KnowledgeBase.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseVulnerabilityNote_WindowsDetail_KnowledgeBase(): VulnerabilityNote_WindowsDetail_KnowledgeBase {
  return { name: "", url: "" };
}

export const VulnerabilityNote_WindowsDetail_KnowledgeBase: MessageFns<VulnerabilityNote_WindowsDetail_KnowledgeBase> =
  {
    encode(
      message: VulnerabilityNote_WindowsDetail_KnowledgeBase,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.name !== "") {
        writer.uint32(10).string(message.name);
      }
      if (message.url !== "") {
        writer.uint32(18).string(message.url);
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): VulnerabilityNote_WindowsDetail_KnowledgeBase {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseVulnerabilityNote_WindowsDetail_KnowledgeBase();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.name = reader.string();
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.url = reader.string();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): VulnerabilityNote_WindowsDetail_KnowledgeBase {
      return {
        name: isSet(object.name) ? globalThis.String(object.name) : "",
        url: isSet(object.url) ? globalThis.String(object.url) : "",
      };
    },

    toJSON(message: VulnerabilityNote_WindowsDetail_KnowledgeBase): unknown {
      const obj: any = {};
      if (message.name !== "") {
        obj.name = message.name;
      }
      if (message.url !== "") {
        obj.url = message.url;
      }
      return obj;
    },

    create(
      base?: DeepPartial<VulnerabilityNote_WindowsDetail_KnowledgeBase>,
    ): VulnerabilityNote_WindowsDetail_KnowledgeBase {
      return VulnerabilityNote_WindowsDetail_KnowledgeBase.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<VulnerabilityNote_WindowsDetail_KnowledgeBase>,
    ): VulnerabilityNote_WindowsDetail_KnowledgeBase {
      const message = createBaseVulnerabilityNote_WindowsDetail_KnowledgeBase();
      message.name = object.name ?? "";
      message.url = object.url ?? "";
      return message;
    },
  };

function createBaseVulnerabilityOccurrence(): VulnerabilityOccurrence {
  return {
    type: "",
    severity: 0,
    cvssScore: 0,
    cvssv3: undefined,
    packageIssue: [],
    shortDescription: "",
    longDescription: "",
    relatedUrls: [],
    effectiveSeverity: 0,
    fixAvailable: false,
    cvssVersion: 0,
    cvssV2: undefined,
    vexAssessment: undefined,
    extraDetails: "",
  };
}

export const VulnerabilityOccurrence: MessageFns<VulnerabilityOccurrence> = {
  encode(message: VulnerabilityOccurrence, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.severity !== 0) {
      writer.uint32(16).int32(message.severity);
    }
    if (message.cvssScore !== 0) {
      writer.uint32(29).float(message.cvssScore);
    }
    if (message.cvssv3 !== undefined) {
      CVSS.encode(message.cvssv3, writer.uint32(82).fork()).join();
    }
    for (const v of message.packageIssue) {
      VulnerabilityOccurrence_PackageIssue.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.shortDescription !== "") {
      writer.uint32(42).string(message.shortDescription);
    }
    if (message.longDescription !== "") {
      writer.uint32(50).string(message.longDescription);
    }
    for (const v of message.relatedUrls) {
      RelatedUrl.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.effectiveSeverity !== 0) {
      writer.uint32(64).int32(message.effectiveSeverity);
    }
    if (message.fixAvailable !== false) {
      writer.uint32(72).bool(message.fixAvailable);
    }
    if (message.cvssVersion !== 0) {
      writer.uint32(88).int32(message.cvssVersion);
    }
    if (message.cvssV2 !== undefined) {
      CVSS.encode(message.cvssV2, writer.uint32(98).fork()).join();
    }
    if (message.vexAssessment !== undefined) {
      VulnerabilityOccurrence_VexAssessment.encode(message.vexAssessment, writer.uint32(106).fork()).join();
    }
    if (message.extraDetails !== "") {
      writer.uint32(114).string(message.extraDetails);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VulnerabilityOccurrence {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVulnerabilityOccurrence();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.severity = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.cvssScore = reader.float();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.cvssv3 = CVSS.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.packageIssue.push(VulnerabilityOccurrence_PackageIssue.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.shortDescription = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.longDescription = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.relatedUrls.push(RelatedUrl.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.effectiveSeverity = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.fixAvailable = reader.bool();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.cvssVersion = reader.int32() as any;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.cvssV2 = CVSS.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.vexAssessment = VulnerabilityOccurrence_VexAssessment.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.extraDetails = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VulnerabilityOccurrence {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      severity: isSet(object.severity) ? severityFromJSON(object.severity) : 0,
      cvssScore: isSet(object.cvssScore) ? globalThis.Number(object.cvssScore) : 0,
      cvssv3: isSet(object.cvssv3) ? CVSS.fromJSON(object.cvssv3) : undefined,
      packageIssue: globalThis.Array.isArray(object?.packageIssue)
        ? object.packageIssue.map((e: any) => VulnerabilityOccurrence_PackageIssue.fromJSON(e))
        : [],
      shortDescription: isSet(object.shortDescription) ? globalThis.String(object.shortDescription) : "",
      longDescription: isSet(object.longDescription) ? globalThis.String(object.longDescription) : "",
      relatedUrls: globalThis.Array.isArray(object?.relatedUrls)
        ? object.relatedUrls.map((e: any) => RelatedUrl.fromJSON(e))
        : [],
      effectiveSeverity: isSet(object.effectiveSeverity) ? severityFromJSON(object.effectiveSeverity) : 0,
      fixAvailable: isSet(object.fixAvailable) ? globalThis.Boolean(object.fixAvailable) : false,
      cvssVersion: isSet(object.cvssVersion) ? cVSSVersionFromJSON(object.cvssVersion) : 0,
      cvssV2: isSet(object.cvssV2) ? CVSS.fromJSON(object.cvssV2) : undefined,
      vexAssessment: isSet(object.vexAssessment)
        ? VulnerabilityOccurrence_VexAssessment.fromJSON(object.vexAssessment)
        : undefined,
      extraDetails: isSet(object.extraDetails) ? globalThis.String(object.extraDetails) : "",
    };
  },

  toJSON(message: VulnerabilityOccurrence): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.severity !== 0) {
      obj.severity = severityToJSON(message.severity);
    }
    if (message.cvssScore !== 0) {
      obj.cvssScore = message.cvssScore;
    }
    if (message.cvssv3 !== undefined) {
      obj.cvssv3 = CVSS.toJSON(message.cvssv3);
    }
    if (message.packageIssue?.length) {
      obj.packageIssue = message.packageIssue.map((e) => VulnerabilityOccurrence_PackageIssue.toJSON(e));
    }
    if (message.shortDescription !== "") {
      obj.shortDescription = message.shortDescription;
    }
    if (message.longDescription !== "") {
      obj.longDescription = message.longDescription;
    }
    if (message.relatedUrls?.length) {
      obj.relatedUrls = message.relatedUrls.map((e) => RelatedUrl.toJSON(e));
    }
    if (message.effectiveSeverity !== 0) {
      obj.effectiveSeverity = severityToJSON(message.effectiveSeverity);
    }
    if (message.fixAvailable !== false) {
      obj.fixAvailable = message.fixAvailable;
    }
    if (message.cvssVersion !== 0) {
      obj.cvssVersion = cVSSVersionToJSON(message.cvssVersion);
    }
    if (message.cvssV2 !== undefined) {
      obj.cvssV2 = CVSS.toJSON(message.cvssV2);
    }
    if (message.vexAssessment !== undefined) {
      obj.vexAssessment = VulnerabilityOccurrence_VexAssessment.toJSON(message.vexAssessment);
    }
    if (message.extraDetails !== "") {
      obj.extraDetails = message.extraDetails;
    }
    return obj;
  },

  create(base?: DeepPartial<VulnerabilityOccurrence>): VulnerabilityOccurrence {
    return VulnerabilityOccurrence.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VulnerabilityOccurrence>): VulnerabilityOccurrence {
    const message = createBaseVulnerabilityOccurrence();
    message.type = object.type ?? "";
    message.severity = object.severity ?? 0;
    message.cvssScore = object.cvssScore ?? 0;
    message.cvssv3 = (object.cvssv3 !== undefined && object.cvssv3 !== null)
      ? CVSS.fromPartial(object.cvssv3)
      : undefined;
    message.packageIssue = object.packageIssue?.map((e) => VulnerabilityOccurrence_PackageIssue.fromPartial(e)) || [];
    message.shortDescription = object.shortDescription ?? "";
    message.longDescription = object.longDescription ?? "";
    message.relatedUrls = object.relatedUrls?.map((e) => RelatedUrl.fromPartial(e)) || [];
    message.effectiveSeverity = object.effectiveSeverity ?? 0;
    message.fixAvailable = object.fixAvailable ?? false;
    message.cvssVersion = object.cvssVersion ?? 0;
    message.cvssV2 = (object.cvssV2 !== undefined && object.cvssV2 !== null)
      ? CVSS.fromPartial(object.cvssV2)
      : undefined;
    message.vexAssessment = (object.vexAssessment !== undefined && object.vexAssessment !== null)
      ? VulnerabilityOccurrence_VexAssessment.fromPartial(object.vexAssessment)
      : undefined;
    message.extraDetails = object.extraDetails ?? "";
    return message;
  },
};

function createBaseVulnerabilityOccurrence_PackageIssue(): VulnerabilityOccurrence_PackageIssue {
  return {
    affectedCpeUri: "",
    affectedPackage: "",
    affectedVersion: undefined,
    fixedCpeUri: "",
    fixedPackage: "",
    fixedVersion: undefined,
    fixAvailable: false,
    packageType: "",
    effectiveSeverity: 0,
    fileLocation: [],
  };
}

export const VulnerabilityOccurrence_PackageIssue: MessageFns<VulnerabilityOccurrence_PackageIssue> = {
  encode(message: VulnerabilityOccurrence_PackageIssue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.affectedCpeUri !== "") {
      writer.uint32(10).string(message.affectedCpeUri);
    }
    if (message.affectedPackage !== "") {
      writer.uint32(18).string(message.affectedPackage);
    }
    if (message.affectedVersion !== undefined) {
      Version.encode(message.affectedVersion, writer.uint32(26).fork()).join();
    }
    if (message.fixedCpeUri !== "") {
      writer.uint32(34).string(message.fixedCpeUri);
    }
    if (message.fixedPackage !== "") {
      writer.uint32(42).string(message.fixedPackage);
    }
    if (message.fixedVersion !== undefined) {
      Version.encode(message.fixedVersion, writer.uint32(50).fork()).join();
    }
    if (message.fixAvailable !== false) {
      writer.uint32(56).bool(message.fixAvailable);
    }
    if (message.packageType !== "") {
      writer.uint32(66).string(message.packageType);
    }
    if (message.effectiveSeverity !== 0) {
      writer.uint32(72).int32(message.effectiveSeverity);
    }
    for (const v of message.fileLocation) {
      FileLocation.encode(v!, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VulnerabilityOccurrence_PackageIssue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVulnerabilityOccurrence_PackageIssue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.affectedCpeUri = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.affectedPackage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.affectedVersion = Version.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.fixedCpeUri = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.fixedPackage = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.fixedVersion = Version.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.fixAvailable = reader.bool();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.packageType = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.effectiveSeverity = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.fileLocation.push(FileLocation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VulnerabilityOccurrence_PackageIssue {
    return {
      affectedCpeUri: isSet(object.affectedCpeUri) ? globalThis.String(object.affectedCpeUri) : "",
      affectedPackage: isSet(object.affectedPackage) ? globalThis.String(object.affectedPackage) : "",
      affectedVersion: isSet(object.affectedVersion) ? Version.fromJSON(object.affectedVersion) : undefined,
      fixedCpeUri: isSet(object.fixedCpeUri) ? globalThis.String(object.fixedCpeUri) : "",
      fixedPackage: isSet(object.fixedPackage) ? globalThis.String(object.fixedPackage) : "",
      fixedVersion: isSet(object.fixedVersion) ? Version.fromJSON(object.fixedVersion) : undefined,
      fixAvailable: isSet(object.fixAvailable) ? globalThis.Boolean(object.fixAvailable) : false,
      packageType: isSet(object.packageType) ? globalThis.String(object.packageType) : "",
      effectiveSeverity: isSet(object.effectiveSeverity) ? severityFromJSON(object.effectiveSeverity) : 0,
      fileLocation: globalThis.Array.isArray(object?.fileLocation)
        ? object.fileLocation.map((e: any) => FileLocation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: VulnerabilityOccurrence_PackageIssue): unknown {
    const obj: any = {};
    if (message.affectedCpeUri !== "") {
      obj.affectedCpeUri = message.affectedCpeUri;
    }
    if (message.affectedPackage !== "") {
      obj.affectedPackage = message.affectedPackage;
    }
    if (message.affectedVersion !== undefined) {
      obj.affectedVersion = Version.toJSON(message.affectedVersion);
    }
    if (message.fixedCpeUri !== "") {
      obj.fixedCpeUri = message.fixedCpeUri;
    }
    if (message.fixedPackage !== "") {
      obj.fixedPackage = message.fixedPackage;
    }
    if (message.fixedVersion !== undefined) {
      obj.fixedVersion = Version.toJSON(message.fixedVersion);
    }
    if (message.fixAvailable !== false) {
      obj.fixAvailable = message.fixAvailable;
    }
    if (message.packageType !== "") {
      obj.packageType = message.packageType;
    }
    if (message.effectiveSeverity !== 0) {
      obj.effectiveSeverity = severityToJSON(message.effectiveSeverity);
    }
    if (message.fileLocation?.length) {
      obj.fileLocation = message.fileLocation.map((e) => FileLocation.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<VulnerabilityOccurrence_PackageIssue>): VulnerabilityOccurrence_PackageIssue {
    return VulnerabilityOccurrence_PackageIssue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VulnerabilityOccurrence_PackageIssue>): VulnerabilityOccurrence_PackageIssue {
    const message = createBaseVulnerabilityOccurrence_PackageIssue();
    message.affectedCpeUri = object.affectedCpeUri ?? "";
    message.affectedPackage = object.affectedPackage ?? "";
    message.affectedVersion = (object.affectedVersion !== undefined && object.affectedVersion !== null)
      ? Version.fromPartial(object.affectedVersion)
      : undefined;
    message.fixedCpeUri = object.fixedCpeUri ?? "";
    message.fixedPackage = object.fixedPackage ?? "";
    message.fixedVersion = (object.fixedVersion !== undefined && object.fixedVersion !== null)
      ? Version.fromPartial(object.fixedVersion)
      : undefined;
    message.fixAvailable = object.fixAvailable ?? false;
    message.packageType = object.packageType ?? "";
    message.effectiveSeverity = object.effectiveSeverity ?? 0;
    message.fileLocation = object.fileLocation?.map((e) => FileLocation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseVulnerabilityOccurrence_VexAssessment(): VulnerabilityOccurrence_VexAssessment {
  return {
    cve: "",
    vulnerabilityId: "",
    relatedUris: [],
    noteName: "",
    state: 0,
    impacts: [],
    remediations: [],
    justification: undefined,
  };
}

export const VulnerabilityOccurrence_VexAssessment: MessageFns<VulnerabilityOccurrence_VexAssessment> = {
  encode(message: VulnerabilityOccurrence_VexAssessment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cve !== "") {
      writer.uint32(10).string(message.cve);
    }
    if (message.vulnerabilityId !== "") {
      writer.uint32(66).string(message.vulnerabilityId);
    }
    for (const v of message.relatedUris) {
      RelatedUrl.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.noteName !== "") {
      writer.uint32(26).string(message.noteName);
    }
    if (message.state !== 0) {
      writer.uint32(32).int32(message.state);
    }
    for (const v of message.impacts) {
      writer.uint32(42).string(v!);
    }
    for (const v of message.remediations) {
      VulnerabilityAssessmentNote_Assessment_Remediation.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.justification !== undefined) {
      VulnerabilityAssessmentNote_Assessment_Justification.encode(message.justification, writer.uint32(58).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VulnerabilityOccurrence_VexAssessment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVulnerabilityOccurrence_VexAssessment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cve = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.vulnerabilityId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.relatedUris.push(RelatedUrl.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.noteName = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.impacts.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.remediations.push(VulnerabilityAssessmentNote_Assessment_Remediation.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.justification = VulnerabilityAssessmentNote_Assessment_Justification.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VulnerabilityOccurrence_VexAssessment {
    return {
      cve: isSet(object.cve) ? globalThis.String(object.cve) : "",
      vulnerabilityId: isSet(object.vulnerabilityId) ? globalThis.String(object.vulnerabilityId) : "",
      relatedUris: globalThis.Array.isArray(object?.relatedUris)
        ? object.relatedUris.map((e: any) => RelatedUrl.fromJSON(e))
        : [],
      noteName: isSet(object.noteName) ? globalThis.String(object.noteName) : "",
      state: isSet(object.state) ? vulnerabilityAssessmentNote_Assessment_StateFromJSON(object.state) : 0,
      impacts: globalThis.Array.isArray(object?.impacts) ? object.impacts.map((e: any) => globalThis.String(e)) : [],
      remediations: globalThis.Array.isArray(object?.remediations)
        ? object.remediations.map((e: any) => VulnerabilityAssessmentNote_Assessment_Remediation.fromJSON(e))
        : [],
      justification: isSet(object.justification)
        ? VulnerabilityAssessmentNote_Assessment_Justification.fromJSON(object.justification)
        : undefined,
    };
  },

  toJSON(message: VulnerabilityOccurrence_VexAssessment): unknown {
    const obj: any = {};
    if (message.cve !== "") {
      obj.cve = message.cve;
    }
    if (message.vulnerabilityId !== "") {
      obj.vulnerabilityId = message.vulnerabilityId;
    }
    if (message.relatedUris?.length) {
      obj.relatedUris = message.relatedUris.map((e) => RelatedUrl.toJSON(e));
    }
    if (message.noteName !== "") {
      obj.noteName = message.noteName;
    }
    if (message.state !== 0) {
      obj.state = vulnerabilityAssessmentNote_Assessment_StateToJSON(message.state);
    }
    if (message.impacts?.length) {
      obj.impacts = message.impacts;
    }
    if (message.remediations?.length) {
      obj.remediations = message.remediations.map((e) => VulnerabilityAssessmentNote_Assessment_Remediation.toJSON(e));
    }
    if (message.justification !== undefined) {
      obj.justification = VulnerabilityAssessmentNote_Assessment_Justification.toJSON(message.justification);
    }
    return obj;
  },

  create(base?: DeepPartial<VulnerabilityOccurrence_VexAssessment>): VulnerabilityOccurrence_VexAssessment {
    return VulnerabilityOccurrence_VexAssessment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VulnerabilityOccurrence_VexAssessment>): VulnerabilityOccurrence_VexAssessment {
    const message = createBaseVulnerabilityOccurrence_VexAssessment();
    message.cve = object.cve ?? "";
    message.vulnerabilityId = object.vulnerabilityId ?? "";
    message.relatedUris = object.relatedUris?.map((e) => RelatedUrl.fromPartial(e)) || [];
    message.noteName = object.noteName ?? "";
    message.state = object.state ?? 0;
    message.impacts = object.impacts?.map((e) => e) || [];
    message.remediations =
      object.remediations?.map((e) => VulnerabilityAssessmentNote_Assessment_Remediation.fromPartial(e)) || [];
    message.justification = (object.justification !== undefined && object.justification !== null)
      ? VulnerabilityAssessmentNote_Assessment_Justification.fromPartial(object.justification)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
