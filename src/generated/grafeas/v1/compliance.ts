// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: grafeas/v1/compliance.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Severity, severityFromJSON, severityToJSON } from "./severity.js";

export const protobufPackage = "grafeas.v1";

export interface ComplianceNote {
  /** The title that identifies this compliance check. */
  title: string;
  /** A description about this compliance check. */
  description: string;
  /** The OS and config versions the benchmark applies to. */
  version: ComplianceVersion[];
  /** A rationale for the existence of this compliance check. */
  rationale: string;
  /** A description of remediation steps if the compliance check fails. */
  remediation: string;
  cisBenchmark?:
    | ComplianceNote_CisBenchmark
    | undefined;
  /** Serialized scan instructions with a predefined format. */
  scanInstructions: Buffer;
  impact?: string | undefined;
}

/** A compliance check that is a CIS benchmark. */
export interface ComplianceNote_CisBenchmark {
  profileLevel: number;
  severity: Severity;
}

/**
 * Describes the CIS benchmark version that is applicable to a given OS and
 * os version.
 */
export interface ComplianceVersion {
  /**
   * The CPE URI (https://cpe.mitre.org/specification/) this benchmark is
   * applicable to.
   */
  cpeUri: string;
  /**
   * The name of the document that defines this benchmark, e.g. "CIS
   * Container-Optimized OS".
   */
  benchmarkDocument: string;
  /**
   * The version of the benchmark. This is set to the version of the OS-specific
   * CIS document the benchmark is defined in.
   */
  version: string;
}

/**
 * An indication that the compliance checks in the associated ComplianceNote
 * were not satisfied for particular resources or a specified reason.
 */
export interface ComplianceOccurrence {
  nonCompliantFiles: NonCompliantFile[];
  nonComplianceReason: string;
  /** The OS and config version the benchmark was run on. */
  version: ComplianceVersion | undefined;
}

/** Details about files that caused a compliance check to fail. */
export interface NonCompliantFile {
  /** Empty if `display_command` is set. */
  path: string;
  /** Command to display the non-compliant files. */
  displayCommand: string;
  /** Explains why a file is non compliant for a CIS check. */
  reason: string;
}

function createBaseComplianceNote(): ComplianceNote {
  return {
    title: "",
    description: "",
    version: [],
    rationale: "",
    remediation: "",
    cisBenchmark: undefined,
    scanInstructions: Buffer.alloc(0),
    impact: undefined,
  };
}

export const ComplianceNote: MessageFns<ComplianceNote> = {
  encode(message: ComplianceNote, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    for (const v of message.version) {
      ComplianceVersion.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.rationale !== "") {
      writer.uint32(34).string(message.rationale);
    }
    if (message.remediation !== "") {
      writer.uint32(42).string(message.remediation);
    }
    if (message.cisBenchmark !== undefined) {
      ComplianceNote_CisBenchmark.encode(message.cisBenchmark, writer.uint32(50).fork()).join();
    }
    if (message.scanInstructions.length !== 0) {
      writer.uint32(58).bytes(message.scanInstructions);
    }
    if (message.impact !== undefined) {
      writer.uint32(66).string(message.impact);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComplianceNote {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComplianceNote();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.version.push(ComplianceVersion.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.rationale = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.remediation = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.cisBenchmark = ComplianceNote_CisBenchmark.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.scanInstructions = Buffer.from(reader.bytes());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.impact = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComplianceNote {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      version: globalThis.Array.isArray(object?.version)
        ? object.version.map((e: any) => ComplianceVersion.fromJSON(e))
        : [],
      rationale: isSet(object.rationale) ? globalThis.String(object.rationale) : "",
      remediation: isSet(object.remediation) ? globalThis.String(object.remediation) : "",
      cisBenchmark: isSet(object.cisBenchmark) ? ComplianceNote_CisBenchmark.fromJSON(object.cisBenchmark) : undefined,
      scanInstructions: isSet(object.scanInstructions)
        ? Buffer.from(bytesFromBase64(object.scanInstructions))
        : Buffer.alloc(0),
      impact: isSet(object.impact) ? globalThis.String(object.impact) : undefined,
    };
  },

  toJSON(message: ComplianceNote): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.version?.length) {
      obj.version = message.version.map((e) => ComplianceVersion.toJSON(e));
    }
    if (message.rationale !== "") {
      obj.rationale = message.rationale;
    }
    if (message.remediation !== "") {
      obj.remediation = message.remediation;
    }
    if (message.cisBenchmark !== undefined) {
      obj.cisBenchmark = ComplianceNote_CisBenchmark.toJSON(message.cisBenchmark);
    }
    if (message.scanInstructions.length !== 0) {
      obj.scanInstructions = base64FromBytes(message.scanInstructions);
    }
    if (message.impact !== undefined) {
      obj.impact = message.impact;
    }
    return obj;
  },

  create(base?: DeepPartial<ComplianceNote>): ComplianceNote {
    return ComplianceNote.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ComplianceNote>): ComplianceNote {
    const message = createBaseComplianceNote();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.version = object.version?.map((e) => ComplianceVersion.fromPartial(e)) || [];
    message.rationale = object.rationale ?? "";
    message.remediation = object.remediation ?? "";
    message.cisBenchmark = (object.cisBenchmark !== undefined && object.cisBenchmark !== null)
      ? ComplianceNote_CisBenchmark.fromPartial(object.cisBenchmark)
      : undefined;
    message.scanInstructions = object.scanInstructions ?? Buffer.alloc(0);
    message.impact = object.impact ?? undefined;
    return message;
  },
};

function createBaseComplianceNote_CisBenchmark(): ComplianceNote_CisBenchmark {
  return { profileLevel: 0, severity: 0 };
}

export const ComplianceNote_CisBenchmark: MessageFns<ComplianceNote_CisBenchmark> = {
  encode(message: ComplianceNote_CisBenchmark, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.profileLevel !== 0) {
      writer.uint32(8).int32(message.profileLevel);
    }
    if (message.severity !== 0) {
      writer.uint32(16).int32(message.severity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComplianceNote_CisBenchmark {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComplianceNote_CisBenchmark();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.profileLevel = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.severity = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComplianceNote_CisBenchmark {
    return {
      profileLevel: isSet(object.profileLevel) ? globalThis.Number(object.profileLevel) : 0,
      severity: isSet(object.severity) ? severityFromJSON(object.severity) : 0,
    };
  },

  toJSON(message: ComplianceNote_CisBenchmark): unknown {
    const obj: any = {};
    if (message.profileLevel !== 0) {
      obj.profileLevel = Math.round(message.profileLevel);
    }
    if (message.severity !== 0) {
      obj.severity = severityToJSON(message.severity);
    }
    return obj;
  },

  create(base?: DeepPartial<ComplianceNote_CisBenchmark>): ComplianceNote_CisBenchmark {
    return ComplianceNote_CisBenchmark.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ComplianceNote_CisBenchmark>): ComplianceNote_CisBenchmark {
    const message = createBaseComplianceNote_CisBenchmark();
    message.profileLevel = object.profileLevel ?? 0;
    message.severity = object.severity ?? 0;
    return message;
  },
};

function createBaseComplianceVersion(): ComplianceVersion {
  return { cpeUri: "", benchmarkDocument: "", version: "" };
}

export const ComplianceVersion: MessageFns<ComplianceVersion> = {
  encode(message: ComplianceVersion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cpeUri !== "") {
      writer.uint32(10).string(message.cpeUri);
    }
    if (message.benchmarkDocument !== "") {
      writer.uint32(26).string(message.benchmarkDocument);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComplianceVersion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComplianceVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cpeUri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.benchmarkDocument = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComplianceVersion {
    return {
      cpeUri: isSet(object.cpeUri) ? globalThis.String(object.cpeUri) : "",
      benchmarkDocument: isSet(object.benchmarkDocument) ? globalThis.String(object.benchmarkDocument) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
    };
  },

  toJSON(message: ComplianceVersion): unknown {
    const obj: any = {};
    if (message.cpeUri !== "") {
      obj.cpeUri = message.cpeUri;
    }
    if (message.benchmarkDocument !== "") {
      obj.benchmarkDocument = message.benchmarkDocument;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    return obj;
  },

  create(base?: DeepPartial<ComplianceVersion>): ComplianceVersion {
    return ComplianceVersion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ComplianceVersion>): ComplianceVersion {
    const message = createBaseComplianceVersion();
    message.cpeUri = object.cpeUri ?? "";
    message.benchmarkDocument = object.benchmarkDocument ?? "";
    message.version = object.version ?? "";
    return message;
  },
};

function createBaseComplianceOccurrence(): ComplianceOccurrence {
  return { nonCompliantFiles: [], nonComplianceReason: "", version: undefined };
}

export const ComplianceOccurrence: MessageFns<ComplianceOccurrence> = {
  encode(message: ComplianceOccurrence, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nonCompliantFiles) {
      NonCompliantFile.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.nonComplianceReason !== "") {
      writer.uint32(26).string(message.nonComplianceReason);
    }
    if (message.version !== undefined) {
      ComplianceVersion.encode(message.version, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComplianceOccurrence {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComplianceOccurrence();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nonCompliantFiles.push(NonCompliantFile.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nonComplianceReason = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.version = ComplianceVersion.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComplianceOccurrence {
    return {
      nonCompliantFiles: globalThis.Array.isArray(object?.nonCompliantFiles)
        ? object.nonCompliantFiles.map((e: any) => NonCompliantFile.fromJSON(e))
        : [],
      nonComplianceReason: isSet(object.nonComplianceReason) ? globalThis.String(object.nonComplianceReason) : "",
      version: isSet(object.version) ? ComplianceVersion.fromJSON(object.version) : undefined,
    };
  },

  toJSON(message: ComplianceOccurrence): unknown {
    const obj: any = {};
    if (message.nonCompliantFiles?.length) {
      obj.nonCompliantFiles = message.nonCompliantFiles.map((e) => NonCompliantFile.toJSON(e));
    }
    if (message.nonComplianceReason !== "") {
      obj.nonComplianceReason = message.nonComplianceReason;
    }
    if (message.version !== undefined) {
      obj.version = ComplianceVersion.toJSON(message.version);
    }
    return obj;
  },

  create(base?: DeepPartial<ComplianceOccurrence>): ComplianceOccurrence {
    return ComplianceOccurrence.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ComplianceOccurrence>): ComplianceOccurrence {
    const message = createBaseComplianceOccurrence();
    message.nonCompliantFiles = object.nonCompliantFiles?.map((e) => NonCompliantFile.fromPartial(e)) || [];
    message.nonComplianceReason = object.nonComplianceReason ?? "";
    message.version = (object.version !== undefined && object.version !== null)
      ? ComplianceVersion.fromPartial(object.version)
      : undefined;
    return message;
  },
};

function createBaseNonCompliantFile(): NonCompliantFile {
  return { path: "", displayCommand: "", reason: "" };
}

export const NonCompliantFile: MessageFns<NonCompliantFile> = {
  encode(message: NonCompliantFile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.displayCommand !== "") {
      writer.uint32(18).string(message.displayCommand);
    }
    if (message.reason !== "") {
      writer.uint32(26).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NonCompliantFile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNonCompliantFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayCommand = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NonCompliantFile {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      displayCommand: isSet(object.displayCommand) ? globalThis.String(object.displayCommand) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: NonCompliantFile): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.displayCommand !== "") {
      obj.displayCommand = message.displayCommand;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create(base?: DeepPartial<NonCompliantFile>): NonCompliantFile {
    return NonCompliantFile.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NonCompliantFile>): NonCompliantFile {
    const message = createBaseNonCompliantFile();
    message.path = object.path ?? "";
    message.displayCommand = object.displayCommand ?? "";
    message.reason = object.reason ?? "";
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
