// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: grafeas/v1/vex.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { RelatedUrl } from "./common.js";

export const protobufPackage = "grafeas.v1";

/**
 * A single VulnerabilityAssessmentNote represents
 * one particular product's vulnerability assessment for one CVE.
 */
export interface VulnerabilityAssessmentNote {
  /** The title of the note. E.g. `Vex-Debian-11.4` */
  title: string;
  /** A one sentence description of this Vex. */
  shortDescription: string;
  /** A detailed description of this Vex. */
  longDescription: string;
  /**
   * Identifies the language used by this document,
   * corresponding to IETF BCP 47 / RFC 5646.
   */
  languageCode: string;
  /** Publisher details of this Note. */
  publisher:
    | VulnerabilityAssessmentNote_Publisher
    | undefined;
  /** The product affected by this vex. */
  product:
    | VulnerabilityAssessmentNote_Product
    | undefined;
  /** Represents a vulnerability assessment for the product. */
  assessment: VulnerabilityAssessmentNote_Assessment | undefined;
}

/**
 * Publisher contains information about the publisher of
 * this Note.
 * (-- api-linter: core::0123::resource-annotation=disabled
 *     aip.dev/not-precedent: Publisher is not a separate resource. --)
 */
export interface VulnerabilityAssessmentNote_Publisher {
  /**
   * Name of the publisher.
   * Examples: 'Google', 'Google Cloud Platform'.
   */
  name: string;
  /**
   * Provides information about the authority of the issuing party to
   * release the document, in particular, the party's constituency and
   * responsibilities or other obligations.
   */
  issuingAuthority: string;
  /**
   * The context or namespace.
   * Contains a URL which is under control of the issuing party and can
   * be used as a globally unique identifier for that issuing party.
   * Example: https://csaf.io
   */
  publisherNamespace: string;
}

/**
 * Product contains information about a product and how to uniquely identify
 * it.
 * (-- api-linter: core::0123::resource-annotation=disabled
 *     aip.dev/not-precedent: Product is not a separate resource. --)
 */
export interface VulnerabilityAssessmentNote_Product {
  /** Name of the product. */
  name: string;
  /**
   * Token that identifies a product so that it can be referred to from other
   * parts in the document. There is no predefined format as long as it
   * uniquely identifies a group in the context of the current document.
   */
  id: string;
  /**
   * Contains a URI which is vendor-specific.
   * Example: The artifact repository URL of an image.
   */
  genericUri?: string | undefined;
}

/**
 * Assessment provides all information that is related to a single
 * vulnerability for this product.
 */
export interface VulnerabilityAssessmentNote_Assessment {
  /**
   * Holds the MITRE standard Common Vulnerabilities and Exposures (CVE)
   * tracking number for the vulnerability.
   * Deprecated: Use vulnerability_id instead to denote CVEs.
   *
   * @deprecated
   */
  cve: string;
  /**
   * The vulnerability identifier for this Assessment. Will hold one of
   * common identifiers e.g. CVE, GHSA etc.
   */
  vulnerabilityId: string;
  /** A one sentence description of this Vex. */
  shortDescription: string;
  /** A detailed description of this Vex. */
  longDescription: string;
  /**
   * Holds a list of references associated with this vulnerability item and
   * assessment. These uris have additional information about the
   * vulnerability and the assessment itself. E.g. Link to a document which
   * details how this assessment concluded the state of this vulnerability.
   */
  relatedUris: RelatedUrl[];
  /** Provides the state of this Vulnerability assessment. */
  state: VulnerabilityAssessmentNote_Assessment_State;
  /**
   * Contains information about the impact of this vulnerability,
   * this will change with time.
   */
  impacts: string[];
  /**
   * Justification provides the justification when the state of the
   * assessment if NOT_AFFECTED.
   */
  justification:
    | VulnerabilityAssessmentNote_Assessment_Justification
    | undefined;
  /** Specifies details on how to handle (and presumably, fix) a vulnerability. */
  remediations: VulnerabilityAssessmentNote_Assessment_Remediation[];
}

/** Provides the state of this Vulnerability assessment. */
export enum VulnerabilityAssessmentNote_Assessment_State {
  /** STATE_UNSPECIFIED - No state is specified. */
  STATE_UNSPECIFIED = 0,
  /** AFFECTED - This product is known to be affected by this vulnerability. */
  AFFECTED = 1,
  /** NOT_AFFECTED - This product is known to be not affected by this vulnerability. */
  NOT_AFFECTED = 2,
  /** FIXED - This product contains a fix for this vulnerability. */
  FIXED = 3,
  /**
   * UNDER_INVESTIGATION - It is not known yet whether these versions are or are not affected
   * by the vulnerability. However, it is still under investigation.
   */
  UNDER_INVESTIGATION = 4,
  UNRECOGNIZED = -1,
}

export function vulnerabilityAssessmentNote_Assessment_StateFromJSON(
  object: any,
): VulnerabilityAssessmentNote_Assessment_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return VulnerabilityAssessmentNote_Assessment_State.STATE_UNSPECIFIED;
    case 1:
    case "AFFECTED":
      return VulnerabilityAssessmentNote_Assessment_State.AFFECTED;
    case 2:
    case "NOT_AFFECTED":
      return VulnerabilityAssessmentNote_Assessment_State.NOT_AFFECTED;
    case 3:
    case "FIXED":
      return VulnerabilityAssessmentNote_Assessment_State.FIXED;
    case 4:
    case "UNDER_INVESTIGATION":
      return VulnerabilityAssessmentNote_Assessment_State.UNDER_INVESTIGATION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VulnerabilityAssessmentNote_Assessment_State.UNRECOGNIZED;
  }
}

export function vulnerabilityAssessmentNote_Assessment_StateToJSON(
  object: VulnerabilityAssessmentNote_Assessment_State,
): string {
  switch (object) {
    case VulnerabilityAssessmentNote_Assessment_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case VulnerabilityAssessmentNote_Assessment_State.AFFECTED:
      return "AFFECTED";
    case VulnerabilityAssessmentNote_Assessment_State.NOT_AFFECTED:
      return "NOT_AFFECTED";
    case VulnerabilityAssessmentNote_Assessment_State.FIXED:
      return "FIXED";
    case VulnerabilityAssessmentNote_Assessment_State.UNDER_INVESTIGATION:
      return "UNDER_INVESTIGATION";
    case VulnerabilityAssessmentNote_Assessment_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Justification provides the justification when the state of the
 * assessment if NOT_AFFECTED.
 */
export interface VulnerabilityAssessmentNote_Assessment_Justification {
  /** The justification type for this vulnerability. */
  justificationType: VulnerabilityAssessmentNote_Assessment_Justification_JustificationType;
  /** Additional details on why this justification was chosen. */
  details: string;
}

/** Provides the type of justification. */
export enum VulnerabilityAssessmentNote_Assessment_Justification_JustificationType {
  /** JUSTIFICATION_TYPE_UNSPECIFIED - JUSTIFICATION_TYPE_UNSPECIFIED. */
  JUSTIFICATION_TYPE_UNSPECIFIED = 0,
  /** COMPONENT_NOT_PRESENT - The vulnerable component is not present in the product. */
  COMPONENT_NOT_PRESENT = 1,
  /**
   * VULNERABLE_CODE_NOT_PRESENT - The vulnerable code is not present. Typically this case
   * occurs when source code is configured or built in a way that excludes
   * the vulnerable code.
   */
  VULNERABLE_CODE_NOT_PRESENT = 2,
  /**
   * VULNERABLE_CODE_NOT_IN_EXECUTE_PATH - The vulnerable code can not be executed.
   * Typically this case occurs when the product includes the vulnerable
   * code but does not call or use the vulnerable code.
   */
  VULNERABLE_CODE_NOT_IN_EXECUTE_PATH = 3,
  /**
   * VULNERABLE_CODE_CANNOT_BE_CONTROLLED_BY_ADVERSARY - The vulnerable code cannot be controlled by an attacker to exploit
   * the vulnerability.
   */
  VULNERABLE_CODE_CANNOT_BE_CONTROLLED_BY_ADVERSARY = 4,
  /**
   * INLINE_MITIGATIONS_ALREADY_EXIST - The product includes built-in protections or features that prevent
   * exploitation of the vulnerability. These built-in protections cannot
   * be subverted by the attacker and cannot be configured or disabled by
   * the user. These mitigations completely prevent exploitation based on
   * known attack vectors.
   */
  INLINE_MITIGATIONS_ALREADY_EXIST = 5,
  UNRECOGNIZED = -1,
}

export function vulnerabilityAssessmentNote_Assessment_Justification_JustificationTypeFromJSON(
  object: any,
): VulnerabilityAssessmentNote_Assessment_Justification_JustificationType {
  switch (object) {
    case 0:
    case "JUSTIFICATION_TYPE_UNSPECIFIED":
      return VulnerabilityAssessmentNote_Assessment_Justification_JustificationType.JUSTIFICATION_TYPE_UNSPECIFIED;
    case 1:
    case "COMPONENT_NOT_PRESENT":
      return VulnerabilityAssessmentNote_Assessment_Justification_JustificationType.COMPONENT_NOT_PRESENT;
    case 2:
    case "VULNERABLE_CODE_NOT_PRESENT":
      return VulnerabilityAssessmentNote_Assessment_Justification_JustificationType.VULNERABLE_CODE_NOT_PRESENT;
    case 3:
    case "VULNERABLE_CODE_NOT_IN_EXECUTE_PATH":
      return VulnerabilityAssessmentNote_Assessment_Justification_JustificationType.VULNERABLE_CODE_NOT_IN_EXECUTE_PATH;
    case 4:
    case "VULNERABLE_CODE_CANNOT_BE_CONTROLLED_BY_ADVERSARY":
      return VulnerabilityAssessmentNote_Assessment_Justification_JustificationType
        .VULNERABLE_CODE_CANNOT_BE_CONTROLLED_BY_ADVERSARY;
    case 5:
    case "INLINE_MITIGATIONS_ALREADY_EXIST":
      return VulnerabilityAssessmentNote_Assessment_Justification_JustificationType.INLINE_MITIGATIONS_ALREADY_EXIST;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VulnerabilityAssessmentNote_Assessment_Justification_JustificationType.UNRECOGNIZED;
  }
}

export function vulnerabilityAssessmentNote_Assessment_Justification_JustificationTypeToJSON(
  object: VulnerabilityAssessmentNote_Assessment_Justification_JustificationType,
): string {
  switch (object) {
    case VulnerabilityAssessmentNote_Assessment_Justification_JustificationType.JUSTIFICATION_TYPE_UNSPECIFIED:
      return "JUSTIFICATION_TYPE_UNSPECIFIED";
    case VulnerabilityAssessmentNote_Assessment_Justification_JustificationType.COMPONENT_NOT_PRESENT:
      return "COMPONENT_NOT_PRESENT";
    case VulnerabilityAssessmentNote_Assessment_Justification_JustificationType.VULNERABLE_CODE_NOT_PRESENT:
      return "VULNERABLE_CODE_NOT_PRESENT";
    case VulnerabilityAssessmentNote_Assessment_Justification_JustificationType.VULNERABLE_CODE_NOT_IN_EXECUTE_PATH:
      return "VULNERABLE_CODE_NOT_IN_EXECUTE_PATH";
    case VulnerabilityAssessmentNote_Assessment_Justification_JustificationType
      .VULNERABLE_CODE_CANNOT_BE_CONTROLLED_BY_ADVERSARY:
      return "VULNERABLE_CODE_CANNOT_BE_CONTROLLED_BY_ADVERSARY";
    case VulnerabilityAssessmentNote_Assessment_Justification_JustificationType.INLINE_MITIGATIONS_ALREADY_EXIST:
      return "INLINE_MITIGATIONS_ALREADY_EXIST";
    case VulnerabilityAssessmentNote_Assessment_Justification_JustificationType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Specifies details on how to handle (and presumably, fix) a vulnerability. */
export interface VulnerabilityAssessmentNote_Assessment_Remediation {
  /** The type of remediation that can be applied. */
  remediationType: VulnerabilityAssessmentNote_Assessment_Remediation_RemediationType;
  /** Contains a comprehensive human-readable discussion of the remediation. */
  details: string;
  /** Contains the URL where to obtain the remediation. */
  remediationUri: RelatedUrl | undefined;
}

/** The type of remediation that can be applied. */
export enum VulnerabilityAssessmentNote_Assessment_Remediation_RemediationType {
  /** REMEDIATION_TYPE_UNSPECIFIED - No remediation type specified. */
  REMEDIATION_TYPE_UNSPECIFIED = 0,
  /** MITIGATION - A MITIGATION is available. */
  MITIGATION = 1,
  /** NO_FIX_PLANNED - No fix is planned. */
  NO_FIX_PLANNED = 2,
  /** NONE_AVAILABLE - Not available. */
  NONE_AVAILABLE = 3,
  /** VENDOR_FIX - A vendor fix is available. */
  VENDOR_FIX = 4,
  /** WORKAROUND - A workaround is available. */
  WORKAROUND = 5,
  UNRECOGNIZED = -1,
}

export function vulnerabilityAssessmentNote_Assessment_Remediation_RemediationTypeFromJSON(
  object: any,
): VulnerabilityAssessmentNote_Assessment_Remediation_RemediationType {
  switch (object) {
    case 0:
    case "REMEDIATION_TYPE_UNSPECIFIED":
      return VulnerabilityAssessmentNote_Assessment_Remediation_RemediationType.REMEDIATION_TYPE_UNSPECIFIED;
    case 1:
    case "MITIGATION":
      return VulnerabilityAssessmentNote_Assessment_Remediation_RemediationType.MITIGATION;
    case 2:
    case "NO_FIX_PLANNED":
      return VulnerabilityAssessmentNote_Assessment_Remediation_RemediationType.NO_FIX_PLANNED;
    case 3:
    case "NONE_AVAILABLE":
      return VulnerabilityAssessmentNote_Assessment_Remediation_RemediationType.NONE_AVAILABLE;
    case 4:
    case "VENDOR_FIX":
      return VulnerabilityAssessmentNote_Assessment_Remediation_RemediationType.VENDOR_FIX;
    case 5:
    case "WORKAROUND":
      return VulnerabilityAssessmentNote_Assessment_Remediation_RemediationType.WORKAROUND;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VulnerabilityAssessmentNote_Assessment_Remediation_RemediationType.UNRECOGNIZED;
  }
}

export function vulnerabilityAssessmentNote_Assessment_Remediation_RemediationTypeToJSON(
  object: VulnerabilityAssessmentNote_Assessment_Remediation_RemediationType,
): string {
  switch (object) {
    case VulnerabilityAssessmentNote_Assessment_Remediation_RemediationType.REMEDIATION_TYPE_UNSPECIFIED:
      return "REMEDIATION_TYPE_UNSPECIFIED";
    case VulnerabilityAssessmentNote_Assessment_Remediation_RemediationType.MITIGATION:
      return "MITIGATION";
    case VulnerabilityAssessmentNote_Assessment_Remediation_RemediationType.NO_FIX_PLANNED:
      return "NO_FIX_PLANNED";
    case VulnerabilityAssessmentNote_Assessment_Remediation_RemediationType.NONE_AVAILABLE:
      return "NONE_AVAILABLE";
    case VulnerabilityAssessmentNote_Assessment_Remediation_RemediationType.VENDOR_FIX:
      return "VENDOR_FIX";
    case VulnerabilityAssessmentNote_Assessment_Remediation_RemediationType.WORKAROUND:
      return "WORKAROUND";
    case VulnerabilityAssessmentNote_Assessment_Remediation_RemediationType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseVulnerabilityAssessmentNote(): VulnerabilityAssessmentNote {
  return {
    title: "",
    shortDescription: "",
    longDescription: "",
    languageCode: "",
    publisher: undefined,
    product: undefined,
    assessment: undefined,
  };
}

export const VulnerabilityAssessmentNote: MessageFns<VulnerabilityAssessmentNote> = {
  encode(message: VulnerabilityAssessmentNote, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.shortDescription !== "") {
      writer.uint32(18).string(message.shortDescription);
    }
    if (message.longDescription !== "") {
      writer.uint32(26).string(message.longDescription);
    }
    if (message.languageCode !== "") {
      writer.uint32(34).string(message.languageCode);
    }
    if (message.publisher !== undefined) {
      VulnerabilityAssessmentNote_Publisher.encode(message.publisher, writer.uint32(42).fork()).join();
    }
    if (message.product !== undefined) {
      VulnerabilityAssessmentNote_Product.encode(message.product, writer.uint32(50).fork()).join();
    }
    if (message.assessment !== undefined) {
      VulnerabilityAssessmentNote_Assessment.encode(message.assessment, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VulnerabilityAssessmentNote {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVulnerabilityAssessmentNote();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.shortDescription = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.longDescription = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.publisher = VulnerabilityAssessmentNote_Publisher.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.product = VulnerabilityAssessmentNote_Product.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.assessment = VulnerabilityAssessmentNote_Assessment.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VulnerabilityAssessmentNote {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      shortDescription: isSet(object.shortDescription) ? globalThis.String(object.shortDescription) : "",
      longDescription: isSet(object.longDescription) ? globalThis.String(object.longDescription) : "",
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
      publisher: isSet(object.publisher) ? VulnerabilityAssessmentNote_Publisher.fromJSON(object.publisher) : undefined,
      product: isSet(object.product) ? VulnerabilityAssessmentNote_Product.fromJSON(object.product) : undefined,
      assessment: isSet(object.assessment)
        ? VulnerabilityAssessmentNote_Assessment.fromJSON(object.assessment)
        : undefined,
    };
  },

  toJSON(message: VulnerabilityAssessmentNote): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.shortDescription !== "") {
      obj.shortDescription = message.shortDescription;
    }
    if (message.longDescription !== "") {
      obj.longDescription = message.longDescription;
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (message.publisher !== undefined) {
      obj.publisher = VulnerabilityAssessmentNote_Publisher.toJSON(message.publisher);
    }
    if (message.product !== undefined) {
      obj.product = VulnerabilityAssessmentNote_Product.toJSON(message.product);
    }
    if (message.assessment !== undefined) {
      obj.assessment = VulnerabilityAssessmentNote_Assessment.toJSON(message.assessment);
    }
    return obj;
  },

  create(base?: DeepPartial<VulnerabilityAssessmentNote>): VulnerabilityAssessmentNote {
    return VulnerabilityAssessmentNote.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VulnerabilityAssessmentNote>): VulnerabilityAssessmentNote {
    const message = createBaseVulnerabilityAssessmentNote();
    message.title = object.title ?? "";
    message.shortDescription = object.shortDescription ?? "";
    message.longDescription = object.longDescription ?? "";
    message.languageCode = object.languageCode ?? "";
    message.publisher = (object.publisher !== undefined && object.publisher !== null)
      ? VulnerabilityAssessmentNote_Publisher.fromPartial(object.publisher)
      : undefined;
    message.product = (object.product !== undefined && object.product !== null)
      ? VulnerabilityAssessmentNote_Product.fromPartial(object.product)
      : undefined;
    message.assessment = (object.assessment !== undefined && object.assessment !== null)
      ? VulnerabilityAssessmentNote_Assessment.fromPartial(object.assessment)
      : undefined;
    return message;
  },
};

function createBaseVulnerabilityAssessmentNote_Publisher(): VulnerabilityAssessmentNote_Publisher {
  return { name: "", issuingAuthority: "", publisherNamespace: "" };
}

export const VulnerabilityAssessmentNote_Publisher: MessageFns<VulnerabilityAssessmentNote_Publisher> = {
  encode(message: VulnerabilityAssessmentNote_Publisher, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.issuingAuthority !== "") {
      writer.uint32(18).string(message.issuingAuthority);
    }
    if (message.publisherNamespace !== "") {
      writer.uint32(26).string(message.publisherNamespace);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VulnerabilityAssessmentNote_Publisher {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVulnerabilityAssessmentNote_Publisher();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.issuingAuthority = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.publisherNamespace = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VulnerabilityAssessmentNote_Publisher {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      issuingAuthority: isSet(object.issuingAuthority) ? globalThis.String(object.issuingAuthority) : "",
      publisherNamespace: isSet(object.publisherNamespace) ? globalThis.String(object.publisherNamespace) : "",
    };
  },

  toJSON(message: VulnerabilityAssessmentNote_Publisher): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.issuingAuthority !== "") {
      obj.issuingAuthority = message.issuingAuthority;
    }
    if (message.publisherNamespace !== "") {
      obj.publisherNamespace = message.publisherNamespace;
    }
    return obj;
  },

  create(base?: DeepPartial<VulnerabilityAssessmentNote_Publisher>): VulnerabilityAssessmentNote_Publisher {
    return VulnerabilityAssessmentNote_Publisher.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VulnerabilityAssessmentNote_Publisher>): VulnerabilityAssessmentNote_Publisher {
    const message = createBaseVulnerabilityAssessmentNote_Publisher();
    message.name = object.name ?? "";
    message.issuingAuthority = object.issuingAuthority ?? "";
    message.publisherNamespace = object.publisherNamespace ?? "";
    return message;
  },
};

function createBaseVulnerabilityAssessmentNote_Product(): VulnerabilityAssessmentNote_Product {
  return { name: "", id: "", genericUri: undefined };
}

export const VulnerabilityAssessmentNote_Product: MessageFns<VulnerabilityAssessmentNote_Product> = {
  encode(message: VulnerabilityAssessmentNote_Product, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.genericUri !== undefined) {
      writer.uint32(26).string(message.genericUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VulnerabilityAssessmentNote_Product {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVulnerabilityAssessmentNote_Product();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.genericUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VulnerabilityAssessmentNote_Product {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      genericUri: isSet(object.genericUri) ? globalThis.String(object.genericUri) : undefined,
    };
  },

  toJSON(message: VulnerabilityAssessmentNote_Product): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.genericUri !== undefined) {
      obj.genericUri = message.genericUri;
    }
    return obj;
  },

  create(base?: DeepPartial<VulnerabilityAssessmentNote_Product>): VulnerabilityAssessmentNote_Product {
    return VulnerabilityAssessmentNote_Product.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VulnerabilityAssessmentNote_Product>): VulnerabilityAssessmentNote_Product {
    const message = createBaseVulnerabilityAssessmentNote_Product();
    message.name = object.name ?? "";
    message.id = object.id ?? "";
    message.genericUri = object.genericUri ?? undefined;
    return message;
  },
};

function createBaseVulnerabilityAssessmentNote_Assessment(): VulnerabilityAssessmentNote_Assessment {
  return {
    cve: "",
    vulnerabilityId: "",
    shortDescription: "",
    longDescription: "",
    relatedUris: [],
    state: 0,
    impacts: [],
    justification: undefined,
    remediations: [],
  };
}

export const VulnerabilityAssessmentNote_Assessment: MessageFns<VulnerabilityAssessmentNote_Assessment> = {
  encode(message: VulnerabilityAssessmentNote_Assessment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cve !== "") {
      writer.uint32(10).string(message.cve);
    }
    if (message.vulnerabilityId !== "") {
      writer.uint32(74).string(message.vulnerabilityId);
    }
    if (message.shortDescription !== "") {
      writer.uint32(18).string(message.shortDescription);
    }
    if (message.longDescription !== "") {
      writer.uint32(26).string(message.longDescription);
    }
    for (const v of message.relatedUris) {
      RelatedUrl.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(40).int32(message.state);
    }
    for (const v of message.impacts) {
      writer.uint32(50).string(v!);
    }
    if (message.justification !== undefined) {
      VulnerabilityAssessmentNote_Assessment_Justification.encode(message.justification, writer.uint32(58).fork())
        .join();
    }
    for (const v of message.remediations) {
      VulnerabilityAssessmentNote_Assessment_Remediation.encode(v!, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VulnerabilityAssessmentNote_Assessment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVulnerabilityAssessmentNote_Assessment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cve = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.vulnerabilityId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.shortDescription = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.longDescription = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.relatedUris.push(RelatedUrl.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.impacts.push(reader.string());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.justification = VulnerabilityAssessmentNote_Assessment_Justification.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.remediations.push(VulnerabilityAssessmentNote_Assessment_Remediation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VulnerabilityAssessmentNote_Assessment {
    return {
      cve: isSet(object.cve) ? globalThis.String(object.cve) : "",
      vulnerabilityId: isSet(object.vulnerabilityId) ? globalThis.String(object.vulnerabilityId) : "",
      shortDescription: isSet(object.shortDescription) ? globalThis.String(object.shortDescription) : "",
      longDescription: isSet(object.longDescription) ? globalThis.String(object.longDescription) : "",
      relatedUris: globalThis.Array.isArray(object?.relatedUris)
        ? object.relatedUris.map((e: any) => RelatedUrl.fromJSON(e))
        : [],
      state: isSet(object.state) ? vulnerabilityAssessmentNote_Assessment_StateFromJSON(object.state) : 0,
      impacts: globalThis.Array.isArray(object?.impacts) ? object.impacts.map((e: any) => globalThis.String(e)) : [],
      justification: isSet(object.justification)
        ? VulnerabilityAssessmentNote_Assessment_Justification.fromJSON(object.justification)
        : undefined,
      remediations: globalThis.Array.isArray(object?.remediations)
        ? object.remediations.map((e: any) => VulnerabilityAssessmentNote_Assessment_Remediation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: VulnerabilityAssessmentNote_Assessment): unknown {
    const obj: any = {};
    if (message.cve !== "") {
      obj.cve = message.cve;
    }
    if (message.vulnerabilityId !== "") {
      obj.vulnerabilityId = message.vulnerabilityId;
    }
    if (message.shortDescription !== "") {
      obj.shortDescription = message.shortDescription;
    }
    if (message.longDescription !== "") {
      obj.longDescription = message.longDescription;
    }
    if (message.relatedUris?.length) {
      obj.relatedUris = message.relatedUris.map((e) => RelatedUrl.toJSON(e));
    }
    if (message.state !== 0) {
      obj.state = vulnerabilityAssessmentNote_Assessment_StateToJSON(message.state);
    }
    if (message.impacts?.length) {
      obj.impacts = message.impacts;
    }
    if (message.justification !== undefined) {
      obj.justification = VulnerabilityAssessmentNote_Assessment_Justification.toJSON(message.justification);
    }
    if (message.remediations?.length) {
      obj.remediations = message.remediations.map((e) => VulnerabilityAssessmentNote_Assessment_Remediation.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<VulnerabilityAssessmentNote_Assessment>): VulnerabilityAssessmentNote_Assessment {
    return VulnerabilityAssessmentNote_Assessment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VulnerabilityAssessmentNote_Assessment>): VulnerabilityAssessmentNote_Assessment {
    const message = createBaseVulnerabilityAssessmentNote_Assessment();
    message.cve = object.cve ?? "";
    message.vulnerabilityId = object.vulnerabilityId ?? "";
    message.shortDescription = object.shortDescription ?? "";
    message.longDescription = object.longDescription ?? "";
    message.relatedUris = object.relatedUris?.map((e) => RelatedUrl.fromPartial(e)) || [];
    message.state = object.state ?? 0;
    message.impacts = object.impacts?.map((e) => e) || [];
    message.justification = (object.justification !== undefined && object.justification !== null)
      ? VulnerabilityAssessmentNote_Assessment_Justification.fromPartial(object.justification)
      : undefined;
    message.remediations =
      object.remediations?.map((e) => VulnerabilityAssessmentNote_Assessment_Remediation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseVulnerabilityAssessmentNote_Assessment_Justification(): VulnerabilityAssessmentNote_Assessment_Justification {
  return { justificationType: 0, details: "" };
}

export const VulnerabilityAssessmentNote_Assessment_Justification: MessageFns<
  VulnerabilityAssessmentNote_Assessment_Justification
> = {
  encode(
    message: VulnerabilityAssessmentNote_Assessment_Justification,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.justificationType !== 0) {
      writer.uint32(8).int32(message.justificationType);
    }
    if (message.details !== "") {
      writer.uint32(18).string(message.details);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VulnerabilityAssessmentNote_Assessment_Justification {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVulnerabilityAssessmentNote_Assessment_Justification();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.justificationType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.details = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VulnerabilityAssessmentNote_Assessment_Justification {
    return {
      justificationType: isSet(object.justificationType)
        ? vulnerabilityAssessmentNote_Assessment_Justification_JustificationTypeFromJSON(object.justificationType)
        : 0,
      details: isSet(object.details) ? globalThis.String(object.details) : "",
    };
  },

  toJSON(message: VulnerabilityAssessmentNote_Assessment_Justification): unknown {
    const obj: any = {};
    if (message.justificationType !== 0) {
      obj.justificationType = vulnerabilityAssessmentNote_Assessment_Justification_JustificationTypeToJSON(
        message.justificationType,
      );
    }
    if (message.details !== "") {
      obj.details = message.details;
    }
    return obj;
  },

  create(
    base?: DeepPartial<VulnerabilityAssessmentNote_Assessment_Justification>,
  ): VulnerabilityAssessmentNote_Assessment_Justification {
    return VulnerabilityAssessmentNote_Assessment_Justification.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<VulnerabilityAssessmentNote_Assessment_Justification>,
  ): VulnerabilityAssessmentNote_Assessment_Justification {
    const message = createBaseVulnerabilityAssessmentNote_Assessment_Justification();
    message.justificationType = object.justificationType ?? 0;
    message.details = object.details ?? "";
    return message;
  },
};

function createBaseVulnerabilityAssessmentNote_Assessment_Remediation(): VulnerabilityAssessmentNote_Assessment_Remediation {
  return { remediationType: 0, details: "", remediationUri: undefined };
}

export const VulnerabilityAssessmentNote_Assessment_Remediation: MessageFns<
  VulnerabilityAssessmentNote_Assessment_Remediation
> = {
  encode(
    message: VulnerabilityAssessmentNote_Assessment_Remediation,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.remediationType !== 0) {
      writer.uint32(8).int32(message.remediationType);
    }
    if (message.details !== "") {
      writer.uint32(18).string(message.details);
    }
    if (message.remediationUri !== undefined) {
      RelatedUrl.encode(message.remediationUri, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VulnerabilityAssessmentNote_Assessment_Remediation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVulnerabilityAssessmentNote_Assessment_Remediation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.remediationType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.details = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.remediationUri = RelatedUrl.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VulnerabilityAssessmentNote_Assessment_Remediation {
    return {
      remediationType: isSet(object.remediationType)
        ? vulnerabilityAssessmentNote_Assessment_Remediation_RemediationTypeFromJSON(object.remediationType)
        : 0,
      details: isSet(object.details) ? globalThis.String(object.details) : "",
      remediationUri: isSet(object.remediationUri) ? RelatedUrl.fromJSON(object.remediationUri) : undefined,
    };
  },

  toJSON(message: VulnerabilityAssessmentNote_Assessment_Remediation): unknown {
    const obj: any = {};
    if (message.remediationType !== 0) {
      obj.remediationType = vulnerabilityAssessmentNote_Assessment_Remediation_RemediationTypeToJSON(
        message.remediationType,
      );
    }
    if (message.details !== "") {
      obj.details = message.details;
    }
    if (message.remediationUri !== undefined) {
      obj.remediationUri = RelatedUrl.toJSON(message.remediationUri);
    }
    return obj;
  },

  create(
    base?: DeepPartial<VulnerabilityAssessmentNote_Assessment_Remediation>,
  ): VulnerabilityAssessmentNote_Assessment_Remediation {
    return VulnerabilityAssessmentNote_Assessment_Remediation.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<VulnerabilityAssessmentNote_Assessment_Remediation>,
  ): VulnerabilityAssessmentNote_Assessment_Remediation {
    const message = createBaseVulnerabilityAssessmentNote_Assessment_Remediation();
    message.remediationType = object.remediationType ?? 0;
    message.details = object.details ?? "";
    message.remediationUri = (object.remediationUri !== undefined && object.remediationUri !== null)
      ? RelatedUrl.fromPartial(object.remediationUri)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
