// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: grafeas/v1/build.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { InTotoProvenance } from "./intoto_provenance.js";
import { InTotoSlsaProvenanceV1, InTotoStatement } from "./intoto_statement.js";
import { BuildProvenance } from "./provenance.js";

export const protobufPackage = "grafeas.v1";

/**
 * Note holding the version of the provider's builder and the signature of the
 * provenance message in the build details occurrence.
 */
export interface BuildNote {
  /** Required. Immutable. Version of the builder which produced this build. */
  builderVersion: string;
}

/** Details of a build occurrence. */
export interface BuildOccurrence {
  /** The actual provenance for the build. */
  provenance:
    | BuildProvenance
    | undefined;
  /**
   * Serialized JSON representation of the provenance, used in generating the
   * build signature in the corresponding build note. After verifying the
   * signature, `provenance_bytes` can be unmarshalled and compared to the
   * provenance to confirm that it is unchanged. A base64-encoded string
   * representation of the provenance bytes is used for the signature in order
   * to interoperate with openssl which expects this format for signature
   * verification.
   *
   * The serialized form is captured both to avoid ambiguity in how the
   * provenance is marshalled to json as well to prevent incompatibilities with
   * future changes.
   */
  provenanceBytes: string;
  /**
   * Deprecated. See InTotoStatement for the replacement.
   * In-toto Provenance representation as defined in spec.
   */
  intotoProvenance:
    | InTotoProvenance
    | undefined;
  /**
   * In-toto Statement representation as defined in spec.
   * The intoto_statement can contain any type of provenance. The serialized
   * payload of the statement can be stored and signed in the Occurrence's
   * envelope.
   */
  intotoStatement:
    | InTotoStatement
    | undefined;
  /**
   * In-Toto Slsa Provenance V1 represents a slsa provenance meeting the slsa
   * spec, wrapped in an in-toto statement. This allows for direct
   * jsonification of a to-spec in-toto slsa statement with a to-spec
   * slsa provenance.
   */
  inTotoSlsaProvenanceV1: InTotoSlsaProvenanceV1 | undefined;
}

function createBaseBuildNote(): BuildNote {
  return { builderVersion: "" };
}

export const BuildNote: MessageFns<BuildNote> = {
  encode(message: BuildNote, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.builderVersion !== "") {
      writer.uint32(10).string(message.builderVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildNote {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildNote();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.builderVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildNote {
    return { builderVersion: isSet(object.builderVersion) ? globalThis.String(object.builderVersion) : "" };
  },

  toJSON(message: BuildNote): unknown {
    const obj: any = {};
    if (message.builderVersion !== "") {
      obj.builderVersion = message.builderVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<BuildNote>): BuildNote {
    return BuildNote.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BuildNote>): BuildNote {
    const message = createBaseBuildNote();
    message.builderVersion = object.builderVersion ?? "";
    return message;
  },
};

function createBaseBuildOccurrence(): BuildOccurrence {
  return {
    provenance: undefined,
    provenanceBytes: "",
    intotoProvenance: undefined,
    intotoStatement: undefined,
    inTotoSlsaProvenanceV1: undefined,
  };
}

export const BuildOccurrence: MessageFns<BuildOccurrence> = {
  encode(message: BuildOccurrence, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.provenance !== undefined) {
      BuildProvenance.encode(message.provenance, writer.uint32(10).fork()).join();
    }
    if (message.provenanceBytes !== "") {
      writer.uint32(18).string(message.provenanceBytes);
    }
    if (message.intotoProvenance !== undefined) {
      InTotoProvenance.encode(message.intotoProvenance, writer.uint32(26).fork()).join();
    }
    if (message.intotoStatement !== undefined) {
      InTotoStatement.encode(message.intotoStatement, writer.uint32(34).fork()).join();
    }
    if (message.inTotoSlsaProvenanceV1 !== undefined) {
      InTotoSlsaProvenanceV1.encode(message.inTotoSlsaProvenanceV1, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildOccurrence {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildOccurrence();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.provenance = BuildProvenance.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.provenanceBytes = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.intotoProvenance = InTotoProvenance.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.intotoStatement = InTotoStatement.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.inTotoSlsaProvenanceV1 = InTotoSlsaProvenanceV1.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildOccurrence {
    return {
      provenance: isSet(object.provenance) ? BuildProvenance.fromJSON(object.provenance) : undefined,
      provenanceBytes: isSet(object.provenanceBytes) ? globalThis.String(object.provenanceBytes) : "",
      intotoProvenance: isSet(object.intotoProvenance) ? InTotoProvenance.fromJSON(object.intotoProvenance) : undefined,
      intotoStatement: isSet(object.intotoStatement) ? InTotoStatement.fromJSON(object.intotoStatement) : undefined,
      inTotoSlsaProvenanceV1: isSet(object.inTotoSlsaProvenanceV1)
        ? InTotoSlsaProvenanceV1.fromJSON(object.inTotoSlsaProvenanceV1)
        : undefined,
    };
  },

  toJSON(message: BuildOccurrence): unknown {
    const obj: any = {};
    if (message.provenance !== undefined) {
      obj.provenance = BuildProvenance.toJSON(message.provenance);
    }
    if (message.provenanceBytes !== "") {
      obj.provenanceBytes = message.provenanceBytes;
    }
    if (message.intotoProvenance !== undefined) {
      obj.intotoProvenance = InTotoProvenance.toJSON(message.intotoProvenance);
    }
    if (message.intotoStatement !== undefined) {
      obj.intotoStatement = InTotoStatement.toJSON(message.intotoStatement);
    }
    if (message.inTotoSlsaProvenanceV1 !== undefined) {
      obj.inTotoSlsaProvenanceV1 = InTotoSlsaProvenanceV1.toJSON(message.inTotoSlsaProvenanceV1);
    }
    return obj;
  },

  create(base?: DeepPartial<BuildOccurrence>): BuildOccurrence {
    return BuildOccurrence.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BuildOccurrence>): BuildOccurrence {
    const message = createBaseBuildOccurrence();
    message.provenance = (object.provenance !== undefined && object.provenance !== null)
      ? BuildProvenance.fromPartial(object.provenance)
      : undefined;
    message.provenanceBytes = object.provenanceBytes ?? "";
    message.intotoProvenance = (object.intotoProvenance !== undefined && object.intotoProvenance !== null)
      ? InTotoProvenance.fromPartial(object.intotoProvenance)
      : undefined;
    message.intotoStatement = (object.intotoStatement !== undefined && object.intotoStatement !== null)
      ? InTotoStatement.fromPartial(object.intotoStatement)
      : undefined;
    message.inTotoSlsaProvenanceV1 =
      (object.inTotoSlsaProvenanceV1 !== undefined && object.inTotoSlsaProvenanceV1 !== null)
        ? InTotoSlsaProvenanceV1.fromPartial(object.inTotoSlsaProvenanceV1)
        : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
